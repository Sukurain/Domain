var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb2, mod) => function __require() {
  return mod || (0, cb2[__getOwnPropNames(cb2)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all4) => {
  for (var name in all4)
    __defProp(target, name, { get: all4[name], enumerable: true });
};
var __copyProps = (to, from3, except2, desc2) => {
  if (from3 && typeof from3 === "object" || typeof from3 === "function") {
    for (let key2 of __getOwnPropNames(from3))
      if (!__hasOwnProp.call(to, key2) && key2 !== except2)
        __defProp(to, key2, { get: () => from3[key2], enumerable: !(desc2 = __getOwnPropDesc(from3, key2)) || desc2.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __decorateClass = (decorators, target, key2, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key2) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key2, result);
  return result;
};
var __publicField = (obj, key2, value) => {
  __defNormalProp(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);
  return value;
};

// node_modules/@esbuild-plugins/node-globals-polyfill/process.js
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e2) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e3) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e2) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e3) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
function nextTick(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      args[i2 - 1] = arguments[i2];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
function noop() {
}
function binding(name) {
  throw new Error("process.binding is not supported");
}
function cwd() {
  return "/";
}
function chdir(dir) {
  throw new Error("process.chdir is not supported");
}
function umask() {
  return 0;
}
function hrtime(previousTimestamp) {
  var clocktime = performanceNow.call(performance2) * 1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds, nanoseconds];
}
function uptime() {
  var currentTime = /* @__PURE__ */ new Date();
  var dif = currentTime - startTime;
  return dif / 1e3;
}
var cachedSetTimeout, cachedClearTimeout, queue, draining, currentQueue, queueIndex, title, platform, browser, env, argv, version, versions, release, config, on, addListener, once, off, removeListener, removeAllListeners, emit, performance2, performanceNow, startTime, process, defines;
var init_process = __esm({
  "node_modules/@esbuild-plugins/node-globals-polyfill/process.js"() {
    cachedSetTimeout = defaultSetTimout;
    cachedClearTimeout = defaultClearTimeout;
    if (typeof globalThis.setTimeout === "function") {
      cachedSetTimeout = setTimeout;
    }
    if (typeof globalThis.clearTimeout === "function") {
      cachedClearTimeout = clearTimeout;
    }
    queue = [];
    draining = false;
    queueIndex = -1;
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    title = "browser";
    platform = "browser";
    browser = true;
    env = {};
    argv = [];
    version = "";
    versions = {};
    release = {};
    config = {};
    on = noop;
    addListener = noop;
    once = noop;
    off = noop;
    removeListener = noop;
    removeAllListeners = noop;
    emit = noop;
    performance2 = globalThis.performance || {};
    performanceNow = performance2.now || performance2.mozNow || performance2.msNow || performance2.oNow || performance2.webkitNow || function() {
      return (/* @__PURE__ */ new Date()).getTime();
    };
    startTime = /* @__PURE__ */ new Date();
    process = {
      nextTick,
      title,
      browser,
      env,
      argv,
      version,
      versions,
      on,
      addListener,
      once,
      off,
      removeListener,
      removeAllListeners,
      emit,
      binding,
      cwd,
      chdir,
      umask,
      hrtime,
      platform,
      release,
      config,
      uptime
    };
    defines = {};
    Object.keys(defines).forEach((key2) => {
      const segs = key2.split(".");
      let target = process;
      for (let i2 = 0; i2 < segs.length; i2++) {
        const seg = segs[i2];
        if (i2 === segs.length - 1) {
          target[seg] = defines[key2];
        } else {
          target = target[seg] || (target[seg] = {});
        }
      }
    });
  }
});

// node_modules/@esbuild-plugins/node-globals-polyfill/Buffer.js
function init() {
  inited = true;
  var code4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i2 = 0, len = code4.length; i2 < len; ++i2) {
    lookup[i2] = code4[i2];
    revLookup[code4.charCodeAt(i2)] = i2;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
}
function base64toByteArray(b64) {
  if (!inited) {
    init();
  }
  var i2, j2, l2, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
  arr = new Arr(len * 3 / 4 - placeHolders);
  l2 = placeHolders > 0 ? len - 4 : len;
  var L2 = 0;
  for (i2 = 0, j2 = 0; i2 < l2; i2 += 4, j2 += 3) {
    tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
    arr[L2++] = tmp >> 16 & 255;
    arr[L2++] = tmp >> 8 & 255;
    arr[L2++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
    arr[L2++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
    arr[L2++] = tmp >> 8 & 255;
    arr[L2++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i2 = start; i2 < end; i2 += 3) {
    tmp = (uint8[i2] << 16) + (uint8[i2 + 1] << 8) + uint8[i2 + 2];
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function base64fromByteArray(uint8) {
  if (!inited) {
    init();
  }
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var output = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i2 = 0, len2 = len - extraBytes; i2 < len2; i2 += maxChunkLength) {
    parts.push(
      encodeChunk(
        uint8,
        i2,
        i2 + maxChunkLength > len2 ? len2 : i2 + maxChunkLength
      )
    );
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 63];
    output += lookup[tmp << 2 & 63];
    output += "=";
  }
  parts.push(output);
  return parts.join("");
}
function kMaxLength() {
  return Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length);
    that.__proto__ = Buffer2.prototype;
  } else {
    if (that === null) {
      that = new Buffer2(length);
    }
    that.length = length;
  }
  return that;
}
function Buffer2(arg, encodingOrOffset, length) {
  if (!Buffer2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer2)) {
    return new Buffer2(arg, encodingOrOffset, length);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length);
}
function from(that, value, encodingOrOffset, length) {
  if (typeof value === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }
  if (typeof value === "string") {
    return fromString(that, value, encodingOrOffset);
  }
  return fromObject(that, value);
}
function assertSize(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc(that, size, fill3, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill3 !== void 0) {
    return typeof encoding === "string" ? createBuffer(that, size).fill(fill3, encoding) : createBuffer(that, size).fill(fill3);
  }
  return createBuffer(that, size);
}
function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer2.TYPED_ARRAY_SUPPORT) {
    for (var i2 = 0; i2 < size; ++i2) {
      that[i2] = 0;
    }
  }
  return that;
}
function fromString(that, string3, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer2.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length = byteLength(string3, encoding) | 0;
  that = createBuffer(that, length);
  var actual = that.write(string3, encoding);
  if (actual !== length) {
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i2 = 0; i2 < length; i2 += 1) {
    that[i2] = array[i2] & 255;
  }
  return that;
}
function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength;
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length === void 0) {
    array = new Uint8Array(array);
  } else if (length === void 0) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer2.prototype;
  } else {
    that = fromArrayLike(that, array);
  }
  return that;
}
function fromObject(that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }
  throw new TypeError(
    "First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object."
  );
}
function checked(length) {
  if (length >= kMaxLength()) {
    throw new RangeError(
      "Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes"
    );
  }
  return length | 0;
}
function internalIsBuffer(b2) {
  return !!(b2 != null && b2._isBuffer);
}
function byteLength(string3, encoding) {
  if (internalIsBuffer(string3)) {
    return string3.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string3) || string3 instanceof ArrayBuffer)) {
    return string3.byteLength;
  }
  if (typeof string3 !== "string") {
    string3 = "" + string3;
  }
  var len = string3.length;
  if (len === 0)
    return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes(string3).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes(string3).length;
      default:
        if (loweredCase)
          return utf8ToBytes(string3).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
function slowToString(encoding, start, end) {
  var loweredCase = false;
  if (start === void 0 || start < 0) {
    start = 0;
  }
  if (start > this.length) {
    return "";
  }
  if (end === void 0 || end > this.length) {
    end = this.length;
  }
  if (end <= 0) {
    return "";
  }
  end >>>= 0;
  start >>>= 0;
  if (end <= start) {
    return "";
  }
  if (!encoding)
    encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice(this, start, end);
      case "utf8":
      case "utf-8":
        return utf8Slice(this, start, end);
      case "ascii":
        return asciiSlice(this, start, end);
      case "latin1":
      case "binary":
        return latin1Slice(this, start, end);
      case "base64":
        return base64Slice(this, start, end);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice(this, start, end);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
function swap(b2, n2, m2) {
  var i2 = b2[n2];
  b2[n2] = b2[m2];
  b2[m2] = i2;
}
function bidirectionalIndexOf(buffer, val2, byteOffset, encoding, dir) {
  if (buffer.length === 0)
    return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length - 1;
  }
  if (byteOffset < 0)
    byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir)
      return -1;
    else
      byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir)
      byteOffset = 0;
    else
      return -1;
  }
  if (typeof val2 === "string") {
    val2 = Buffer2.from(val2, encoding);
  }
  if (internalIsBuffer(val2)) {
    if (val2.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val2, byteOffset, encoding, dir);
  } else if (typeof val2 === "number") {
    val2 = val2 & 255;
    if (Buffer2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(
          buffer,
          val2,
          byteOffset
        );
      } else {
        return Uint8Array.prototype.lastIndexOf.call(
          buffer,
          val2,
          byteOffset
        );
      }
    }
    return arrayIndexOf(buffer, [val2], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val2, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val2.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val2.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read2(buf, i3) {
    if (indexSize === 1) {
      return buf[i3];
    } else {
      return buf.readUInt16BE(i3 * indexSize);
    }
  }
  var i2;
  if (dir) {
    var foundIndex = -1;
    for (i2 = byteOffset; i2 < arrLength; i2++) {
      if (read2(arr, i2) === read2(val2, foundIndex === -1 ? 0 : i2 - foundIndex)) {
        if (foundIndex === -1)
          foundIndex = i2;
        if (i2 - foundIndex + 1 === valLength)
          return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1)
          i2 -= i2 - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength)
      byteOffset = arrLength - valLength;
    for (i2 = byteOffset; i2 >= 0; i2--) {
      var found = true;
      for (var j2 = 0; j2 < valLength; j2++) {
        if (read2(arr, i2 + j2) !== read2(val2, j2)) {
          found = false;
          break;
        }
      }
      if (found)
        return i2;
    }
  }
  return -1;
}
function hexWrite(buf, string3, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }
  var strLen = string3.length;
  if (strLen % 2 !== 0)
    throw new TypeError("Invalid hex string");
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i2 = 0; i2 < length; ++i2) {
    var parsed = parseInt(string3.substr(i2 * 2, 2), 16);
    if (isNaN(parsed))
      return i2;
    buf[offset + i2] = parsed;
  }
  return i2;
}
function utf8Write(buf, string3, offset, length) {
  return blitBuffer(
    utf8ToBytes(string3, buf.length - offset),
    buf,
    offset,
    length
  );
}
function asciiWrite(buf, string3, offset, length) {
  return blitBuffer(asciiToBytes(string3), buf, offset, length);
}
function latin1Write(buf, string3, offset, length) {
  return asciiWrite(buf, string3, offset, length);
}
function base64Write(buf, string3, offset, length) {
  return blitBuffer(base64ToBytes(string3), buf, offset, length);
}
function ucs2Write(buf, string3, offset, length) {
  return blitBuffer(
    utf16leToBytes(string3, buf.length - offset),
    buf,
    offset,
    length
  );
}
function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64fromByteArray(buf);
  } else {
    return base64fromByteArray(buf.slice(start, end));
  }
}
function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i2 = start;
  while (i2 < end) {
    var firstByte = buf[i2];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i2 + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i2 + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i2 + 1];
          thirdByte = buf[i2 + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i2 + 1];
          thirdByte = buf[i2 + 2];
          fourthByte = buf[i2 + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i2 += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i2 = 0;
  while (i2 < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
    );
  }
  return res;
}
function asciiSlice(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i2 = start; i2 < end; ++i2) {
    ret += String.fromCharCode(buf[i2] & 127);
  }
  return ret;
}
function latin1Slice(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i2 = start; i2 < end; ++i2) {
    ret += String.fromCharCode(buf[i2]);
  }
  return ret;
}
function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0)
    start = 0;
  if (!end || end < 0 || end > len)
    end = len;
  var out = "";
  for (var i2 = start; i2 < end; ++i2) {
    out += toHex(buf[i2]);
  }
  return out;
}
function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = "";
  for (var i2 = 0; i2 < bytes.length; i2 += 2) {
    res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
  }
  return res;
}
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0)
    throw new RangeError("offset is not uint");
  if (offset + ext > length)
    throw new RangeError("Trying to access beyond buffer length");
}
function checkInt(buf, value, offset, ext, max, min) {
  if (!internalIsBuffer(buf))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min)
    throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
}
function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 65535 + value + 1;
  for (var i2 = 0, j2 = Math.min(buf.length - offset, 2); i2 < j2; ++i2) {
    buf[offset + i2] = (value & 255 << 8 * (littleEndian ? i2 : 1 - i2)) >>> (littleEndian ? i2 : 1 - i2) * 8;
  }
}
function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 4294967295 + value + 1;
  for (var i2 = 0, j2 = Math.min(buf.length - offset, 4); i2 < j2; ++i2) {
    buf[offset + i2] = value >>> (littleEndian ? i2 : 3 - i2) * 8 & 255;
  }
}
function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
  if (offset < 0)
    throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(
      buf,
      value,
      offset,
      4,
      34028234663852886e22,
      -34028234663852886e22
    );
  }
  ieee754write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}
function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(
      buf,
      value,
      offset,
      8,
      17976931348623157e292,
      -17976931348623157e292
    );
  }
  ieee754write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}
function base64clean(str) {
  str = stringtrim(str).replace(INVALID_BASE64_RE, "");
  if (str.length < 2)
    return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function stringtrim(str) {
  if (str.trim)
    return str.trim();
  return str.replace(/^\s+|\s+$/g, "");
}
function toHex(n2) {
  if (n2 < 16)
    return "0" + n2.toString(16);
  return n2.toString(16);
}
function utf8ToBytes(string3, units) {
  units = units || Infinity;
  var codePoint;
  var length = string3.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i2 = 0; i2 < length; ++i2) {
    codePoint = string3.charCodeAt(i2);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        } else if (i2 + 1 === length) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes.push(
        codePoint >> 12 | 224,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes.push(
        codePoint >> 18 | 240,
        codePoint >> 12 & 63 | 128,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function asciiToBytes(str) {
  var byteArray = [];
  for (var i2 = 0; i2 < str.length; ++i2) {
    byteArray.push(str.charCodeAt(i2) & 255);
  }
  return byteArray;
}
function utf16leToBytes(str, units) {
  var c2, hi, lo;
  var byteArray = [];
  for (var i2 = 0; i2 < str.length; ++i2) {
    if ((units -= 2) < 0)
      break;
    c2 = str.charCodeAt(i2);
    hi = c2 >> 8;
    lo = c2 % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes(str) {
  return base64toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
  for (var i2 = 0; i2 < length; ++i2) {
    if (i2 + offset >= dst.length || i2 >= src.length)
      break;
    dst[i2 + offset] = src[i2];
  }
  return i2;
}
function isnan(val2) {
  return val2 !== val2;
}
function isBuffer(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
}
function isFastBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
}
function ieee754read(buffer, offset, isLE, mLen, nBytes) {
  var e2, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i2 = isLE ? nBytes - 1 : 0;
  var d2 = isLE ? -1 : 1;
  var s2 = buffer[offset + i2];
  i2 += d2;
  e2 = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e2 = e2 * 256 + buffer[offset + i2], i2 += d2, nBits -= 8) {
  }
  m2 = e2 & (1 << -nBits) - 1;
  e2 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer[offset + i2], i2 += d2, nBits -= 8) {
  }
  if (e2 === 0) {
    e2 = 1 - eBias;
  } else if (e2 === eMax) {
    return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e2 = e2 - eBias;
  }
  return (s2 ? -1 : 1) * m2 * Math.pow(2, e2 - mLen);
}
function ieee754write(buffer, value, offset, isLE, mLen, nBytes) {
  var e2, m2, c2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i2 = isLE ? 0 : nBytes - 1;
  var d2 = isLE ? 1 : -1;
  var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m2 = isNaN(value) ? 1 : 0;
    e2 = eMax;
  } else {
    e2 = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c2 = Math.pow(2, -e2)) < 1) {
      e2--;
      c2 *= 2;
    }
    if (e2 + eBias >= 1) {
      value += rt / c2;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c2 >= 2) {
      e2++;
      c2 /= 2;
    }
    if (e2 + eBias >= eMax) {
      m2 = 0;
      e2 = eMax;
    } else if (e2 + eBias >= 1) {
      m2 = (value * c2 - 1) * Math.pow(2, mLen);
      e2 = e2 + eBias;
    } else {
      m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e2 = 0;
    }
  }
  for (; mLen >= 8; buffer[offset + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {
  }
  e2 = e2 << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i2] = e2 & 255, i2 += d2, e2 /= 256, eLen -= 8) {
  }
  buffer[offset + i2 - d2] |= s2 * 128;
}
var lookup, revLookup, Arr, inited, MAX_ARGUMENTS_LENGTH, INVALID_BASE64_RE;
var init_Buffer = __esm({
  "node_modules/@esbuild-plugins/node-globals-polyfill/Buffer.js"() {
    init_process();
    init_buffer();
    lookup = [];
    revLookup = [];
    Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    inited = false;
    Buffer2.TYPED_ARRAY_SUPPORT = globalThis.TYPED_ARRAY_SUPPORT !== void 0 ? globalThis.TYPED_ARRAY_SUPPORT : true;
    Buffer2.poolSize = 8192;
    Buffer2._augment = function(arr) {
      arr.__proto__ = Buffer2.prototype;
      return arr;
    };
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(null, value, encodingOrOffset, length);
    };
    Buffer2.kMaxLength = kMaxLength();
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      Buffer2.prototype.__proto__ = Uint8Array.prototype;
      Buffer2.__proto__ = Uint8Array;
      if (typeof Symbol !== "undefined" && Symbol.species && Buffer2[Symbol.species] === Buffer2) {
      }
    }
    Buffer2.alloc = function(size, fill3, encoding) {
      return alloc(null, size, fill3, encoding);
    };
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(null, size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(null, size);
    };
    Buffer2.isBuffer = isBuffer;
    Buffer2.compare = function compare(a2, b2) {
      if (!internalIsBuffer(a2) || !internalIsBuffer(b2)) {
        throw new TypeError("Arguments must be Buffers");
      }
      if (a2 === b2)
        return 0;
      var x2 = a2.length;
      var y2 = b2.length;
      for (var i2 = 0, len = Math.min(x2, y2); i2 < len; ++i2) {
        if (a2[i2] !== b2[i2]) {
          x2 = a2[i2];
          y2 = b2[i2];
          break;
        }
      }
      if (x2 < y2)
        return -1;
      if (y2 < x2)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat(list4, length) {
      if (!Array.isArray(list4)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list4.length === 0) {
        return Buffer2.alloc(0);
      }
      var i2;
      if (length === void 0) {
        length = 0;
        for (i2 = 0; i2 < list4.length; ++i2) {
          length += list4[i2].length;
        }
      }
      var buffer = Buffer2.allocUnsafe(length);
      var pos = 0;
      for (i2 = 0; i2 < list4.length; ++i2) {
        var buf = list4[i2];
        if (!internalIsBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        buf.copy(buffer, pos);
        pos += buf.length;
      }
      return buffer;
    };
    Buffer2.byteLength = byteLength;
    Buffer2.prototype._isBuffer = true;
    Buffer2.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i2 = 0; i2 < len; i2 += 2) {
        swap(this, i2, i2 + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i2 = 0; i2 < len; i2 += 4) {
        swap(this, i2, i2 + 3);
        swap(this, i2 + 1, i2 + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i2 = 0; i2 < len; i2 += 8) {
        swap(this, i2, i2 + 7);
        swap(this, i2 + 1, i2 + 6);
        swap(this, i2 + 2, i2 + 5);
        swap(this, i2 + 3, i2 + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString() {
      var length = this.length | 0;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.equals = function equals(b2) {
      if (!internalIsBuffer(b2))
        throw new TypeError("Argument must be a Buffer");
      if (this === b2)
        return true;
      return Buffer2.compare(this, b2) === 0;
    };
    Buffer2.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
      if (!internalIsBuffer(target)) {
        throw new TypeError("Argument must be a Buffer");
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x2 = thisEnd - thisStart;
      var y2 = end - start;
      var len = Math.min(x2, y2);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i2 = 0; i2 < len; ++i2) {
        if (thisCopy[i2] !== targetCopy[i2]) {
          x2 = thisCopy[i2];
          y2 = targetCopy[i2];
          break;
        }
      }
      if (x2 < y2)
        return -1;
      if (y2 < x2)
        return 1;
      return 0;
    };
    Buffer2.prototype.includes = function includes(val2, byteOffset, encoding) {
      return this.indexOf(val2, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val2, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val2, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val2, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val2, byteOffset, encoding, false);
    };
    Buffer2.prototype.write = function write(string3, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset | 0;
        if (isFinite(length)) {
          length = length | 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string3.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string3, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string3, offset, length);
          case "ascii":
            return asciiWrite(this, string3, offset, length);
          case "latin1":
          case "binary":
            return latin1Write(this, string3, offset, length);
          case "base64":
            return base64Write(this, string3, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string3, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    MAX_ARGUMENTS_LENGTH = 4096;
    Buffer2.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf;
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer2.prototype;
      } else {
        var sliceLen = end - start;
        newBuf = new Buffer2(sliceLen, void 0);
        for (var i2 = 0; i2 < sliceLen; ++i2) {
          newBuf[i2] = this[i2 + start];
        }
      }
      return newBuf;
    };
    Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength3, this.length);
      var val2 = this[offset];
      var mul = 1;
      var i2 = 0;
      while (++i2 < byteLength3 && (mul *= 256)) {
        val2 += this[offset + i2] * mul;
      }
      return val2;
    };
    Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert) {
        checkOffset(offset, byteLength3, this.length);
      }
      var val2 = this[offset + --byteLength3];
      var mul = 1;
      while (byteLength3 > 0 && (mul *= 256)) {
        val2 += this[offset + --byteLength3] * mul;
      }
      return val2;
    };
    Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength3, this.length);
      var val2 = this[offset];
      var mul = 1;
      var i2 = 0;
      while (++i2 < byteLength3 && (mul *= 256)) {
        val2 += this[offset + i2] * mul;
      }
      mul *= 128;
      if (val2 >= mul)
        val2 -= Math.pow(2, 8 * byteLength3);
      return val2;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength3, this.length);
      var i2 = byteLength3;
      var mul = 1;
      var val2 = this[offset + --i2];
      while (i2 > 0 && (mul *= 256)) {
        val2 += this[offset + --i2] * mul;
      }
      mul *= 128;
      if (val2 >= mul)
        val2 -= Math.pow(2, 8 * byteLength3);
      return val2;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val2 = this[offset] | this[offset + 1] << 8;
      return val2 & 32768 ? val2 | 4294901760 : val2;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val2 = this[offset + 1] | this[offset] << 8;
      return val2 & 32768 ? val2 | 4294901760 : val2;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754read(this, offset, false, 52, 8);
    };
    Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt(this, value, offset, byteLength3, maxBytes, 0);
      }
      var mul = 1;
      var i2 = 0;
      this[offset] = value & 255;
      while (++i2 < byteLength3 && (mul *= 256)) {
        this[offset + i2] = value / mul & 255;
      }
      return offset + byteLength3;
    };
    Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt(this, value, offset, byteLength3, maxBytes, 0);
      }
      var i2 = byteLength3 - 1;
      var mul = 1;
      this[offset + i2] = value & 255;
      while (--i2 >= 0 && (mul *= 256)) {
        this[offset + i2] = value / mul & 255;
      }
      return offset + byteLength3;
    };
    Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      if (!Buffer2.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt(this, value, offset, byteLength3, limit - 1, -limit);
      }
      var i2 = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i2 < byteLength3 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
          sub = 1;
        }
        this[offset + i2] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength3;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt(this, value, offset, byteLength3, limit - 1, -limit);
      }
      var i2 = byteLength3 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i2] = value & 255;
      while (--i2 >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
          sub = 1;
        }
        this[offset + i2] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength3;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (!Buffer2.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("sourceStart out of bounds");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      var i2;
      if (this === target && start < targetStart && targetStart < end) {
        for (i2 = len - 1; i2 >= 0; --i2) {
          target[i2 + targetStart] = this[i2 + start];
        }
      } else if (len < 1e3 || !Buffer2.TYPED_ARRAY_SUPPORT) {
        for (i2 = 0; i2 < len; ++i2) {
          target[i2 + targetStart] = this[i2 + start];
        }
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, start + len),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val2, start, end, encoding) {
      if (typeof val2 === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (val2.length === 1) {
          var code4 = val2.charCodeAt(0);
          if (code4 < 256) {
            val2 = code4;
          }
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
      } else if (typeof val2 === "number") {
        val2 = val2 & 255;
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val2)
        val2 = 0;
      var i2;
      if (typeof val2 === "number") {
        for (i2 = start; i2 < end; ++i2) {
          this[i2] = val2;
        }
      } else {
        var bytes = internalIsBuffer(val2) ? val2 : utf8ToBytes(new Buffer2(val2, encoding).toString());
        var len = bytes.length;
        for (i2 = 0; i2 < end - start; ++i2) {
          this[i2 + start] = bytes[i2 % len];
        }
      }
      return this;
    };
    INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
  }
});

// node_modules/@esbuild-plugins/node-globals-polyfill/_buffer.js
var init_buffer = __esm({
  "node_modules/@esbuild-plugins/node-globals-polyfill/_buffer.js"() {
    init_Buffer();
  }
});

// node_modules/cookie/index.js
var require_cookie = __commonJS({
  "node_modules/cookie/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    exports.parse = parse6;
    exports.serialize = serialize4;
    var __toString = Object.prototype.toString;
    var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
    function parse6(str, options) {
      if (typeof str !== "string") {
        throw new TypeError("argument str must be a string");
      }
      var obj = {};
      var opt = options || {};
      var dec = opt.decode || decode3;
      var index3 = 0;
      while (index3 < str.length) {
        var eqIdx = str.indexOf("=", index3);
        if (eqIdx === -1) {
          break;
        }
        var endIdx = str.indexOf(";", index3);
        if (endIdx === -1) {
          endIdx = str.length;
        } else if (endIdx < eqIdx) {
          index3 = str.lastIndexOf(";", eqIdx - 1) + 1;
          continue;
        }
        var key2 = str.slice(index3, eqIdx).trim();
        if (void 0 === obj[key2]) {
          var val2 = str.slice(eqIdx + 1, endIdx).trim();
          if (val2.charCodeAt(0) === 34) {
            val2 = val2.slice(1, -1);
          }
          obj[key2] = tryDecode(val2, dec);
        }
        index3 = endIdx + 1;
      }
      return obj;
    }
    function serialize4(name, val2, options) {
      var opt = options || {};
      var enc = opt.encode || encode3;
      if (typeof enc !== "function") {
        throw new TypeError("option encode is invalid");
      }
      if (!fieldContentRegExp.test(name)) {
        throw new TypeError("argument name is invalid");
      }
      var value = enc(val2);
      if (value && !fieldContentRegExp.test(value)) {
        throw new TypeError("argument val is invalid");
      }
      var str = name + "=" + value;
      if (null != opt.maxAge) {
        var maxAge = opt.maxAge - 0;
        if (isNaN(maxAge) || !isFinite(maxAge)) {
          throw new TypeError("option maxAge is invalid");
        }
        str += "; Max-Age=" + Math.floor(maxAge);
      }
      if (opt.domain) {
        if (!fieldContentRegExp.test(opt.domain)) {
          throw new TypeError("option domain is invalid");
        }
        str += "; Domain=" + opt.domain;
      }
      if (opt.path) {
        if (!fieldContentRegExp.test(opt.path)) {
          throw new TypeError("option path is invalid");
        }
        str += "; Path=" + opt.path;
      }
      if (opt.expires) {
        var expires = opt.expires;
        if (!isDate2(expires) || isNaN(expires.valueOf())) {
          throw new TypeError("option expires is invalid");
        }
        str += "; Expires=" + expires.toUTCString();
      }
      if (opt.httpOnly) {
        str += "; HttpOnly";
      }
      if (opt.secure) {
        str += "; Secure";
      }
      if (opt.partitioned) {
        str += "; Partitioned";
      }
      if (opt.priority) {
        var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
        switch (priority) {
          case "low":
            str += "; Priority=Low";
            break;
          case "medium":
            str += "; Priority=Medium";
            break;
          case "high":
            str += "; Priority=High";
            break;
          default:
            throw new TypeError("option priority is invalid");
        }
      }
      if (opt.sameSite) {
        var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
        switch (sameSite) {
          case true:
            str += "; SameSite=Strict";
            break;
          case "lax":
            str += "; SameSite=Lax";
            break;
          case "strict":
            str += "; SameSite=Strict";
            break;
          case "none":
            str += "; SameSite=None";
            break;
          default:
            throw new TypeError("option sameSite is invalid");
        }
      }
      return str;
    }
    function decode3(str) {
      return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
    }
    function encode3(val2) {
      return encodeURIComponent(val2);
    }
    function isDate2(val2) {
      return __toString.call(val2) === "[object Date]" || val2 instanceof Date;
    }
    function tryDecode(str, decode4) {
      try {
        return decode4(str);
      } catch (e2) {
        return str;
      }
    }
  }
});

// node_modules/fast-decode-uri-component/index.js
var require_fast_decode_uri_component = __commonJS({
  "node_modules/fast-decode-uri-component/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var UTF8_ACCEPT = 12;
    var UTF8_REJECT = 0;
    var UTF8_DATA = [
      // The first part of the table maps bytes to character to a transition.
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      4,
      4,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      6,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      8,
      7,
      7,
      10,
      9,
      9,
      9,
      11,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      // The second part of the table maps a state to a new state when adding a
      // transition.
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      12,
      0,
      0,
      0,
      0,
      24,
      36,
      48,
      60,
      72,
      84,
      96,
      0,
      12,
      12,
      12,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      24,
      24,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      24,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      48,
      48,
      48,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      48,
      48,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      48,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // The third part maps the current transition to a mask that needs to apply
      // to the byte.
      127,
      63,
      63,
      63,
      0,
      31,
      15,
      15,
      15,
      7,
      7,
      7
    ];
    function decodeURIComponent3(uri2) {
      var percentPosition = uri2.indexOf("%");
      if (percentPosition === -1)
        return uri2;
      var length = uri2.length;
      var decoded = "";
      var last = 0;
      var codepoint = 0;
      var startOfOctets = percentPosition;
      var state = UTF8_ACCEPT;
      while (percentPosition > -1 && percentPosition < length) {
        var high = hexCodeToInt(uri2[percentPosition + 1], 4);
        var low = hexCodeToInt(uri2[percentPosition + 2], 0);
        var byte2 = high | low;
        var type = UTF8_DATA[byte2];
        state = UTF8_DATA[256 + state + type];
        codepoint = codepoint << 6 | byte2 & UTF8_DATA[364 + type];
        if (state === UTF8_ACCEPT) {
          decoded += uri2.slice(last, startOfOctets);
          decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(
            55232 + (codepoint >> 10),
            56320 + (codepoint & 1023)
          );
          codepoint = 0;
          last = percentPosition + 3;
          percentPosition = startOfOctets = uri2.indexOf("%", last);
        } else if (state === UTF8_REJECT) {
          return null;
        } else {
          percentPosition += 3;
          if (percentPosition < length && uri2.charCodeAt(percentPosition) === 37)
            continue;
          return null;
        }
      }
      return decoded + uri2.slice(last);
    }
    var HEX = {
      "0": 0,
      "1": 1,
      "2": 2,
      "3": 3,
      "4": 4,
      "5": 5,
      "6": 6,
      "7": 7,
      "8": 8,
      "9": 9,
      "a": 10,
      "A": 10,
      "b": 11,
      "B": 11,
      "c": 12,
      "C": 12,
      "d": 13,
      "D": 13,
      "e": 14,
      "E": 14,
      "f": 15,
      "F": 15
    };
    function hexCodeToInt(c2, shift) {
      var i2 = HEX[c2];
      return i2 === void 0 ? 255 : i2 << shift;
    }
    module.exports = decodeURIComponent3;
  }
});

// node_modules/reflect-metadata/Reflect.js
var require_Reflect = __commonJS({
  "node_modules/reflect-metadata/Reflect.js"() {
    init_process();
    init_buffer();
    var Reflect2;
    (function(Reflect3) {
      (function(factory) {
        var root4 = typeof globalThis === "object" ? globalThis : typeof globalThis === "object" ? globalThis : typeof self === "object" ? self : typeof this === "object" ? this : sloppyModeThis();
        var exporter = makeExporter(Reflect3);
        if (typeof root4.Reflect !== "undefined") {
          exporter = makeExporter(root4.Reflect, exporter);
        }
        factory(exporter, root4);
        if (typeof root4.Reflect === "undefined") {
          root4.Reflect = Reflect3;
        }
        function makeExporter(target, previous3) {
          return function(key2, value) {
            Object.defineProperty(target, key2, { configurable: true, writable: true, value });
            if (previous3)
              previous3(key2, value);
          };
        }
        function functionThis() {
          try {
            return Function("return this;")();
          } catch (_) {
          }
        }
        function indirectEvalThis() {
          try {
            return (void 0, eval)("(function() { return this; })()");
          } catch (_) {
          }
        }
        function sloppyModeThis() {
          return functionThis() || indirectEvalThis();
        }
      })(function(exporter, root4) {
        var hasOwn = Object.prototype.hasOwnProperty;
        var supportsSymbol = typeof Symbol === "function";
        var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
        var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
        var supportsCreate = typeof Object.create === "function";
        var supportsProto = { __proto__: [] } instanceof Array;
        var downLevel = !supportsCreate && !supportsProto;
        var HashMap = {
          // create an object in dictionary mode (a.k.a. "slow" mode in v8)
          create: supportsCreate ? function() {
            return MakeDictionary(/* @__PURE__ */ Object.create(null));
          } : supportsProto ? function() {
            return MakeDictionary({ __proto__: null });
          } : function() {
            return MakeDictionary({});
          },
          has: downLevel ? function(map9, key2) {
            return hasOwn.call(map9, key2);
          } : function(map9, key2) {
            return key2 in map9;
          },
          get: downLevel ? function(map9, key2) {
            return hasOwn.call(map9, key2) ? map9[key2] : void 0;
          } : function(map9, key2) {
            return map9[key2];
          }
        };
        var functionPrototype = Object.getPrototypeOf(Function);
        var _Map = typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
        var _Set = typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
        var _WeakMap = typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
        var registrySymbol = supportsSymbol ? Symbol.for("@reflect-metadata:registry") : void 0;
        var metadataRegistry = GetOrCreateMetadataRegistry();
        var metadataProvider = CreateMetadataProvider(metadataRegistry);
        function decorate(decorators, target, propertyKey, attributes) {
          if (!IsUndefined5(propertyKey)) {
            if (!IsArray5(decorators))
              throw new TypeError();
            if (!IsObject5(target))
              throw new TypeError();
            if (!IsObject5(attributes) && !IsUndefined5(attributes) && !IsNull5(attributes))
              throw new TypeError();
            if (IsNull5(attributes))
              attributes = void 0;
            propertyKey = ToPropertyKey(propertyKey);
            return DecorateProperty(decorators, target, propertyKey, attributes);
          } else {
            if (!IsArray5(decorators))
              throw new TypeError();
            if (!IsConstructor3(target))
              throw new TypeError();
            return DecorateConstructor(decorators, target);
          }
        }
        exporter("decorate", decorate);
        function metadata(metadataKey, metadataValue) {
          function decorator(target, propertyKey) {
            if (!IsObject5(target))
              throw new TypeError();
            if (!IsUndefined5(propertyKey) && !IsPropertyKey(propertyKey))
              throw new TypeError();
            OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
          }
          return decorator;
        }
        exporter("metadata", metadata);
        function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
          if (!IsObject5(target))
            throw new TypeError();
          if (!IsUndefined5(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        exporter("defineMetadata", defineMetadata);
        function hasMetadata(metadataKey, target, propertyKey) {
          if (!IsObject5(target))
            throw new TypeError();
          if (!IsUndefined5(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryHasMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasMetadata", hasMetadata);
        function hasOwnMetadata(metadataKey, target, propertyKey) {
          if (!IsObject5(target))
            throw new TypeError();
          if (!IsUndefined5(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasOwnMetadata", hasOwnMetadata);
        function getMetadata(metadataKey, target, propertyKey) {
          if (!IsObject5(target))
            throw new TypeError();
          if (!IsUndefined5(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryGetMetadata(metadataKey, target, propertyKey);
        }
        exporter("getMetadata", getMetadata);
        function getOwnMetadata(metadataKey, target, propertyKey) {
          if (!IsObject5(target))
            throw new TypeError();
          if (!IsUndefined5(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("getOwnMetadata", getOwnMetadata);
        function getMetadataKeys(target, propertyKey) {
          if (!IsObject5(target))
            throw new TypeError();
          if (!IsUndefined5(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryMetadataKeys(target, propertyKey);
        }
        exporter("getMetadataKeys", getMetadataKeys);
        function getOwnMetadataKeys(target, propertyKey) {
          if (!IsObject5(target))
            throw new TypeError();
          if (!IsUndefined5(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryOwnMetadataKeys(target, propertyKey);
        }
        exporter("getOwnMetadataKeys", getOwnMetadataKeys);
        function deleteMetadata(metadataKey, target, propertyKey) {
          if (!IsObject5(target))
            throw new TypeError();
          if (!IsUndefined5(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          if (!IsObject5(target))
            throw new TypeError();
          if (!IsUndefined5(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          var provider = GetMetadataProvider(
            target,
            propertyKey,
            /*Create*/
            false
          );
          if (IsUndefined5(provider))
            return false;
          return provider.OrdinaryDeleteMetadata(metadataKey, target, propertyKey);
        }
        exporter("deleteMetadata", deleteMetadata);
        function DecorateConstructor(decorators, target) {
          for (var i2 = decorators.length - 1; i2 >= 0; --i2) {
            var decorator = decorators[i2];
            var decorated = decorator(target);
            if (!IsUndefined5(decorated) && !IsNull5(decorated)) {
              if (!IsConstructor3(decorated))
                throw new TypeError();
              target = decorated;
            }
          }
          return target;
        }
        function DecorateProperty(decorators, target, propertyKey, descriptor) {
          for (var i2 = decorators.length - 1; i2 >= 0; --i2) {
            var decorator = decorators[i2];
            var decorated = decorator(target, propertyKey, descriptor);
            if (!IsUndefined5(decorated) && !IsNull5(decorated)) {
              if (!IsObject5(decorated))
                throw new TypeError();
              descriptor = decorated;
            }
          }
          return descriptor;
        }
        function OrdinaryHasMetadata(MetadataKey, O2, P2) {
          var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O2, P2);
          if (hasOwn2)
            return true;
          var parent = OrdinaryGetPrototypeOf(O2);
          if (!IsNull5(parent))
            return OrdinaryHasMetadata(MetadataKey, parent, P2);
          return false;
        }
        function OrdinaryHasOwnMetadata(MetadataKey, O2, P2) {
          var provider = GetMetadataProvider(
            O2,
            P2,
            /*Create*/
            false
          );
          if (IsUndefined5(provider))
            return false;
          return ToBoolean(provider.OrdinaryHasOwnMetadata(MetadataKey, O2, P2));
        }
        function OrdinaryGetMetadata(MetadataKey, O2, P2) {
          var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O2, P2);
          if (hasOwn2)
            return OrdinaryGetOwnMetadata(MetadataKey, O2, P2);
          var parent = OrdinaryGetPrototypeOf(O2);
          if (!IsNull5(parent))
            return OrdinaryGetMetadata(MetadataKey, parent, P2);
          return void 0;
        }
        function OrdinaryGetOwnMetadata(MetadataKey, O2, P2) {
          var provider = GetMetadataProvider(
            O2,
            P2,
            /*Create*/
            false
          );
          if (IsUndefined5(provider))
            return;
          return provider.OrdinaryGetOwnMetadata(MetadataKey, O2, P2);
        }
        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O2, P2) {
          var provider = GetMetadataProvider(
            O2,
            P2,
            /*Create*/
            true
          );
          provider.OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O2, P2);
        }
        function OrdinaryMetadataKeys(O2, P2) {
          var ownKeys = OrdinaryOwnMetadataKeys(O2, P2);
          var parent = OrdinaryGetPrototypeOf(O2);
          if (parent === null)
            return ownKeys;
          var parentKeys = OrdinaryMetadataKeys(parent, P2);
          if (parentKeys.length <= 0)
            return ownKeys;
          if (ownKeys.length <= 0)
            return parentKeys;
          var set = new _Set();
          var keys3 = [];
          for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
            var key2 = ownKeys_1[_i];
            var hasKey = set.has(key2);
            if (!hasKey) {
              set.add(key2);
              keys3.push(key2);
            }
          }
          for (var _a89 = 0, parentKeys_1 = parentKeys; _a89 < parentKeys_1.length; _a89++) {
            var key2 = parentKeys_1[_a89];
            var hasKey = set.has(key2);
            if (!hasKey) {
              set.add(key2);
              keys3.push(key2);
            }
          }
          return keys3;
        }
        function OrdinaryOwnMetadataKeys(O2, P2) {
          var provider = GetMetadataProvider(
            O2,
            P2,
            /*create*/
            false
          );
          if (!provider) {
            return [];
          }
          return provider.OrdinaryOwnMetadataKeys(O2, P2);
        }
        function Type2(x2) {
          if (x2 === null)
            return 1;
          switch (typeof x2) {
            case "undefined":
              return 0;
            case "boolean":
              return 2;
            case "string":
              return 3;
            case "symbol":
              return 4;
            case "number":
              return 5;
            case "object":
              return x2 === null ? 1 : 6;
            default:
              return 6;
          }
        }
        function IsUndefined5(x2) {
          return x2 === void 0;
        }
        function IsNull5(x2) {
          return x2 === null;
        }
        function IsSymbol5(x2) {
          return typeof x2 === "symbol";
        }
        function IsObject5(x2) {
          return typeof x2 === "object" ? x2 !== null : typeof x2 === "function";
        }
        function ToPrimitive(input, PreferredType) {
          switch (Type2(input)) {
            case 0:
              return input;
            case 1:
              return input;
            case 2:
              return input;
            case 3:
              return input;
            case 4:
              return input;
            case 5:
              return input;
          }
          var hint = PreferredType === 3 ? "string" : PreferredType === 5 ? "number" : "default";
          var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
          if (exoticToPrim !== void 0) {
            var result = exoticToPrim.call(input, hint);
            if (IsObject5(result))
              throw new TypeError();
            return result;
          }
          return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
        }
        function OrdinaryToPrimitive(O2, hint) {
          if (hint === "string") {
            var toString_1 = O2.toString;
            if (IsCallable(toString_1)) {
              var result = toString_1.call(O2);
              if (!IsObject5(result))
                return result;
            }
            var valueOf = O2.valueOf;
            if (IsCallable(valueOf)) {
              var result = valueOf.call(O2);
              if (!IsObject5(result))
                return result;
            }
          } else {
            var valueOf = O2.valueOf;
            if (IsCallable(valueOf)) {
              var result = valueOf.call(O2);
              if (!IsObject5(result))
                return result;
            }
            var toString_2 = O2.toString;
            if (IsCallable(toString_2)) {
              var result = toString_2.call(O2);
              if (!IsObject5(result))
                return result;
            }
          }
          throw new TypeError();
        }
        function ToBoolean(argument) {
          return !!argument;
        }
        function ToString(argument) {
          return "" + argument;
        }
        function ToPropertyKey(argument) {
          var key2 = ToPrimitive(
            argument,
            3
            /* String */
          );
          if (IsSymbol5(key2))
            return key2;
          return ToString(key2);
        }
        function IsArray5(argument) {
          return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : Object.prototype.toString.call(argument) === "[object Array]";
        }
        function IsCallable(argument) {
          return typeof argument === "function";
        }
        function IsConstructor3(argument) {
          return typeof argument === "function";
        }
        function IsPropertyKey(argument) {
          switch (Type2(argument)) {
            case 3:
              return true;
            case 4:
              return true;
            default:
              return false;
          }
        }
        function SameValueZero(x2, y2) {
          return x2 === y2 || x2 !== x2 && y2 !== y2;
        }
        function GetMethod(V2, P2) {
          var func = V2[P2];
          if (func === void 0 || func === null)
            return void 0;
          if (!IsCallable(func))
            throw new TypeError();
          return func;
        }
        function GetIterator(obj) {
          var method = GetMethod(obj, iteratorSymbol);
          if (!IsCallable(method))
            throw new TypeError();
          var iterator = method.call(obj);
          if (!IsObject5(iterator))
            throw new TypeError();
          return iterator;
        }
        function IteratorValue(iterResult) {
          return iterResult.value;
        }
        function IteratorStep(iterator) {
          var result = iterator.next();
          return result.done ? false : result;
        }
        function IteratorClose(iterator) {
          var f2 = iterator["return"];
          if (f2)
            f2.call(iterator);
        }
        function OrdinaryGetPrototypeOf(O2) {
          var proto = Object.getPrototypeOf(O2);
          if (typeof O2 !== "function" || O2 === functionPrototype)
            return proto;
          if (proto !== functionPrototype)
            return proto;
          var prototype = O2.prototype;
          var prototypeProto = prototype && Object.getPrototypeOf(prototype);
          if (prototypeProto == null || prototypeProto === Object.prototype)
            return proto;
          var constructor = prototypeProto.constructor;
          if (typeof constructor !== "function")
            return proto;
          if (constructor === O2)
            return proto;
          return constructor;
        }
        function CreateMetadataRegistry() {
          var fallback;
          if (!IsUndefined5(registrySymbol) && typeof root4.Reflect !== "undefined" && !(registrySymbol in root4.Reflect) && typeof root4.Reflect.defineMetadata === "function") {
            fallback = CreateFallbackProvider(root4.Reflect);
          }
          var first;
          var second;
          var rest;
          var targetProviderMap = new _WeakMap();
          var registry = {
            registerProvider,
            getProvider,
            setProvider
          };
          return registry;
          function registerProvider(provider) {
            if (!Object.isExtensible(registry)) {
              throw new Error("Cannot add provider to a frozen registry.");
            }
            switch (true) {
              case fallback === provider:
                break;
              case IsUndefined5(first):
                first = provider;
                break;
              case first === provider:
                break;
              case IsUndefined5(second):
                second = provider;
                break;
              case second === provider:
                break;
              default:
                if (rest === void 0)
                  rest = new _Set();
                rest.add(provider);
                break;
            }
          }
          function getProviderNoCache(O2, P2) {
            if (!IsUndefined5(first)) {
              if (first.isProviderFor(O2, P2))
                return first;
              if (!IsUndefined5(second)) {
                if (second.isProviderFor(O2, P2))
                  return first;
                if (!IsUndefined5(rest)) {
                  var iterator = GetIterator(rest);
                  while (true) {
                    var next = IteratorStep(iterator);
                    if (!next) {
                      return void 0;
                    }
                    var provider = IteratorValue(next);
                    if (provider.isProviderFor(O2, P2)) {
                      IteratorClose(iterator);
                      return provider;
                    }
                  }
                }
              }
            }
            if (!IsUndefined5(fallback) && fallback.isProviderFor(O2, P2)) {
              return fallback;
            }
            return void 0;
          }
          function getProvider(O2, P2) {
            var providerMap = targetProviderMap.get(O2);
            var provider;
            if (!IsUndefined5(providerMap)) {
              provider = providerMap.get(P2);
            }
            if (!IsUndefined5(provider)) {
              return provider;
            }
            provider = getProviderNoCache(O2, P2);
            if (!IsUndefined5(provider)) {
              if (IsUndefined5(providerMap)) {
                providerMap = new _Map();
                targetProviderMap.set(O2, providerMap);
              }
              providerMap.set(P2, provider);
            }
            return provider;
          }
          function hasProvider(provider) {
            if (IsUndefined5(provider))
              throw new TypeError();
            return first === provider || second === provider || !IsUndefined5(rest) && rest.has(provider);
          }
          function setProvider(O2, P2, provider) {
            if (!hasProvider(provider)) {
              throw new Error("Metadata provider not registered.");
            }
            var existingProvider = getProvider(O2, P2);
            if (existingProvider !== provider) {
              if (!IsUndefined5(existingProvider)) {
                return false;
              }
              var providerMap = targetProviderMap.get(O2);
              if (IsUndefined5(providerMap)) {
                providerMap = new _Map();
                targetProviderMap.set(O2, providerMap);
              }
              providerMap.set(P2, provider);
            }
            return true;
          }
        }
        function GetOrCreateMetadataRegistry() {
          var metadataRegistry2;
          if (!IsUndefined5(registrySymbol) && IsObject5(root4.Reflect) && Object.isExtensible(root4.Reflect)) {
            metadataRegistry2 = root4.Reflect[registrySymbol];
          }
          if (IsUndefined5(metadataRegistry2)) {
            metadataRegistry2 = CreateMetadataRegistry();
          }
          if (!IsUndefined5(registrySymbol) && IsObject5(root4.Reflect) && Object.isExtensible(root4.Reflect)) {
            Object.defineProperty(root4.Reflect, registrySymbol, {
              enumerable: false,
              configurable: false,
              writable: false,
              value: metadataRegistry2
            });
          }
          return metadataRegistry2;
        }
        function CreateMetadataProvider(registry) {
          var metadata2 = new _WeakMap();
          var provider = {
            isProviderFor: function(O2, P2) {
              var targetMetadata = metadata2.get(O2);
              if (IsUndefined5(targetMetadata))
                return false;
              return targetMetadata.has(P2);
            },
            OrdinaryDefineOwnMetadata: OrdinaryDefineOwnMetadata2,
            OrdinaryHasOwnMetadata: OrdinaryHasOwnMetadata2,
            OrdinaryGetOwnMetadata: OrdinaryGetOwnMetadata2,
            OrdinaryOwnMetadataKeys: OrdinaryOwnMetadataKeys2,
            OrdinaryDeleteMetadata
          };
          metadataRegistry.registerProvider(provider);
          return provider;
          function GetOrCreateMetadataMap(O2, P2, Create4) {
            var targetMetadata = metadata2.get(O2);
            var createdTargetMetadata = false;
            if (IsUndefined5(targetMetadata)) {
              if (!Create4)
                return void 0;
              targetMetadata = new _Map();
              metadata2.set(O2, targetMetadata);
              createdTargetMetadata = true;
            }
            var metadataMap = targetMetadata.get(P2);
            if (IsUndefined5(metadataMap)) {
              if (!Create4)
                return void 0;
              metadataMap = new _Map();
              targetMetadata.set(P2, metadataMap);
              if (!registry.setProvider(O2, P2, provider)) {
                targetMetadata.delete(P2);
                if (createdTargetMetadata) {
                  metadata2.delete(O2);
                }
                throw new Error("Wrong provider for target.");
              }
            }
            return metadataMap;
          }
          function OrdinaryHasOwnMetadata2(MetadataKey, O2, P2) {
            var metadataMap = GetOrCreateMetadataMap(
              O2,
              P2,
              /*Create*/
              false
            );
            if (IsUndefined5(metadataMap))
              return false;
            return ToBoolean(metadataMap.has(MetadataKey));
          }
          function OrdinaryGetOwnMetadata2(MetadataKey, O2, P2) {
            var metadataMap = GetOrCreateMetadataMap(
              O2,
              P2,
              /*Create*/
              false
            );
            if (IsUndefined5(metadataMap))
              return void 0;
            return metadataMap.get(MetadataKey);
          }
          function OrdinaryDefineOwnMetadata2(MetadataKey, MetadataValue, O2, P2) {
            var metadataMap = GetOrCreateMetadataMap(
              O2,
              P2,
              /*Create*/
              true
            );
            metadataMap.set(MetadataKey, MetadataValue);
          }
          function OrdinaryOwnMetadataKeys2(O2, P2) {
            var keys3 = [];
            var metadataMap = GetOrCreateMetadataMap(
              O2,
              P2,
              /*Create*/
              false
            );
            if (IsUndefined5(metadataMap))
              return keys3;
            var keysObj = metadataMap.keys();
            var iterator = GetIterator(keysObj);
            var k2 = 0;
            while (true) {
              var next = IteratorStep(iterator);
              if (!next) {
                keys3.length = k2;
                return keys3;
              }
              var nextValue = IteratorValue(next);
              try {
                keys3[k2] = nextValue;
              } catch (e2) {
                try {
                  IteratorClose(iterator);
                } finally {
                  throw e2;
                }
              }
              k2++;
            }
          }
          function OrdinaryDeleteMetadata(MetadataKey, O2, P2) {
            var metadataMap = GetOrCreateMetadataMap(
              O2,
              P2,
              /*Create*/
              false
            );
            if (IsUndefined5(metadataMap))
              return false;
            if (!metadataMap.delete(MetadataKey))
              return false;
            if (metadataMap.size === 0) {
              var targetMetadata = metadata2.get(O2);
              if (!IsUndefined5(targetMetadata)) {
                targetMetadata.delete(P2);
                if (targetMetadata.size === 0) {
                  metadata2.delete(targetMetadata);
                }
              }
            }
            return true;
          }
        }
        function CreateFallbackProvider(reflect) {
          var defineMetadata2 = reflect.defineMetadata, hasOwnMetadata2 = reflect.hasOwnMetadata, getOwnMetadata2 = reflect.getOwnMetadata, getOwnMetadataKeys2 = reflect.getOwnMetadataKeys, deleteMetadata2 = reflect.deleteMetadata;
          var metadataOwner = new _WeakMap();
          var provider = {
            isProviderFor: function(O2, P2) {
              var metadataPropertySet = metadataOwner.get(O2);
              if (!IsUndefined5(metadataPropertySet) && metadataPropertySet.has(P2)) {
                return true;
              }
              if (getOwnMetadataKeys2(O2, P2).length) {
                if (IsUndefined5(metadataPropertySet)) {
                  metadataPropertySet = new _Set();
                  metadataOwner.set(O2, metadataPropertySet);
                }
                metadataPropertySet.add(P2);
                return true;
              }
              return false;
            },
            OrdinaryDefineOwnMetadata: defineMetadata2,
            OrdinaryHasOwnMetadata: hasOwnMetadata2,
            OrdinaryGetOwnMetadata: getOwnMetadata2,
            OrdinaryOwnMetadataKeys: getOwnMetadataKeys2,
            OrdinaryDeleteMetadata: deleteMetadata2
          };
          return provider;
        }
        function GetMetadataProvider(O2, P2, Create4) {
          var registeredProvider = metadataRegistry.getProvider(O2, P2);
          if (!IsUndefined5(registeredProvider)) {
            return registeredProvider;
          }
          if (Create4) {
            if (metadataRegistry.setProvider(O2, P2, metadataProvider)) {
              return metadataProvider;
            }
            throw new Error("Illegal state.");
          }
          return void 0;
        }
        function CreateMapPolyfill() {
          var cacheSentinel = {};
          var arraySentinel = [];
          var MapIterator = (
            /** @class */
            function() {
              function MapIterator2(keys3, values, selector) {
                this._index = 0;
                this._keys = keys3;
                this._values = values;
                this._selector = selector;
              }
              MapIterator2.prototype["@@iterator"] = function() {
                return this;
              };
              MapIterator2.prototype[iteratorSymbol] = function() {
                return this;
              };
              MapIterator2.prototype.next = function() {
                var index3 = this._index;
                if (index3 >= 0 && index3 < this._keys.length) {
                  var result = this._selector(this._keys[index3], this._values[index3]);
                  if (index3 + 1 >= this._keys.length) {
                    this._index = -1;
                    this._keys = arraySentinel;
                    this._values = arraySentinel;
                  } else {
                    this._index++;
                  }
                  return { value: result, done: false };
                }
                return { value: void 0, done: true };
              };
              MapIterator2.prototype.throw = function(error3) {
                if (this._index >= 0) {
                  this._index = -1;
                  this._keys = arraySentinel;
                  this._values = arraySentinel;
                }
                throw error3;
              };
              MapIterator2.prototype.return = function(value) {
                if (this._index >= 0) {
                  this._index = -1;
                  this._keys = arraySentinel;
                  this._values = arraySentinel;
                }
                return { value, done: true };
              };
              return MapIterator2;
            }()
          );
          var Map2 = (
            /** @class */
            function() {
              function Map3() {
                this._keys = [];
                this._values = [];
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
              }
              Object.defineProperty(Map3.prototype, "size", {
                get: function() {
                  return this._keys.length;
                },
                enumerable: true,
                configurable: true
              });
              Map3.prototype.has = function(key2) {
                return this._find(
                  key2,
                  /*insert*/
                  false
                ) >= 0;
              };
              Map3.prototype.get = function(key2) {
                var index3 = this._find(
                  key2,
                  /*insert*/
                  false
                );
                return index3 >= 0 ? this._values[index3] : void 0;
              };
              Map3.prototype.set = function(key2, value) {
                var index3 = this._find(
                  key2,
                  /*insert*/
                  true
                );
                this._values[index3] = value;
                return this;
              };
              Map3.prototype.delete = function(key2) {
                var index3 = this._find(
                  key2,
                  /*insert*/
                  false
                );
                if (index3 >= 0) {
                  var size = this._keys.length;
                  for (var i2 = index3 + 1; i2 < size; i2++) {
                    this._keys[i2 - 1] = this._keys[i2];
                    this._values[i2 - 1] = this._values[i2];
                  }
                  this._keys.length--;
                  this._values.length--;
                  if (SameValueZero(key2, this._cacheKey)) {
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                  }
                  return true;
                }
                return false;
              };
              Map3.prototype.clear = function() {
                this._keys.length = 0;
                this._values.length = 0;
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
              };
              Map3.prototype.keys = function() {
                return new MapIterator(this._keys, this._values, getKey);
              };
              Map3.prototype.values = function() {
                return new MapIterator(this._keys, this._values, getValue);
              };
              Map3.prototype.entries = function() {
                return new MapIterator(this._keys, this._values, getEntry);
              };
              Map3.prototype["@@iterator"] = function() {
                return this.entries();
              };
              Map3.prototype[iteratorSymbol] = function() {
                return this.entries();
              };
              Map3.prototype._find = function(key2, insert) {
                if (!SameValueZero(this._cacheKey, key2)) {
                  this._cacheIndex = -1;
                  for (var i2 = 0; i2 < this._keys.length; i2++) {
                    if (SameValueZero(this._keys[i2], key2)) {
                      this._cacheIndex = i2;
                      break;
                    }
                  }
                }
                if (this._cacheIndex < 0 && insert) {
                  this._cacheIndex = this._keys.length;
                  this._keys.push(key2);
                  this._values.push(void 0);
                }
                return this._cacheIndex;
              };
              return Map3;
            }()
          );
          return Map2;
          function getKey(key2, _) {
            return key2;
          }
          function getValue(_, value) {
            return value;
          }
          function getEntry(key2, value) {
            return [key2, value];
          }
        }
        function CreateSetPolyfill() {
          var Set5 = (
            /** @class */
            function() {
              function Set6() {
                this._map = new _Map();
              }
              Object.defineProperty(Set6.prototype, "size", {
                get: function() {
                  return this._map.size;
                },
                enumerable: true,
                configurable: true
              });
              Set6.prototype.has = function(value) {
                return this._map.has(value);
              };
              Set6.prototype.add = function(value) {
                return this._map.set(value, value), this;
              };
              Set6.prototype.delete = function(value) {
                return this._map.delete(value);
              };
              Set6.prototype.clear = function() {
                this._map.clear();
              };
              Set6.prototype.keys = function() {
                return this._map.keys();
              };
              Set6.prototype.values = function() {
                return this._map.keys();
              };
              Set6.prototype.entries = function() {
                return this._map.entries();
              };
              Set6.prototype["@@iterator"] = function() {
                return this.keys();
              };
              Set6.prototype[iteratorSymbol] = function() {
                return this.keys();
              };
              return Set6;
            }()
          );
          return Set5;
        }
        function CreateWeakMapPolyfill() {
          var UUID_SIZE = 16;
          var keys3 = HashMap.create();
          var rootKey = CreateUniqueKey();
          return (
            /** @class */
            function() {
              function WeakMap2() {
                this._key = CreateUniqueKey();
              }
              WeakMap2.prototype.has = function(target) {
                var table2 = GetOrCreateWeakMapTable(
                  target,
                  /*create*/
                  false
                );
                return table2 !== void 0 ? HashMap.has(table2, this._key) : false;
              };
              WeakMap2.prototype.get = function(target) {
                var table2 = GetOrCreateWeakMapTable(
                  target,
                  /*create*/
                  false
                );
                return table2 !== void 0 ? HashMap.get(table2, this._key) : void 0;
              };
              WeakMap2.prototype.set = function(target, value) {
                var table2 = GetOrCreateWeakMapTable(
                  target,
                  /*create*/
                  true
                );
                table2[this._key] = value;
                return this;
              };
              WeakMap2.prototype.delete = function(target) {
                var table2 = GetOrCreateWeakMapTable(
                  target,
                  /*create*/
                  false
                );
                return table2 !== void 0 ? delete table2[this._key] : false;
              };
              WeakMap2.prototype.clear = function() {
                this._key = CreateUniqueKey();
              };
              return WeakMap2;
            }()
          );
          function CreateUniqueKey() {
            var key2;
            do
              key2 = "@@WeakMap@@" + CreateUUID();
            while (HashMap.has(keys3, key2));
            keys3[key2] = true;
            return key2;
          }
          function GetOrCreateWeakMapTable(target, create2) {
            if (!hasOwn.call(target, rootKey)) {
              if (!create2)
                return void 0;
              Object.defineProperty(target, rootKey, { value: HashMap.create() });
            }
            return target[rootKey];
          }
          function FillRandomBytes(buffer, size) {
            for (var i2 = 0; i2 < size; ++i2)
              buffer[i2] = Math.random() * 255 | 0;
            return buffer;
          }
          function GenRandomBytes(size) {
            if (typeof Uint8Array === "function") {
              var array = new Uint8Array(size);
              if (typeof crypto !== "undefined") {
                crypto.getRandomValues(array);
              } else if (typeof msCrypto !== "undefined") {
                msCrypto.getRandomValues(array);
              } else {
                FillRandomBytes(array, size);
              }
              return array;
            }
            return FillRandomBytes(new Array(size), size);
          }
          function CreateUUID() {
            var data = GenRandomBytes(UUID_SIZE);
            data[6] = data[6] & 79 | 64;
            data[8] = data[8] & 191 | 128;
            var result = "";
            for (var offset = 0; offset < UUID_SIZE; ++offset) {
              var byte2 = data[offset];
              if (offset === 4 || offset === 6 || offset === 8)
                result += "-";
              if (byte2 < 16)
                result += "0";
              result += byte2.toString(16).toLowerCase();
            }
            return result;
          }
        }
        function MakeDictionary(obj) {
          obj.__ = void 0;
          delete obj.__;
          return obj;
        }
      });
    })(Reflect2 || (Reflect2 = {}));
  }
});

// node_modules/oslo/dist/index.js
function createDate(timeSpan) {
  return new Date(Date.now() + timeSpan.milliseconds());
}
var TimeSpan;
var init_dist = __esm({
  "node_modules/oslo/dist/index.js"() {
    init_process();
    init_buffer();
    TimeSpan = class {
      constructor(value, unit) {
        this.value = value;
        this.unit = unit;
      }
      value;
      unit;
      milliseconds() {
        if (this.unit === "ms") {
          return this.value;
        }
        if (this.unit === "s") {
          return this.value * 1e3;
        }
        if (this.unit === "m") {
          return this.value * 1e3 * 60;
        }
        if (this.unit === "h") {
          return this.value * 1e3 * 60 * 60;
        }
        if (this.unit === "d") {
          return this.value * 1e3 * 60 * 60 * 24;
        }
        return this.value * 1e3 * 60 * 60 * 24 * 7;
      }
      seconds() {
        return this.milliseconds() / 1e3;
      }
      transform(x2) {
        return new TimeSpan(Math.round(this.milliseconds() * x2), "ms");
      }
    };
  }
});

// node_modules/oslo/dist/crypto/ecdsa.js
var ECDSA;
var init_ecdsa = __esm({
  "node_modules/oslo/dist/crypto/ecdsa.js"() {
    init_process();
    init_buffer();
    ECDSA = class {
      hash;
      curve;
      constructor(hash, curve) {
        this.hash = hash;
        this.curve = curve;
      }
      async sign(privateKey, data) {
        const cryptoKey = await crypto.subtle.importKey("pkcs8", privateKey, {
          name: "ECDSA",
          namedCurve: this.curve
        }, false, ["sign"]);
        const signature = await crypto.subtle.sign({
          name: "ECDSA",
          hash: this.hash
        }, cryptoKey, data);
        return signature;
      }
      async verify(publicKey, signature, data) {
        const cryptoKey = await crypto.subtle.importKey("spki", publicKey, {
          name: "ECDSA",
          namedCurve: this.curve
        }, false, ["verify"]);
        return await crypto.subtle.verify({
          name: "ECDSA",
          hash: this.hash
        }, cryptoKey, signature, data);
      }
      async generateKeyPair() {
        const cryptoKeyPair = await crypto.subtle.generateKey({
          name: "ECDSA",
          namedCurve: this.curve
        }, true, ["sign"]);
        const privateKey = await crypto.subtle.exportKey("pkcs8", cryptoKeyPair.privateKey);
        const publicKey = await crypto.subtle.exportKey("spki", cryptoKeyPair.publicKey);
        return {
          privateKey,
          publicKey
        };
      }
    };
  }
});

// node_modules/oslo/dist/crypto/hmac.js
var HMAC;
var init_hmac = __esm({
  "node_modules/oslo/dist/crypto/hmac.js"() {
    init_process();
    init_buffer();
    HMAC = class {
      hash;
      constructor(hash) {
        this.hash = hash;
      }
      async verify(key2, signature, data) {
        const cryptoKey = await crypto.subtle.importKey("raw", key2, {
          name: "HMAC",
          hash: this.hash
        }, false, ["verify"]);
        return await crypto.subtle.verify("HMAC", cryptoKey, signature, data);
      }
      async sign(key2, data) {
        const cryptoKey = await crypto.subtle.importKey("raw", key2, {
          name: "HMAC",
          hash: this.hash
        }, false, ["sign"]);
        const signature = await crypto.subtle.sign("HMAC", cryptoKey, data);
        return signature;
      }
      async generateKey() {
        const cryptoKey = await crypto.subtle.generateKey({
          name: "HMAC",
          hash: this.hash
        }, true, ["sign"]);
        const key2 = await crypto.subtle.exportKey("raw", cryptoKey);
        return key2;
      }
    };
  }
});

// node_modules/oslo/dist/crypto/rsa.js
var RSASSAPKCS1v1_5, RSASSAPSS;
var init_rsa = __esm({
  "node_modules/oslo/dist/crypto/rsa.js"() {
    init_process();
    init_buffer();
    RSASSAPKCS1v1_5 = class {
      hash;
      constructor(hash) {
        this.hash = hash;
      }
      async verify(publicKey, signature, data) {
        const cryptoKey = await crypto.subtle.importKey("spki", publicKey, {
          name: "RSASSA-PKCS1-v1_5",
          hash: this.hash
        }, false, ["verify"]);
        return await crypto.subtle.verify("RSASSA-PKCS1-v1_5", cryptoKey, signature, data);
      }
      async sign(privateKey, data) {
        const cryptoKey = await crypto.subtle.importKey("pkcs8", privateKey, {
          name: "RSASSA-PKCS1-v1_5",
          hash: this.hash
        }, false, ["sign"]);
        const signature = await crypto.subtle.sign("RSASSA-PKCS1-v1_5", cryptoKey, data);
        return signature;
      }
      async generateKeyPair(modulusLength) {
        const cryptoKeyPair = await crypto.subtle.generateKey({
          name: "RSASSA-PKCS1-v1_5",
          hash: this.hash,
          modulusLength: modulusLength ?? 2048,
          publicExponent: new Uint8Array([1, 0, 1])
        }, true, ["sign"]);
        const privateKey = await crypto.subtle.exportKey("pkcs8", cryptoKeyPair.privateKey);
        const publicKey = await crypto.subtle.exportKey("spki", cryptoKeyPair.publicKey);
        return {
          privateKey,
          publicKey
        };
      }
    };
    RSASSAPSS = class {
      hash;
      saltLength;
      constructor(hash) {
        this.hash = hash;
        if (hash === "SHA-1") {
          this.saltLength = 20;
        } else if (hash === "SHA-256") {
          this.saltLength = 32;
        } else if (hash === "SHA-384") {
          this.saltLength = 48;
        } else {
          this.saltLength = 64;
        }
      }
      async verify(publicKey, signature, data) {
        const cryptoKey = await crypto.subtle.importKey("spki", publicKey, {
          name: "RSA-PSS",
          hash: this.hash
        }, false, ["verify"]);
        return await crypto.subtle.verify({
          name: "RSA-PSS",
          saltLength: this.saltLength
        }, cryptoKey, signature, data);
      }
      async sign(privateKey, data) {
        const cryptoKey = await crypto.subtle.importKey("pkcs8", privateKey, {
          name: "RSA-PSS",
          hash: this.hash
        }, false, ["sign"]);
        const signature = await crypto.subtle.sign({
          name: "RSA-PSS",
          saltLength: this.saltLength
        }, cryptoKey, data);
        return signature;
      }
      async generateKeyPair(modulusLength) {
        const cryptoKeyPair = await crypto.subtle.generateKey({
          name: "RSA-PSS",
          hash: this.hash,
          modulusLength: modulusLength ?? 2048,
          publicExponent: new Uint8Array([1, 0, 1])
        }, true, ["sign"]);
        const privateKey = await crypto.subtle.exportKey("pkcs8", cryptoKeyPair.privateKey);
        const publicKey = await crypto.subtle.exportKey("spki", cryptoKeyPair.publicKey);
        return {
          privateKey,
          publicKey
        };
      }
    };
  }
});

// node_modules/oslo/dist/crypto/sha.js
async function sha256(data) {
  return await crypto.subtle.digest("SHA-256", data);
}
var init_sha = __esm({
  "node_modules/oslo/dist/crypto/sha.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/oslo/dist/bytes.js
var init_bytes = __esm({
  "node_modules/oslo/dist/bytes.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/oslo/dist/crypto/random.js
var init_random = __esm({
  "node_modules/oslo/dist/crypto/random.js"() {
    init_process();
    init_buffer();
    init_bytes();
  }
});

// node_modules/oslo/dist/crypto/buffer.js
var init_buffer2 = __esm({
  "node_modules/oslo/dist/crypto/buffer.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/oslo/dist/crypto/index.js
var init_crypto = __esm({
  "node_modules/oslo/dist/crypto/index.js"() {
    init_process();
    init_buffer();
    init_ecdsa();
    init_hmac();
    init_rsa();
    init_sha();
    init_random();
    init_buffer2();
  }
});

// node_modules/oslo/dist/encoding/hex.js
var init_hex = __esm({
  "node_modules/oslo/dist/encoding/hex.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/oslo/dist/encoding/base32.js
var Base32Encoding, base32, base32hex;
var init_base32 = __esm({
  "node_modules/oslo/dist/encoding/base32.js"() {
    init_process();
    init_buffer();
    Base32Encoding = class {
      alphabet;
      padding;
      decodeMap = /* @__PURE__ */ new Map();
      constructor(alphabet2, options) {
        if (alphabet2.length !== 32) {
          throw new Error("Invalid alphabet");
        }
        this.alphabet = alphabet2;
        this.padding = options?.padding ?? "=";
        if (this.alphabet.includes(this.padding) || this.padding.length !== 1) {
          throw new Error("Invalid padding");
        }
        for (let i2 = 0; i2 < alphabet2.length; i2++) {
          this.decodeMap.set(alphabet2[i2], i2);
        }
      }
      encode(data, options) {
        let result = "";
        let buffer = 0;
        let shift = 0;
        for (let i2 = 0; i2 < data.length; i2++) {
          buffer = buffer << 8 | data[i2];
          shift += 8;
          while (shift >= 5) {
            shift -= 5;
            result += this.alphabet[buffer >> shift & 31];
          }
        }
        if (shift > 0) {
          result += this.alphabet[buffer << 5 - shift & 31];
        }
        const includePadding = options?.includePadding ?? true;
        if (includePadding) {
          const padCount = (8 - result.length % 8) % 8;
          for (let i2 = 0; i2 < padCount; i2++) {
            result += "=";
          }
        }
        return result;
      }
      decode(data, options) {
        const strict = options?.strict ?? true;
        const chunkCount = Math.ceil(data.length / 8);
        const result = [];
        for (let i2 = 0; i2 < chunkCount; i2++) {
          let padCount = 0;
          const chunks = [];
          for (let j2 = 0; j2 < 8; j2++) {
            const encoded = data[i2 * 8 + j2];
            if (encoded === "=") {
              if (i2 + 1 !== chunkCount) {
                throw new Error(`Invalid character: ${encoded}`);
              }
              padCount += 1;
              continue;
            }
            if (encoded === void 0) {
              if (strict) {
                throw new Error("Invalid data");
              }
              padCount += 1;
              continue;
            }
            const value = this.decodeMap.get(encoded) ?? null;
            if (value === null) {
              throw new Error(`Invalid character: ${encoded}`);
            }
            chunks.push(value);
          }
          if (padCount === 8 || padCount === 7 || padCount === 5 || padCount === 2) {
            throw new Error("Invalid padding");
          }
          const byte1 = (chunks[0] << 3) + (chunks[1] >> 2);
          result.push(byte1);
          if (padCount < 6) {
            const byte2 = ((chunks[1] & 3) << 6) + (chunks[2] << 1) + (chunks[3] >> 4);
            result.push(byte2);
          }
          if (padCount < 4) {
            const byte3 = ((chunks[3] & 255) << 4) + (chunks[4] >> 1);
            result.push(byte3);
          }
          if (padCount < 3) {
            const byte4 = ((chunks[4] & 1) << 7) + (chunks[5] << 2) + (chunks[6] >> 3);
            result.push(byte4);
          }
          if (padCount < 1) {
            const byte5 = ((chunks[6] & 7) << 5) + chunks[7];
            result.push(byte5);
          }
        }
        return Uint8Array.from(result);
      }
    };
    base32 = new Base32Encoding("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567");
    base32hex = new Base32Encoding("0123456789ABCDEFGHIJKLMNOPQRSTUV");
  }
});

// node_modules/oslo/dist/encoding/base64.js
var Base64Encoding, base64, base64url;
var init_base64 = __esm({
  "node_modules/oslo/dist/encoding/base64.js"() {
    init_process();
    init_buffer();
    Base64Encoding = class {
      alphabet;
      padding;
      decodeMap = /* @__PURE__ */ new Map();
      constructor(alphabet2, options) {
        if (alphabet2.length !== 64) {
          throw new Error("Invalid alphabet");
        }
        this.alphabet = alphabet2;
        this.padding = options?.padding ?? "=";
        if (this.alphabet.includes(this.padding) || this.padding.length !== 1) {
          throw new Error("Invalid padding");
        }
        for (let i2 = 0; i2 < alphabet2.length; i2++) {
          this.decodeMap.set(alphabet2[i2], i2);
        }
      }
      encode(data, options) {
        let result = "";
        let buffer = 0;
        let shift = 0;
        for (let i2 = 0; i2 < data.length; i2++) {
          buffer = buffer << 8 | data[i2];
          shift += 8;
          while (shift >= 6) {
            shift += -6;
            result += this.alphabet[buffer >> shift & 63];
          }
        }
        if (shift > 0) {
          result += this.alphabet[buffer << 6 - shift & 63];
        }
        const includePadding = options?.includePadding ?? true;
        if (includePadding) {
          const padCount = (4 - result.length % 4) % 4;
          for (let i2 = 0; i2 < padCount; i2++) {
            result += "=";
          }
        }
        return result;
      }
      decode(data, options) {
        const strict = options?.strict ?? true;
        const chunkCount = Math.ceil(data.length / 4);
        const result = [];
        for (let i2 = 0; i2 < chunkCount; i2++) {
          let padCount = 0;
          let buffer = 0;
          for (let j2 = 0; j2 < 4; j2++) {
            const encoded = data[i2 * 4 + j2];
            if (encoded === "=") {
              if (i2 + 1 !== chunkCount) {
                throw new Error(`Invalid character: ${encoded}`);
              }
              padCount += 1;
              continue;
            }
            if (encoded === void 0) {
              if (strict) {
                throw new Error("Invalid data");
              }
              padCount += 1;
              continue;
            }
            const value = this.decodeMap.get(encoded) ?? null;
            if (value === null) {
              throw new Error(`Invalid character: ${encoded}`);
            }
            buffer += value << 6 * (3 - j2);
          }
          result.push(buffer >> 16 & 255);
          if (padCount < 2) {
            result.push(buffer >> 8 & 255);
          }
          if (padCount < 1) {
            result.push(buffer & 255);
          }
        }
        return Uint8Array.from(result);
      }
    };
    base64 = new Base64Encoding("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
    base64url = new Base64Encoding("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_");
  }
});

// node_modules/oslo/dist/encoding/index.js
var init_encoding = __esm({
  "node_modules/oslo/dist/encoding/index.js"() {
    init_process();
    init_buffer();
    init_hex();
    init_base32();
    init_base64();
    init_base32();
    init_base64();
  }
});

// node_modules/oslo/dist/oauth2/index.js
function generateCodeVerifier() {
  const randomValues = new Uint8Array(32);
  crypto.getRandomValues(randomValues);
  return base64url.encode(randomValues, {
    includePadding: false
  });
}
function generateState() {
  const randomValues = new Uint8Array(32);
  crypto.getRandomValues(randomValues);
  return base64url.encode(randomValues, {
    includePadding: false
  });
}
var OAuth2Client, OAuth2RequestError;
var init_oauth2 = __esm({
  "node_modules/oslo/dist/oauth2/index.js"() {
    init_process();
    init_buffer();
    init_crypto();
    init_encoding();
    OAuth2Client = class {
      clientId;
      authorizeEndpoint;
      tokenEndpoint;
      redirectURI;
      constructor(clientId, authorizeEndpoint39, tokenEndpoint39, options) {
        this.clientId = clientId;
        this.authorizeEndpoint = authorizeEndpoint39;
        this.tokenEndpoint = tokenEndpoint39;
        this.redirectURI = options?.redirectURI ?? null;
      }
      async createAuthorizationURL(options) {
        const scopes = Array.from(new Set(options?.scopes ?? []));
        const authorizationUrl = new URL(this.authorizeEndpoint);
        authorizationUrl.searchParams.set("response_type", "code");
        authorizationUrl.searchParams.set("client_id", this.clientId);
        if (options?.state !== void 0) {
          authorizationUrl.searchParams.set("state", options.state);
        }
        if (scopes.length > 0) {
          authorizationUrl.searchParams.set("scope", scopes.join(" "));
        }
        if (this.redirectURI !== null) {
          authorizationUrl.searchParams.set("redirect_uri", this.redirectURI);
        }
        if (options?.codeVerifier !== void 0) {
          const codeChallengeMethod = options?.codeChallengeMethod ?? "S256";
          if (codeChallengeMethod === "S256") {
            const codeChallengeBuffer = await sha256(new TextEncoder().encode(options.codeVerifier));
            const codeChallenge = base64url.encode(new Uint8Array(codeChallengeBuffer), {
              includePadding: false
            });
            authorizationUrl.searchParams.set("code_challenge", codeChallenge);
            authorizationUrl.searchParams.set("code_challenge_method", "S256");
          } else if (codeChallengeMethod === "plain") {
            authorizationUrl.searchParams.set("code_challenge", options.codeVerifier);
            authorizationUrl.searchParams.set("code_challenge_method", "plain");
          } else {
            throw new TypeError(`Invalid value for 'codeChallengeMethod': ${codeChallengeMethod}`);
          }
        }
        return authorizationUrl;
      }
      async validateAuthorizationCode(authorizationCode, options) {
        const body3 = new URLSearchParams();
        body3.set("code", authorizationCode);
        body3.set("client_id", this.clientId);
        body3.set("grant_type", "authorization_code");
        if (this.redirectURI !== null) {
          body3.set("redirect_uri", this.redirectURI);
        }
        if (options?.codeVerifier !== void 0) {
          body3.set("code_verifier", options.codeVerifier);
        }
        return await this.sendTokenRequest(body3, options);
      }
      async refreshAccessToken(refreshToken, options) {
        const body3 = new URLSearchParams();
        body3.set("refresh_token", refreshToken);
        body3.set("client_id", this.clientId);
        body3.set("grant_type", "refresh_token");
        const scopes = Array.from(new Set(options?.scopes ?? []));
        if (scopes.length > 0) {
          body3.set("scope", scopes.join(" "));
        }
        return await this.sendTokenRequest(body3, options);
      }
      async sendTokenRequest(body3, options) {
        const headers = new Headers();
        headers.set("Content-Type", "application/x-www-form-urlencoded");
        headers.set("Accept", "application/json");
        headers.set("User-Agent", "oslo");
        if (options?.credentials !== void 0) {
          const authenticateWith = options?.authenticateWith ?? "http_basic_auth";
          if (authenticateWith === "http_basic_auth") {
            const encodedCredentials = base64.encode(new TextEncoder().encode(`${this.clientId}:${options.credentials}`));
            headers.set("Authorization", `Basic ${encodedCredentials}`);
          } else if (authenticateWith === "request_body") {
            body3.set("client_secret", options.credentials);
          } else {
            throw new TypeError(`Invalid value for 'authenticateWith': ${authenticateWith}`);
          }
        }
        const request = new Request(this.tokenEndpoint, {
          method: "POST",
          headers,
          body: body3
        });
        const response = await fetch(request);
        const result = await response.json();
        if (!("access_token" in result) && "error" in result) {
          throw new OAuth2RequestError(request, result);
        } else if (!response.ok) {
          throw new OAuth2RequestError(request, {});
        }
        return result;
      }
    };
    OAuth2RequestError = class extends Error {
      request;
      description;
      constructor(request, body3) {
        super(body3.error ?? "");
        this.request = request;
        this.description = body3.error_description ?? null;
      }
    };
  }
});

// node_modules/arctic/dist/providers/amazon-cognito.js
var AmazonCognito;
var init_amazon_cognito = __esm({
  "node_modules/arctic/dist/providers/amazon-cognito.js"() {
    init_process();
    init_buffer();
    init_dist();
    init_oauth2();
    AmazonCognito = class {
      client;
      clientSecret;
      constructor(userPoolDomain, clientId, clientSecret, redirectURI) {
        const authorizeEndpoint39 = userPoolDomain + "/oauth2/authorize";
        const tokenEndpoint39 = userPoolDomain + "/oauth2/token";
        this.client = new OAuth2Client(clientId, authorizeEndpoint39, tokenEndpoint39, {
          redirectURI
        });
        this.clientSecret = clientSecret;
      }
      async createAuthorizationURL(state, codeVerifier, options) {
        const scopes = options?.scopes ?? [];
        return await this.client.createAuthorizationURL({
          state,
          codeVerifier,
          scopes: [...scopes, "openid"]
        });
      }
      async validateAuthorizationCode(code4, codeVerifier) {
        const result = await this.client.validateAuthorizationCode(code4, {
          credentials: this.clientSecret,
          codeVerifier
        });
        const tokens = {
          accessToken: result.access_token,
          refreshToken: result.refresh_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s")),
          idToken: result.id_token
        };
        return tokens;
      }
      async refreshAccessToken(refreshToken) {
        const result = await this.client.refreshAccessToken(refreshToken, {
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s")),
          idToken: result.id_token
        };
        return tokens;
      }
    };
  }
});

// node_modules/arctic/dist/providers/anilist.js
var authorizeEndpoint, tokenEndpoint, AniList;
var init_anilist = __esm({
  "node_modules/arctic/dist/providers/anilist.js"() {
    init_process();
    init_buffer();
    init_oauth2();
    authorizeEndpoint = "https://anilist.co/api/v2/oauth/authorize";
    tokenEndpoint = "https://anilist.co/api/v2/oauth/token";
    AniList = class {
      client;
      clientSecret;
      constructor(clientId, clientSecret, redirectURI) {
        this.client = new OAuth2Client(clientId, authorizeEndpoint, tokenEndpoint, {
          redirectURI
        });
        this.clientSecret = clientSecret;
      }
      async createAuthorizationURL(state) {
        return await this.client.createAuthorizationURL({
          state
        });
      }
      async validateAuthorizationCode(code4) {
        const result = await this.client.validateAuthorizationCode(code4, {
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token
        };
        return tokens;
      }
    };
  }
});

// node_modules/oslo/dist/jwt/index.js
async function createJWT(algorithm, key2, payloadClaims, options) {
  const header = {
    alg: algorithm,
    typ: "JWT",
    ...options?.headers
  };
  const payload = {
    ...payloadClaims
  };
  if (options?.audiences !== void 0) {
    payload.aud = options.audiences;
  }
  if (options?.subject !== void 0) {
    payload.sub = options.subject;
  }
  if (options?.issuer !== void 0) {
    payload.iss = options.issuer;
  }
  if (options?.jwtId !== void 0) {
    payload.jti = options.jwtId;
  }
  if (options?.expiresIn !== void 0) {
    payload.exp = Math.floor(Date.now() / 1e3) + options.expiresIn.seconds();
  }
  if (options?.notBefore !== void 0) {
    payload.nbf = Math.floor(options.notBefore.getTime() / 1e3);
  }
  if (options?.includeIssuedTimestamp === true) {
    payload.iat = Math.floor(Date.now() / 1e3);
  }
  const textEncoder = new TextEncoder();
  const headerPart = base64url.encode(textEncoder.encode(JSON.stringify(header)), {
    includePadding: false
  });
  const payloadPart = base64url.encode(textEncoder.encode(JSON.stringify(payload)), {
    includePadding: false
  });
  const data = textEncoder.encode([headerPart, payloadPart].join("."));
  const signature = await getAlgorithm(algorithm).sign(key2, data);
  const signaturePart = base64url.encode(new Uint8Array(signature), {
    includePadding: false
  });
  const value = [headerPart, payloadPart, signaturePart].join(".");
  return value;
}
function getAlgorithm(algorithm) {
  if (algorithm === "ES256" || algorithm === "ES384" || algorithm === "ES512") {
    return new ECDSA(ecdsaDictionary[algorithm].hash, ecdsaDictionary[algorithm].curve);
  }
  if (algorithm === "HS256" || algorithm === "HS384" || algorithm === "HS512") {
    return new HMAC(hmacDictionary[algorithm]);
  }
  if (algorithm === "RS256" || algorithm === "RS384" || algorithm === "RS512") {
    return new RSASSAPKCS1v1_5(rsassapkcs1v1_5Dictionary[algorithm]);
  }
  if (algorithm === "PS256" || algorithm === "PS384" || algorithm === "PS512") {
    return new RSASSAPSS(rsassapssDictionary[algorithm]);
  }
  throw new TypeError("Invalid algorithm");
}
var ecdsaDictionary, hmacDictionary, rsassapkcs1v1_5Dictionary, rsassapssDictionary;
var init_jwt = __esm({
  "node_modules/oslo/dist/jwt/index.js"() {
    init_process();
    init_buffer();
    init_crypto();
    init_encoding();
    init_dist();
    ecdsaDictionary = {
      ES256: {
        hash: "SHA-256",
        curve: "P-256"
      },
      ES384: {
        hash: "SHA-384",
        curve: "P-384"
      },
      ES512: {
        hash: "SHA-512",
        curve: "P-521"
      }
    };
    hmacDictionary = {
      HS256: "SHA-256",
      HS384: "SHA-384",
      HS512: "SHA-512"
    };
    rsassapkcs1v1_5Dictionary = {
      RS256: "SHA-256",
      RS384: "SHA-384",
      RS512: "SHA-512"
    };
    rsassapssDictionary = {
      PS256: "SHA-256",
      PS384: "SHA-384",
      PS512: "SHA-512"
    };
  }
});

// node_modules/arctic/dist/providers/apple.js
function parsePKCS8PEM(pkcs8) {
  return base64.decode(pkcs8.replace("-----BEGIN PRIVATE KEY-----", "").replace("-----END PRIVATE KEY-----", "").replaceAll("\r", "").replaceAll("\n", "").trim(), {
    strict: false
  });
}
var authorizeEndpoint2, tokenEndpoint2, Apple;
var init_apple = __esm({
  "node_modules/arctic/dist/providers/apple.js"() {
    init_process();
    init_buffer();
    init_dist();
    init_encoding();
    init_jwt();
    init_oauth2();
    authorizeEndpoint2 = "https://appleid.apple.com/auth/authorize";
    tokenEndpoint2 = "https://appleid.apple.com/auth/token";
    Apple = class {
      client;
      credentials;
      constructor(credentials, redirectURI) {
        this.client = new OAuth2Client(credentials.clientId, authorizeEndpoint2, tokenEndpoint2, {
          redirectURI
        });
        this.credentials = credentials;
      }
      async createAuthorizationURL(state, options) {
        return await this.client.createAuthorizationURL({
          state,
          scopes: options?.scopes
        });
      }
      async validateAuthorizationCode(code4) {
        const result = await this.client.validateAuthorizationCode(code4, {
          authenticateWith: "request_body",
          credentials: await this.createClientSecret()
        });
        const tokens = {
          accessToken: result.access_token,
          refreshToken: result.refresh_token ?? null,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s")),
          idToken: result.id_token
        };
        return tokens;
      }
      async refreshAccessToken(refreshToken) {
        const result = await this.client.refreshAccessToken(refreshToken, {
          authenticateWith: "request_body",
          credentials: await this.createClientSecret()
        });
        const tokens = {
          accessToken: result.access_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s")),
          idToken: result.id_token
        };
        return tokens;
      }
      async createClientSecret() {
        const audience = "https://appleid.apple.com";
        const payload = {};
        const jwt2 = await createJWT("ES256", parsePKCS8PEM(this.credentials.certificate), payload, {
          headers: {
            kid: this.credentials.keyId
          },
          issuer: this.credentials.teamId,
          includeIssuedTimestamp: true,
          expiresIn: new TimeSpan(5, "m"),
          audiences: [audience],
          subject: this.credentials.clientId
        });
        return jwt2;
      }
    };
  }
});

// node_modules/arctic/dist/providers/atlassian.js
var authorizeEndpoint3, tokenEndpoint3, Atlassian;
var init_atlassian = __esm({
  "node_modules/arctic/dist/providers/atlassian.js"() {
    init_process();
    init_buffer();
    init_oauth2();
    init_dist();
    authorizeEndpoint3 = "https://auth.atlassian.com/authorize";
    tokenEndpoint3 = "https://auth.atlassian.com/oauth/token";
    Atlassian = class {
      client;
      clientSecret;
      constructor(clientId, clientSecret, redirectURI) {
        this.client = new OAuth2Client(clientId, authorizeEndpoint3, tokenEndpoint3, {
          redirectURI
        });
        this.clientSecret = clientSecret;
      }
      async createAuthorizationURL(state, options) {
        const url = await this.client.createAuthorizationURL({
          state,
          scopes: options?.scopes
        });
        url.searchParams.set("audience", "api.atlassian.com");
        url.searchParams.set("prompt", "consent");
        return url;
      }
      async validateAuthorizationCode(code4) {
        const result = await this.client.validateAuthorizationCode(code4, {
          authenticateWith: "request_body",
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s")),
          refreshToken: result.refresh_token ?? null
        };
        return tokens;
      }
      async refreshAccessToken(refreshToken) {
        const result = await this.client.refreshAccessToken(refreshToken, {
          authenticateWith: "request_body",
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s")),
          refreshToken: result.refresh_token ?? null
        };
        return tokens;
      }
    };
  }
});

// node_modules/arctic/dist/providers/auth0.js
var Auth0;
var init_auth0 = __esm({
  "node_modules/arctic/dist/providers/auth0.js"() {
    init_process();
    init_buffer();
    init_oauth2();
    Auth0 = class {
      client;
      appDomain;
      clientSecret;
      constructor(appDomain, clientId, clientSecret, redirectURI) {
        this.appDomain = appDomain;
        const authorizeEndpoint39 = this.appDomain + "/authorize";
        const tokenEndpoint39 = this.appDomain + "/oauth/token";
        this.client = new OAuth2Client(clientId, authorizeEndpoint39, tokenEndpoint39, {
          redirectURI
        });
        this.clientSecret = clientSecret;
      }
      async createAuthorizationURL(state, options) {
        const scopes = options?.scopes ?? [];
        return await this.client.createAuthorizationURL({
          state,
          scopes: [...scopes, "openid"]
        });
      }
      async validateAuthorizationCode(code4) {
        const result = await this.client.validateAuthorizationCode(code4, {
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          refreshToken: result.refresh_token,
          idToken: result.id_token
        };
        return tokens;
      }
      async refreshAccessToken(refreshToken) {
        const result = await this.client.refreshAccessToken(refreshToken, {
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          refreshToken: result.refresh_token,
          idToken: result.id_token
        };
        return tokens;
      }
    };
  }
});

// node_modules/arctic/dist/providers/authentik.js
var Authentik;
var init_authentik = __esm({
  "node_modules/arctic/dist/providers/authentik.js"() {
    init_process();
    init_buffer();
    init_oauth2();
    init_dist();
    Authentik = class {
      client;
      clientSecret;
      constructor(realmURL, clientId, clientSecret, redirectURI) {
        const authorizeEndpoint39 = realmURL + "/application/o/authorize/";
        const tokenEndpoint39 = realmURL + "/application/o/token/";
        this.client = new OAuth2Client(clientId, authorizeEndpoint39, tokenEndpoint39, {
          redirectURI
        });
        this.clientSecret = clientSecret;
      }
      async createAuthorizationURL(state, codeVerifier, options) {
        const scopes = options?.scopes ?? [];
        return await this.client.createAuthorizationURL({
          state,
          codeVerifier,
          scopes: [...scopes, "openid"]
        });
      }
      async validateAuthorizationCode(code4, codeVerifier) {
        const result = await this.client.validateAuthorizationCode(code4, {
          codeVerifier,
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s")),
          refreshToken: result.refresh_token ?? null,
          idToken: result.id_token
        };
        return tokens;
      }
      async refreshAccessToken(refreshToken) {
        const result = await this.client.refreshAccessToken(refreshToken, {
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s")),
          refreshToken: result.refresh_token ?? null,
          idToken: result.id_token
        };
        return tokens;
      }
    };
  }
});

// node_modules/arctic/dist/providers/bitbucket.js
var authorizeEndpoint4, tokenEndpoint4, Bitbucket;
var init_bitbucket = __esm({
  "node_modules/arctic/dist/providers/bitbucket.js"() {
    init_process();
    init_buffer();
    init_oauth2();
    init_dist();
    authorizeEndpoint4 = "https://bitbucket.org/site/oauth2/authorize";
    tokenEndpoint4 = "https://bitbucket.org/site/oauth2/access_token";
    Bitbucket = class {
      client;
      clientSecret;
      constructor(clientId, clientSecret, redirectURI) {
        this.client = new OAuth2Client(clientId, authorizeEndpoint4, tokenEndpoint4, {
          redirectURI
        });
        this.clientSecret = clientSecret;
      }
      async createAuthorizationURL(state, options) {
        return await this.client.createAuthorizationURL({
          state,
          scopes: options?.scopes ?? []
        });
      }
      async validateAuthorizationCode(code4) {
        const result = await this.client.validateAuthorizationCode(code4, {
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s")),
          refreshToken: result.refresh_token
        };
        return tokens;
      }
      async refreshAccessToken(refreshToken) {
        const result = await this.client.refreshAccessToken(refreshToken, {
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s")),
          refreshToken: result.refresh_token
        };
        return tokens;
      }
    };
  }
});

// node_modules/arctic/dist/providers/box.js
var authorizeEndpoint5, tokenEndpoint5, Box;
var init_box = __esm({
  "node_modules/arctic/dist/providers/box.js"() {
    init_process();
    init_buffer();
    init_oauth2();
    authorizeEndpoint5 = "https://account.box.com/api/oauth2/authorize";
    tokenEndpoint5 = "https://api.box.com/oauth2/token";
    Box = class {
      client;
      clientSecret;
      constructor(clientId, clientSecret, redirectURI) {
        this.client = new OAuth2Client(clientId, authorizeEndpoint5, tokenEndpoint5, {
          redirectURI
        });
        this.clientSecret = clientSecret;
      }
      async createAuthorizationURL(state) {
        return await this.client.createAuthorizationURL({
          state
        });
      }
      async validateAuthorizationCode(code4) {
        const result = await this.client.validateAuthorizationCode(code4, {
          authenticateWith: "request_body",
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token
        };
        return tokens;
      }
    };
  }
});

// node_modules/arctic/dist/providers/coinbase.js
var authorizeEndpoint6, tokenEndpoint6, Coinbase;
var init_coinbase = __esm({
  "node_modules/arctic/dist/providers/coinbase.js"() {
    init_process();
    init_buffer();
    init_oauth2();
    init_dist();
    authorizeEndpoint6 = "https://www.coinbase.com/oauth/authorize";
    tokenEndpoint6 = "https://www.coinbase.com/oauth/token";
    Coinbase = class {
      client;
      clientSecret;
      constructor(clientId, clientSecret, options) {
        this.client = new OAuth2Client(clientId, authorizeEndpoint6, tokenEndpoint6, {
          redirectURI: options?.redirectURI
        });
        this.clientSecret = clientSecret;
      }
      async createAuthorizationURL(state, options) {
        return await this.client.createAuthorizationURL({
          state,
          scopes: options?.scopes ?? []
        });
      }
      async validateAuthorizationCode(code4) {
        const result = await this.client.validateAuthorizationCode(code4, {
          authenticateWith: "request_body",
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          refreshToken: result.refresh_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s"))
        };
        return tokens;
      }
      async refreshAccessToken(refreshToken) {
        const result = await this.client.refreshAccessToken(refreshToken, {
          authenticateWith: "request_body",
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          refreshToken: result.refresh_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s"))
        };
        return tokens;
      }
    };
  }
});

// node_modules/arctic/dist/providers/discord.js
var authorizeEndpoint7, tokenEndpoint7, Discord;
var init_discord = __esm({
  "node_modules/arctic/dist/providers/discord.js"() {
    init_process();
    init_buffer();
    init_oauth2();
    init_dist();
    authorizeEndpoint7 = "https://discord.com/oauth2/authorize";
    tokenEndpoint7 = "https://discord.com/api/oauth2/token";
    Discord = class {
      client;
      clientSecret;
      constructor(clientId, clientSecret, redirectURI) {
        this.client = new OAuth2Client(clientId, authorizeEndpoint7, tokenEndpoint7, {
          redirectURI
        });
        this.clientSecret = clientSecret;
      }
      async createAuthorizationURL(state, options) {
        return await this.client.createAuthorizationURL({
          state,
          scopes: options?.scopes ?? []
        });
      }
      async validateAuthorizationCode(code4) {
        const result = await this.client.validateAuthorizationCode(code4, {
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          refreshToken: result.refresh_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s"))
        };
        return tokens;
      }
      async refreshAccessToken(refreshToken) {
        const result = await this.client.refreshAccessToken(refreshToken, {
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          refreshToken: result.refresh_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s"))
        };
        return tokens;
      }
    };
  }
});

// node_modules/arctic/dist/providers/dribbble.js
var authorizeEndpoint8, tokenEndpoint8, Dribbble;
var init_dribbble = __esm({
  "node_modules/arctic/dist/providers/dribbble.js"() {
    init_process();
    init_buffer();
    init_oauth2();
    authorizeEndpoint8 = "https://dribbble.com/oauth/authorize";
    tokenEndpoint8 = "https://dribbble.com/oauth/token";
    Dribbble = class {
      client;
      clientSecret;
      constructor(clientId, clientSecret, redirectURI) {
        this.client = new OAuth2Client(clientId, authorizeEndpoint8, tokenEndpoint8, {
          redirectURI
        });
        this.clientSecret = clientSecret;
      }
      async createAuthorizationURL(state, options) {
        return await this.client.createAuthorizationURL({
          state,
          scopes: options?.scopes ?? []
        });
      }
      async validateAuthorizationCode(code4) {
        const result = await this.client.validateAuthorizationCode(code4, {
          authenticateWith: "request_body",
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token
        };
        return tokens;
      }
    };
  }
});

// node_modules/arctic/dist/providers/dropbox.js
var authorizeEndpoint9, tokenEndpoint9, Dropbox;
var init_dropbox = __esm({
  "node_modules/arctic/dist/providers/dropbox.js"() {
    init_process();
    init_buffer();
    init_oauth2();
    init_dist();
    authorizeEndpoint9 = "https://www.dropbox.com/oauth2/authorize";
    tokenEndpoint9 = "https://api.dropboxapi.com/oauth2/token";
    Dropbox = class {
      client;
      clientSecret;
      constructor(clientId, clientSecret, redirectURI) {
        this.client = new OAuth2Client(clientId, authorizeEndpoint9, tokenEndpoint9, {
          redirectURI
        });
        this.clientSecret = clientSecret;
      }
      async createAuthorizationURL(state, options) {
        const scopes = options?.scopes ?? [];
        return await this.client.createAuthorizationURL({
          state,
          scopes: [...scopes, "openid"]
        });
      }
      async validateAuthorizationCode(code4) {
        const result = await this.client.validateAuthorizationCode(code4, {
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s")),
          refreshToken: result.refresh_token ?? null,
          idToken: result.id_token
        };
        return tokens;
      }
      async refreshAccessToken(refreshToken) {
        const result = await this.client.refreshAccessToken(refreshToken, {
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s"))
        };
        return tokens;
      }
    };
  }
});

// node_modules/arctic/dist/providers/facebook.js
var authorizeEndpoint10, tokenEndpoint10, Facebook;
var init_facebook = __esm({
  "node_modules/arctic/dist/providers/facebook.js"() {
    init_process();
    init_buffer();
    init_oauth2();
    init_dist();
    authorizeEndpoint10 = "https://www.facebook.com/v16.0/dialog/oauth";
    tokenEndpoint10 = "https://graph.facebook.com/v16.0/oauth/access_token";
    Facebook = class {
      client;
      clientSecret;
      constructor(clientId, clientSecret, redirectURI) {
        this.client = new OAuth2Client(clientId, authorizeEndpoint10, tokenEndpoint10, {
          redirectURI
        });
        this.clientSecret = clientSecret;
      }
      async createAuthorizationURL(state, options) {
        return await this.client.createAuthorizationURL({
          state,
          scopes: options?.scopes ?? []
        });
      }
      async validateAuthorizationCode(code4) {
        const result = await this.client.validateAuthorizationCode(code4, {
          authenticateWith: "request_body",
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s"))
        };
        return tokens;
      }
    };
  }
});

// node_modules/arctic/dist/providers/figma.js
var authorizeEndpoint11, tokenEndpoint11, Figma;
var init_figma = __esm({
  "node_modules/arctic/dist/providers/figma.js"() {
    init_process();
    init_buffer();
    init_dist();
    init_oauth2();
    authorizeEndpoint11 = "https://www.figma.com/oauth";
    tokenEndpoint11 = "https://www.figma.com/api/oauth/token";
    Figma = class {
      client;
      clientSecret;
      constructor(clientId, clientSecret, redirectURI) {
        this.client = new OAuth2Client(clientId, authorizeEndpoint11, tokenEndpoint11, {
          redirectURI
        });
        this.clientSecret = clientSecret;
      }
      async createAuthorizationURL(state, options) {
        return await this.client.createAuthorizationURL({
          state,
          scopes: options?.scopes ?? []
        });
      }
      async validateAuthorizationCode(code4) {
        const result = await this.client.validateAuthorizationCode(code4, {
          authenticateWith: "request_body",
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          refreshToken: result.refresh_token ?? null,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s")),
          userId: result.user_id
        };
        return tokens;
      }
      async refreshAccessToken(refreshToken) {
        const result = await this.client.refreshAccessToken(refreshToken, {
          authenticateWith: "request_body",
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s"))
        };
        return tokens;
      }
    };
  }
});

// node_modules/arctic/dist/providers/intuit.js
var authorizeEndpoint12, tokenEndpoint12, Intuit;
var init_intuit = __esm({
  "node_modules/arctic/dist/providers/intuit.js"() {
    init_process();
    init_buffer();
    init_oauth2();
    init_dist();
    authorizeEndpoint12 = "https://appcenter.intuit.com/connect/oauth2";
    tokenEndpoint12 = "https://oauth.platform.intuit.com/oauth2/v1/tokens/bearer";
    Intuit = class {
      client;
      clientSecret;
      constructor(clientId, clientSecret, redirectURI) {
        this.client = new OAuth2Client(clientId, authorizeEndpoint12, tokenEndpoint12, {
          redirectURI
        });
        this.clientSecret = clientSecret;
      }
      async createAuthorizationURL(state, options) {
        const scopes = options?.scopes ?? [];
        return await this.client.createAuthorizationURL({
          state,
          scopes: [...scopes, "openid"]
        });
      }
      async validateAuthorizationCode(code4) {
        const result = await this.client.validateAuthorizationCode(code4, {
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s")),
          refreshToken: result.refresh_token,
          refreshTokenExpiresAt: createDate(new TimeSpan(result.x_refresh_token_expires_in, "s")),
          idToken: result.id_token
        };
        return tokens;
      }
      async refreshAccessToken(accessToken) {
        const result = await this.client.refreshAccessToken(accessToken, {
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s")),
          refreshToken: result.refresh_token,
          refreshTokenExpiresAt: createDate(new TimeSpan(result.x_refresh_token_expires_in, "s")),
          idToken: result.id_token
        };
        return tokens;
      }
    };
  }
});

// node_modules/arctic/dist/providers/github.js
var GitHub;
var init_github = __esm({
  "node_modules/arctic/dist/providers/github.js"() {
    init_process();
    init_buffer();
    init_oauth2();
    GitHub = class {
      client;
      clientSecret;
      constructor(clientId, clientSecret, options) {
        const baseUrl = options?.enterpriseDomain ?? "https://github.com";
        const authorizeEndpoint39 = baseUrl + "/login/oauth/authorize";
        const tokenEndpoint39 = baseUrl + "/login/oauth/access_token";
        this.client = new OAuth2Client(clientId, authorizeEndpoint39, tokenEndpoint39, {
          redirectURI: options?.redirectURI
        });
        this.clientSecret = clientSecret;
      }
      async createAuthorizationURL(state, options) {
        return await this.client.createAuthorizationURL({
          state,
          scopes: options?.scopes ?? []
        });
      }
      async validateAuthorizationCode(code4) {
        const result = await this.client.validateAuthorizationCode(code4, {
          authenticateWith: "request_body",
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token
        };
        return tokens;
      }
    };
  }
});

// node_modules/arctic/dist/providers/gitlab.js
var GitLab;
var init_gitlab = __esm({
  "node_modules/arctic/dist/providers/gitlab.js"() {
    init_process();
    init_buffer();
    init_oauth2();
    init_dist();
    GitLab = class {
      client;
      clientSecret;
      constructor(clientId, clientSecret, redirectURI, options) {
        const domain3 = options?.domain ?? "https://gitlab.com";
        const authorizeEndpoint39 = domain3 + "/oauth/authorize";
        const tokenEndpoint39 = domain3 + "/oauth/token";
        this.client = new OAuth2Client(clientId, authorizeEndpoint39, tokenEndpoint39, {
          redirectURI
        });
        this.clientSecret = clientSecret;
      }
      async createAuthorizationURL(state, options) {
        return await this.client.createAuthorizationURL({
          state,
          scopes: options?.scopes ?? []
        });
      }
      async validateAuthorizationCode(code4) {
        const result = await this.client.validateAuthorizationCode(code4, {
          authenticateWith: "request_body",
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s")),
          refreshToken: result.refresh_token
        };
        return tokens;
      }
      async refreshAccessToken(refreshToken) {
        const result = await this.client.refreshAccessToken(refreshToken, {
          authenticateWith: "request_body",
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s")),
          refreshToken: result.refresh_token
        };
        return tokens;
      }
    };
  }
});

// node_modules/arctic/dist/providers/google.js
var authorizeEndpoint13, tokenEndpoint13, Google;
var init_google = __esm({
  "node_modules/arctic/dist/providers/google.js"() {
    init_process();
    init_buffer();
    init_dist();
    init_oauth2();
    authorizeEndpoint13 = "https://accounts.google.com/o/oauth2/v2/auth";
    tokenEndpoint13 = "https://oauth2.googleapis.com/token";
    Google = class {
      client;
      clientSecret;
      constructor(clientId, clientSecret, redirectURI) {
        this.client = new OAuth2Client(clientId, authorizeEndpoint13, tokenEndpoint13, {
          redirectURI
        });
        this.clientSecret = clientSecret;
      }
      async createAuthorizationURL(state, codeVerifier, options) {
        const scopes = options?.scopes ?? [];
        return await this.client.createAuthorizationURL({
          state,
          codeVerifier,
          scopes: [...scopes, "openid"]
        });
      }
      async validateAuthorizationCode(code4, codeVerifier) {
        const result = await this.client.validateAuthorizationCode(code4, {
          authenticateWith: "request_body",
          credentials: this.clientSecret,
          codeVerifier
        });
        const tokens = {
          accessToken: result.access_token,
          refreshToken: result.refresh_token ?? null,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s")),
          idToken: result.id_token
        };
        return tokens;
      }
      async refreshAccessToken(refreshToken) {
        const result = await this.client.refreshAccessToken(refreshToken, {
          authenticateWith: "request_body",
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s"))
        };
        return tokens;
      }
    };
  }
});

// node_modules/arctic/dist/providers/kakao.js
var authorizeEndpoint14, tokenEndpoint14, Kakao;
var init_kakao = __esm({
  "node_modules/arctic/dist/providers/kakao.js"() {
    init_process();
    init_buffer();
    init_dist();
    init_oauth2();
    authorizeEndpoint14 = "https://kauth.kakao.com/oauth/authorize";
    tokenEndpoint14 = "https://kauth.kakao.com/oauth/token";
    Kakao = class {
      client;
      clientSecret;
      constructor(clientId, clientSecret, redirectURI) {
        this.client = new OAuth2Client(clientId, authorizeEndpoint14, tokenEndpoint14, {
          redirectURI
        });
        this.clientSecret = clientSecret;
      }
      async createAuthorizationURL(state, options) {
        return await this.client.createAuthorizationURL({
          state,
          scopes: options?.scopes ?? []
        });
      }
      async validateAuthorizationCode(code4) {
        const result = await this.client.validateAuthorizationCode(code4, {
          authenticateWith: "request_body",
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s")),
          refreshToken: result.refresh_token,
          refreshTokenExpiresAt: createDate(new TimeSpan(result.refresh_token_expires_in, "s"))
        };
        return tokens;
      }
      async refreshAccessToken(refreshToken) {
        const result = await this.client.refreshAccessToken(refreshToken, {
          authenticateWith: "request_body",
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s")),
          refreshToken: result.refresh_token,
          refreshTokenExpiresAt: createDate(new TimeSpan(result.refresh_token_expires_in, "s"))
        };
        return tokens;
      }
    };
  }
});

// node_modules/arctic/dist/providers/keycloak.js
var Keycloak;
var init_keycloak = __esm({
  "node_modules/arctic/dist/providers/keycloak.js"() {
    init_process();
    init_buffer();
    init_oauth2();
    init_dist();
    Keycloak = class {
      client;
      realmURL;
      clientSecret;
      constructor(realmURL, clientId, clientSecret, redirectURI) {
        this.realmURL = realmURL;
        const authorizeEndpoint39 = this.realmURL + "/protocol/openid-connect/auth";
        const tokenEndpoint39 = this.realmURL + "/protocol/openid-connect/token";
        this.client = new OAuth2Client(clientId, authorizeEndpoint39, tokenEndpoint39, {
          redirectURI
        });
        this.clientSecret = clientSecret;
      }
      async createAuthorizationURL(state, codeVerifier, options) {
        const scopes = options?.scopes ?? [];
        return await this.client.createAuthorizationURL({
          state,
          codeVerifier,
          scopes: [...scopes, "openid"]
        });
      }
      async validateAuthorizationCode(code4, codeVerifier) {
        const result = await this.client.validateAuthorizationCode(code4, {
          codeVerifier,
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s")),
          refreshToken: result.refresh_token,
          refreshTokenExpiresAt: createDate(new TimeSpan(result.refresh_expires_in, "s")),
          idToken: result.id_token
        };
        return tokens;
      }
      async refreshAccessToken(refreshToken) {
        const result = await this.client.refreshAccessToken(refreshToken, {
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s")),
          refreshToken: result.refresh_token,
          refreshTokenExpiresAt: createDate(new TimeSpan(result.refresh_expires_in, "s")),
          idToken: result.id_token
        };
        return tokens;
      }
    };
  }
});

// node_modules/arctic/dist/providers/lichess.js
var authorizeEndpoint15, tokenEndpoint15, Lichess;
var init_lichess = __esm({
  "node_modules/arctic/dist/providers/lichess.js"() {
    init_process();
    init_buffer();
    init_oauth2();
    authorizeEndpoint15 = "https://lichess.org/oauth";
    tokenEndpoint15 = "https://lichess.org/api/token";
    Lichess = class {
      client;
      constructor(clientId, redirectURI) {
        this.client = new OAuth2Client(clientId, authorizeEndpoint15, tokenEndpoint15, {
          redirectURI
        });
      }
      async createAuthorizationURL(state, codeVerifier, options) {
        return await this.client.createAuthorizationURL({
          state,
          scopes: options?.scopes ?? [],
          codeVerifier
        });
      }
      async validateAuthorizationCode(code4, codeVerifier) {
        const result = await this.client.validateAuthorizationCode(code4, {
          codeVerifier
        });
        const tokens = {
          accessToken: result.access_token
        };
        return tokens;
      }
    };
  }
});

// node_modules/arctic/dist/providers/line.js
var authorizeEndpoint16, tokenEndpoint16, Line;
var init_line = __esm({
  "node_modules/arctic/dist/providers/line.js"() {
    init_process();
    init_buffer();
    init_oauth2();
    init_dist();
    authorizeEndpoint16 = "https://access.line.me/oauth2/v2.1/authorize";
    tokenEndpoint16 = "https://api.line.me/oauth2/v2.1/token";
    Line = class {
      client;
      clientSecret;
      constructor(clientId, clientSecret, redirectURI) {
        this.client = new OAuth2Client(clientId, authorizeEndpoint16, tokenEndpoint16, {
          redirectURI
        });
        this.clientSecret = clientSecret;
      }
      async createAuthorizationURL(state, codeVerifier, options) {
        const scopes = options?.scopes ?? [];
        return await this.client.createAuthorizationURL({
          state,
          codeVerifier,
          scopes: [...scopes, "openid"]
        });
      }
      async validateAuthorizationCode(code4, codeVerifier) {
        const result = await this.client.validateAuthorizationCode(code4, {
          authenticateWith: "request_body",
          credentials: this.clientSecret,
          codeVerifier
        });
        const tokens = {
          accessToken: result.access_token,
          refreshToken: result.refresh_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s")),
          idToken: result.id_token
        };
        return tokens;
      }
      async refreshAccessToken(refreshToken) {
        const result = await this.client.refreshAccessToken(refreshToken, {
          authenticateWith: "request_body",
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          refreshToken: result.refresh_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s"))
        };
        return tokens;
      }
    };
  }
});

// node_modules/arctic/dist/providers/linear.js
var authorizeEndpoint17, tokenEndpoint17, Linear;
var init_linear = __esm({
  "node_modules/arctic/dist/providers/linear.js"() {
    init_process();
    init_buffer();
    init_oauth2();
    init_dist();
    authorizeEndpoint17 = "https://linear.app/oauth/authorize";
    tokenEndpoint17 = "https://api.linear.app/oauth/token";
    Linear = class {
      client;
      clientSecret;
      constructor(clientId, clientSecret, redirectURI) {
        this.client = new OAuth2Client(clientId, authorizeEndpoint17, tokenEndpoint17, {
          redirectURI
        });
        this.clientSecret = clientSecret;
      }
      async createAuthorizationURL(state, options) {
        const scopes = options?.scopes ?? [];
        return await this.client.createAuthorizationURL({
          state,
          scopes: [...scopes, "read"]
        });
      }
      async validateAuthorizationCode(code4) {
        const result = await this.client.validateAuthorizationCode(code4, {
          authenticateWith: "request_body",
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s"))
        };
        return tokens;
      }
    };
  }
});

// node_modules/arctic/dist/providers/linkedin.js
var authorizeEndpoint18, tokenEndpoint18, LinkedIn;
var init_linkedin = __esm({
  "node_modules/arctic/dist/providers/linkedin.js"() {
    init_process();
    init_buffer();
    init_oauth2();
    init_dist();
    authorizeEndpoint18 = "https://www.linkedin.com/oauth/v2/authorization";
    tokenEndpoint18 = "https://www.linkedin.com/oauth/v2/accessToken";
    LinkedIn = class {
      client;
      clientSecret;
      constructor(clientId, clientSecret, redirectURI) {
        this.client = new OAuth2Client(clientId, authorizeEndpoint18, tokenEndpoint18, {
          redirectURI
        });
        this.clientSecret = clientSecret;
      }
      async createAuthorizationURL(state, options) {
        const scopes = options?.scopes ?? [];
        return await this.client.createAuthorizationURL({
          state,
          scopes: [...scopes, "openid"]
        });
      }
      async validateAuthorizationCode(code4) {
        const result = await this.client.validateAuthorizationCode(code4, {
          authenticateWith: "request_body",
          credentials: this.clientSecret
        });
        const tokens = {
          idToken: result.id_token,
          accessToken: result.access_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s")),
          refreshToken: result.refresh_token ?? null,
          refreshTokenExpiresAt: result.refresh_token_expires_in ? createDate(new TimeSpan(result.refresh_token_expires_in, "s")) : null
        };
        return tokens;
      }
      async refreshAccessToken(accessToken) {
        const result = await this.client.refreshAccessToken(accessToken, {
          authenticateWith: "request_body",
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s")),
          refreshToken: result.refresh_token,
          refreshTokenExpiresAt: createDate(new TimeSpan(result.refresh_token_expires_in, "s"))
        };
        return tokens;
      }
    };
  }
});

// node_modules/arctic/dist/providers/microsoft-entra-id.js
var MicrosoftEntraId;
var init_microsoft_entra_id = __esm({
  "node_modules/arctic/dist/providers/microsoft-entra-id.js"() {
    init_process();
    init_buffer();
    init_dist();
    init_oauth2();
    MicrosoftEntraId = class {
      client;
      clientSecret;
      constructor(tenant, clientId, clientSecret, redirectURI) {
        const authorizeEndpoint39 = `https://login.microsoftonline.com/${tenant}/oauth2/v2.0/authorize`;
        const tokenEndpoint39 = `https://login.microsoftonline.com/${tenant}/oauth2/v2.0/token`;
        this.client = new OAuth2Client(clientId, authorizeEndpoint39, tokenEndpoint39, {
          redirectURI
        });
        this.clientSecret = clientSecret;
      }
      async createAuthorizationURL(state, codeVerifier, options) {
        const scopes = options?.scopes ?? [];
        const url = await this.client.createAuthorizationURL({
          state,
          codeVerifier,
          scopes: [...scopes, "openid"]
        });
        url.searchParams.set("nonce", "_");
        return url;
      }
      async validateAuthorizationCode(code4, codeVerifier) {
        const result = await this.client.validateAuthorizationCode(code4, {
          credentials: this.clientSecret,
          codeVerifier
        });
        const tokens = {
          accessToken: result.access_token,
          refreshToken: result.refresh_token ?? null,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s")),
          idToken: result.id_token
        };
        return tokens;
      }
      async refreshAccessToken(refreshToken) {
        const result = await this.client.refreshAccessToken(refreshToken, {
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          refreshToken: result.refresh_token ?? null,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s")),
          idToken: result.id_token
        };
        return tokens;
      }
    };
  }
});

// node_modules/arctic/dist/providers/myanimelist.js
var authorizeEndpoint19, tokenEndpoint19, MyAnimeList;
var init_myanimelist = __esm({
  "node_modules/arctic/dist/providers/myanimelist.js"() {
    init_process();
    init_buffer();
    init_dist();
    init_oauth2();
    authorizeEndpoint19 = "https://myanimelist.net/v1/oauth2/authorize";
    tokenEndpoint19 = "https://myanimelist.net/v1/oauth2/token";
    MyAnimeList = class {
      client;
      clientSecret;
      constructor(clientId, clientSecret, options) {
        this.client = new OAuth2Client(clientId, authorizeEndpoint19, tokenEndpoint19, {
          redirectURI: options?.redirectURI
        });
        this.clientSecret = clientSecret;
      }
      async createAuthorizationURL(state, codeVerifier) {
        return await this.client.createAuthorizationURL({
          state,
          codeVerifier,
          codeChallengeMethod: "plain"
        });
      }
      async validateAuthorizationCode(code4, codeVerifier) {
        const result = await this.client.validateAuthorizationCode(code4, {
          credentials: this.clientSecret,
          codeVerifier
        });
        const tokens = {
          accessToken: result.access_token,
          refreshToken: result.refresh_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s"))
        };
        return tokens;
      }
      async refreshAccessToken(refreshToken) {
        const result = await this.client.refreshAccessToken(refreshToken, {
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          refreshToken: result.refresh_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s"))
        };
        return tokens;
      }
    };
  }
});

// node_modules/arctic/dist/providers/notion.js
var authorizeEndpoint20, tokenEndpoint20, Notion;
var init_notion = __esm({
  "node_modules/arctic/dist/providers/notion.js"() {
    init_process();
    init_buffer();
    init_oauth2();
    authorizeEndpoint20 = "https://api.notion.com/v1/oauth/authorize";
    tokenEndpoint20 = "https://api.notion.com/v1/oauth/token";
    Notion = class {
      client;
      clientSecret;
      constructor(clientId, clientSecret, redirectURI) {
        this.client = new OAuth2Client(clientId, authorizeEndpoint20, tokenEndpoint20, {
          redirectURI
        });
        this.clientSecret = clientSecret;
      }
      async createAuthorizationURL(state) {
        return await this.client.createAuthorizationURL({
          state
        });
      }
      async validateAuthorizationCode(code4) {
        const result = await this.client.validateAuthorizationCode(code4, {
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token
        };
        return tokens;
      }
    };
  }
});

// node_modules/arctic/dist/providers/okta.js
var Okta;
var init_okta = __esm({
  "node_modules/arctic/dist/providers/okta.js"() {
    init_process();
    init_buffer();
    init_oauth2();
    init_dist();
    Okta = class {
      client;
      clientSecret;
      constructor(oktaDomain, clientId, clientSecret, redirectURI, options) {
        let authorizeEndpoint39;
        let tokenEndpoint39;
        if (options?.authorizationServerId) {
          authorizeEndpoint39 = `${oktaDomain}/oauth2/${options.authorizationServerId}/v1/authorize`;
          tokenEndpoint39 = `${oktaDomain}/oauth2/${options.authorizationServerId}/v1/token`;
        } else {
          authorizeEndpoint39 = `${oktaDomain}/oauth2/v1/authorize`;
          tokenEndpoint39 = `${oktaDomain}/oauth2/v1/token`;
        }
        this.client = new OAuth2Client(clientId, authorizeEndpoint39, tokenEndpoint39, {
          redirectURI
        });
        this.clientSecret = clientSecret;
      }
      async createAuthorizationURL(state, codeVerifier, options) {
        const url = await this.client.createAuthorizationURL({
          codeVerifier,
          scopes: [...options?.scopes ?? [], "openid"]
        });
        url.searchParams.set("state", state);
        return url;
      }
      async validateAuthorizationCode(code4, codeVerifier) {
        const result = await this.client.validateAuthorizationCode(code4, {
          codeVerifier,
          credentials: this.clientSecret,
          authenticateWith: "request_body"
        });
        const tokens = {
          accessToken: result.access_token,
          refreshToken: result.refresh_token ?? null,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s")),
          idToken: result.id_token,
          deviceSecret: result.device_secret ?? null
        };
        return tokens;
      }
      async refreshAccessToken(refreshToken, options) {
        const result = await this.client.refreshAccessToken(refreshToken, {
          credentials: this.clientSecret,
          authenticateWith: "request_body",
          scopes: options?.scopes ?? []
        });
        const tokens = {
          accessToken: result.access_token,
          refreshToken: result.refresh_token ?? null,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s")),
          idToken: result.id_token,
          deviceSecret: result.device_secret ?? null
        };
        return tokens;
      }
    };
  }
});

// node_modules/arctic/dist/providers/osu.js
var authorizeEndpoint21, tokenEndpoint21, Osu;
var init_osu = __esm({
  "node_modules/arctic/dist/providers/osu.js"() {
    init_process();
    init_buffer();
    init_oauth2();
    init_dist();
    authorizeEndpoint21 = "https://osu.ppy.sh/oauth/authorize";
    tokenEndpoint21 = "https://osu.ppy.sh/oauth/token";
    Osu = class {
      client;
      clientSecret;
      constructor(clientId, clientSecret, options) {
        this.client = new OAuth2Client(clientId, authorizeEndpoint21, tokenEndpoint21, {
          redirectURI: options?.redirectURI
        });
        this.clientSecret = clientSecret;
      }
      async createAuthorizationURL(state, options) {
        return await this.client.createAuthorizationURL({
          state,
          scopes: options?.scopes ?? []
        });
      }
      async validateAuthorizationCode(code4) {
        const result = await this.client.validateAuthorizationCode(code4, {
          authenticateWith: "request_body",
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          refreshToken: result.refresh_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s"))
        };
        return tokens;
      }
      async refreshAccessToken(refreshToken) {
        const result = await this.client.refreshAccessToken(refreshToken, {
          authenticateWith: "request_body",
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          refreshToken: result.refresh_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s"))
        };
        return tokens;
      }
    };
  }
});

// node_modules/arctic/dist/providers/patreon.js
var authorizeEndpoint22, tokenEndpoint22, Patreon;
var init_patreon = __esm({
  "node_modules/arctic/dist/providers/patreon.js"() {
    init_process();
    init_buffer();
    init_oauth2();
    init_dist();
    authorizeEndpoint22 = "https://www.patreon.com/oauth2/authorize";
    tokenEndpoint22 = "https://www.patreon.com/api/oauth2/token";
    Patreon = class {
      client;
      clientSecret;
      constructor(clientId, clientSecret, redirectURI) {
        this.client = new OAuth2Client(clientId, authorizeEndpoint22, tokenEndpoint22, {
          redirectURI
        });
        this.clientSecret = clientSecret;
      }
      async createAuthorizationURL(state, options) {
        return await this.client.createAuthorizationURL({
          state,
          scopes: options?.scopes ?? []
        });
      }
      async validateAuthorizationCode(code4) {
        const result = await this.client.validateAuthorizationCode(code4, {
          authenticateWith: "request_body",
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          refreshToken: result.refresh_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s"))
        };
        return tokens;
      }
      async refreshAccessToken(refreshToken) {
        const result = await this.client.refreshAccessToken(refreshToken, {
          authenticateWith: "request_body",
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          refreshToken: result.refresh_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s"))
        };
        return tokens;
      }
    };
  }
});

// node_modules/arctic/dist/providers/reddit.js
var authorizeEndpoint23, tokenEndpoint23, Reddit;
var init_reddit = __esm({
  "node_modules/arctic/dist/providers/reddit.js"() {
    init_process();
    init_buffer();
    init_oauth2();
    init_dist();
    authorizeEndpoint23 = "https://www.reddit.com/api/v1/authorize";
    tokenEndpoint23 = "https://www.reddit.com/api/v1/access_token";
    Reddit = class {
      client;
      clientSecret;
      constructor(clientId, clientSecret, redirectURI) {
        this.client = new OAuth2Client(clientId, authorizeEndpoint23, tokenEndpoint23, {
          redirectURI
        });
        this.clientSecret = clientSecret;
      }
      async createAuthorizationURL(state, options) {
        return await this.client.createAuthorizationURL({
          state,
          scopes: options?.scopes ?? []
        });
      }
      async validateAuthorizationCode(code4) {
        const result = await this.client.validateAuthorizationCode(code4, {
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s")),
          refreshToken: result.refresh_token ?? null
        };
        return tokens;
      }
      async refreshAccessToken(refreshToken) {
        const result = await this.client.refreshAccessToken(refreshToken, {
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s")),
          refreshToken: result.refresh_token ?? null
        };
        return tokens;
      }
    };
  }
});

// node_modules/arctic/dist/providers/roblox.js
var authorizeEndpoint24, tokenEndpoint24, Roblox;
var init_roblox = __esm({
  "node_modules/arctic/dist/providers/roblox.js"() {
    init_process();
    init_buffer();
    init_dist();
    init_oauth2();
    authorizeEndpoint24 = "https://apis.roblox.com/oauth/v1/authorize";
    tokenEndpoint24 = "https://apis.roblox.com/oauth/v1/token";
    Roblox = class {
      client;
      clientSecret;
      constructor(clientId, clientSecret, redirectURI) {
        this.client = new OAuth2Client(clientId, authorizeEndpoint24, tokenEndpoint24, {
          redirectURI
        });
        this.clientSecret = clientSecret;
      }
      async createAuthorizationURL(state, codeVerifier, options) {
        const scopes = options?.scopes ?? [];
        return await this.client.createAuthorizationURL({
          state,
          codeVerifier,
          scopes: [...scopes, "openid"]
        });
      }
      async validateAuthorizationCode(code4, codeVerifier) {
        const result = await this.client.validateAuthorizationCode(code4, {
          credentials: this.clientSecret,
          codeVerifier,
          authenticateWith: "request_body"
          // Roblox doesn't support HTTP basic auth
        });
        const tokens = {
          accessToken: result.access_token,
          refreshToken: result.refresh_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s")),
          idToken: result.id_token
        };
        return tokens;
      }
      async refreshAccessToken(refreshToken) {
        const result = await this.client.refreshAccessToken(refreshToken, {
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          refreshToken: result.refresh_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s")),
          idToken: result.id_token
        };
        return tokens;
      }
    };
  }
});

// node_modules/arctic/dist/providers/salesforce.js
var Salesforce;
var init_salesforce = __esm({
  "node_modules/arctic/dist/providers/salesforce.js"() {
    init_process();
    init_buffer();
    init_oauth2();
    Salesforce = class {
      client;
      clientSecret;
      constructor(clientId, clientSecret, redirectURI) {
        const authorizeEndpoint39 = "https://login.salesforce.com/services/oauth2/authorize";
        const tokenEndpoint39 = "https://login.salesforce.com/services/oauth2/token";
        this.client = new OAuth2Client(clientId, authorizeEndpoint39, tokenEndpoint39, {
          redirectURI
        });
        this.clientSecret = clientSecret;
      }
      async createAuthorizationURL(state, codeVerifier, options) {
        return await this.client.createAuthorizationURL({
          state,
          codeVerifier,
          scopes: options?.scopes ?? []
        });
      }
      async validateAuthorizationCode(code4, codeVerifier) {
        const result = await this.client.validateAuthorizationCode(code4, {
          credentials: this.clientSecret,
          codeVerifier
        });
        return {
          accessToken: result.access_token,
          refreshToken: result.refresh_token ?? null,
          idToken: result.id_token
        };
      }
      async refreshAccessToken(refreshToken) {
        const result = await this.client.refreshAccessToken(refreshToken, {
          credentials: this.clientSecret
        });
        return {
          accessToken: result.access_token,
          refreshToken: result.refresh_token ?? null,
          idToken: result.id_token
        };
      }
    };
  }
});

// node_modules/arctic/dist/providers/shikimori.js
var authorizeEndpoint25, tokenEndpoint25, Shikimori;
var init_shikimori = __esm({
  "node_modules/arctic/dist/providers/shikimori.js"() {
    init_process();
    init_buffer();
    init_oauth2();
    authorizeEndpoint25 = "https://shikimori.one/oauth/authorize";
    tokenEndpoint25 = "https://shikimori.one/oauth/token";
    Shikimori = class {
      client;
      clientSecret;
      constructor(clientId, clientSecret, redirectURI) {
        this.client = new OAuth2Client(clientId, authorizeEndpoint25, tokenEndpoint25, {
          redirectURI
        });
        this.clientSecret = clientSecret;
      }
      createAuthorizationURL(state, scopes) {
        return this.client.createAuthorizationURL({ state, scopes });
      }
      async validateAuthorizationCode(code4) {
        const result = await this.client.validateAuthorizationCode(code4, {
          authenticateWith: "request_body",
          credentials: this.clientSecret
        });
        return {
          accessToken: result.access_token,
          refreshToken: result.refresh_token,
          accessTokenExpiresAt: new Date((result.created_at + result.expires_in) * 1e3)
        };
      }
      async refreshAccessToken(refreshToken) {
        const result = await this.client.refreshAccessToken(refreshToken, {
          authenticateWith: "request_body",
          credentials: this.clientSecret
        });
        return {
          accessToken: result.access_token,
          refreshToken: result.refresh_token,
          accessTokenExpiresAt: new Date((result.created_at + result.expires_in) * 1e3)
        };
      }
    };
  }
});

// node_modules/arctic/dist/providers/slack.js
var authorizeEndpoint26, tokenEndpoint26, Slack;
var init_slack = __esm({
  "node_modules/arctic/dist/providers/slack.js"() {
    init_process();
    init_buffer();
    init_oauth2();
    authorizeEndpoint26 = "https://slack.com/openid/connect/authorize";
    tokenEndpoint26 = "https://slack.com/api/openid.connect.token";
    Slack = class {
      client;
      clientSecret;
      constructor(clientId, clientSecret, redirectURI) {
        this.client = new OAuth2Client(clientId, authorizeEndpoint26, tokenEndpoint26, {
          redirectURI
        });
        this.clientSecret = clientSecret;
      }
      async createAuthorizationURL(state, options) {
        const scopes = options?.scopes ?? [];
        return await this.client.createAuthorizationURL({
          state,
          scopes: [...scopes, "openid"]
        });
      }
      async validateAuthorizationCode(code4) {
        const result = await this.client.validateAuthorizationCode(code4, {
          credentials: this.clientSecret,
          authenticateWith: "request_body"
        });
        const tokens = {
          accessToken: result.access_token,
          idToken: result.id_token
        };
        return tokens;
      }
    };
  }
});

// node_modules/arctic/dist/providers/spotify.js
var authorizeEndpoint27, tokenEndpoint27, Spotify;
var init_spotify = __esm({
  "node_modules/arctic/dist/providers/spotify.js"() {
    init_process();
    init_buffer();
    init_dist();
    init_oauth2();
    authorizeEndpoint27 = "https://accounts.spotify.com/authorize";
    tokenEndpoint27 = "https://accounts.spotify.com/api/token";
    Spotify = class {
      client;
      clientSecret;
      constructor(clientId, clientSecret, redirectURI) {
        this.client = new OAuth2Client(clientId, authorizeEndpoint27, tokenEndpoint27, {
          redirectURI
        });
        this.clientSecret = clientSecret;
      }
      async createAuthorizationURL(state, options) {
        return await this.client.createAuthorizationURL({
          state,
          scopes: options?.scopes ?? []
        });
      }
      async validateAuthorizationCode(code4) {
        const result = await this.client.validateAuthorizationCode(code4, {
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          refreshToken: result.refresh_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s"))
        };
        return tokens;
      }
      async refreshAccessToken(refreshToken) {
        const result = await this.client.refreshAccessToken(refreshToken, {
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          refreshToken: result.refresh_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s"))
        };
        return tokens;
      }
    };
  }
});

// node_modules/arctic/dist/providers/strava.js
var authorizeEndpoint28, tokenEndpoint28, Strava;
var init_strava = __esm({
  "node_modules/arctic/dist/providers/strava.js"() {
    init_process();
    init_buffer();
    init_oauth2();
    init_dist();
    authorizeEndpoint28 = "https://www.strava.com/oauth/authorize";
    tokenEndpoint28 = "https://www.strava.com/oauth/token";
    Strava = class {
      client;
      clientSecret;
      constructor(clientId, clientSecret, redirectURI) {
        this.client = new OAuth2Client(clientId, authorizeEndpoint28, tokenEndpoint28, {
          redirectURI
        });
        this.clientSecret = clientSecret;
      }
      async createAuthorizationURL(state, options) {
        return await this.client.createAuthorizationURL({
          state,
          scopes: options?.scopes ?? []
        });
      }
      async validateAuthorizationCode(code4) {
        const result = await this.client.validateAuthorizationCode(code4, {
          authenticateWith: "request_body",
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          refreshToken: result.refresh_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s"))
        };
        return tokens;
      }
      async refreshAccessToken(refreshToken) {
        const result = await this.client.refreshAccessToken(refreshToken, {
          authenticateWith: "request_body",
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          refreshToken: result.refresh_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s"))
        };
        return tokens;
      }
    };
  }
});

// node_modules/arctic/dist/providers/tiltify.js
var authorizeEndpoint29, tokenEndpoint29, Tiltify;
var init_tiltify = __esm({
  "node_modules/arctic/dist/providers/tiltify.js"() {
    init_process();
    init_buffer();
    init_dist();
    init_oauth2();
    authorizeEndpoint29 = "https://v5api.tiltify.com/oauth/authorizeze";
    tokenEndpoint29 = "https://v5api.tiltify.com/oauth/token";
    Tiltify = class {
      client;
      clientSecret;
      constructor(clientId, clientSecret, redirectURI) {
        this.client = new OAuth2Client(clientId, authorizeEndpoint29, tokenEndpoint29, {
          redirectURI
        });
        this.clientSecret = clientSecret;
      }
      async createAuthorizationURL(state, options) {
        return await this.client.createAuthorizationURL({
          state,
          scopes: options?.scopes ?? []
        });
      }
      async validateAuthorizationCode(code4) {
        const result = await this.client.validateAuthorizationCode(code4, {
          authenticateWith: "request_body",
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          refreshToken: result.refresh_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s"))
        };
        return tokens;
      }
      async refreshAccessToken(refreshToken) {
        const result = await this.client.refreshAccessToken(refreshToken, {
          authenticateWith: "request_body",
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          refreshToken: result.refresh_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s"))
        };
        return tokens;
      }
    };
  }
});

// node_modules/arctic/dist/providers/tumblr.js
var authorizeEndpoint30, tokenEndpoint30, Tumblr;
var init_tumblr = __esm({
  "node_modules/arctic/dist/providers/tumblr.js"() {
    init_process();
    init_buffer();
    init_oauth2();
    init_dist();
    authorizeEndpoint30 = "https://www.tumblr.com/oauth2/authorize";
    tokenEndpoint30 = "https://api.tumblr.com/v2/oauth2/token";
    Tumblr = class {
      client;
      clientSecret;
      constructor(clientId, clientSecret, options) {
        this.client = new OAuth2Client(clientId, authorizeEndpoint30, tokenEndpoint30, {
          redirectURI: options?.redirectURI
        });
        this.clientSecret = clientSecret;
      }
      async createAuthorizationURL(state, options) {
        const scopes = options?.scopes ?? [];
        return await this.client.createAuthorizationURL({
          state,
          scopes: [...scopes, "basic"]
        });
      }
      async validateAuthorizationCode(code4) {
        const result = await this.client.validateAuthorizationCode(code4, {
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          refreshToken: result.refresh_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s"))
        };
        return tokens;
      }
      async refreshAccessToken(refreshToken) {
        const result = await this.client.refreshAccessToken(refreshToken, {
          authenticateWith: "request_body",
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          refreshToken: result.refresh_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s"))
        };
        return tokens;
      }
    };
  }
});

// node_modules/arctic/dist/providers/twitch.js
var authorizeEndpoint31, tokenEndpoint31, Twitch;
var init_twitch = __esm({
  "node_modules/arctic/dist/providers/twitch.js"() {
    init_process();
    init_buffer();
    init_dist();
    init_oauth2();
    authorizeEndpoint31 = "https://id.twitch.tv/oauth2/authorize";
    tokenEndpoint31 = "https://id.twitch.tv/oauth2/token";
    Twitch = class {
      client;
      clientSecret;
      constructor(clientId, clientSecret, redirectURI) {
        this.client = new OAuth2Client(clientId, authorizeEndpoint31, tokenEndpoint31, {
          redirectURI
        });
        this.clientSecret = clientSecret;
      }
      async createAuthorizationURL(state, options) {
        return await this.client.createAuthorizationURL({
          state,
          scopes: options?.scopes ?? []
        });
      }
      async validateAuthorizationCode(code4) {
        const result = await this.client.validateAuthorizationCode(code4, {
          authenticateWith: "request_body",
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          refreshToken: result.refresh_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s"))
        };
        return tokens;
      }
      async refreshAccessToken(refreshToken) {
        const result = await this.client.refreshAccessToken(refreshToken, {
          authenticateWith: "request_body",
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          refreshToken: result.refresh_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s"))
        };
        return tokens;
      }
    };
  }
});

// node_modules/arctic/dist/providers/twitter.js
var authorizeEndpoint32, tokenEndpoint32, Twitter;
var init_twitter = __esm({
  "node_modules/arctic/dist/providers/twitter.js"() {
    init_process();
    init_buffer();
    init_oauth2();
    authorizeEndpoint32 = "https://twitter.com/i/oauth2/authorize";
    tokenEndpoint32 = "https://api.twitter.com/2/oauth2/token";
    Twitter = class {
      client;
      clientSecret;
      constructor(clientId, clientSecret, redirectURI) {
        this.client = new OAuth2Client(clientId, authorizeEndpoint32, tokenEndpoint32, {
          redirectURI
        });
        this.clientSecret = clientSecret;
      }
      async createAuthorizationURL(state, codeVerifier, options) {
        return await this.client.createAuthorizationURL({
          state,
          codeVerifier,
          scopes: options?.scopes ?? []
        });
      }
      async validateAuthorizationCode(code4, codeVerifier) {
        const result = await this.client.validateAuthorizationCode(code4, {
          credentials: this.clientSecret,
          codeVerifier
        });
        const tokens = {
          accessToken: result.access_token,
          refreshToken: result.refresh_token ?? null
        };
        return tokens;
      }
      async refreshAccessToken(refreshToken) {
        const result = await this.client.refreshAccessToken(refreshToken, {
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          refreshToken: result.refresh_token ?? null
        };
        return tokens;
      }
    };
  }
});

// node_modules/arctic/dist/providers/vk.js
var authorizeEndpoint33, tokenEndpoint33, VK;
var init_vk = __esm({
  "node_modules/arctic/dist/providers/vk.js"() {
    init_process();
    init_buffer();
    init_oauth2();
    init_dist();
    authorizeEndpoint33 = "https://oauth.vk.com/authorize";
    tokenEndpoint33 = "https://oauth.vk.com/access_token";
    VK = class {
      client;
      clientSecret;
      constructor(clientId, clientSecret, redirectURI) {
        this.client = new OAuth2Client(clientId, authorizeEndpoint33, tokenEndpoint33, {
          redirectURI
        });
        this.clientSecret = clientSecret;
      }
      async createAuthorizationURL(state, options) {
        return await this.client.createAuthorizationURL({
          state,
          scopes: options?.scopes ?? []
        });
      }
      async validateAuthorizationCode(code4) {
        const result = await this.client.validateAuthorizationCode(code4, {
          authenticateWith: "request_body",
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s")),
          userId: result.user_id,
          email: result.email ?? null
        };
        return tokens;
      }
    };
  }
});

// node_modules/arctic/dist/providers/workos.js
var authorizeEndpoint34, tokenEndpoint34, WorkOS;
var init_workos = __esm({
  "node_modules/arctic/dist/providers/workos.js"() {
    init_process();
    init_buffer();
    init_oauth2();
    authorizeEndpoint34 = "https://api.workos.com/sso/authorize";
    tokenEndpoint34 = "https://api.workos.com/sso/token";
    WorkOS = class {
      client;
      clientSecret;
      constructor(clientId, clientSecret, redirectURI) {
        this.client = new OAuth2Client(clientId, authorizeEndpoint34, tokenEndpoint34, {
          redirectURI
        });
        this.clientSecret = clientSecret;
      }
      async createAuthorizationURL(state) {
        return await this.client.createAuthorizationURL({
          state
        });
      }
      async validateAuthorizationCode(code4) {
        const result = await this.client.validateAuthorizationCode(code4, {
          authenticateWith: "request_body",
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token
        };
        return tokens;
      }
    };
  }
});

// node_modules/arctic/dist/providers/yahoo.js
var authorizeEndpoint35, tokenEndpoint35, Yahoo;
var init_yahoo = __esm({
  "node_modules/arctic/dist/providers/yahoo.js"() {
    init_process();
    init_buffer();
    init_oauth2();
    init_dist();
    authorizeEndpoint35 = "https://api.login.yahoo.com/oauth2/request_auth";
    tokenEndpoint35 = "https://api.login.yahoo.com/oauth2/get_token";
    Yahoo = class {
      client;
      clientSecret;
      constructor(clientId, clientSecret, redirectURI) {
        this.client = new OAuth2Client(clientId, authorizeEndpoint35, tokenEndpoint35, {
          redirectURI
        });
        this.clientSecret = clientSecret;
      }
      async createAuthorizationURL(state, options) {
        const scopes = options?.scopes ?? [];
        return await this.client.createAuthorizationURL({
          state,
          scopes: [...scopes, "openid"]
        });
      }
      async validateAuthorizationCode(code4) {
        const result = await this.client.validateAuthorizationCode(code4, {
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s")),
          refreshToken: result.refresh_token,
          idToken: result.id_token
        };
        return tokens;
      }
      async refreshAccessToken(refreshToken) {
        const result = await this.client.refreshAccessToken(refreshToken, {
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s")),
          refreshToken: result.refresh_token,
          idToken: result.id_token
        };
        return tokens;
      }
    };
  }
});

// node_modules/arctic/dist/providers/yandex.js
var authorizeEndpoint36, tokenEndpoint36, Yandex;
var init_yandex = __esm({
  "node_modules/arctic/dist/providers/yandex.js"() {
    init_process();
    init_buffer();
    init_oauth2();
    init_dist();
    authorizeEndpoint36 = "https://oauth.yandex.com/authorize";
    tokenEndpoint36 = "https://oauth.yandex.com/token";
    Yandex = class {
      client;
      clientSecret;
      constructor(clientId, clientSecret, options) {
        this.client = new OAuth2Client(clientId, authorizeEndpoint36, tokenEndpoint36, {
          redirectURI: options?.redirectURI
        });
        this.clientSecret = clientSecret;
      }
      async createAuthorizationURL(state, options) {
        return await this.client.createAuthorizationURL({
          state,
          scopes: options?.scopes ?? []
        });
      }
      async validateAuthorizationCode(code4) {
        const result = await this.client.validateAuthorizationCode(code4, {
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          refreshToken: result.refresh_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s"))
        };
        return tokens;
      }
      async refreshAccessToken(refreshToken) {
        const result = await this.client.refreshAccessToken(refreshToken, {
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          refreshToken: result.refresh_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s"))
        };
        return tokens;
      }
    };
  }
});

// node_modules/arctic/dist/providers/zoom.js
var authorizeEndpoint37, tokenEndpoint37, Zoom;
var init_zoom = __esm({
  "node_modules/arctic/dist/providers/zoom.js"() {
    init_process();
    init_buffer();
    init_dist();
    init_oauth2();
    authorizeEndpoint37 = "https://zoom.us/oauth/authorize";
    tokenEndpoint37 = "https://zoom.us/oauth/token";
    Zoom = class {
      client;
      clientSecret;
      constructor(clientId, clientSecret, redirectURI) {
        this.client = new OAuth2Client(clientId, authorizeEndpoint37, tokenEndpoint37, {
          redirectURI
        });
        this.clientSecret = clientSecret;
      }
      async createAuthorizationURL(state, codeVerifier, options) {
        return await this.client.createAuthorizationURL({
          state,
          codeVerifier,
          scopes: options?.scopes ?? []
        });
      }
      async validateAuthorizationCode(code4, codeVerifier) {
        const result = await this.client.validateAuthorizationCode(code4, {
          credentials: this.clientSecret,
          codeVerifier
        });
        const tokens = {
          accessToken: result.access_token,
          refreshToken: result.refresh_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s"))
        };
        return tokens;
      }
      async refreshAccessToken(refreshToken) {
        const result = await this.client.refreshAccessToken(refreshToken, {
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          refreshToken: result.refresh_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s"))
        };
        return tokens;
      }
    };
  }
});

// node_modules/arctic/dist/providers/42.js
var authorizeEndpoint38, tokenEndpoint38, FortyTwo;
var init__ = __esm({
  "node_modules/arctic/dist/providers/42.js"() {
    init_process();
    init_buffer();
    init_oauth2();
    init_dist();
    authorizeEndpoint38 = "https://api.intra.42.fr/oauth/authorize";
    tokenEndpoint38 = "https://api.intra.42.fr/oauth/token";
    FortyTwo = class {
      client;
      clientSecret;
      constructor(clientId, clientSecret, redirectURI) {
        this.client = new OAuth2Client(clientId, authorizeEndpoint38, tokenEndpoint38, {
          redirectURI
        });
        this.clientSecret = clientSecret;
      }
      async createAuthorizationURL(state, options) {
        return await this.client.createAuthorizationURL({
          state,
          scopes: options?.scopes ?? []
        });
      }
      async validateAuthorizationCode(code4) {
        const result = await this.client.validateAuthorizationCode(code4, {
          authenticateWith: "request_body",
          credentials: this.clientSecret
        });
        const tokens = {
          accessToken: result.access_token,
          accessTokenExpiresAt: createDate(new TimeSpan(result.expires_in, "s"))
        };
        return tokens;
      }
    };
  }
});

// node_modules/arctic/dist/index.js
var dist_exports = {};
__export(dist_exports, {
  AmazonCognito: () => AmazonCognito,
  AniList: () => AniList,
  Apple: () => Apple,
  Atlassian: () => Atlassian,
  Auth0: () => Auth0,
  Authentik: () => Authentik,
  Bitbucket: () => Bitbucket,
  Box: () => Box,
  Coinbase: () => Coinbase,
  Discord: () => Discord,
  Dribbble: () => Dribbble,
  Dropbox: () => Dropbox,
  Facebook: () => Facebook,
  Figma: () => Figma,
  FortyTwo: () => FortyTwo,
  GitHub: () => GitHub,
  GitLab: () => GitLab,
  Google: () => Google,
  Intuit: () => Intuit,
  Kakao: () => Kakao,
  Keycloak: () => Keycloak,
  Lichess: () => Lichess,
  Line: () => Line,
  Linear: () => Linear,
  LinkedIn: () => LinkedIn,
  MicrosoftEntraId: () => MicrosoftEntraId,
  MyAnimeList: () => MyAnimeList,
  Notion: () => Notion,
  OAuth2RequestError: () => OAuth2RequestError,
  Okta: () => Okta,
  Osu: () => Osu,
  Patreon: () => Patreon,
  Reddit: () => Reddit,
  Roblox: () => Roblox,
  Salesforce: () => Salesforce,
  Shikimori: () => Shikimori,
  Slack: () => Slack,
  Spotify: () => Spotify,
  Strava: () => Strava,
  Tiltify: () => Tiltify,
  Tumblr: () => Tumblr,
  Twitch: () => Twitch,
  Twitter: () => Twitter,
  VK: () => VK,
  WorkOS: () => WorkOS,
  Yahoo: () => Yahoo,
  Yandex: () => Yandex,
  Zoom: () => Zoom,
  generateCodeVerifier: () => generateCodeVerifier,
  generateState: () => generateState
});
var init_dist2 = __esm({
  "node_modules/arctic/dist/index.js"() {
    init_process();
    init_buffer();
    init_amazon_cognito();
    init_anilist();
    init_apple();
    init_atlassian();
    init_auth0();
    init_authentik();
    init_bitbucket();
    init_box();
    init_coinbase();
    init_discord();
    init_dribbble();
    init_dropbox();
    init_facebook();
    init_figma();
    init_intuit();
    init_github();
    init_gitlab();
    init_google();
    init_kakao();
    init_keycloak();
    init_lichess();
    init_line();
    init_linear();
    init_linkedin();
    init_microsoft_entra_id();
    init_myanimelist();
    init_notion();
    init_okta();
    init_osu();
    init_patreon();
    init_reddit();
    init_roblox();
    init_salesforce();
    init_shikimori();
    init_slack();
    init_spotify();
    init_strava();
    init_tiltify();
    init_tumblr();
    init_twitch();
    init_twitter();
    init_vk();
    init_workos();
    init_yahoo();
    init_yandex();
    init_zoom();
    init__();
    init_oauth2();
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/guard/guard.js
var require_guard = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/value/guard/guard.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IsAsyncIterator = IsAsyncIterator5;
    exports.IsIterator = IsIterator5;
    exports.IsStandardObject = IsStandardObject2;
    exports.IsInstanceObject = IsInstanceObject;
    exports.IsPromise = IsPromise4;
    exports.IsDate = IsDate5;
    exports.IsMap = IsMap;
    exports.IsSet = IsSet;
    exports.IsRegExp = IsRegExp4;
    exports.IsTypedArray = IsTypedArray2;
    exports.IsInt8Array = IsInt8Array;
    exports.IsUint8Array = IsUint8Array5;
    exports.IsUint8ClampedArray = IsUint8ClampedArray;
    exports.IsInt16Array = IsInt16Array;
    exports.IsUint16Array = IsUint16Array;
    exports.IsInt32Array = IsInt32Array;
    exports.IsUint32Array = IsUint32Array;
    exports.IsFloat32Array = IsFloat32Array;
    exports.IsFloat64Array = IsFloat64Array;
    exports.IsBigInt64Array = IsBigInt64Array;
    exports.IsBigUint64Array = IsBigUint64Array;
    exports.HasPropertyKey = HasPropertyKey2;
    exports.IsObject = IsObject5;
    exports.IsArray = IsArray5;
    exports.IsUndefined = IsUndefined5;
    exports.IsNull = IsNull5;
    exports.IsBoolean = IsBoolean5;
    exports.IsNumber = IsNumber5;
    exports.IsInteger = IsInteger4;
    exports.IsBigInt = IsBigInt5;
    exports.IsString = IsString5;
    exports.IsFunction = IsFunction5;
    exports.IsSymbol = IsSymbol5;
    exports.IsValueType = IsValueType2;
    function IsAsyncIterator5(value) {
      return IsObject5(value) && Symbol.asyncIterator in value;
    }
    function IsIterator5(value) {
      return IsObject5(value) && Symbol.iterator in value;
    }
    function IsStandardObject2(value) {
      return IsObject5(value) && (Object.getPrototypeOf(value) === Object.prototype || Object.getPrototypeOf(value) === null);
    }
    function IsInstanceObject(value) {
      return IsObject5(value) && !IsArray5(value) && IsFunction5(value.constructor) && value.constructor.name !== "Object";
    }
    function IsPromise4(value) {
      return value instanceof Promise;
    }
    function IsDate5(value) {
      return value instanceof Date && Number.isFinite(value.getTime());
    }
    function IsMap(value) {
      return value instanceof globalThis.Map;
    }
    function IsSet(value) {
      return value instanceof globalThis.Set;
    }
    function IsRegExp4(value) {
      return value instanceof globalThis.RegExp;
    }
    function IsTypedArray2(value) {
      return ArrayBuffer.isView(value);
    }
    function IsInt8Array(value) {
      return value instanceof globalThis.Int8Array;
    }
    function IsUint8Array5(value) {
      return value instanceof globalThis.Uint8Array;
    }
    function IsUint8ClampedArray(value) {
      return value instanceof globalThis.Uint8ClampedArray;
    }
    function IsInt16Array(value) {
      return value instanceof globalThis.Int16Array;
    }
    function IsUint16Array(value) {
      return value instanceof globalThis.Uint16Array;
    }
    function IsInt32Array(value) {
      return value instanceof globalThis.Int32Array;
    }
    function IsUint32Array(value) {
      return value instanceof globalThis.Uint32Array;
    }
    function IsFloat32Array(value) {
      return value instanceof globalThis.Float32Array;
    }
    function IsFloat64Array(value) {
      return value instanceof globalThis.Float64Array;
    }
    function IsBigInt64Array(value) {
      return value instanceof globalThis.BigInt64Array;
    }
    function IsBigUint64Array(value) {
      return value instanceof globalThis.BigUint64Array;
    }
    function HasPropertyKey2(value, key2) {
      return key2 in value;
    }
    function IsObject5(value) {
      return value !== null && typeof value === "object";
    }
    function IsArray5(value) {
      return Array.isArray(value) && !ArrayBuffer.isView(value);
    }
    function IsUndefined5(value) {
      return value === void 0;
    }
    function IsNull5(value) {
      return value === null;
    }
    function IsBoolean5(value) {
      return typeof value === "boolean";
    }
    function IsNumber5(value) {
      return typeof value === "number";
    }
    function IsInteger4(value) {
      return Number.isInteger(value);
    }
    function IsBigInt5(value) {
      return typeof value === "bigint";
    }
    function IsString5(value) {
      return typeof value === "string";
    }
    function IsFunction5(value) {
      return typeof value === "function";
    }
    function IsSymbol5(value) {
      return typeof value === "symbol";
    }
    function IsValueType2(value) {
      return IsBigInt5(value) || IsBoolean5(value) || IsNull5(value) || IsNumber5(value) || IsString5(value) || IsSymbol5(value) || IsUndefined5(value);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/guard/index.js
var require_guard2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/value/guard/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_guard(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/system/policy.js
var require_policy = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/system/policy.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeSystemPolicy = void 0;
    var index_1 = require_guard2();
    var TypeSystemPolicy2;
    (function(TypeSystemPolicy3) {
      TypeSystemPolicy3.ExactOptionalPropertyTypes = false;
      TypeSystemPolicy3.AllowArrayObject = false;
      TypeSystemPolicy3.AllowNaN = false;
      TypeSystemPolicy3.AllowNullVoid = false;
      function IsExactOptionalProperty(value, key2) {
        return TypeSystemPolicy3.ExactOptionalPropertyTypes ? key2 in value : value[key2] !== void 0;
      }
      TypeSystemPolicy3.IsExactOptionalProperty = IsExactOptionalProperty;
      function IsObjectLike(value) {
        const isObject4 = (0, index_1.IsObject)(value);
        return TypeSystemPolicy3.AllowArrayObject ? isObject4 : isObject4 && !(0, index_1.IsArray)(value);
      }
      TypeSystemPolicy3.IsObjectLike = IsObjectLike;
      function IsRecordLike(value) {
        return IsObjectLike(value) && !(value instanceof Date) && !(value instanceof Uint8Array);
      }
      TypeSystemPolicy3.IsRecordLike = IsRecordLike;
      function IsNumberLike(value) {
        return TypeSystemPolicy3.AllowNaN ? (0, index_1.IsNumber)(value) : Number.isFinite(value);
      }
      TypeSystemPolicy3.IsNumberLike = IsNumberLike;
      function IsVoidLike(value) {
        const isUndefined2 = (0, index_1.IsUndefined)(value);
        return TypeSystemPolicy3.AllowNullVoid ? isUndefined2 || value === null : isUndefined2;
      }
      TypeSystemPolicy3.IsVoidLike = IsVoidLike;
    })(TypeSystemPolicy2 || (exports.TypeSystemPolicy = TypeSystemPolicy2 = {}));
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/registry/format.js
var require_format = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/registry/format.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Entries = Entries3;
    exports.Clear = Clear3;
    exports.Delete = Delete5;
    exports.Has = Has4;
    exports.Set = Set5;
    exports.Get = Get4;
    var map9 = /* @__PURE__ */ new Map();
    function Entries3() {
      return new Map(map9);
    }
    function Clear3() {
      return map9.clear();
    }
    function Delete5(format3) {
      return map9.delete(format3);
    }
    function Has4(format3) {
      return map9.has(format3);
    }
    function Set5(format3, func) {
      map9.set(format3, func);
    }
    function Get4(format3) {
      return map9.get(format3);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/registry/type.js
var require_type = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/registry/type.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Entries = Entries3;
    exports.Clear = Clear3;
    exports.Delete = Delete5;
    exports.Has = Has4;
    exports.Set = Set5;
    exports.Get = Get4;
    var map9 = /* @__PURE__ */ new Map();
    function Entries3() {
      return new Map(map9);
    }
    function Clear3() {
      return map9.clear();
    }
    function Delete5(kind) {
      return map9.delete(kind);
    }
    function Has4(kind) {
      return map9.has(kind);
    }
    function Set5(kind, func) {
      map9.set(kind, func);
    }
    function Get4(kind) {
      return map9.get(kind);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/registry/index.js
var require_registry = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/registry/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeRegistry = exports.FormatRegistry = void 0;
    exports.FormatRegistry = require_format();
    exports.TypeRegistry = require_type();
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/symbols/symbols.js
var require_symbols = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/symbols/symbols.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Kind = exports.Hint = exports.OptionalKind = exports.ReadonlyKind = exports.TransformKind = void 0;
    exports.TransformKind = Symbol.for("TypeBox.Transform");
    exports.ReadonlyKind = Symbol.for("TypeBox.Readonly");
    exports.OptionalKind = Symbol.for("TypeBox.Optional");
    exports.Hint = Symbol.for("TypeBox.Hint");
    exports.Kind = Symbol.for("TypeBox.Kind");
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/symbols/index.js
var require_symbols2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/symbols/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_symbols(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/unsafe/unsafe.js
var require_unsafe = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/unsafe/unsafe.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Unsafe = Unsafe2;
    var index_1 = require_symbols2();
    function Unsafe2(options = {}) {
      return {
        ...options,
        [index_1.Kind]: options[index_1.Kind] ?? "Unsafe"
      };
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/unsafe/index.js
var require_unsafe2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/unsafe/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_unsafe(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/error/error.js
var require_error = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/error/error.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeBoxError = void 0;
    var TypeBoxError2 = class extends Error {
      constructor(message2) {
        super(message2);
      }
    };
    exports.TypeBoxError = TypeBoxError2;
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/error/index.js
var require_error2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/error/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_error(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/system/system.js
var require_system = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/system/system.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeSystem = exports.TypeSystemDuplicateFormat = exports.TypeSystemDuplicateTypeKind = void 0;
    var index_1 = require_registry();
    var index_2 = require_unsafe2();
    var index_3 = require_symbols2();
    var index_4 = require_error2();
    var TypeSystemDuplicateTypeKind2 = class extends index_4.TypeBoxError {
      constructor(kind) {
        super(`Duplicate type kind '${kind}' detected`);
      }
    };
    exports.TypeSystemDuplicateTypeKind = TypeSystemDuplicateTypeKind2;
    var TypeSystemDuplicateFormat2 = class extends index_4.TypeBoxError {
      constructor(kind) {
        super(`Duplicate string format '${kind}' detected`);
      }
    };
    exports.TypeSystemDuplicateFormat = TypeSystemDuplicateFormat2;
    var TypeSystem2;
    (function(TypeSystem3) {
      function Type2(kind, check) {
        if (index_1.TypeRegistry.Has(kind))
          throw new TypeSystemDuplicateTypeKind2(kind);
        index_1.TypeRegistry.Set(kind, check);
        return (options = {}) => (0, index_2.Unsafe)({ ...options, [index_3.Kind]: kind });
      }
      TypeSystem3.Type = Type2;
      function Format2(format3, check) {
        if (index_1.FormatRegistry.Has(format3))
          throw new TypeSystemDuplicateFormat2(format3);
        index_1.FormatRegistry.Set(format3, check);
        return format3;
      }
      TypeSystem3.Format = Format2;
    })(TypeSystem2 || (exports.TypeSystem = TypeSystem2 = {}));
  }
});

// node_modules/@sinclair/typebox/build/cjs/system/index.js
var require_system2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/system/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_policy(), exports);
    __exportStar(require_system(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/mapped/mapped-key.js
var require_mapped_key = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/mapped/mapped-key.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MappedKey = MappedKey;
    var index_1 = require_symbols2();
    function MappedKey(T2) {
      return {
        [index_1.Kind]: "MappedKey",
        keys: T2
      };
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/mapped/mapped-result.js
var require_mapped_result = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/mapped/mapped-result.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MappedResult = MappedResult2;
    var index_1 = require_symbols2();
    function MappedResult2(properties) {
      return {
        [index_1.Kind]: "MappedResult",
        properties
      };
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/guard/value.js
var require_value = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/guard/value.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IsAsyncIterator = IsAsyncIterator5;
    exports.IsArray = IsArray5;
    exports.IsBigInt = IsBigInt5;
    exports.IsBoolean = IsBoolean5;
    exports.IsDate = IsDate5;
    exports.IsFunction = IsFunction5;
    exports.IsIterator = IsIterator5;
    exports.IsNull = IsNull5;
    exports.IsNumber = IsNumber5;
    exports.IsObject = IsObject5;
    exports.IsRegExp = IsRegExp4;
    exports.IsString = IsString5;
    exports.IsSymbol = IsSymbol5;
    exports.IsUint8Array = IsUint8Array5;
    exports.IsUndefined = IsUndefined5;
    function IsAsyncIterator5(value) {
      return IsObject5(value) && !IsArray5(value) && !IsUint8Array5(value) && Symbol.asyncIterator in value;
    }
    function IsArray5(value) {
      return Array.isArray(value);
    }
    function IsBigInt5(value) {
      return typeof value === "bigint";
    }
    function IsBoolean5(value) {
      return typeof value === "boolean";
    }
    function IsDate5(value) {
      return value instanceof globalThis.Date;
    }
    function IsFunction5(value) {
      return typeof value === "function";
    }
    function IsIterator5(value) {
      return IsObject5(value) && !IsArray5(value) && !IsUint8Array5(value) && Symbol.iterator in value;
    }
    function IsNull5(value) {
      return value === null;
    }
    function IsNumber5(value) {
      return typeof value === "number";
    }
    function IsObject5(value) {
      return typeof value === "object" && value !== null;
    }
    function IsRegExp4(value) {
      return value instanceof globalThis.RegExp;
    }
    function IsString5(value) {
      return typeof value === "string";
    }
    function IsSymbol5(value) {
      return typeof value === "symbol";
    }
    function IsUint8Array5(value) {
      return value instanceof globalThis.Uint8Array;
    }
    function IsUndefined5(value) {
      return value === void 0;
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/clone/value.js
var require_value2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/clone/value.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Clone = Clone4;
    var ValueGuard = require_value();
    function ArrayType7(value) {
      return value.map((value2) => Visit17(value2));
    }
    function DateType5(value) {
      return new Date(value.getTime());
    }
    function Uint8ArrayType3(value) {
      return new Uint8Array(value);
    }
    function RegExpType2(value) {
      return new RegExp(value.source, value.flags);
    }
    function ObjectType7(value) {
      const result = {};
      for (const key2 of Object.getOwnPropertyNames(value)) {
        result[key2] = Visit17(value[key2]);
      }
      for (const key2 of Object.getOwnPropertySymbols(value)) {
        result[key2] = Visit17(value[key2]);
      }
      return result;
    }
    function Visit17(value) {
      return ValueGuard.IsArray(value) ? ArrayType7(value) : ValueGuard.IsDate(value) ? DateType5(value) : ValueGuard.IsUint8Array(value) ? Uint8ArrayType3(value) : ValueGuard.IsRegExp(value) ? RegExpType2(value) : ValueGuard.IsObject(value) ? ObjectType7(value) : value;
    }
    function Clone4(value) {
      return Visit17(value);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/clone/type.js
var require_type2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/clone/type.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CloneRest = CloneRest2;
    exports.CloneType = CloneType2;
    var value_1 = require_value2();
    function CloneRest2(schemas) {
      return schemas.map((schema) => CloneType2(schema));
    }
    function CloneType2(schema, options = {}) {
      return { ...(0, value_1.Clone)(schema), ...options };
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/discard/discard.js
var require_discard = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/discard/discard.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Discard = Discard2;
    function DiscardKey2(value, key2) {
      const { [key2]: _, ...rest } = value;
      return rest;
    }
    function Discard2(value, keys3) {
      return keys3.reduce((acc, key2) => DiscardKey2(acc, key2), value);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/discard/index.js
var require_discard2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/discard/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_discard(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/array/array.js
var require_array = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/array/array.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Array = Array3;
    var type_1 = require_type2();
    var index_1 = require_symbols2();
    function Array3(schema, options = {}) {
      return {
        ...options,
        [index_1.Kind]: "Array",
        type: "array",
        items: (0, type_1.CloneType)(schema)
      };
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/array/index.js
var require_array2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/array/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_array(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/async-iterator/async-iterator.js
var require_async_iterator = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/async-iterator/async-iterator.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsyncIterator = AsyncIterator2;
    var index_1 = require_symbols2();
    var type_1 = require_type2();
    function AsyncIterator2(items, options = {}) {
      return {
        ...options,
        [index_1.Kind]: "AsyncIterator",
        type: "AsyncIterator",
        items: (0, type_1.CloneType)(items)
      };
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/async-iterator/index.js
var require_async_iterator2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/async-iterator/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_async_iterator(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/constructor/constructor.js
var require_constructor = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/constructor/constructor.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Constructor = Constructor2;
    var type_1 = require_type2();
    var index_1 = require_symbols2();
    function Constructor2(parameters, returns, options) {
      return {
        ...options,
        [index_1.Kind]: "Constructor",
        type: "Constructor",
        parameters: (0, type_1.CloneRest)(parameters),
        returns: (0, type_1.CloneType)(returns)
      };
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/constructor/index.js
var require_constructor2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/constructor/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_constructor(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/function/function.js
var require_function = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/function/function.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Function = Function3;
    var type_1 = require_type2();
    var index_1 = require_symbols2();
    function Function3(parameters, returns, options) {
      return {
        ...options,
        [index_1.Kind]: "Function",
        type: "Function",
        parameters: (0, type_1.CloneRest)(parameters),
        returns: (0, type_1.CloneType)(returns)
      };
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/function/index.js
var require_function2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/function/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_function(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/never/never.js
var require_never = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/never/never.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Never = Never2;
    var index_1 = require_symbols2();
    function Never2(options = {}) {
      return {
        ...options,
        [index_1.Kind]: "Never",
        not: {}
      };
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/never/index.js
var require_never2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/never/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_never(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/guard/kind.js
var require_kind = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/guard/kind.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IsReadonly = IsReadonly3;
    exports.IsOptional = IsOptional3;
    exports.IsAny = IsAny3;
    exports.IsArray = IsArray5;
    exports.IsAsyncIterator = IsAsyncIterator5;
    exports.IsBigInt = IsBigInt5;
    exports.IsBoolean = IsBoolean5;
    exports.IsConstructor = IsConstructor3;
    exports.IsDate = IsDate5;
    exports.IsFunction = IsFunction5;
    exports.IsInteger = IsInteger4;
    exports.IsProperties = IsProperties2;
    exports.IsIntersect = IsIntersect3;
    exports.IsIterator = IsIterator5;
    exports.IsKindOf = IsKindOf3;
    exports.IsLiteralString = IsLiteralString2;
    exports.IsLiteralNumber = IsLiteralNumber2;
    exports.IsLiteralBoolean = IsLiteralBoolean2;
    exports.IsLiteral = IsLiteral3;
    exports.IsMappedKey = IsMappedKey3;
    exports.IsMappedResult = IsMappedResult3;
    exports.IsNever = IsNever3;
    exports.IsNot = IsNot3;
    exports.IsNull = IsNull5;
    exports.IsNumber = IsNumber5;
    exports.IsObject = IsObject5;
    exports.IsPromise = IsPromise4;
    exports.IsRecord = IsRecord3;
    exports.IsRecursive = IsRecursive2;
    exports.IsRef = IsRef3;
    exports.IsRegExp = IsRegExp4;
    exports.IsString = IsString5;
    exports.IsSymbol = IsSymbol5;
    exports.IsTemplateLiteral = IsTemplateLiteral3;
    exports.IsThis = IsThis3;
    exports.IsTransform = IsTransform3;
    exports.IsTuple = IsTuple3;
    exports.IsUndefined = IsUndefined5;
    exports.IsUnion = IsUnion3;
    exports.IsUint8Array = IsUint8Array5;
    exports.IsUnknown = IsUnknown3;
    exports.IsUnsafe = IsUnsafe3;
    exports.IsVoid = IsVoid3;
    exports.IsKind = IsKind3;
    exports.IsSchema = IsSchema3;
    var ValueGuard = require_value();
    var index_1 = require_symbols2();
    function IsReadonly3(value) {
      return ValueGuard.IsObject(value) && value[index_1.ReadonlyKind] === "Readonly";
    }
    function IsOptional3(value) {
      return ValueGuard.IsObject(value) && value[index_1.OptionalKind] === "Optional";
    }
    function IsAny3(value) {
      return IsKindOf3(value, "Any");
    }
    function IsArray5(value) {
      return IsKindOf3(value, "Array");
    }
    function IsAsyncIterator5(value) {
      return IsKindOf3(value, "AsyncIterator");
    }
    function IsBigInt5(value) {
      return IsKindOf3(value, "BigInt");
    }
    function IsBoolean5(value) {
      return IsKindOf3(value, "Boolean");
    }
    function IsConstructor3(value) {
      return IsKindOf3(value, "Constructor");
    }
    function IsDate5(value) {
      return IsKindOf3(value, "Date");
    }
    function IsFunction5(value) {
      return IsKindOf3(value, "Function");
    }
    function IsInteger4(value) {
      return IsKindOf3(value, "Integer");
    }
    function IsProperties2(value) {
      return ValueGuard.IsObject(value);
    }
    function IsIntersect3(value) {
      return IsKindOf3(value, "Intersect");
    }
    function IsIterator5(value) {
      return IsKindOf3(value, "Iterator");
    }
    function IsKindOf3(value, kind) {
      return ValueGuard.IsObject(value) && index_1.Kind in value && value[index_1.Kind] === kind;
    }
    function IsLiteralString2(value) {
      return IsLiteral3(value) && ValueGuard.IsString(value.const);
    }
    function IsLiteralNumber2(value) {
      return IsLiteral3(value) && ValueGuard.IsNumber(value.const);
    }
    function IsLiteralBoolean2(value) {
      return IsLiteral3(value) && ValueGuard.IsBoolean(value.const);
    }
    function IsLiteral3(value) {
      return IsKindOf3(value, "Literal");
    }
    function IsMappedKey3(value) {
      return IsKindOf3(value, "MappedKey");
    }
    function IsMappedResult3(value) {
      return IsKindOf3(value, "MappedResult");
    }
    function IsNever3(value) {
      return IsKindOf3(value, "Never");
    }
    function IsNot3(value) {
      return IsKindOf3(value, "Not");
    }
    function IsNull5(value) {
      return IsKindOf3(value, "Null");
    }
    function IsNumber5(value) {
      return IsKindOf3(value, "Number");
    }
    function IsObject5(value) {
      return IsKindOf3(value, "Object");
    }
    function IsPromise4(value) {
      return IsKindOf3(value, "Promise");
    }
    function IsRecord3(value) {
      return IsKindOf3(value, "Record");
    }
    function IsRecursive2(value) {
      return ValueGuard.IsObject(value) && index_1.Hint in value && value[index_1.Hint] === "Recursive";
    }
    function IsRef3(value) {
      return IsKindOf3(value, "Ref");
    }
    function IsRegExp4(value) {
      return IsKindOf3(value, "RegExp");
    }
    function IsString5(value) {
      return IsKindOf3(value, "String");
    }
    function IsSymbol5(value) {
      return IsKindOf3(value, "Symbol");
    }
    function IsTemplateLiteral3(value) {
      return IsKindOf3(value, "TemplateLiteral");
    }
    function IsThis3(value) {
      return IsKindOf3(value, "This");
    }
    function IsTransform3(value) {
      return ValueGuard.IsObject(value) && index_1.TransformKind in value;
    }
    function IsTuple3(value) {
      return IsKindOf3(value, "Tuple");
    }
    function IsUndefined5(value) {
      return IsKindOf3(value, "Undefined");
    }
    function IsUnion3(value) {
      return IsKindOf3(value, "Union");
    }
    function IsUint8Array5(value) {
      return IsKindOf3(value, "Uint8Array");
    }
    function IsUnknown3(value) {
      return IsKindOf3(value, "Unknown");
    }
    function IsUnsafe3(value) {
      return IsKindOf3(value, "Unsafe");
    }
    function IsVoid3(value) {
      return IsKindOf3(value, "Void");
    }
    function IsKind3(value) {
      return ValueGuard.IsObject(value) && index_1.Kind in value && ValueGuard.IsString(value[index_1.Kind]);
    }
    function IsSchema3(value) {
      return IsAny3(value) || IsArray5(value) || IsBoolean5(value) || IsBigInt5(value) || IsAsyncIterator5(value) || IsConstructor3(value) || IsDate5(value) || IsFunction5(value) || IsInteger4(value) || IsIntersect3(value) || IsIterator5(value) || IsLiteral3(value) || IsMappedKey3(value) || IsMappedResult3(value) || IsNever3(value) || IsNot3(value) || IsNull5(value) || IsNumber5(value) || IsObject5(value) || IsPromise4(value) || IsRecord3(value) || IsRef3(value) || IsRegExp4(value) || IsString5(value) || IsSymbol5(value) || IsTemplateLiteral3(value) || IsThis3(value) || IsTuple3(value) || IsUndefined5(value) || IsUnion3(value) || IsUint8Array5(value) || IsUnknown3(value) || IsUnsafe3(value) || IsVoid3(value) || IsKind3(value);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/optional/optional.js
var require_optional = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/optional/optional.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Optional = Optional2;
    var index_1 = require_symbols2();
    var type_1 = require_type2();
    var index_2 = require_discard2();
    var optional_from_mapped_result_1 = require_optional_from_mapped_result();
    var kind_1 = require_kind();
    function RemoveOptional2(schema) {
      return (0, index_2.Discard)((0, type_1.CloneType)(schema), [index_1.OptionalKind]);
    }
    function AddOptional2(schema) {
      return { ...(0, type_1.CloneType)(schema), [index_1.OptionalKind]: "Optional" };
    }
    function OptionalWithFlag2(schema, F2) {
      return F2 === false ? RemoveOptional2(schema) : AddOptional2(schema);
    }
    function Optional2(schema, enable) {
      const F2 = enable ?? true;
      return (0, kind_1.IsMappedResult)(schema) ? (0, optional_from_mapped_result_1.OptionalFromMappedResult)(schema, F2) : OptionalWithFlag2(schema, F2);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/optional/optional-from-mapped-result.js
var require_optional_from_mapped_result = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/optional/optional-from-mapped-result.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OptionalFromMappedResult = OptionalFromMappedResult2;
    var index_1 = require_mapped2();
    var optional_1 = require_optional();
    function FromProperties20(P2, F2) {
      const Acc = {};
      for (const K2 of globalThis.Object.getOwnPropertyNames(P2))
        Acc[K2] = (0, optional_1.Optional)(P2[K2], F2);
      return Acc;
    }
    function FromMappedResult13(R2, F2) {
      return FromProperties20(R2.properties, F2);
    }
    function OptionalFromMappedResult2(R2, F2) {
      const P2 = FromMappedResult13(R2, F2);
      return (0, index_1.MappedResult)(P2);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/optional/index.js
var require_optional2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/optional/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_optional_from_mapped_result(), exports);
    __exportStar(require_optional(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intersect/intersect-create.js
var require_intersect_create = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/intersect/intersect-create.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IntersectCreate = IntersectCreate2;
    var index_1 = require_symbols2();
    var type_1 = require_type2();
    var kind_1 = require_kind();
    function IntersectCreate2(T2, options) {
      const allObjects = T2.every((schema) => (0, kind_1.IsObject)(schema));
      const clonedUnevaluatedProperties = (0, kind_1.IsSchema)(options.unevaluatedProperties) ? { unevaluatedProperties: (0, type_1.CloneType)(options.unevaluatedProperties) } : {};
      return options.unevaluatedProperties === false || (0, kind_1.IsSchema)(options.unevaluatedProperties) || allObjects ? { ...options, ...clonedUnevaluatedProperties, [index_1.Kind]: "Intersect", type: "object", allOf: (0, type_1.CloneRest)(T2) } : { ...options, ...clonedUnevaluatedProperties, [index_1.Kind]: "Intersect", allOf: (0, type_1.CloneRest)(T2) };
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intersect/intersect-evaluated.js
var require_intersect_evaluated = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/intersect/intersect-evaluated.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IntersectEvaluated = IntersectEvaluated2;
    var index_1 = require_symbols2();
    var type_1 = require_type2();
    var index_2 = require_discard2();
    var index_3 = require_never2();
    var index_4 = require_optional2();
    var intersect_create_1 = require_intersect_create();
    var kind_1 = require_kind();
    function IsIntersectOptional2(T2) {
      return T2.every((L2) => (0, kind_1.IsOptional)(L2));
    }
    function RemoveOptionalFromType3(T2) {
      return (0, index_2.Discard)(T2, [index_1.OptionalKind]);
    }
    function RemoveOptionalFromRest3(T2) {
      return T2.map((L2) => (0, kind_1.IsOptional)(L2) ? RemoveOptionalFromType3(L2) : L2);
    }
    function ResolveIntersect2(T2, options) {
      return IsIntersectOptional2(T2) ? (0, index_4.Optional)((0, intersect_create_1.IntersectCreate)(RemoveOptionalFromRest3(T2), options)) : (0, intersect_create_1.IntersectCreate)(RemoveOptionalFromRest3(T2), options);
    }
    function IntersectEvaluated2(T2, options = {}) {
      if (T2.length === 0)
        return (0, index_3.Never)(options);
      if (T2.length === 1)
        return (0, type_1.CloneType)(T2[0], options);
      if (T2.some((schema) => (0, kind_1.IsTransform)(schema)))
        throw new Error("Cannot intersect transform types");
      return ResolveIntersect2(T2, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intersect/intersect-type.js
var require_intersect_type = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/intersect/intersect-type.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_symbols2();
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intersect/intersect.js
var require_intersect = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/intersect/intersect.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Intersect = Intersect3;
    var type_1 = require_type2();
    var index_1 = require_never2();
    var intersect_create_1 = require_intersect_create();
    var kind_1 = require_kind();
    function Intersect3(T2, options = {}) {
      if (T2.length === 0)
        return (0, index_1.Never)(options);
      if (T2.length === 1)
        return (0, type_1.CloneType)(T2[0], options);
      if (T2.some((schema) => (0, kind_1.IsTransform)(schema)))
        throw new Error("Cannot intersect transform types");
      return (0, intersect_create_1.IntersectCreate)(T2, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intersect/index.js
var require_intersect2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/intersect/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_intersect_evaluated(), exports);
    __exportStar(require_intersect_type(), exports);
    __exportStar(require_intersect(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/union/union-create.js
var require_union_create = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/union/union-create.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UnionCreate = UnionCreate2;
    var type_1 = require_type2();
    var index_1 = require_symbols2();
    function UnionCreate2(T2, options) {
      return { ...options, [index_1.Kind]: "Union", anyOf: (0, type_1.CloneRest)(T2) };
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/union/union-evaluated.js
var require_union_evaluated = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/union/union-evaluated.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UnionEvaluated = UnionEvaluated2;
    var index_1 = require_symbols2();
    var type_1 = require_type2();
    var index_2 = require_discard2();
    var index_3 = require_never2();
    var index_4 = require_optional2();
    var union_create_1 = require_union_create();
    var kind_1 = require_kind();
    function IsUnionOptional2(T2) {
      return T2.some((L2) => (0, kind_1.IsOptional)(L2));
    }
    function RemoveOptionalFromRest3(T2) {
      return T2.map((L2) => (0, kind_1.IsOptional)(L2) ? RemoveOptionalFromType3(L2) : L2);
    }
    function RemoveOptionalFromType3(T2) {
      return (0, index_2.Discard)(T2, [index_1.OptionalKind]);
    }
    function ResolveUnion2(T2, options) {
      return IsUnionOptional2(T2) ? (0, index_4.Optional)((0, union_create_1.UnionCreate)(RemoveOptionalFromRest3(T2), options)) : (0, union_create_1.UnionCreate)(RemoveOptionalFromRest3(T2), options);
    }
    function UnionEvaluated2(T2, options = {}) {
      return T2.length === 0 ? (0, index_3.Never)(options) : T2.length === 1 ? (0, type_1.CloneType)(T2[0], options) : ResolveUnion2(T2, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/union/union-type.js
var require_union_type = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/union/union-type.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_symbols2();
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/union/union.js
var require_union = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/union/union.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Union = Union3;
    var index_1 = require_never2();
    var type_1 = require_type2();
    var union_create_1 = require_union_create();
    function Union3(T2, options = {}) {
      return T2.length === 0 ? (0, index_1.Never)(options) : T2.length === 1 ? (0, type_1.CloneType)(T2[0], options) : (0, union_create_1.UnionCreate)(T2, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/union/index.js
var require_union2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/union/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_union_evaluated(), exports);
    __exportStar(require_union_type(), exports);
    __exportStar(require_union(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/parse.js
var require_parse = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/template-literal/parse.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TemplateLiteralParserError = void 0;
    exports.TemplateLiteralParse = TemplateLiteralParse2;
    exports.TemplateLiteralParseExact = TemplateLiteralParseExact2;
    var index_1 = require_error2();
    var TemplateLiteralParserError2 = class extends index_1.TypeBoxError {
    };
    exports.TemplateLiteralParserError = TemplateLiteralParserError2;
    function Unescape2(pattern) {
      return pattern.replace(/\\\$/g, "$").replace(/\\\*/g, "*").replace(/\\\^/g, "^").replace(/\\\|/g, "|").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
    }
    function IsNonEscaped2(pattern, index3, char) {
      return pattern[index3] === char && pattern.charCodeAt(index3 - 1) !== 92;
    }
    function IsOpenParen2(pattern, index3) {
      return IsNonEscaped2(pattern, index3, "(");
    }
    function IsCloseParen2(pattern, index3) {
      return IsNonEscaped2(pattern, index3, ")");
    }
    function IsSeparator2(pattern, index3) {
      return IsNonEscaped2(pattern, index3, "|");
    }
    function IsGroup2(pattern) {
      if (!(IsOpenParen2(pattern, 0) && IsCloseParen2(pattern, pattern.length - 1)))
        return false;
      let count2 = 0;
      for (let index3 = 0; index3 < pattern.length; index3++) {
        if (IsOpenParen2(pattern, index3))
          count2 += 1;
        if (IsCloseParen2(pattern, index3))
          count2 -= 1;
        if (count2 === 0 && index3 !== pattern.length - 1)
          return false;
      }
      return true;
    }
    function InGroup2(pattern) {
      return pattern.slice(1, pattern.length - 1);
    }
    function IsPrecedenceOr2(pattern) {
      let count2 = 0;
      for (let index3 = 0; index3 < pattern.length; index3++) {
        if (IsOpenParen2(pattern, index3))
          count2 += 1;
        if (IsCloseParen2(pattern, index3))
          count2 -= 1;
        if (IsSeparator2(pattern, index3) && count2 === 0)
          return true;
      }
      return false;
    }
    function IsPrecedenceAnd2(pattern) {
      for (let index3 = 0; index3 < pattern.length; index3++) {
        if (IsOpenParen2(pattern, index3))
          return true;
      }
      return false;
    }
    function Or2(pattern) {
      let [count2, start] = [0, 0];
      const expressions = [];
      for (let index3 = 0; index3 < pattern.length; index3++) {
        if (IsOpenParen2(pattern, index3))
          count2 += 1;
        if (IsCloseParen2(pattern, index3))
          count2 -= 1;
        if (IsSeparator2(pattern, index3) && count2 === 0) {
          const range2 = pattern.slice(start, index3);
          if (range2.length > 0)
            expressions.push(TemplateLiteralParse2(range2));
          start = index3 + 1;
        }
      }
      const range = pattern.slice(start);
      if (range.length > 0)
        expressions.push(TemplateLiteralParse2(range));
      if (expressions.length === 0)
        return { type: "const", const: "" };
      if (expressions.length === 1)
        return expressions[0];
      return { type: "or", expr: expressions };
    }
    function And2(pattern) {
      function Group(value, index3) {
        if (!IsOpenParen2(value, index3))
          throw new TemplateLiteralParserError2(`TemplateLiteralParser: Index must point to open parens`);
        let count2 = 0;
        for (let scan = index3; scan < value.length; scan++) {
          if (IsOpenParen2(value, scan))
            count2 += 1;
          if (IsCloseParen2(value, scan))
            count2 -= 1;
          if (count2 === 0)
            return [index3, scan];
        }
        throw new TemplateLiteralParserError2(`TemplateLiteralParser: Unclosed group parens in expression`);
      }
      function Range(pattern2, index3) {
        for (let scan = index3; scan < pattern2.length; scan++) {
          if (IsOpenParen2(pattern2, scan))
            return [index3, scan];
        }
        return [index3, pattern2.length];
      }
      const expressions = [];
      for (let index3 = 0; index3 < pattern.length; index3++) {
        if (IsOpenParen2(pattern, index3)) {
          const [start, end] = Group(pattern, index3);
          const range = pattern.slice(start, end + 1);
          expressions.push(TemplateLiteralParse2(range));
          index3 = end;
        } else {
          const [start, end] = Range(pattern, index3);
          const range = pattern.slice(start, end);
          if (range.length > 0)
            expressions.push(TemplateLiteralParse2(range));
          index3 = end - 1;
        }
      }
      return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
    }
    function TemplateLiteralParse2(pattern) {
      return IsGroup2(pattern) ? TemplateLiteralParse2(InGroup2(pattern)) : IsPrecedenceOr2(pattern) ? Or2(pattern) : IsPrecedenceAnd2(pattern) ? And2(pattern) : { type: "const", const: Unescape2(pattern) };
    }
    function TemplateLiteralParseExact2(pattern) {
      return TemplateLiteralParse2(pattern.slice(1, pattern.length - 1));
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/finite.js
var require_finite = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/template-literal/finite.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TemplateLiteralFiniteError = void 0;
    exports.IsTemplateLiteralExpressionFinite = IsTemplateLiteralExpressionFinite2;
    exports.IsTemplateLiteralFinite = IsTemplateLiteralFinite2;
    var parse_1 = require_parse();
    var index_1 = require_error2();
    var TemplateLiteralFiniteError2 = class extends index_1.TypeBoxError {
    };
    exports.TemplateLiteralFiniteError = TemplateLiteralFiniteError2;
    function IsNumberExpression2(expression) {
      return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
    }
    function IsBooleanExpression2(expression) {
      return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
    }
    function IsStringExpression2(expression) {
      return expression.type === "const" && expression.const === ".*";
    }
    function IsTemplateLiteralExpressionFinite2(expression) {
      return IsNumberExpression2(expression) || IsStringExpression2(expression) ? false : IsBooleanExpression2(expression) ? true : expression.type === "and" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite2(expr)) : expression.type === "or" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite2(expr)) : expression.type === "const" ? true : (() => {
        throw new TemplateLiteralFiniteError2(`Unknown expression type`);
      })();
    }
    function IsTemplateLiteralFinite2(schema) {
      const expression = (0, parse_1.TemplateLiteralParseExact)(schema.pattern);
      return IsTemplateLiteralExpressionFinite2(expression);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/generate.js
var require_generate = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/template-literal/generate.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TemplateLiteralGenerateError = void 0;
    exports.TemplateLiteralExpressionGenerate = TemplateLiteralExpressionGenerate2;
    exports.TemplateLiteralGenerate = TemplateLiteralGenerate2;
    var finite_1 = require_finite();
    var parse_1 = require_parse();
    var index_1 = require_error2();
    var TemplateLiteralGenerateError2 = class extends index_1.TypeBoxError {
    };
    exports.TemplateLiteralGenerateError = TemplateLiteralGenerateError2;
    function* GenerateReduce2(buffer) {
      if (buffer.length === 1)
        return yield* buffer[0];
      for (const left of buffer[0]) {
        for (const right of GenerateReduce2(buffer.slice(1))) {
          yield `${left}${right}`;
        }
      }
    }
    function* GenerateAnd2(expression) {
      return yield* GenerateReduce2(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate2(expr)]));
    }
    function* GenerateOr2(expression) {
      for (const expr of expression.expr)
        yield* TemplateLiteralExpressionGenerate2(expr);
    }
    function* GenerateConst2(expression) {
      return yield expression.const;
    }
    function* TemplateLiteralExpressionGenerate2(expression) {
      return expression.type === "and" ? yield* GenerateAnd2(expression) : expression.type === "or" ? yield* GenerateOr2(expression) : expression.type === "const" ? yield* GenerateConst2(expression) : (() => {
        throw new TemplateLiteralGenerateError2("Unknown expression");
      })();
    }
    function TemplateLiteralGenerate2(schema) {
      const expression = (0, parse_1.TemplateLiteralParseExact)(schema.pattern);
      return (0, finite_1.IsTemplateLiteralExpressionFinite)(expression) ? [...TemplateLiteralExpressionGenerate2(expression)] : [];
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/literal/literal.js
var require_literal = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/literal/literal.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Literal = Literal2;
    var index_1 = require_symbols2();
    function Literal2(value, options = {}) {
      return {
        ...options,
        [index_1.Kind]: "Literal",
        const: value,
        type: typeof value
      };
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/literal/index.js
var require_literal2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/literal/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_literal(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/boolean/boolean.js
var require_boolean = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/boolean/boolean.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Boolean = Boolean3;
    var index_1 = require_symbols2();
    function Boolean3(options = {}) {
      return {
        ...options,
        [index_1.Kind]: "Boolean",
        type: "boolean"
      };
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/boolean/index.js
var require_boolean2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/boolean/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_boolean(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/bigint/bigint.js
var require_bigint = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/bigint/bigint.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BigInt = BigInt3;
    var index_1 = require_symbols2();
    function BigInt3(options = {}) {
      return {
        ...options,
        [index_1.Kind]: "BigInt",
        type: "bigint"
      };
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/bigint/index.js
var require_bigint2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/bigint/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_bigint(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/number/number.js
var require_number = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/number/number.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Number = Number3;
    var index_1 = require_symbols2();
    function Number3(options = {}) {
      return {
        ...options,
        [index_1.Kind]: "Number",
        type: "number"
      };
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/number/index.js
var require_number2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/number/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_number(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/string/string.js
var require_string = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/string/string.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.String = String3;
    var index_1 = require_symbols2();
    function String3(options = {}) {
      return { ...options, [index_1.Kind]: "String", type: "string" };
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/string/index.js
var require_string2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/string/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_string(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/syntax.js
var require_syntax = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/template-literal/syntax.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TemplateLiteralSyntax = TemplateLiteralSyntax2;
    var index_1 = require_literal2();
    var index_2 = require_boolean2();
    var index_3 = require_bigint2();
    var index_4 = require_number2();
    var index_5 = require_string2();
    var index_6 = require_union2();
    var index_7 = require_never2();
    function* FromUnion20(syntax) {
      const trim = syntax.trim().replace(/"|'/g, "");
      return trim === "boolean" ? yield (0, index_2.Boolean)() : trim === "number" ? yield (0, index_4.Number)() : trim === "bigint" ? yield (0, index_3.BigInt)() : trim === "string" ? yield (0, index_5.String)() : yield (() => {
        const literals = trim.split("|").map((literal) => (0, index_1.Literal)(literal.trim()));
        return literals.length === 0 ? (0, index_7.Never)() : literals.length === 1 ? literals[0] : (0, index_6.UnionEvaluated)(literals);
      })();
    }
    function* FromTerminal2(syntax) {
      if (syntax[1] !== "{") {
        const L2 = (0, index_1.Literal)("$");
        const R2 = FromSyntax2(syntax.slice(1));
        return yield* [L2, ...R2];
      }
      for (let i2 = 2; i2 < syntax.length; i2++) {
        if (syntax[i2] === "}") {
          const L2 = FromUnion20(syntax.slice(2, i2));
          const R2 = FromSyntax2(syntax.slice(i2 + 1));
          return yield* [...L2, ...R2];
        }
      }
      yield (0, index_1.Literal)(syntax);
    }
    function* FromSyntax2(syntax) {
      for (let i2 = 0; i2 < syntax.length; i2++) {
        if (syntax[i2] === "$") {
          const L2 = (0, index_1.Literal)(syntax.slice(0, i2));
          const R2 = FromTerminal2(syntax.slice(i2));
          return yield* [L2, ...R2];
        }
      }
      yield (0, index_1.Literal)(syntax);
    }
    function TemplateLiteralSyntax2(syntax) {
      return [...FromSyntax2(syntax)];
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/patterns/patterns.js
var require_patterns = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/patterns/patterns.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PatternStringExact = exports.PatternNumberExact = exports.PatternBooleanExact = exports.PatternString = exports.PatternNumber = exports.PatternBoolean = void 0;
    exports.PatternBoolean = "(true|false)";
    exports.PatternNumber = "(0|[1-9][0-9]*)";
    exports.PatternString = "(.*)";
    exports.PatternBooleanExact = `^${exports.PatternBoolean}$`;
    exports.PatternNumberExact = `^${exports.PatternNumber}$`;
    exports.PatternStringExact = `^${exports.PatternString}$`;
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/patterns/index.js
var require_patterns2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/patterns/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_patterns(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/pattern.js
var require_pattern = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/template-literal/pattern.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TemplateLiteralPatternError = void 0;
    exports.TemplateLiteralPattern = TemplateLiteralPattern2;
    var index_1 = require_patterns2();
    var index_2 = require_symbols2();
    var index_3 = require_error2();
    var kind_1 = require_kind();
    var TemplateLiteralPatternError2 = class extends index_3.TypeBoxError {
    };
    exports.TemplateLiteralPatternError = TemplateLiteralPatternError2;
    function Escape3(value) {
      return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function Visit17(schema, acc) {
      return (0, kind_1.IsTemplateLiteral)(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : (0, kind_1.IsUnion)(schema) ? `(${schema.anyOf.map((schema2) => Visit17(schema2, acc)).join("|")})` : (0, kind_1.IsNumber)(schema) ? `${acc}${index_1.PatternNumber}` : (0, kind_1.IsInteger)(schema) ? `${acc}${index_1.PatternNumber}` : (0, kind_1.IsBigInt)(schema) ? `${acc}${index_1.PatternNumber}` : (0, kind_1.IsString)(schema) ? `${acc}${index_1.PatternString}` : (0, kind_1.IsLiteral)(schema) ? `${acc}${Escape3(schema.const.toString())}` : (0, kind_1.IsBoolean)(schema) ? `${acc}${index_1.PatternBoolean}` : (() => {
        throw new TemplateLiteralPatternError2(`Unexpected Kind '${schema[index_2.Kind]}'`);
      })();
    }
    function TemplateLiteralPattern2(kinds) {
      return `^${kinds.map((schema) => Visit17(schema, "")).join("")}$`;
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/union.js
var require_union3 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/template-literal/union.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TemplateLiteralToUnion = TemplateLiteralToUnion2;
    var index_1 = require_union2();
    var index_2 = require_literal2();
    var generate_1 = require_generate();
    function TemplateLiteralToUnion2(schema) {
      const R2 = (0, generate_1.TemplateLiteralGenerate)(schema);
      const L2 = R2.map((S2) => (0, index_2.Literal)(S2));
      return (0, index_1.UnionEvaluated)(L2);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/template-literal.js
var require_template_literal = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/template-literal/template-literal.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TemplateLiteral = TemplateLiteral2;
    var syntax_1 = require_syntax();
    var pattern_1 = require_pattern();
    var value_1 = require_value();
    var index_1 = require_symbols2();
    function TemplateLiteral2(unresolved, options = {}) {
      const pattern = (0, value_1.IsString)(unresolved) ? (0, pattern_1.TemplateLiteralPattern)((0, syntax_1.TemplateLiteralSyntax)(unresolved)) : (0, pattern_1.TemplateLiteralPattern)(unresolved);
      return { ...options, [index_1.Kind]: "TemplateLiteral", type: "string", pattern };
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/index.js
var require_template_literal2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/template-literal/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_finite(), exports);
    __exportStar(require_generate(), exports);
    __exportStar(require_syntax(), exports);
    __exportStar(require_parse(), exports);
    __exportStar(require_pattern(), exports);
    __exportStar(require_union3(), exports);
    __exportStar(require_template_literal(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/indexed/indexed-property-keys.js
var require_indexed_property_keys = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/indexed/indexed-property-keys.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndexPropertyKeys = IndexPropertyKeys2;
    var index_1 = require_template_literal2();
    var kind_1 = require_kind();
    function FromTemplateLiteral7(T2) {
      const R2 = (0, index_1.TemplateLiteralGenerate)(T2);
      return R2.map((S2) => S2.toString());
    }
    function FromUnion20(T2) {
      const Acc = [];
      for (const L2 of T2)
        Acc.push(...IndexPropertyKeys2(L2));
      return Acc;
    }
    function FromLiteral7(T2) {
      return [T2.toString()];
    }
    function IndexPropertyKeys2(T2) {
      return [...new Set((0, kind_1.IsTemplateLiteral)(T2) ? FromTemplateLiteral7(T2) : (0, kind_1.IsUnion)(T2) ? FromUnion20(T2.anyOf) : (0, kind_1.IsLiteral)(T2) ? FromLiteral7(T2.const) : (0, kind_1.IsNumber)(T2) ? ["[number]"] : (0, kind_1.IsInteger)(T2) ? ["[number]"] : [])];
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/indexed/indexed-from-mapped-result.js
var require_indexed_from_mapped_result = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/indexed/indexed-from-mapped-result.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndexFromMappedResult = IndexFromMappedResult2;
    var index_1 = require_mapped2();
    var indexed_property_keys_1 = require_indexed_property_keys();
    var index_2 = require_indexed2();
    function FromProperties20(T2, P2, options) {
      const Acc = {};
      for (const K2 of Object.getOwnPropertyNames(P2)) {
        Acc[K2] = (0, index_2.Index)(T2, (0, indexed_property_keys_1.IndexPropertyKeys)(P2[K2]), options);
      }
      return Acc;
    }
    function FromMappedResult13(T2, R2, options) {
      return FromProperties20(T2, R2.properties, options);
    }
    function IndexFromMappedResult2(T2, R2, options) {
      const P2 = FromMappedResult13(T2, R2, options);
      return (0, index_1.MappedResult)(P2);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/indexed/indexed.js
var require_indexed = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/indexed/indexed.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndexFromPropertyKey = IndexFromPropertyKey2;
    exports.IndexFromPropertyKeys = IndexFromPropertyKeys2;
    exports.Index = Index2;
    var index_1 = require_never2();
    var index_2 = require_intersect2();
    var index_3 = require_union2();
    var type_1 = require_type2();
    var indexed_property_keys_1 = require_indexed_property_keys();
    var indexed_from_mapped_key_1 = require_indexed_from_mapped_key();
    var indexed_from_mapped_result_1 = require_indexed_from_mapped_result();
    var kind_1 = require_kind();
    function FromRest9(T2, K2) {
      return T2.map((L2) => IndexFromPropertyKey2(L2, K2));
    }
    function FromIntersectRest2(T2) {
      return T2.filter((L2) => !(0, kind_1.IsNever)(L2));
    }
    function FromIntersect18(T2, K2) {
      return (0, index_2.IntersectEvaluated)(FromIntersectRest2(FromRest9(T2, K2)));
    }
    function FromUnionRest2(T2) {
      return T2.some((L2) => (0, kind_1.IsNever)(L2)) ? [] : T2;
    }
    function FromUnion20(T2, K2) {
      return (0, index_3.UnionEvaluated)(FromUnionRest2(FromRest9(T2, K2)));
    }
    function FromTuple15(T2, K2) {
      return K2 in T2 ? T2[K2] : K2 === "[number]" ? (0, index_3.UnionEvaluated)(T2) : (0, index_1.Never)();
    }
    function FromArray16(T2, K2) {
      return K2 === "[number]" ? T2 : (0, index_1.Never)();
    }
    function FromProperty3(T2, K2) {
      return K2 in T2 ? T2[K2] : (0, index_1.Never)();
    }
    function IndexFromPropertyKey2(T2, K2) {
      return (0, kind_1.IsIntersect)(T2) ? FromIntersect18(T2.allOf, K2) : (0, kind_1.IsUnion)(T2) ? FromUnion20(T2.anyOf, K2) : (0, kind_1.IsTuple)(T2) ? FromTuple15(T2.items ?? [], K2) : (0, kind_1.IsArray)(T2) ? FromArray16(T2.items, K2) : (0, kind_1.IsObject)(T2) ? FromProperty3(T2.properties, K2) : (0, index_1.Never)();
    }
    function IndexFromPropertyKeys2(T2, K2) {
      return K2.map((L2) => IndexFromPropertyKey2(T2, L2));
    }
    function FromSchema2(T2, K2) {
      return (0, index_3.UnionEvaluated)(IndexFromPropertyKeys2(T2, K2));
    }
    function Index2(T2, K2, options = {}) {
      return (0, kind_1.IsMappedResult)(K2) ? (0, type_1.CloneType)((0, indexed_from_mapped_result_1.IndexFromMappedResult)(T2, K2, options)) : (0, kind_1.IsMappedKey)(K2) ? (0, type_1.CloneType)((0, indexed_from_mapped_key_1.IndexFromMappedKey)(T2, K2, options)) : (0, kind_1.IsSchema)(K2) ? (0, type_1.CloneType)(FromSchema2(T2, (0, indexed_property_keys_1.IndexPropertyKeys)(K2)), options) : (0, type_1.CloneType)(FromSchema2(T2, K2), options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/indexed/indexed-from-mapped-key.js
var require_indexed_from_mapped_key = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/indexed/indexed-from-mapped-key.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndexFromMappedKey = IndexFromMappedKey2;
    var indexed_1 = require_indexed();
    var index_1 = require_mapped2();
    function MappedIndexPropertyKey2(T2, K2, options) {
      return { [K2]: (0, indexed_1.Index)(T2, [K2], options) };
    }
    function MappedIndexPropertyKeys2(T2, K2, options) {
      return K2.reduce((Acc, L2) => {
        return { ...Acc, ...MappedIndexPropertyKey2(T2, L2, options) };
      }, {});
    }
    function MappedIndexProperties2(T2, K2, options) {
      return MappedIndexPropertyKeys2(T2, K2.keys, options);
    }
    function IndexFromMappedKey2(T2, K2, options) {
      const P2 = MappedIndexProperties2(T2, K2, options);
      return (0, index_1.MappedResult)(P2);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/indexed/index.js
var require_indexed2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/indexed/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_indexed_from_mapped_key(), exports);
    __exportStar(require_indexed_from_mapped_result(), exports);
    __exportStar(require_indexed_property_keys(), exports);
    __exportStar(require_indexed(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/iterator/iterator.js
var require_iterator = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/iterator/iterator.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Iterator = Iterator2;
    var type_1 = require_type2();
    var index_1 = require_symbols2();
    function Iterator2(items, options = {}) {
      return {
        ...options,
        [index_1.Kind]: "Iterator",
        type: "Iterator",
        items: (0, type_1.CloneType)(items)
      };
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/iterator/index.js
var require_iterator2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/iterator/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_iterator(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/object/object.js
var require_object = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/object/object.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Object = void 0;
    var type_1 = require_type2();
    var index_1 = require_symbols2();
    var kind_1 = require_kind();
    function _Object2(properties, options = {}) {
      const propertyKeys = globalThis.Object.getOwnPropertyNames(properties);
      const optionalKeys = propertyKeys.filter((key2) => (0, kind_1.IsOptional)(properties[key2]));
      const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));
      const clonedAdditionalProperties = (0, kind_1.IsSchema)(options.additionalProperties) ? { additionalProperties: (0, type_1.CloneType)(options.additionalProperties) } : {};
      const clonedProperties = {};
      for (const key2 of propertyKeys)
        clonedProperties[key2] = (0, type_1.CloneType)(properties[key2]);
      return requiredKeys.length > 0 ? { ...options, ...clonedAdditionalProperties, [index_1.Kind]: "Object", type: "object", properties: clonedProperties, required: requiredKeys } : { ...options, ...clonedAdditionalProperties, [index_1.Kind]: "Object", type: "object", properties: clonedProperties };
    }
    exports.Object = _Object2;
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/object/index.js
var require_object2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/object/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_object(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/promise/promise.js
var require_promise = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/promise/promise.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Promise = Promise3;
    var type_1 = require_type2();
    var index_1 = require_symbols2();
    function Promise3(item, options = {}) {
      return {
        ...options,
        [index_1.Kind]: "Promise",
        type: "Promise",
        item: (0, type_1.CloneType)(item)
      };
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/promise/index.js
var require_promise2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/promise/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_promise(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/readonly/readonly.js
var require_readonly = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/readonly/readonly.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Readonly = Readonly2;
    var index_1 = require_symbols2();
    var type_1 = require_type2();
    var index_2 = require_discard2();
    var readonly_from_mapped_result_1 = require_readonly_from_mapped_result();
    var kind_1 = require_kind();
    function RemoveReadonly2(schema) {
      return (0, index_2.Discard)((0, type_1.CloneType)(schema), [index_1.ReadonlyKind]);
    }
    function AddReadonly2(schema) {
      return { ...(0, type_1.CloneType)(schema), [index_1.ReadonlyKind]: "Readonly" };
    }
    function ReadonlyWithFlag2(schema, F2) {
      return F2 === false ? RemoveReadonly2(schema) : AddReadonly2(schema);
    }
    function Readonly2(schema, enable) {
      const F2 = enable ?? true;
      return (0, kind_1.IsMappedResult)(schema) ? (0, readonly_from_mapped_result_1.ReadonlyFromMappedResult)(schema, F2) : ReadonlyWithFlag2(schema, F2);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/readonly/readonly-from-mapped-result.js
var require_readonly_from_mapped_result = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/readonly/readonly-from-mapped-result.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReadonlyFromMappedResult = ReadonlyFromMappedResult2;
    var index_1 = require_mapped2();
    var readonly_1 = require_readonly();
    function FromProperties20(K2, F2) {
      const Acc = {};
      for (const K22 of globalThis.Object.getOwnPropertyNames(K2))
        Acc[K22] = (0, readonly_1.Readonly)(K2[K22], F2);
      return Acc;
    }
    function FromMappedResult13(R2, F2) {
      return FromProperties20(R2.properties, F2);
    }
    function ReadonlyFromMappedResult2(R2, F2) {
      const P2 = FromMappedResult13(R2, F2);
      return (0, index_1.MappedResult)(P2);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/readonly/index.js
var require_readonly2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/readonly/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_readonly_from_mapped_result(), exports);
    __exportStar(require_readonly(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/tuple/tuple.js
var require_tuple = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/tuple/tuple.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tuple = Tuple2;
    var type_1 = require_type2();
    var index_1 = require_symbols2();
    function Tuple2(items, options = {}) {
      const [additionalItems, minItems, maxItems] = [false, items.length, items.length];
      return items.length > 0 ? { ...options, [index_1.Kind]: "Tuple", type: "array", items: (0, type_1.CloneRest)(items), additionalItems, minItems, maxItems } : { ...options, [index_1.Kind]: "Tuple", type: "array", minItems, maxItems };
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/tuple/index.js
var require_tuple2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/tuple/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_tuple(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/sets/set.js
var require_set = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/sets/set.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SetIncludes = SetIncludes2;
    exports.SetIsSubset = SetIsSubset;
    exports.SetDistinct = SetDistinct2;
    exports.SetIntersect = SetIntersect2;
    exports.SetUnion = SetUnion;
    exports.SetComplement = SetComplement;
    exports.SetIntersectMany = SetIntersectMany2;
    exports.SetUnionMany = SetUnionMany2;
    function SetIncludes2(T2, S2) {
      return T2.includes(S2);
    }
    function SetIsSubset(T2, S2) {
      return T2.every((L2) => SetIncludes2(S2, L2));
    }
    function SetDistinct2(T2) {
      return [...new Set(T2)];
    }
    function SetIntersect2(T2, S2) {
      return T2.filter((L2) => S2.includes(L2));
    }
    function SetUnion(T2, S2) {
      return [...T2, ...S2];
    }
    function SetComplement(T2, S2) {
      return T2.filter((L2) => !S2.includes(L2));
    }
    function SetIntersectManyResolve2(T2, Init) {
      return T2.reduce((Acc, L2) => {
        return SetIntersect2(Acc, L2);
      }, Init);
    }
    function SetIntersectMany2(T2) {
      return T2.length === 1 ? T2[0] : T2.length > 1 ? SetIntersectManyResolve2(T2.slice(1), T2[0]) : [];
    }
    function SetUnionMany2(T2) {
      const Acc = [];
      for (const L2 of T2)
        Acc.push(...L2);
      return Acc;
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/sets/index.js
var require_sets = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/sets/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_set(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/mapped/mapped.js
var require_mapped = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/mapped/mapped.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MappedFunctionReturnType = MappedFunctionReturnType2;
    exports.Mapped = Mapped2;
    var index_1 = require_symbols2();
    var type_1 = require_type2();
    var index_2 = require_discard2();
    var index_3 = require_array2();
    var index_4 = require_async_iterator2();
    var index_5 = require_constructor2();
    var index_6 = require_function2();
    var index_7 = require_indexed2();
    var index_8 = require_intersect2();
    var index_9 = require_iterator2();
    var index_10 = require_literal2();
    var index_11 = require_object2();
    var index_12 = require_optional2();
    var index_13 = require_promise2();
    var index_14 = require_readonly2();
    var index_15 = require_tuple2();
    var index_16 = require_union2();
    var index_17 = require_sets();
    var mapped_result_1 = require_mapped_result();
    var kind_1 = require_kind();
    function FromMappedResult13(K2, P2) {
      return K2 in P2 ? FromSchemaType2(K2, P2[K2]) : (0, mapped_result_1.MappedResult)(P2);
    }
    function MappedKeyToKnownMappedResultProperties2(K2) {
      return { [K2]: (0, index_10.Literal)(K2) };
    }
    function MappedKeyToUnknownMappedResultProperties2(P2) {
      const Acc = {};
      for (const L2 of P2)
        Acc[L2] = (0, index_10.Literal)(L2);
      return Acc;
    }
    function MappedKeyToMappedResultProperties2(K2, P2) {
      return (0, index_17.SetIncludes)(P2, K2) ? MappedKeyToKnownMappedResultProperties2(K2) : MappedKeyToUnknownMappedResultProperties2(P2);
    }
    function FromMappedKey5(K2, P2) {
      const R2 = MappedKeyToMappedResultProperties2(K2, P2);
      return FromMappedResult13(K2, R2);
    }
    function FromRest9(K2, T2) {
      return T2.map((L2) => FromSchemaType2(K2, L2));
    }
    function FromProperties20(K2, T2) {
      const Acc = {};
      for (const K22 of globalThis.Object.getOwnPropertyNames(T2))
        Acc[K22] = FromSchemaType2(K2, T2[K22]);
      return Acc;
    }
    function FromSchemaType2(K2, T2) {
      return (
        // unevaluated modifier types
        (0, kind_1.IsOptional)(T2) ? (0, index_12.Optional)(FromSchemaType2(K2, (0, index_2.Discard)(T2, [index_1.OptionalKind]))) : (0, kind_1.IsReadonly)(T2) ? (0, index_14.Readonly)(FromSchemaType2(K2, (0, index_2.Discard)(T2, [index_1.ReadonlyKind]))) : (
          // unevaluated mapped types
          (0, kind_1.IsMappedResult)(T2) ? FromMappedResult13(K2, T2.properties) : (0, kind_1.IsMappedKey)(T2) ? FromMappedKey5(K2, T2.keys) : (
            // unevaluated types
            (0, kind_1.IsConstructor)(T2) ? (0, index_5.Constructor)(FromRest9(K2, T2.parameters), FromSchemaType2(K2, T2.returns)) : (0, kind_1.IsFunction)(T2) ? (0, index_6.Function)(FromRest9(K2, T2.parameters), FromSchemaType2(K2, T2.returns)) : (0, kind_1.IsAsyncIterator)(T2) ? (0, index_4.AsyncIterator)(FromSchemaType2(K2, T2.items)) : (0, kind_1.IsIterator)(T2) ? (0, index_9.Iterator)(FromSchemaType2(K2, T2.items)) : (0, kind_1.IsIntersect)(T2) ? (0, index_8.Intersect)(FromRest9(K2, T2.allOf)) : (0, kind_1.IsUnion)(T2) ? (0, index_16.Union)(FromRest9(K2, T2.anyOf)) : (0, kind_1.IsTuple)(T2) ? (0, index_15.Tuple)(FromRest9(K2, T2.items ?? [])) : (0, kind_1.IsObject)(T2) ? (0, index_11.Object)(FromProperties20(K2, T2.properties)) : (0, kind_1.IsArray)(T2) ? (0, index_3.Array)(FromSchemaType2(K2, T2.items)) : (0, kind_1.IsPromise)(T2) ? (0, index_13.Promise)(FromSchemaType2(K2, T2.item)) : T2
          )
        )
      );
    }
    function MappedFunctionReturnType2(K2, T2) {
      const Acc = {};
      for (const L2 of K2)
        Acc[L2] = FromSchemaType2(L2, T2);
      return Acc;
    }
    function Mapped2(key2, map9, options = {}) {
      const K2 = (0, kind_1.IsSchema)(key2) ? (0, index_7.IndexPropertyKeys)(key2) : key2;
      const RT = map9({ [index_1.Kind]: "MappedKey", keys: K2 });
      const R2 = MappedFunctionReturnType2(K2, RT);
      return (0, type_1.CloneType)((0, index_11.Object)(R2), options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/mapped/index.js
var require_mapped2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/mapped/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_mapped_key(), exports);
    __exportStar(require_mapped_result(), exports);
    __exportStar(require_mapped(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/keyof/keyof-property-keys.js
var require_keyof_property_keys = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/keyof/keyof-property-keys.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KeyOfPropertyKeys = KeyOfPropertyKeys2;
    exports.KeyOfPattern = KeyOfPattern2;
    var index_1 = require_sets();
    var kind_1 = require_kind();
    function FromRest9(T2) {
      const Acc = [];
      for (const L2 of T2)
        Acc.push(KeyOfPropertyKeys2(L2));
      return Acc;
    }
    function FromIntersect18(T2) {
      const C2 = FromRest9(T2);
      const R2 = (0, index_1.SetUnionMany)(C2);
      return R2;
    }
    function FromUnion20(T2) {
      const C2 = FromRest9(T2);
      const R2 = (0, index_1.SetIntersectMany)(C2);
      return R2;
    }
    function FromTuple15(T2) {
      return T2.map((_, I2) => I2.toString());
    }
    function FromArray16(_) {
      return ["[number]"];
    }
    function FromProperties20(T2) {
      return globalThis.Object.getOwnPropertyNames(T2);
    }
    function FromPatternProperties2(patternProperties) {
      if (!includePatternProperties2)
        return [];
      const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);
      return patternPropertyKeys.map((key2) => {
        return key2[0] === "^" && key2[key2.length - 1] === "$" ? key2.slice(1, key2.length - 1) : key2;
      });
    }
    function KeyOfPropertyKeys2(T2) {
      return (0, kind_1.IsIntersect)(T2) ? FromIntersect18(T2.allOf) : (0, kind_1.IsUnion)(T2) ? FromUnion20(T2.anyOf) : (0, kind_1.IsTuple)(T2) ? FromTuple15(T2.items ?? []) : (0, kind_1.IsArray)(T2) ? FromArray16(T2.items) : (0, kind_1.IsObject)(T2) ? FromProperties20(T2.properties) : (0, kind_1.IsRecord)(T2) ? FromPatternProperties2(T2.patternProperties) : [];
    }
    var includePatternProperties2 = false;
    function KeyOfPattern2(schema) {
      includePatternProperties2 = true;
      const keys3 = KeyOfPropertyKeys2(schema);
      includePatternProperties2 = false;
      const pattern = keys3.map((key2) => `(${key2})`);
      return `^(${pattern.join("|")})$`;
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/keyof/keyof.js
var require_keyof = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/keyof/keyof.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KeyOfPropertyKeysToRest = KeyOfPropertyKeysToRest2;
    exports.KeyOf = KeyOf2;
    var index_1 = require_literal2();
    var index_2 = require_number2();
    var keyof_property_keys_1 = require_keyof_property_keys();
    var index_3 = require_union2();
    var type_1 = require_type2();
    var keyof_from_mapped_result_1 = require_keyof_from_mapped_result();
    var kind_1 = require_kind();
    function KeyOfPropertyKeysToRest2(T2) {
      return T2.map((L2) => L2 === "[number]" ? (0, index_2.Number)() : (0, index_1.Literal)(L2));
    }
    function KeyOf2(T2, options = {}) {
      if ((0, kind_1.IsMappedResult)(T2)) {
        return (0, keyof_from_mapped_result_1.KeyOfFromMappedResult)(T2, options);
      } else {
        const K2 = (0, keyof_property_keys_1.KeyOfPropertyKeys)(T2);
        const S2 = KeyOfPropertyKeysToRest2(K2);
        const U2 = (0, index_3.UnionEvaluated)(S2);
        return (0, type_1.CloneType)(U2, options);
      }
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/keyof/keyof-from-mapped-result.js
var require_keyof_from_mapped_result = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/keyof/keyof-from-mapped-result.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KeyOfFromMappedResult = KeyOfFromMappedResult2;
    var index_1 = require_mapped2();
    var keyof_1 = require_keyof();
    function FromProperties20(K2, options) {
      const Acc = {};
      for (const K22 of globalThis.Object.getOwnPropertyNames(K2))
        Acc[K22] = (0, keyof_1.KeyOf)(K2[K22], options);
      return Acc;
    }
    function FromMappedResult13(R2, options) {
      return FromProperties20(R2.properties, options);
    }
    function KeyOfFromMappedResult2(R2, options) {
      const P2 = FromMappedResult13(R2, options);
      return (0, index_1.MappedResult)(P2);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/keyof/keyof-property-entries.js
var require_keyof_property_entries = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/keyof/keyof-property-entries.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KeyOfPropertyEntries = KeyOfPropertyEntries2;
    var indexed_1 = require_indexed();
    var keyof_property_keys_1 = require_keyof_property_keys();
    function KeyOfPropertyEntries2(schema) {
      const keys3 = (0, keyof_property_keys_1.KeyOfPropertyKeys)(schema);
      const schemas = (0, indexed_1.IndexFromPropertyKeys)(schema, keys3);
      return keys3.map((_, index3) => [keys3[index3], schemas[index3]]);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/keyof/index.js
var require_keyof2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/keyof/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_keyof_from_mapped_result(), exports);
    __exportStar(require_keyof_property_entries(), exports);
    __exportStar(require_keyof_property_keys(), exports);
    __exportStar(require_keyof(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extends/extends-undefined.js
var require_extends_undefined = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/extends/extends-undefined.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExtendsUndefinedCheck = ExtendsUndefinedCheck2;
    var index_1 = require_symbols2();
    function Intersect3(schema) {
      return schema.allOf.every((schema2) => ExtendsUndefinedCheck2(schema2));
    }
    function Union3(schema) {
      return schema.anyOf.some((schema2) => ExtendsUndefinedCheck2(schema2));
    }
    function Not3(schema) {
      return !ExtendsUndefinedCheck2(schema.not);
    }
    function ExtendsUndefinedCheck2(schema) {
      return schema[index_1.Kind] === "Intersect" ? Intersect3(schema) : schema[index_1.Kind] === "Union" ? Union3(schema) : schema[index_1.Kind] === "Not" ? Not3(schema) : schema[index_1.Kind] === "Undefined" ? true : false;
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/errors/function.js
var require_function3 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/errors/function.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DefaultErrorFunction = DefaultErrorFunction2;
    exports.SetErrorFunction = SetErrorFunction;
    exports.GetErrorFunction = GetErrorFunction2;
    var index_1 = require_symbols2();
    var errors_1 = require_errors();
    function DefaultErrorFunction2(error3) {
      switch (error3.errorType) {
        case errors_1.ValueErrorType.ArrayContains:
          return "Expected array to contain at least one matching value";
        case errors_1.ValueErrorType.ArrayMaxContains:
          return `Expected array to contain no more than ${error3.schema.maxContains} matching values`;
        case errors_1.ValueErrorType.ArrayMinContains:
          return `Expected array to contain at least ${error3.schema.minContains} matching values`;
        case errors_1.ValueErrorType.ArrayMaxItems:
          return `Expected array length to be less or equal to ${error3.schema.maxItems}`;
        case errors_1.ValueErrorType.ArrayMinItems:
          return `Expected array length to be greater or equal to ${error3.schema.minItems}`;
        case errors_1.ValueErrorType.ArrayUniqueItems:
          return "Expected array elements to be unique";
        case errors_1.ValueErrorType.Array:
          return "Expected array";
        case errors_1.ValueErrorType.AsyncIterator:
          return "Expected AsyncIterator";
        case errors_1.ValueErrorType.BigIntExclusiveMaximum:
          return `Expected bigint to be less than ${error3.schema.exclusiveMaximum}`;
        case errors_1.ValueErrorType.BigIntExclusiveMinimum:
          return `Expected bigint to be greater than ${error3.schema.exclusiveMinimum}`;
        case errors_1.ValueErrorType.BigIntMaximum:
          return `Expected bigint to be less or equal to ${error3.schema.maximum}`;
        case errors_1.ValueErrorType.BigIntMinimum:
          return `Expected bigint to be greater or equal to ${error3.schema.minimum}`;
        case errors_1.ValueErrorType.BigIntMultipleOf:
          return `Expected bigint to be a multiple of ${error3.schema.multipleOf}`;
        case errors_1.ValueErrorType.BigInt:
          return "Expected bigint";
        case errors_1.ValueErrorType.Boolean:
          return "Expected boolean";
        case errors_1.ValueErrorType.DateExclusiveMinimumTimestamp:
          return `Expected Date timestamp to be greater than ${error3.schema.exclusiveMinimumTimestamp}`;
        case errors_1.ValueErrorType.DateExclusiveMaximumTimestamp:
          return `Expected Date timestamp to be less than ${error3.schema.exclusiveMaximumTimestamp}`;
        case errors_1.ValueErrorType.DateMinimumTimestamp:
          return `Expected Date timestamp to be greater or equal to ${error3.schema.minimumTimestamp}`;
        case errors_1.ValueErrorType.DateMaximumTimestamp:
          return `Expected Date timestamp to be less or equal to ${error3.schema.maximumTimestamp}`;
        case errors_1.ValueErrorType.DateMultipleOfTimestamp:
          return `Expected Date timestamp to be a multiple of ${error3.schema.multipleOfTimestamp}`;
        case errors_1.ValueErrorType.Date:
          return "Expected Date";
        case errors_1.ValueErrorType.Function:
          return "Expected function";
        case errors_1.ValueErrorType.IntegerExclusiveMaximum:
          return `Expected integer to be less than ${error3.schema.exclusiveMaximum}`;
        case errors_1.ValueErrorType.IntegerExclusiveMinimum:
          return `Expected integer to be greater than ${error3.schema.exclusiveMinimum}`;
        case errors_1.ValueErrorType.IntegerMaximum:
          return `Expected integer to be less or equal to ${error3.schema.maximum}`;
        case errors_1.ValueErrorType.IntegerMinimum:
          return `Expected integer to be greater or equal to ${error3.schema.minimum}`;
        case errors_1.ValueErrorType.IntegerMultipleOf:
          return `Expected integer to be a multiple of ${error3.schema.multipleOf}`;
        case errors_1.ValueErrorType.Integer:
          return "Expected integer";
        case errors_1.ValueErrorType.IntersectUnevaluatedProperties:
          return "Unexpected property";
        case errors_1.ValueErrorType.Intersect:
          return "Expected all values to match";
        case errors_1.ValueErrorType.Iterator:
          return "Expected Iterator";
        case errors_1.ValueErrorType.Literal:
          return `Expected ${typeof error3.schema.const === "string" ? `'${error3.schema.const}'` : error3.schema.const}`;
        case errors_1.ValueErrorType.Never:
          return "Never";
        case errors_1.ValueErrorType.Not:
          return "Value should not match";
        case errors_1.ValueErrorType.Null:
          return "Expected null";
        case errors_1.ValueErrorType.NumberExclusiveMaximum:
          return `Expected number to be less than ${error3.schema.exclusiveMaximum}`;
        case errors_1.ValueErrorType.NumberExclusiveMinimum:
          return `Expected number to be greater than ${error3.schema.exclusiveMinimum}`;
        case errors_1.ValueErrorType.NumberMaximum:
          return `Expected number to be less or equal to ${error3.schema.maximum}`;
        case errors_1.ValueErrorType.NumberMinimum:
          return `Expected number to be greater or equal to ${error3.schema.minimum}`;
        case errors_1.ValueErrorType.NumberMultipleOf:
          return `Expected number to be a multiple of ${error3.schema.multipleOf}`;
        case errors_1.ValueErrorType.Number:
          return "Expected number";
        case errors_1.ValueErrorType.Object:
          return "Expected object";
        case errors_1.ValueErrorType.ObjectAdditionalProperties:
          return "Unexpected property";
        case errors_1.ValueErrorType.ObjectMaxProperties:
          return `Expected object to have no more than ${error3.schema.maxProperties} properties`;
        case errors_1.ValueErrorType.ObjectMinProperties:
          return `Expected object to have at least ${error3.schema.minProperties} properties`;
        case errors_1.ValueErrorType.ObjectRequiredProperty:
          return "Required property";
        case errors_1.ValueErrorType.Promise:
          return "Expected Promise";
        case errors_1.ValueErrorType.RegExp:
          return "Expected string to match regular expression";
        case errors_1.ValueErrorType.StringFormatUnknown:
          return `Unknown format '${error3.schema.format}'`;
        case errors_1.ValueErrorType.StringFormat:
          return `Expected string to match '${error3.schema.format}' format`;
        case errors_1.ValueErrorType.StringMaxLength:
          return `Expected string length less or equal to ${error3.schema.maxLength}`;
        case errors_1.ValueErrorType.StringMinLength:
          return `Expected string length greater or equal to ${error3.schema.minLength}`;
        case errors_1.ValueErrorType.StringPattern:
          return `Expected string to match '${error3.schema.pattern}'`;
        case errors_1.ValueErrorType.String:
          return "Expected string";
        case errors_1.ValueErrorType.Symbol:
          return "Expected symbol";
        case errors_1.ValueErrorType.TupleLength:
          return `Expected tuple to have ${error3.schema.maxItems || 0} elements`;
        case errors_1.ValueErrorType.Tuple:
          return "Expected tuple";
        case errors_1.ValueErrorType.Uint8ArrayMaxByteLength:
          return `Expected byte length less or equal to ${error3.schema.maxByteLength}`;
        case errors_1.ValueErrorType.Uint8ArrayMinByteLength:
          return `Expected byte length greater or equal to ${error3.schema.minByteLength}`;
        case errors_1.ValueErrorType.Uint8Array:
          return "Expected Uint8Array";
        case errors_1.ValueErrorType.Undefined:
          return "Expected undefined";
        case errors_1.ValueErrorType.Union:
          return "Expected union value";
        case errors_1.ValueErrorType.Void:
          return "Expected void";
        case errors_1.ValueErrorType.Kind:
          return `Expected kind '${error3.schema[index_1.Kind]}'`;
        default:
          return "Unknown error type";
      }
    }
    var errorFunction2 = DefaultErrorFunction2;
    function SetErrorFunction(callback) {
      errorFunction2 = callback;
    }
    function GetErrorFunction2() {
      return errorFunction2;
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/deref/deref.js
var require_deref = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/value/deref/deref.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeDereferenceError = void 0;
    exports.Deref = Deref3;
    var index_1 = require_error2();
    var index_2 = require_symbols2();
    var TypeDereferenceError2 = class extends index_1.TypeBoxError {
      constructor(schema) {
        super(`Unable to dereference schema with $id '${schema.$id}'`);
        this.schema = schema;
      }
    };
    exports.TypeDereferenceError = TypeDereferenceError2;
    function Resolve2(schema, references) {
      const target = references.find((target2) => target2.$id === schema.$ref);
      if (target === void 0)
        throw new TypeDereferenceError2(schema);
      return Deref3(target, references);
    }
    function Deref3(schema, references) {
      return schema[index_2.Kind] === "This" || schema[index_2.Kind] === "Ref" ? Resolve2(schema, references) : schema;
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/deref/index.js
var require_deref2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/value/deref/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_deref(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/hash/hash.js
var require_hash = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/value/hash/hash.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueHashError = void 0;
    exports.Hash = Hash3;
    var index_1 = require_guard2();
    var index_2 = require_error2();
    var ValueHashError2 = class extends index_2.TypeBoxError {
      constructor(value) {
        super(`Unable to hash value`);
        this.value = value;
      }
    };
    exports.ValueHashError = ValueHashError2;
    var ByteMarker2;
    (function(ByteMarker3) {
      ByteMarker3[ByteMarker3["Undefined"] = 0] = "Undefined";
      ByteMarker3[ByteMarker3["Null"] = 1] = "Null";
      ByteMarker3[ByteMarker3["Boolean"] = 2] = "Boolean";
      ByteMarker3[ByteMarker3["Number"] = 3] = "Number";
      ByteMarker3[ByteMarker3["String"] = 4] = "String";
      ByteMarker3[ByteMarker3["Object"] = 5] = "Object";
      ByteMarker3[ByteMarker3["Array"] = 6] = "Array";
      ByteMarker3[ByteMarker3["Date"] = 7] = "Date";
      ByteMarker3[ByteMarker3["Uint8Array"] = 8] = "Uint8Array";
      ByteMarker3[ByteMarker3["Symbol"] = 9] = "Symbol";
      ByteMarker3[ByteMarker3["BigInt"] = 10] = "BigInt";
    })(ByteMarker2 || (ByteMarker2 = {}));
    var Accumulator2 = BigInt("14695981039346656037");
    var [Prime2, Size2] = [BigInt("1099511628211"), BigInt("2") ** BigInt("64")];
    var Bytes2 = Array.from({ length: 256 }).map((_, i2) => BigInt(i2));
    var F642 = new Float64Array(1);
    var F64In2 = new DataView(F642.buffer);
    var F64Out2 = new Uint8Array(F642.buffer);
    function* NumberToBytes2(value) {
      const byteCount = value === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value) + 1) / 8);
      for (let i2 = 0; i2 < byteCount; i2++) {
        yield value >> 8 * (byteCount - 1 - i2) & 255;
      }
    }
    function ArrayType7(value) {
      FNV1A642(ByteMarker2.Array);
      for (const item of value) {
        Visit17(item);
      }
    }
    function BooleanType2(value) {
      FNV1A642(ByteMarker2.Boolean);
      FNV1A642(value ? 1 : 0);
    }
    function BigIntType2(value) {
      FNV1A642(ByteMarker2.BigInt);
      F64In2.setBigInt64(0, value);
      for (const byte2 of F64Out2) {
        FNV1A642(byte2);
      }
    }
    function DateType5(value) {
      FNV1A642(ByteMarker2.Date);
      Visit17(value.getTime());
    }
    function NullType2(value) {
      FNV1A642(ByteMarker2.Null);
    }
    function NumberType2(value) {
      FNV1A642(ByteMarker2.Number);
      F64In2.setFloat64(0, value);
      for (const byte2 of F64Out2) {
        FNV1A642(byte2);
      }
    }
    function ObjectType7(value) {
      FNV1A642(ByteMarker2.Object);
      for (const key2 of globalThis.Object.getOwnPropertyNames(value).sort()) {
        Visit17(key2);
        Visit17(value[key2]);
      }
    }
    function StringType2(value) {
      FNV1A642(ByteMarker2.String);
      for (let i2 = 0; i2 < value.length; i2++) {
        for (const byte2 of NumberToBytes2(value.charCodeAt(i2))) {
          FNV1A642(byte2);
        }
      }
    }
    function SymbolType2(value) {
      FNV1A642(ByteMarker2.Symbol);
      Visit17(value.description);
    }
    function Uint8ArrayType3(value) {
      FNV1A642(ByteMarker2.Uint8Array);
      for (let i2 = 0; i2 < value.length; i2++) {
        FNV1A642(value[i2]);
      }
    }
    function UndefinedType2(value) {
      return FNV1A642(ByteMarker2.Undefined);
    }
    function Visit17(value) {
      if ((0, index_1.IsArray)(value))
        return ArrayType7(value);
      if ((0, index_1.IsBoolean)(value))
        return BooleanType2(value);
      if ((0, index_1.IsBigInt)(value))
        return BigIntType2(value);
      if ((0, index_1.IsDate)(value))
        return DateType5(value);
      if ((0, index_1.IsNull)(value))
        return NullType2(value);
      if ((0, index_1.IsNumber)(value))
        return NumberType2(value);
      if ((0, index_1.IsStandardObject)(value))
        return ObjectType7(value);
      if ((0, index_1.IsString)(value))
        return StringType2(value);
      if ((0, index_1.IsSymbol)(value))
        return SymbolType2(value);
      if ((0, index_1.IsUint8Array)(value))
        return Uint8ArrayType3(value);
      if ((0, index_1.IsUndefined)(value))
        return UndefinedType2(value);
      throw new ValueHashError2(value);
    }
    function FNV1A642(byte2) {
      Accumulator2 = Accumulator2 ^ Bytes2[byte2];
      Accumulator2 = Accumulator2 * Prime2 % Size2;
    }
    function Hash3(value) {
      Accumulator2 = BigInt("14695981039346656037");
      Visit17(value);
      return Accumulator2;
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/hash/index.js
var require_hash2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/value/hash/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_hash(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/errors/errors.js
var require_errors = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/errors/errors.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueErrorIterator = exports.ValueErrorsUnknownTypeError = exports.ValueErrorType = void 0;
    exports.Errors = Errors3;
    var index_1 = require_system2();
    var index_2 = require_keyof2();
    var index_3 = require_registry();
    var extends_undefined_1 = require_extends_undefined();
    var function_1 = require_function3();
    var index_4 = require_error2();
    var index_5 = require_deref2();
    var index_6 = require_hash2();
    var index_7 = require_symbols2();
    var index_8 = require_never2();
    var index_9 = require_guard2();
    var ValueErrorType2;
    (function(ValueErrorType3) {
      ValueErrorType3[ValueErrorType3["ArrayContains"] = 0] = "ArrayContains";
      ValueErrorType3[ValueErrorType3["ArrayMaxContains"] = 1] = "ArrayMaxContains";
      ValueErrorType3[ValueErrorType3["ArrayMaxItems"] = 2] = "ArrayMaxItems";
      ValueErrorType3[ValueErrorType3["ArrayMinContains"] = 3] = "ArrayMinContains";
      ValueErrorType3[ValueErrorType3["ArrayMinItems"] = 4] = "ArrayMinItems";
      ValueErrorType3[ValueErrorType3["ArrayUniqueItems"] = 5] = "ArrayUniqueItems";
      ValueErrorType3[ValueErrorType3["Array"] = 6] = "Array";
      ValueErrorType3[ValueErrorType3["AsyncIterator"] = 7] = "AsyncIterator";
      ValueErrorType3[ValueErrorType3["BigIntExclusiveMaximum"] = 8] = "BigIntExclusiveMaximum";
      ValueErrorType3[ValueErrorType3["BigIntExclusiveMinimum"] = 9] = "BigIntExclusiveMinimum";
      ValueErrorType3[ValueErrorType3["BigIntMaximum"] = 10] = "BigIntMaximum";
      ValueErrorType3[ValueErrorType3["BigIntMinimum"] = 11] = "BigIntMinimum";
      ValueErrorType3[ValueErrorType3["BigIntMultipleOf"] = 12] = "BigIntMultipleOf";
      ValueErrorType3[ValueErrorType3["BigInt"] = 13] = "BigInt";
      ValueErrorType3[ValueErrorType3["Boolean"] = 14] = "Boolean";
      ValueErrorType3[ValueErrorType3["DateExclusiveMaximumTimestamp"] = 15] = "DateExclusiveMaximumTimestamp";
      ValueErrorType3[ValueErrorType3["DateExclusiveMinimumTimestamp"] = 16] = "DateExclusiveMinimumTimestamp";
      ValueErrorType3[ValueErrorType3["DateMaximumTimestamp"] = 17] = "DateMaximumTimestamp";
      ValueErrorType3[ValueErrorType3["DateMinimumTimestamp"] = 18] = "DateMinimumTimestamp";
      ValueErrorType3[ValueErrorType3["DateMultipleOfTimestamp"] = 19] = "DateMultipleOfTimestamp";
      ValueErrorType3[ValueErrorType3["Date"] = 20] = "Date";
      ValueErrorType3[ValueErrorType3["Function"] = 21] = "Function";
      ValueErrorType3[ValueErrorType3["IntegerExclusiveMaximum"] = 22] = "IntegerExclusiveMaximum";
      ValueErrorType3[ValueErrorType3["IntegerExclusiveMinimum"] = 23] = "IntegerExclusiveMinimum";
      ValueErrorType3[ValueErrorType3["IntegerMaximum"] = 24] = "IntegerMaximum";
      ValueErrorType3[ValueErrorType3["IntegerMinimum"] = 25] = "IntegerMinimum";
      ValueErrorType3[ValueErrorType3["IntegerMultipleOf"] = 26] = "IntegerMultipleOf";
      ValueErrorType3[ValueErrorType3["Integer"] = 27] = "Integer";
      ValueErrorType3[ValueErrorType3["IntersectUnevaluatedProperties"] = 28] = "IntersectUnevaluatedProperties";
      ValueErrorType3[ValueErrorType3["Intersect"] = 29] = "Intersect";
      ValueErrorType3[ValueErrorType3["Iterator"] = 30] = "Iterator";
      ValueErrorType3[ValueErrorType3["Kind"] = 31] = "Kind";
      ValueErrorType3[ValueErrorType3["Literal"] = 32] = "Literal";
      ValueErrorType3[ValueErrorType3["Never"] = 33] = "Never";
      ValueErrorType3[ValueErrorType3["Not"] = 34] = "Not";
      ValueErrorType3[ValueErrorType3["Null"] = 35] = "Null";
      ValueErrorType3[ValueErrorType3["NumberExclusiveMaximum"] = 36] = "NumberExclusiveMaximum";
      ValueErrorType3[ValueErrorType3["NumberExclusiveMinimum"] = 37] = "NumberExclusiveMinimum";
      ValueErrorType3[ValueErrorType3["NumberMaximum"] = 38] = "NumberMaximum";
      ValueErrorType3[ValueErrorType3["NumberMinimum"] = 39] = "NumberMinimum";
      ValueErrorType3[ValueErrorType3["NumberMultipleOf"] = 40] = "NumberMultipleOf";
      ValueErrorType3[ValueErrorType3["Number"] = 41] = "Number";
      ValueErrorType3[ValueErrorType3["ObjectAdditionalProperties"] = 42] = "ObjectAdditionalProperties";
      ValueErrorType3[ValueErrorType3["ObjectMaxProperties"] = 43] = "ObjectMaxProperties";
      ValueErrorType3[ValueErrorType3["ObjectMinProperties"] = 44] = "ObjectMinProperties";
      ValueErrorType3[ValueErrorType3["ObjectRequiredProperty"] = 45] = "ObjectRequiredProperty";
      ValueErrorType3[ValueErrorType3["Object"] = 46] = "Object";
      ValueErrorType3[ValueErrorType3["Promise"] = 47] = "Promise";
      ValueErrorType3[ValueErrorType3["RegExp"] = 48] = "RegExp";
      ValueErrorType3[ValueErrorType3["StringFormatUnknown"] = 49] = "StringFormatUnknown";
      ValueErrorType3[ValueErrorType3["StringFormat"] = 50] = "StringFormat";
      ValueErrorType3[ValueErrorType3["StringMaxLength"] = 51] = "StringMaxLength";
      ValueErrorType3[ValueErrorType3["StringMinLength"] = 52] = "StringMinLength";
      ValueErrorType3[ValueErrorType3["StringPattern"] = 53] = "StringPattern";
      ValueErrorType3[ValueErrorType3["String"] = 54] = "String";
      ValueErrorType3[ValueErrorType3["Symbol"] = 55] = "Symbol";
      ValueErrorType3[ValueErrorType3["TupleLength"] = 56] = "TupleLength";
      ValueErrorType3[ValueErrorType3["Tuple"] = 57] = "Tuple";
      ValueErrorType3[ValueErrorType3["Uint8ArrayMaxByteLength"] = 58] = "Uint8ArrayMaxByteLength";
      ValueErrorType3[ValueErrorType3["Uint8ArrayMinByteLength"] = 59] = "Uint8ArrayMinByteLength";
      ValueErrorType3[ValueErrorType3["Uint8Array"] = 60] = "Uint8Array";
      ValueErrorType3[ValueErrorType3["Undefined"] = 61] = "Undefined";
      ValueErrorType3[ValueErrorType3["Union"] = 62] = "Union";
      ValueErrorType3[ValueErrorType3["Void"] = 63] = "Void";
    })(ValueErrorType2 || (exports.ValueErrorType = ValueErrorType2 = {}));
    var ValueErrorsUnknownTypeError2 = class extends index_4.TypeBoxError {
      constructor(schema) {
        super("Unknown type");
        this.schema = schema;
      }
    };
    exports.ValueErrorsUnknownTypeError = ValueErrorsUnknownTypeError2;
    function EscapeKey2(key2) {
      return key2.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    function IsDefined3(value) {
      return value !== void 0;
    }
    var ValueErrorIterator2 = class {
      constructor(iterator) {
        this.iterator = iterator;
      }
      [Symbol.iterator]() {
        return this.iterator;
      }
      /** Returns the first value error or undefined if no errors */
      First() {
        const next = this.iterator.next();
        return next.done ? void 0 : next.value;
      }
    };
    exports.ValueErrorIterator = ValueErrorIterator2;
    function Create4(errorType, schema, path2, value) {
      return { type: errorType, schema, path: path2, value, message: (0, function_1.GetErrorFunction)()({ errorType, path: path2, schema, value }) };
    }
    function* FromAny5(schema, references, path2, value) {
    }
    function* FromArray16(schema, references, path2, value) {
      if (!(0, index_9.IsArray)(value)) {
        return yield Create4(ValueErrorType2.Array, schema, path2, value);
      }
      if (IsDefined3(schema.minItems) && !(value.length >= schema.minItems)) {
        yield Create4(ValueErrorType2.ArrayMinItems, schema, path2, value);
      }
      if (IsDefined3(schema.maxItems) && !(value.length <= schema.maxItems)) {
        yield Create4(ValueErrorType2.ArrayMaxItems, schema, path2, value);
      }
      for (let i2 = 0; i2 < value.length; i2++) {
        yield* Visit17(schema.items, references, `${path2}/${i2}`, value[i2]);
      }
      if (schema.uniqueItems === true && !function() {
        const set = /* @__PURE__ */ new Set();
        for (const element2 of value) {
          const hashed = (0, index_6.Hash)(element2);
          if (set.has(hashed)) {
            return false;
          } else {
            set.add(hashed);
          }
        }
        return true;
      }()) {
        yield Create4(ValueErrorType2.ArrayUniqueItems, schema, path2, value);
      }
      if (!(IsDefined3(schema.contains) || IsDefined3(schema.minContains) || IsDefined3(schema.maxContains))) {
        return;
      }
      const containsSchema = IsDefined3(schema.contains) ? schema.contains : (0, index_8.Never)();
      const containsCount = value.reduce((acc, value2, index3) => Visit17(containsSchema, references, `${path2}${index3}`, value2).next().done === true ? acc + 1 : acc, 0);
      if (containsCount === 0) {
        yield Create4(ValueErrorType2.ArrayContains, schema, path2, value);
      }
      if ((0, index_9.IsNumber)(schema.minContains) && containsCount < schema.minContains) {
        yield Create4(ValueErrorType2.ArrayMinContains, schema, path2, value);
      }
      if ((0, index_9.IsNumber)(schema.maxContains) && containsCount > schema.maxContains) {
        yield Create4(ValueErrorType2.ArrayMaxContains, schema, path2, value);
      }
    }
    function* FromAsyncIterator7(schema, references, path2, value) {
      if (!(0, index_9.IsAsyncIterator)(value))
        yield Create4(ValueErrorType2.AsyncIterator, schema, path2, value);
    }
    function* FromBigInt6(schema, references, path2, value) {
      if (!(0, index_9.IsBigInt)(value))
        return yield Create4(ValueErrorType2.BigInt, schema, path2, value);
      if (IsDefined3(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
        yield Create4(ValueErrorType2.BigIntExclusiveMaximum, schema, path2, value);
      }
      if (IsDefined3(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
        yield Create4(ValueErrorType2.BigIntExclusiveMinimum, schema, path2, value);
      }
      if (IsDefined3(schema.maximum) && !(value <= schema.maximum)) {
        yield Create4(ValueErrorType2.BigIntMaximum, schema, path2, value);
      }
      if (IsDefined3(schema.minimum) && !(value >= schema.minimum)) {
        yield Create4(ValueErrorType2.BigIntMinimum, schema, path2, value);
      }
      if (IsDefined3(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
        yield Create4(ValueErrorType2.BigIntMultipleOf, schema, path2, value);
      }
    }
    function* FromBoolean6(schema, references, path2, value) {
      if (!(0, index_9.IsBoolean)(value))
        yield Create4(ValueErrorType2.Boolean, schema, path2, value);
    }
    function* FromConstructor8(schema, references, path2, value) {
      yield* Visit17(schema.returns, references, path2, value.prototype);
    }
    function* FromDate6(schema, references, path2, value) {
      if (!(0, index_9.IsDate)(value))
        return yield Create4(ValueErrorType2.Date, schema, path2, value);
      if (IsDefined3(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
        yield Create4(ValueErrorType2.DateExclusiveMaximumTimestamp, schema, path2, value);
      }
      if (IsDefined3(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
        yield Create4(ValueErrorType2.DateExclusiveMinimumTimestamp, schema, path2, value);
      }
      if (IsDefined3(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
        yield Create4(ValueErrorType2.DateMaximumTimestamp, schema, path2, value);
      }
      if (IsDefined3(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
        yield Create4(ValueErrorType2.DateMinimumTimestamp, schema, path2, value);
      }
      if (IsDefined3(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
        yield Create4(ValueErrorType2.DateMultipleOfTimestamp, schema, path2, value);
      }
    }
    function* FromFunction7(schema, references, path2, value) {
      if (!(0, index_9.IsFunction)(value))
        yield Create4(ValueErrorType2.Function, schema, path2, value);
    }
    function* FromInteger6(schema, references, path2, value) {
      if (!(0, index_9.IsInteger)(value))
        return yield Create4(ValueErrorType2.Integer, schema, path2, value);
      if (IsDefined3(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
        yield Create4(ValueErrorType2.IntegerExclusiveMaximum, schema, path2, value);
      }
      if (IsDefined3(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
        yield Create4(ValueErrorType2.IntegerExclusiveMinimum, schema, path2, value);
      }
      if (IsDefined3(schema.maximum) && !(value <= schema.maximum)) {
        yield Create4(ValueErrorType2.IntegerMaximum, schema, path2, value);
      }
      if (IsDefined3(schema.minimum) && !(value >= schema.minimum)) {
        yield Create4(ValueErrorType2.IntegerMinimum, schema, path2, value);
      }
      if (IsDefined3(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
        yield Create4(ValueErrorType2.IntegerMultipleOf, schema, path2, value);
      }
    }
    function* FromIntersect18(schema, references, path2, value) {
      for (const inner of schema.allOf) {
        const next = Visit17(inner, references, path2, value).next();
        if (!next.done) {
          yield Create4(ValueErrorType2.Intersect, schema, path2, value);
          yield next.value;
        }
      }
      if (schema.unevaluatedProperties === false) {
        const keyCheck = new RegExp((0, index_2.KeyOfPattern)(schema));
        for (const valueKey of Object.getOwnPropertyNames(value)) {
          if (!keyCheck.test(valueKey)) {
            yield Create4(ValueErrorType2.IntersectUnevaluatedProperties, schema, `${path2}/${valueKey}`, value);
          }
        }
      }
      if (typeof schema.unevaluatedProperties === "object") {
        const keyCheck = new RegExp((0, index_2.KeyOfPattern)(schema));
        for (const valueKey of Object.getOwnPropertyNames(value)) {
          if (!keyCheck.test(valueKey)) {
            const next = Visit17(schema.unevaluatedProperties, references, `${path2}/${valueKey}`, value[valueKey]).next();
            if (!next.done)
              yield next.value;
          }
        }
      }
    }
    function* FromIterator7(schema, references, path2, value) {
      if (!(0, index_9.IsIterator)(value))
        yield Create4(ValueErrorType2.Iterator, schema, path2, value);
    }
    function* FromLiteral7(schema, references, path2, value) {
      if (!(value === schema.const))
        yield Create4(ValueErrorType2.Literal, schema, path2, value);
    }
    function* FromNever6(schema, references, path2, value) {
      yield Create4(ValueErrorType2.Never, schema, path2, value);
    }
    function* FromNot8(schema, references, path2, value) {
      if (Visit17(schema.not, references, path2, value).next().done === true)
        yield Create4(ValueErrorType2.Not, schema, path2, value);
    }
    function* FromNull6(schema, references, path2, value) {
      if (!(0, index_9.IsNull)(value))
        yield Create4(ValueErrorType2.Null, schema, path2, value);
    }
    function* FromNumber6(schema, references, path2, value) {
      if (!index_1.TypeSystemPolicy.IsNumberLike(value))
        return yield Create4(ValueErrorType2.Number, schema, path2, value);
      if (IsDefined3(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
        yield Create4(ValueErrorType2.NumberExclusiveMaximum, schema, path2, value);
      }
      if (IsDefined3(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
        yield Create4(ValueErrorType2.NumberExclusiveMinimum, schema, path2, value);
      }
      if (IsDefined3(schema.maximum) && !(value <= schema.maximum)) {
        yield Create4(ValueErrorType2.NumberMaximum, schema, path2, value);
      }
      if (IsDefined3(schema.minimum) && !(value >= schema.minimum)) {
        yield Create4(ValueErrorType2.NumberMinimum, schema, path2, value);
      }
      if (IsDefined3(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
        yield Create4(ValueErrorType2.NumberMultipleOf, schema, path2, value);
      }
    }
    function* FromObject13(schema, references, path2, value) {
      if (!index_1.TypeSystemPolicy.IsObjectLike(value))
        return yield Create4(ValueErrorType2.Object, schema, path2, value);
      if (IsDefined3(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
        yield Create4(ValueErrorType2.ObjectMinProperties, schema, path2, value);
      }
      if (IsDefined3(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
        yield Create4(ValueErrorType2.ObjectMaxProperties, schema, path2, value);
      }
      const requiredKeys = Array.isArray(schema.required) ? schema.required : [];
      const knownKeys = Object.getOwnPropertyNames(schema.properties);
      const unknownKeys = Object.getOwnPropertyNames(value);
      for (const requiredKey of requiredKeys) {
        if (unknownKeys.includes(requiredKey))
          continue;
        yield Create4(ValueErrorType2.ObjectRequiredProperty, schema.properties[requiredKey], `${path2}/${EscapeKey2(requiredKey)}`, void 0);
      }
      if (schema.additionalProperties === false) {
        for (const valueKey of unknownKeys) {
          if (!knownKeys.includes(valueKey)) {
            yield Create4(ValueErrorType2.ObjectAdditionalProperties, schema, `${path2}/${EscapeKey2(valueKey)}`, value[valueKey]);
          }
        }
      }
      if (typeof schema.additionalProperties === "object") {
        for (const valueKey of unknownKeys) {
          if (knownKeys.includes(valueKey))
            continue;
          yield* Visit17(schema.additionalProperties, references, `${path2}/${EscapeKey2(valueKey)}`, value[valueKey]);
        }
      }
      for (const knownKey of knownKeys) {
        const property = schema.properties[knownKey];
        if (schema.required && schema.required.includes(knownKey)) {
          yield* Visit17(property, references, `${path2}/${EscapeKey2(knownKey)}`, value[knownKey]);
          if ((0, extends_undefined_1.ExtendsUndefinedCheck)(schema) && !(knownKey in value)) {
            yield Create4(ValueErrorType2.ObjectRequiredProperty, property, `${path2}/${EscapeKey2(knownKey)}`, void 0);
          }
        } else {
          if (index_1.TypeSystemPolicy.IsExactOptionalProperty(value, knownKey)) {
            yield* Visit17(property, references, `${path2}/${EscapeKey2(knownKey)}`, value[knownKey]);
          }
        }
      }
    }
    function* FromPromise8(schema, references, path2, value) {
      if (!(0, index_9.IsPromise)(value))
        yield Create4(ValueErrorType2.Promise, schema, path2, value);
    }
    function* FromRecord12(schema, references, path2, value) {
      if (!index_1.TypeSystemPolicy.IsRecordLike(value))
        return yield Create4(ValueErrorType2.Object, schema, path2, value);
      if (IsDefined3(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
        yield Create4(ValueErrorType2.ObjectMinProperties, schema, path2, value);
      }
      if (IsDefined3(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
        yield Create4(ValueErrorType2.ObjectMaxProperties, schema, path2, value);
      }
      const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
      const regex2 = new RegExp(patternKey);
      for (const [propertyKey, propertyValue] of Object.entries(value)) {
        if (regex2.test(propertyKey))
          yield* Visit17(patternSchema, references, `${path2}/${EscapeKey2(propertyKey)}`, propertyValue);
      }
      if (typeof schema.additionalProperties === "object") {
        for (const [propertyKey, propertyValue] of Object.entries(value)) {
          if (!regex2.test(propertyKey))
            yield* Visit17(schema.additionalProperties, references, `${path2}/${EscapeKey2(propertyKey)}`, propertyValue);
        }
      }
      if (schema.additionalProperties === false) {
        for (const [propertyKey, propertyValue] of Object.entries(value)) {
          if (regex2.test(propertyKey))
            continue;
          return yield Create4(ValueErrorType2.ObjectAdditionalProperties, schema, `${path2}/${EscapeKey2(propertyKey)}`, propertyValue);
        }
      }
    }
    function* FromRef12(schema, references, path2, value) {
      yield* Visit17((0, index_5.Deref)(schema, references), references, path2, value);
    }
    function* FromRegExp5(schema, references, path2, value) {
      if (!(0, index_9.IsString)(value))
        return yield Create4(ValueErrorType2.String, schema, path2, value);
      if (IsDefined3(schema.minLength) && !(value.length >= schema.minLength)) {
        yield Create4(ValueErrorType2.StringMinLength, schema, path2, value);
      }
      if (IsDefined3(schema.maxLength) && !(value.length <= schema.maxLength)) {
        yield Create4(ValueErrorType2.StringMaxLength, schema, path2, value);
      }
      const regex2 = new RegExp(schema.source, schema.flags);
      if (!regex2.test(value)) {
        return yield Create4(ValueErrorType2.RegExp, schema, path2, value);
      }
    }
    function* FromString6(schema, references, path2, value) {
      if (!(0, index_9.IsString)(value))
        return yield Create4(ValueErrorType2.String, schema, path2, value);
      if (IsDefined3(schema.minLength) && !(value.length >= schema.minLength)) {
        yield Create4(ValueErrorType2.StringMinLength, schema, path2, value);
      }
      if (IsDefined3(schema.maxLength) && !(value.length <= schema.maxLength)) {
        yield Create4(ValueErrorType2.StringMaxLength, schema, path2, value);
      }
      if ((0, index_9.IsString)(schema.pattern)) {
        const regex2 = new RegExp(schema.pattern);
        if (!regex2.test(value)) {
          yield Create4(ValueErrorType2.StringPattern, schema, path2, value);
        }
      }
      if ((0, index_9.IsString)(schema.format)) {
        if (!index_3.FormatRegistry.Has(schema.format)) {
          yield Create4(ValueErrorType2.StringFormatUnknown, schema, path2, value);
        } else {
          const format3 = index_3.FormatRegistry.Get(schema.format);
          if (!format3(value)) {
            yield Create4(ValueErrorType2.StringFormat, schema, path2, value);
          }
        }
      }
    }
    function* FromSymbol6(schema, references, path2, value) {
      if (!(0, index_9.IsSymbol)(value))
        yield Create4(ValueErrorType2.Symbol, schema, path2, value);
    }
    function* FromTemplateLiteral7(schema, references, path2, value) {
      if (!(0, index_9.IsString)(value))
        return yield Create4(ValueErrorType2.String, schema, path2, value);
      const regex2 = new RegExp(schema.pattern);
      if (!regex2.test(value)) {
        yield Create4(ValueErrorType2.StringPattern, schema, path2, value);
      }
    }
    function* FromThis11(schema, references, path2, value) {
      yield* Visit17((0, index_5.Deref)(schema, references), references, path2, value);
    }
    function* FromTuple15(schema, references, path2, value) {
      if (!(0, index_9.IsArray)(value))
        return yield Create4(ValueErrorType2.Tuple, schema, path2, value);
      if (schema.items === void 0 && !(value.length === 0)) {
        return yield Create4(ValueErrorType2.TupleLength, schema, path2, value);
      }
      if (!(value.length === schema.maxItems)) {
        return yield Create4(ValueErrorType2.TupleLength, schema, path2, value);
      }
      if (!schema.items) {
        return;
      }
      for (let i2 = 0; i2 < schema.items.length; i2++) {
        yield* Visit17(schema.items[i2], references, `${path2}/${i2}`, value[i2]);
      }
    }
    function* FromUndefined6(schema, references, path2, value) {
      if (!(0, index_9.IsUndefined)(value))
        yield Create4(ValueErrorType2.Undefined, schema, path2, value);
    }
    function* FromUnion20(schema, references, path2, value) {
      let count2 = 0;
      for (const subschema of schema.anyOf) {
        const errors2 = [...Visit17(subschema, references, path2, value)];
        if (errors2.length === 0)
          return;
        count2 += errors2.length;
      }
      if (count2 > 0) {
        yield Create4(ValueErrorType2.Union, schema, path2, value);
      }
    }
    function* FromUint8Array5(schema, references, path2, value) {
      if (!(0, index_9.IsUint8Array)(value))
        return yield Create4(ValueErrorType2.Uint8Array, schema, path2, value);
      if (IsDefined3(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
        yield Create4(ValueErrorType2.Uint8ArrayMaxByteLength, schema, path2, value);
      }
      if (IsDefined3(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
        yield Create4(ValueErrorType2.Uint8ArrayMinByteLength, schema, path2, value);
      }
    }
    function* FromUnknown5(schema, references, path2, value) {
    }
    function* FromVoid5(schema, references, path2, value) {
      if (!index_1.TypeSystemPolicy.IsVoidLike(value))
        yield Create4(ValueErrorType2.Void, schema, path2, value);
    }
    function* FromKind4(schema, references, path2, value) {
      const check = index_3.TypeRegistry.Get(schema[index_7.Kind]);
      if (!check(schema, value))
        yield Create4(ValueErrorType2.Kind, schema, path2, value);
    }
    function* Visit17(schema, references, path2, value) {
      const references_ = IsDefined3(schema.$id) ? [...references, schema] : references;
      const schema_ = schema;
      switch (schema_[index_7.Kind]) {
        case "Any":
          return yield* FromAny5(schema_, references_, path2, value);
        case "Array":
          return yield* FromArray16(schema_, references_, path2, value);
        case "AsyncIterator":
          return yield* FromAsyncIterator7(schema_, references_, path2, value);
        case "BigInt":
          return yield* FromBigInt6(schema_, references_, path2, value);
        case "Boolean":
          return yield* FromBoolean6(schema_, references_, path2, value);
        case "Constructor":
          return yield* FromConstructor8(schema_, references_, path2, value);
        case "Date":
          return yield* FromDate6(schema_, references_, path2, value);
        case "Function":
          return yield* FromFunction7(schema_, references_, path2, value);
        case "Integer":
          return yield* FromInteger6(schema_, references_, path2, value);
        case "Intersect":
          return yield* FromIntersect18(schema_, references_, path2, value);
        case "Iterator":
          return yield* FromIterator7(schema_, references_, path2, value);
        case "Literal":
          return yield* FromLiteral7(schema_, references_, path2, value);
        case "Never":
          return yield* FromNever6(schema_, references_, path2, value);
        case "Not":
          return yield* FromNot8(schema_, references_, path2, value);
        case "Null":
          return yield* FromNull6(schema_, references_, path2, value);
        case "Number":
          return yield* FromNumber6(schema_, references_, path2, value);
        case "Object":
          return yield* FromObject13(schema_, references_, path2, value);
        case "Promise":
          return yield* FromPromise8(schema_, references_, path2, value);
        case "Record":
          return yield* FromRecord12(schema_, references_, path2, value);
        case "Ref":
          return yield* FromRef12(schema_, references_, path2, value);
        case "RegExp":
          return yield* FromRegExp5(schema_, references_, path2, value);
        case "String":
          return yield* FromString6(schema_, references_, path2, value);
        case "Symbol":
          return yield* FromSymbol6(schema_, references_, path2, value);
        case "TemplateLiteral":
          return yield* FromTemplateLiteral7(schema_, references_, path2, value);
        case "This":
          return yield* FromThis11(schema_, references_, path2, value);
        case "Tuple":
          return yield* FromTuple15(schema_, references_, path2, value);
        case "Undefined":
          return yield* FromUndefined6(schema_, references_, path2, value);
        case "Union":
          return yield* FromUnion20(schema_, references_, path2, value);
        case "Uint8Array":
          return yield* FromUint8Array5(schema_, references_, path2, value);
        case "Unknown":
          return yield* FromUnknown5(schema_, references_, path2, value);
        case "Void":
          return yield* FromVoid5(schema_, references_, path2, value);
        default:
          if (!index_3.TypeRegistry.Has(schema_[index_7.Kind]))
            throw new ValueErrorsUnknownTypeError2(schema);
          return yield* FromKind4(schema_, references_, path2, value);
      }
    }
    function Errors3(...args) {
      const iterator = args.length === 3 ? Visit17(args[0], args[1], "", args[2]) : Visit17(args[0], [], "", args[1]);
      return new ValueErrorIterator2(iterator);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/errors/index.js
var require_errors2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/errors/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_errors(), exports);
    __exportStar(require_function3(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/any/any.js
var require_any = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/any/any.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Any = Any2;
    var index_1 = require_symbols2();
    function Any2(options = {}) {
      return { ...options, [index_1.Kind]: "Any" };
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/any/index.js
var require_any2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/any/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_any(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/unknown/unknown.js
var require_unknown = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/unknown/unknown.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Unknown = Unknown2;
    var index_1 = require_symbols2();
    function Unknown2(options = {}) {
      return {
        ...options,
        [index_1.Kind]: "Unknown"
      };
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/unknown/index.js
var require_unknown2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/unknown/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_unknown(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/guard/type.js
var require_type3 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/guard/type.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeGuardUnknownTypeError = void 0;
    exports.IsReadonly = IsReadonly3;
    exports.IsOptional = IsOptional3;
    exports.IsAny = IsAny3;
    exports.IsArray = IsArray5;
    exports.IsAsyncIterator = IsAsyncIterator5;
    exports.IsBigInt = IsBigInt5;
    exports.IsBoolean = IsBoolean5;
    exports.IsConstructor = IsConstructor3;
    exports.IsDate = IsDate5;
    exports.IsFunction = IsFunction5;
    exports.IsInteger = IsInteger4;
    exports.IsProperties = IsProperties2;
    exports.IsIntersect = IsIntersect3;
    exports.IsIterator = IsIterator5;
    exports.IsKindOf = IsKindOf3;
    exports.IsLiteralString = IsLiteralString2;
    exports.IsLiteralNumber = IsLiteralNumber2;
    exports.IsLiteralBoolean = IsLiteralBoolean2;
    exports.IsLiteral = IsLiteral3;
    exports.IsLiteralValue = IsLiteralValue2;
    exports.IsMappedKey = IsMappedKey3;
    exports.IsMappedResult = IsMappedResult3;
    exports.IsNever = IsNever3;
    exports.IsNot = IsNot3;
    exports.IsNull = IsNull5;
    exports.IsNumber = IsNumber5;
    exports.IsObject = IsObject5;
    exports.IsPromise = IsPromise4;
    exports.IsRecord = IsRecord3;
    exports.IsRecursive = IsRecursive2;
    exports.IsRef = IsRef3;
    exports.IsRegExp = IsRegExp4;
    exports.IsString = IsString5;
    exports.IsSymbol = IsSymbol5;
    exports.IsTemplateLiteral = IsTemplateLiteral3;
    exports.IsThis = IsThis3;
    exports.IsTransform = IsTransform3;
    exports.IsTuple = IsTuple3;
    exports.IsUndefined = IsUndefined5;
    exports.IsUnionLiteral = IsUnionLiteral2;
    exports.IsUnion = IsUnion3;
    exports.IsUint8Array = IsUint8Array5;
    exports.IsUnknown = IsUnknown3;
    exports.IsUnsafe = IsUnsafe3;
    exports.IsVoid = IsVoid3;
    exports.IsKind = IsKind3;
    exports.IsSchema = IsSchema3;
    var ValueGuard = require_value();
    var index_1 = require_symbols2();
    var index_2 = require_error2();
    var TypeGuardUnknownTypeError2 = class extends index_2.TypeBoxError {
    };
    exports.TypeGuardUnknownTypeError = TypeGuardUnknownTypeError2;
    var KnownTypes2 = [
      "Any",
      "Array",
      "AsyncIterator",
      "BigInt",
      "Boolean",
      "Constructor",
      "Date",
      "Enum",
      "Function",
      "Integer",
      "Intersect",
      "Iterator",
      "Literal",
      "MappedKey",
      "MappedResult",
      "Not",
      "Null",
      "Number",
      "Object",
      "Promise",
      "Record",
      "Ref",
      "RegExp",
      "String",
      "Symbol",
      "TemplateLiteral",
      "This",
      "Tuple",
      "Undefined",
      "Union",
      "Uint8Array",
      "Unknown",
      "Void"
    ];
    function IsPattern2(value) {
      try {
        new RegExp(value);
        return true;
      } catch {
        return false;
      }
    }
    function IsControlCharacterFree2(value) {
      if (!ValueGuard.IsString(value))
        return false;
      for (let i2 = 0; i2 < value.length; i2++) {
        const code4 = value.charCodeAt(i2);
        if (code4 >= 7 && code4 <= 13 || code4 === 27 || code4 === 127) {
          return false;
        }
      }
      return true;
    }
    function IsAdditionalProperties2(value) {
      return IsOptionalBoolean2(value) || IsSchema3(value);
    }
    function IsOptionalBigInt2(value) {
      return ValueGuard.IsUndefined(value) || ValueGuard.IsBigInt(value);
    }
    function IsOptionalNumber2(value) {
      return ValueGuard.IsUndefined(value) || ValueGuard.IsNumber(value);
    }
    function IsOptionalBoolean2(value) {
      return ValueGuard.IsUndefined(value) || ValueGuard.IsBoolean(value);
    }
    function IsOptionalString2(value) {
      return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value);
    }
    function IsOptionalPattern2(value) {
      return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value) && IsControlCharacterFree2(value) && IsPattern2(value);
    }
    function IsOptionalFormat2(value) {
      return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value) && IsControlCharacterFree2(value);
    }
    function IsOptionalSchema2(value) {
      return ValueGuard.IsUndefined(value) || IsSchema3(value);
    }
    function IsReadonly3(value) {
      return ValueGuard.IsObject(value) && value[index_1.ReadonlyKind] === "Readonly";
    }
    function IsOptional3(value) {
      return ValueGuard.IsObject(value) && value[index_1.OptionalKind] === "Optional";
    }
    function IsAny3(value) {
      return IsKindOf3(value, "Any") && IsOptionalString2(value.$id);
    }
    function IsArray5(value) {
      return IsKindOf3(value, "Array") && value.type === "array" && IsOptionalString2(value.$id) && IsSchema3(value.items) && IsOptionalNumber2(value.minItems) && IsOptionalNumber2(value.maxItems) && IsOptionalBoolean2(value.uniqueItems) && IsOptionalSchema2(value.contains) && IsOptionalNumber2(value.minContains) && IsOptionalNumber2(value.maxContains);
    }
    function IsAsyncIterator5(value) {
      return IsKindOf3(value, "AsyncIterator") && value.type === "AsyncIterator" && IsOptionalString2(value.$id) && IsSchema3(value.items);
    }
    function IsBigInt5(value) {
      return IsKindOf3(value, "BigInt") && value.type === "bigint" && IsOptionalString2(value.$id) && IsOptionalBigInt2(value.exclusiveMaximum) && IsOptionalBigInt2(value.exclusiveMinimum) && IsOptionalBigInt2(value.maximum) && IsOptionalBigInt2(value.minimum) && IsOptionalBigInt2(value.multipleOf);
    }
    function IsBoolean5(value) {
      return IsKindOf3(value, "Boolean") && value.type === "boolean" && IsOptionalString2(value.$id);
    }
    function IsConstructor3(value) {
      return IsKindOf3(value, "Constructor") && value.type === "Constructor" && IsOptionalString2(value.$id) && ValueGuard.IsArray(value.parameters) && value.parameters.every((schema) => IsSchema3(schema)) && IsSchema3(value.returns);
    }
    function IsDate5(value) {
      return IsKindOf3(value, "Date") && value.type === "Date" && IsOptionalString2(value.$id) && IsOptionalNumber2(value.exclusiveMaximumTimestamp) && IsOptionalNumber2(value.exclusiveMinimumTimestamp) && IsOptionalNumber2(value.maximumTimestamp) && IsOptionalNumber2(value.minimumTimestamp) && IsOptionalNumber2(value.multipleOfTimestamp);
    }
    function IsFunction5(value) {
      return IsKindOf3(value, "Function") && value.type === "Function" && IsOptionalString2(value.$id) && ValueGuard.IsArray(value.parameters) && value.parameters.every((schema) => IsSchema3(schema)) && IsSchema3(value.returns);
    }
    function IsInteger4(value) {
      return IsKindOf3(value, "Integer") && value.type === "integer" && IsOptionalString2(value.$id) && IsOptionalNumber2(value.exclusiveMaximum) && IsOptionalNumber2(value.exclusiveMinimum) && IsOptionalNumber2(value.maximum) && IsOptionalNumber2(value.minimum) && IsOptionalNumber2(value.multipleOf);
    }
    function IsProperties2(value) {
      return ValueGuard.IsObject(value) && Object.entries(value).every(([key2, schema]) => IsControlCharacterFree2(key2) && IsSchema3(schema));
    }
    function IsIntersect3(value) {
      return IsKindOf3(value, "Intersect") && (ValueGuard.IsString(value.type) && value.type !== "object" ? false : true) && ValueGuard.IsArray(value.allOf) && value.allOf.every((schema) => IsSchema3(schema) && !IsTransform3(schema)) && IsOptionalString2(value.type) && (IsOptionalBoolean2(value.unevaluatedProperties) || IsOptionalSchema2(value.unevaluatedProperties)) && IsOptionalString2(value.$id);
    }
    function IsIterator5(value) {
      return IsKindOf3(value, "Iterator") && value.type === "Iterator" && IsOptionalString2(value.$id) && IsSchema3(value.items);
    }
    function IsKindOf3(value, kind) {
      return ValueGuard.IsObject(value) && index_1.Kind in value && value[index_1.Kind] === kind;
    }
    function IsLiteralString2(value) {
      return IsLiteral3(value) && ValueGuard.IsString(value.const);
    }
    function IsLiteralNumber2(value) {
      return IsLiteral3(value) && ValueGuard.IsNumber(value.const);
    }
    function IsLiteralBoolean2(value) {
      return IsLiteral3(value) && ValueGuard.IsBoolean(value.const);
    }
    function IsLiteral3(value) {
      return IsKindOf3(value, "Literal") && IsOptionalString2(value.$id) && IsLiteralValue2(value.const);
    }
    function IsLiteralValue2(value) {
      return ValueGuard.IsBoolean(value) || ValueGuard.IsNumber(value) || ValueGuard.IsString(value);
    }
    function IsMappedKey3(value) {
      return IsKindOf3(value, "MappedKey") && ValueGuard.IsArray(value.keys) && value.keys.every((key2) => ValueGuard.IsNumber(key2) || ValueGuard.IsString(key2));
    }
    function IsMappedResult3(value) {
      return IsKindOf3(value, "MappedResult") && IsProperties2(value.properties);
    }
    function IsNever3(value) {
      return IsKindOf3(value, "Never") && ValueGuard.IsObject(value.not) && Object.getOwnPropertyNames(value.not).length === 0;
    }
    function IsNot3(value) {
      return IsKindOf3(value, "Not") && IsSchema3(value.not);
    }
    function IsNull5(value) {
      return IsKindOf3(value, "Null") && value.type === "null" && IsOptionalString2(value.$id);
    }
    function IsNumber5(value) {
      return IsKindOf3(value, "Number") && value.type === "number" && IsOptionalString2(value.$id) && IsOptionalNumber2(value.exclusiveMaximum) && IsOptionalNumber2(value.exclusiveMinimum) && IsOptionalNumber2(value.maximum) && IsOptionalNumber2(value.minimum) && IsOptionalNumber2(value.multipleOf);
    }
    function IsObject5(value) {
      return IsKindOf3(value, "Object") && value.type === "object" && IsOptionalString2(value.$id) && IsProperties2(value.properties) && IsAdditionalProperties2(value.additionalProperties) && IsOptionalNumber2(value.minProperties) && IsOptionalNumber2(value.maxProperties);
    }
    function IsPromise4(value) {
      return IsKindOf3(value, "Promise") && value.type === "Promise" && IsOptionalString2(value.$id) && IsSchema3(value.item);
    }
    function IsRecord3(value) {
      return IsKindOf3(value, "Record") && value.type === "object" && IsOptionalString2(value.$id) && IsAdditionalProperties2(value.additionalProperties) && ValueGuard.IsObject(value.patternProperties) && ((schema) => {
        const keys3 = Object.getOwnPropertyNames(schema.patternProperties);
        return keys3.length === 1 && IsPattern2(keys3[0]) && ValueGuard.IsObject(schema.patternProperties) && IsSchema3(schema.patternProperties[keys3[0]]);
      })(value);
    }
    function IsRecursive2(value) {
      return ValueGuard.IsObject(value) && index_1.Hint in value && value[index_1.Hint] === "Recursive";
    }
    function IsRef3(value) {
      return IsKindOf3(value, "Ref") && IsOptionalString2(value.$id) && ValueGuard.IsString(value.$ref);
    }
    function IsRegExp4(value) {
      return IsKindOf3(value, "RegExp") && IsOptionalString2(value.$id) && ValueGuard.IsString(value.source) && ValueGuard.IsString(value.flags) && IsOptionalNumber2(value.maxLength) && IsOptionalNumber2(value.minLength);
    }
    function IsString5(value) {
      return IsKindOf3(value, "String") && value.type === "string" && IsOptionalString2(value.$id) && IsOptionalNumber2(value.minLength) && IsOptionalNumber2(value.maxLength) && IsOptionalPattern2(value.pattern) && IsOptionalFormat2(value.format);
    }
    function IsSymbol5(value) {
      return IsKindOf3(value, "Symbol") && value.type === "symbol" && IsOptionalString2(value.$id);
    }
    function IsTemplateLiteral3(value) {
      return IsKindOf3(value, "TemplateLiteral") && value.type === "string" && ValueGuard.IsString(value.pattern) && value.pattern[0] === "^" && value.pattern[value.pattern.length - 1] === "$";
    }
    function IsThis3(value) {
      return IsKindOf3(value, "This") && IsOptionalString2(value.$id) && ValueGuard.IsString(value.$ref);
    }
    function IsTransform3(value) {
      return ValueGuard.IsObject(value) && index_1.TransformKind in value;
    }
    function IsTuple3(value) {
      return IsKindOf3(value, "Tuple") && value.type === "array" && IsOptionalString2(value.$id) && ValueGuard.IsNumber(value.minItems) && ValueGuard.IsNumber(value.maxItems) && value.minItems === value.maxItems && // empty
      (ValueGuard.IsUndefined(value.items) && ValueGuard.IsUndefined(value.additionalItems) && value.minItems === 0 || ValueGuard.IsArray(value.items) && value.items.every((schema) => IsSchema3(schema)));
    }
    function IsUndefined5(value) {
      return IsKindOf3(value, "Undefined") && value.type === "undefined" && IsOptionalString2(value.$id);
    }
    function IsUnionLiteral2(value) {
      return IsUnion3(value) && value.anyOf.every((schema) => IsLiteralString2(schema) || IsLiteralNumber2(schema));
    }
    function IsUnion3(value) {
      return IsKindOf3(value, "Union") && IsOptionalString2(value.$id) && ValueGuard.IsObject(value) && ValueGuard.IsArray(value.anyOf) && value.anyOf.every((schema) => IsSchema3(schema));
    }
    function IsUint8Array5(value) {
      return IsKindOf3(value, "Uint8Array") && value.type === "Uint8Array" && IsOptionalString2(value.$id) && IsOptionalNumber2(value.minByteLength) && IsOptionalNumber2(value.maxByteLength);
    }
    function IsUnknown3(value) {
      return IsKindOf3(value, "Unknown") && IsOptionalString2(value.$id);
    }
    function IsUnsafe3(value) {
      return IsKindOf3(value, "Unsafe");
    }
    function IsVoid3(value) {
      return IsKindOf3(value, "Void") && value.type === "void" && IsOptionalString2(value.$id);
    }
    function IsKind3(value) {
      return ValueGuard.IsObject(value) && index_1.Kind in value && ValueGuard.IsString(value[index_1.Kind]) && !KnownTypes2.includes(value[index_1.Kind]);
    }
    function IsSchema3(value) {
      return ValueGuard.IsObject(value) && (IsAny3(value) || IsArray5(value) || IsBoolean5(value) || IsBigInt5(value) || IsAsyncIterator5(value) || IsConstructor3(value) || IsDate5(value) || IsFunction5(value) || IsInteger4(value) || IsIntersect3(value) || IsIterator5(value) || IsLiteral3(value) || IsMappedKey3(value) || IsMappedResult3(value) || IsNever3(value) || IsNot3(value) || IsNull5(value) || IsNumber5(value) || IsObject5(value) || IsPromise4(value) || IsRecord3(value) || IsRef3(value) || IsRegExp4(value) || IsString5(value) || IsSymbol5(value) || IsTemplateLiteral3(value) || IsThis3(value) || IsTuple3(value) || IsUndefined5(value) || IsUnion3(value) || IsUint8Array5(value) || IsUnknown3(value) || IsUnsafe3(value) || IsVoid3(value) || IsKind3(value));
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/guard/index.js
var require_guard3 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/guard/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueGuard = exports.TypeGuard = exports.KindGuard = void 0;
    exports.KindGuard = require_kind();
    exports.TypeGuard = require_type3();
    exports.ValueGuard = require_value();
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extends/extends-check.js
var require_extends_check = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/extends/extends-check.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExtendsResult = exports.ExtendsResolverError = void 0;
    exports.ExtendsCheck = ExtendsCheck2;
    var index_1 = require_any2();
    var index_2 = require_function2();
    var index_3 = require_number2();
    var index_4 = require_string2();
    var index_5 = require_unknown2();
    var index_6 = require_template_literal2();
    var index_7 = require_patterns2();
    var index_8 = require_symbols2();
    var index_9 = require_error2();
    var index_10 = require_guard3();
    var ExtendsResolverError2 = class extends index_9.TypeBoxError {
    };
    exports.ExtendsResolverError = ExtendsResolverError2;
    var ExtendsResult2;
    (function(ExtendsResult3) {
      ExtendsResult3[ExtendsResult3["Union"] = 0] = "Union";
      ExtendsResult3[ExtendsResult3["True"] = 1] = "True";
      ExtendsResult3[ExtendsResult3["False"] = 2] = "False";
    })(ExtendsResult2 || (exports.ExtendsResult = ExtendsResult2 = {}));
    function IntoBooleanResult2(result) {
      return result === ExtendsResult2.False ? result : ExtendsResult2.True;
    }
    function Throw2(message2) {
      throw new ExtendsResolverError2(message2);
    }
    function IsStructuralRight2(right) {
      return index_10.TypeGuard.IsNever(right) || index_10.TypeGuard.IsIntersect(right) || index_10.TypeGuard.IsUnion(right) || index_10.TypeGuard.IsUnknown(right) || index_10.TypeGuard.IsAny(right);
    }
    function StructuralRight2(left, right) {
      return index_10.TypeGuard.IsNever(right) ? FromNeverRight2(left, right) : index_10.TypeGuard.IsIntersect(right) ? FromIntersectRight2(left, right) : index_10.TypeGuard.IsUnion(right) ? FromUnionRight2(left, right) : index_10.TypeGuard.IsUnknown(right) ? FromUnknownRight2(left, right) : index_10.TypeGuard.IsAny(right) ? FromAnyRight2(left, right) : Throw2("StructuralRight");
    }
    function FromAnyRight2(left, right) {
      return ExtendsResult2.True;
    }
    function FromAny5(left, right) {
      return index_10.TypeGuard.IsIntersect(right) ? FromIntersectRight2(left, right) : index_10.TypeGuard.IsUnion(right) && right.anyOf.some((schema) => index_10.TypeGuard.IsAny(schema) || index_10.TypeGuard.IsUnknown(schema)) ? ExtendsResult2.True : index_10.TypeGuard.IsUnion(right) ? ExtendsResult2.Union : index_10.TypeGuard.IsUnknown(right) ? ExtendsResult2.True : index_10.TypeGuard.IsAny(right) ? ExtendsResult2.True : ExtendsResult2.Union;
    }
    function FromArrayRight2(left, right) {
      return index_10.TypeGuard.IsUnknown(left) ? ExtendsResult2.False : index_10.TypeGuard.IsAny(left) ? ExtendsResult2.Union : index_10.TypeGuard.IsNever(left) ? ExtendsResult2.True : ExtendsResult2.False;
    }
    function FromArray16(left, right) {
      return index_10.TypeGuard.IsObject(right) && IsObjectArrayLike2(right) ? ExtendsResult2.True : IsStructuralRight2(right) ? StructuralRight2(left, right) : !index_10.TypeGuard.IsArray(right) ? ExtendsResult2.False : IntoBooleanResult2(Visit17(left.items, right.items));
    }
    function FromAsyncIterator7(left, right) {
      return IsStructuralRight2(right) ? StructuralRight2(left, right) : !index_10.TypeGuard.IsAsyncIterator(right) ? ExtendsResult2.False : IntoBooleanResult2(Visit17(left.items, right.items));
    }
    function FromBigInt6(left, right) {
      return IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight2(left, right) : index_10.TypeGuard.IsBigInt(right) ? ExtendsResult2.True : ExtendsResult2.False;
    }
    function FromBooleanRight2(left, right) {
      return index_10.TypeGuard.IsLiteralBoolean(left) ? ExtendsResult2.True : index_10.TypeGuard.IsBoolean(left) ? ExtendsResult2.True : ExtendsResult2.False;
    }
    function FromBoolean6(left, right) {
      return IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight2(left, right) : index_10.TypeGuard.IsBoolean(right) ? ExtendsResult2.True : ExtendsResult2.False;
    }
    function FromConstructor8(left, right) {
      return IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : !index_10.TypeGuard.IsConstructor(right) ? ExtendsResult2.False : left.parameters.length > right.parameters.length ? ExtendsResult2.False : !left.parameters.every((schema, index3) => IntoBooleanResult2(Visit17(right.parameters[index3], schema)) === ExtendsResult2.True) ? ExtendsResult2.False : IntoBooleanResult2(Visit17(left.returns, right.returns));
    }
    function FromDate6(left, right) {
      return IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight2(left, right) : index_10.TypeGuard.IsDate(right) ? ExtendsResult2.True : ExtendsResult2.False;
    }
    function FromFunction7(left, right) {
      return IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : !index_10.TypeGuard.IsFunction(right) ? ExtendsResult2.False : left.parameters.length > right.parameters.length ? ExtendsResult2.False : !left.parameters.every((schema, index3) => IntoBooleanResult2(Visit17(right.parameters[index3], schema)) === ExtendsResult2.True) ? ExtendsResult2.False : IntoBooleanResult2(Visit17(left.returns, right.returns));
    }
    function FromIntegerRight2(left, right) {
      return index_10.TypeGuard.IsLiteral(left) && index_10.ValueGuard.IsNumber(left.const) ? ExtendsResult2.True : index_10.TypeGuard.IsNumber(left) || index_10.TypeGuard.IsInteger(left) ? ExtendsResult2.True : ExtendsResult2.False;
    }
    function FromInteger6(left, right) {
      return index_10.TypeGuard.IsInteger(right) || index_10.TypeGuard.IsNumber(right) ? ExtendsResult2.True : IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight2(left, right) : ExtendsResult2.False;
    }
    function FromIntersectRight2(left, right) {
      return right.allOf.every((schema) => Visit17(left, schema) === ExtendsResult2.True) ? ExtendsResult2.True : ExtendsResult2.False;
    }
    function FromIntersect18(left, right) {
      return left.allOf.some((schema) => Visit17(schema, right) === ExtendsResult2.True) ? ExtendsResult2.True : ExtendsResult2.False;
    }
    function FromIterator7(left, right) {
      return IsStructuralRight2(right) ? StructuralRight2(left, right) : !index_10.TypeGuard.IsIterator(right) ? ExtendsResult2.False : IntoBooleanResult2(Visit17(left.items, right.items));
    }
    function FromLiteral7(left, right) {
      return index_10.TypeGuard.IsLiteral(right) && right.const === left.const ? ExtendsResult2.True : IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight2(left, right) : index_10.TypeGuard.IsString(right) ? FromStringRight2(left, right) : index_10.TypeGuard.IsNumber(right) ? FromNumberRight2(left, right) : index_10.TypeGuard.IsInteger(right) ? FromIntegerRight2(left, right) : index_10.TypeGuard.IsBoolean(right) ? FromBooleanRight2(left, right) : ExtendsResult2.False;
    }
    function FromNeverRight2(left, right) {
      return ExtendsResult2.False;
    }
    function FromNever6(left, right) {
      return ExtendsResult2.True;
    }
    function UnwrapTNot2(schema) {
      let [current, depth] = [schema, 0];
      while (true) {
        if (!index_10.TypeGuard.IsNot(current))
          break;
        current = current.not;
        depth += 1;
      }
      return depth % 2 === 0 ? current : (0, index_5.Unknown)();
    }
    function FromNot8(left, right) {
      return index_10.TypeGuard.IsNot(left) ? Visit17(UnwrapTNot2(left), right) : index_10.TypeGuard.IsNot(right) ? Visit17(left, UnwrapTNot2(right)) : Throw2("Invalid fallthrough for Not");
    }
    function FromNull6(left, right) {
      return IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight2(left, right) : index_10.TypeGuard.IsNull(right) ? ExtendsResult2.True : ExtendsResult2.False;
    }
    function FromNumberRight2(left, right) {
      return index_10.TypeGuard.IsLiteralNumber(left) ? ExtendsResult2.True : index_10.TypeGuard.IsNumber(left) || index_10.TypeGuard.IsInteger(left) ? ExtendsResult2.True : ExtendsResult2.False;
    }
    function FromNumber6(left, right) {
      return IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight2(left, right) : index_10.TypeGuard.IsInteger(right) || index_10.TypeGuard.IsNumber(right) ? ExtendsResult2.True : ExtendsResult2.False;
    }
    function IsObjectPropertyCount2(schema, count2) {
      return Object.getOwnPropertyNames(schema.properties).length === count2;
    }
    function IsObjectStringLike2(schema) {
      return IsObjectArrayLike2(schema);
    }
    function IsObjectSymbolLike2(schema) {
      return IsObjectPropertyCount2(schema, 0) || IsObjectPropertyCount2(schema, 1) && "description" in schema.properties && index_10.TypeGuard.IsUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (index_10.TypeGuard.IsString(schema.properties.description.anyOf[0]) && index_10.TypeGuard.IsUndefined(schema.properties.description.anyOf[1]) || index_10.TypeGuard.IsString(schema.properties.description.anyOf[1]) && index_10.TypeGuard.IsUndefined(schema.properties.description.anyOf[0]));
    }
    function IsObjectNumberLike2(schema) {
      return IsObjectPropertyCount2(schema, 0);
    }
    function IsObjectBooleanLike2(schema) {
      return IsObjectPropertyCount2(schema, 0);
    }
    function IsObjectBigIntLike2(schema) {
      return IsObjectPropertyCount2(schema, 0);
    }
    function IsObjectDateLike2(schema) {
      return IsObjectPropertyCount2(schema, 0);
    }
    function IsObjectUint8ArrayLike2(schema) {
      return IsObjectArrayLike2(schema);
    }
    function IsObjectFunctionLike2(schema) {
      const length = (0, index_3.Number)();
      return IsObjectPropertyCount2(schema, 0) || IsObjectPropertyCount2(schema, 1) && "length" in schema.properties && IntoBooleanResult2(Visit17(schema.properties["length"], length)) === ExtendsResult2.True;
    }
    function IsObjectConstructorLike2(schema) {
      return IsObjectPropertyCount2(schema, 0);
    }
    function IsObjectArrayLike2(schema) {
      const length = (0, index_3.Number)();
      return IsObjectPropertyCount2(schema, 0) || IsObjectPropertyCount2(schema, 1) && "length" in schema.properties && IntoBooleanResult2(Visit17(schema.properties["length"], length)) === ExtendsResult2.True;
    }
    function IsObjectPromiseLike2(schema) {
      const then = (0, index_2.Function)([(0, index_1.Any)()], (0, index_1.Any)());
      return IsObjectPropertyCount2(schema, 0) || IsObjectPropertyCount2(schema, 1) && "then" in schema.properties && IntoBooleanResult2(Visit17(schema.properties["then"], then)) === ExtendsResult2.True;
    }
    function Property2(left, right) {
      return Visit17(left, right) === ExtendsResult2.False ? ExtendsResult2.False : index_10.TypeGuard.IsOptional(left) && !index_10.TypeGuard.IsOptional(right) ? ExtendsResult2.False : ExtendsResult2.True;
    }
    function FromObjectRight2(left, right) {
      return index_10.TypeGuard.IsUnknown(left) ? ExtendsResult2.False : index_10.TypeGuard.IsAny(left) ? ExtendsResult2.Union : index_10.TypeGuard.IsNever(left) || index_10.TypeGuard.IsLiteralString(left) && IsObjectStringLike2(right) || index_10.TypeGuard.IsLiteralNumber(left) && IsObjectNumberLike2(right) || index_10.TypeGuard.IsLiteralBoolean(left) && IsObjectBooleanLike2(right) || index_10.TypeGuard.IsSymbol(left) && IsObjectSymbolLike2(right) || index_10.TypeGuard.IsBigInt(left) && IsObjectBigIntLike2(right) || index_10.TypeGuard.IsString(left) && IsObjectStringLike2(right) || index_10.TypeGuard.IsSymbol(left) && IsObjectSymbolLike2(right) || index_10.TypeGuard.IsNumber(left) && IsObjectNumberLike2(right) || index_10.TypeGuard.IsInteger(left) && IsObjectNumberLike2(right) || index_10.TypeGuard.IsBoolean(left) && IsObjectBooleanLike2(right) || index_10.TypeGuard.IsUint8Array(left) && IsObjectUint8ArrayLike2(right) || index_10.TypeGuard.IsDate(left) && IsObjectDateLike2(right) || index_10.TypeGuard.IsConstructor(left) && IsObjectConstructorLike2(right) || index_10.TypeGuard.IsFunction(left) && IsObjectFunctionLike2(right) ? ExtendsResult2.True : index_10.TypeGuard.IsRecord(left) && index_10.TypeGuard.IsString(RecordKey2(left)) ? (() => {
        return right[index_8.Hint] === "Record" ? ExtendsResult2.True : ExtendsResult2.False;
      })() : index_10.TypeGuard.IsRecord(left) && index_10.TypeGuard.IsNumber(RecordKey2(left)) ? (() => {
        return IsObjectPropertyCount2(right, 0) ? ExtendsResult2.True : ExtendsResult2.False;
      })() : ExtendsResult2.False;
    }
    function FromObject13(left, right) {
      return IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight2(left, right) : !index_10.TypeGuard.IsObject(right) ? ExtendsResult2.False : (() => {
        for (const key2 of Object.getOwnPropertyNames(right.properties)) {
          if (!(key2 in left.properties) && !index_10.TypeGuard.IsOptional(right.properties[key2])) {
            return ExtendsResult2.False;
          }
          if (index_10.TypeGuard.IsOptional(right.properties[key2])) {
            return ExtendsResult2.True;
          }
          if (Property2(left.properties[key2], right.properties[key2]) === ExtendsResult2.False) {
            return ExtendsResult2.False;
          }
        }
        return ExtendsResult2.True;
      })();
    }
    function FromPromise8(left, right) {
      return IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) && IsObjectPromiseLike2(right) ? ExtendsResult2.True : !index_10.TypeGuard.IsPromise(right) ? ExtendsResult2.False : IntoBooleanResult2(Visit17(left.item, right.item));
    }
    function RecordKey2(schema) {
      return index_7.PatternNumberExact in schema.patternProperties ? (0, index_3.Number)() : index_7.PatternStringExact in schema.patternProperties ? (0, index_4.String)() : Throw2("Unknown record key pattern");
    }
    function RecordValue2(schema) {
      return index_7.PatternNumberExact in schema.patternProperties ? schema.patternProperties[index_7.PatternNumberExact] : index_7.PatternStringExact in schema.patternProperties ? schema.patternProperties[index_7.PatternStringExact] : Throw2("Unable to get record value schema");
    }
    function FromRecordRight2(left, right) {
      const [Key, Value] = [RecordKey2(right), RecordValue2(right)];
      return index_10.TypeGuard.IsLiteralString(left) && index_10.TypeGuard.IsNumber(Key) && IntoBooleanResult2(Visit17(left, Value)) === ExtendsResult2.True ? ExtendsResult2.True : index_10.TypeGuard.IsUint8Array(left) && index_10.TypeGuard.IsNumber(Key) ? Visit17(left, Value) : index_10.TypeGuard.IsString(left) && index_10.TypeGuard.IsNumber(Key) ? Visit17(left, Value) : index_10.TypeGuard.IsArray(left) && index_10.TypeGuard.IsNumber(Key) ? Visit17(left, Value) : index_10.TypeGuard.IsObject(left) ? (() => {
        for (const key2 of Object.getOwnPropertyNames(left.properties)) {
          if (Property2(Value, left.properties[key2]) === ExtendsResult2.False) {
            return ExtendsResult2.False;
          }
        }
        return ExtendsResult2.True;
      })() : ExtendsResult2.False;
    }
    function FromRecord12(left, right) {
      return IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : !index_10.TypeGuard.IsRecord(right) ? ExtendsResult2.False : Visit17(RecordValue2(left), RecordValue2(right));
    }
    function FromRegExp5(left, right) {
      const L2 = index_10.TypeGuard.IsRegExp(left) ? (0, index_4.String)() : left;
      const R2 = index_10.TypeGuard.IsRegExp(right) ? (0, index_4.String)() : right;
      return Visit17(L2, R2);
    }
    function FromStringRight2(left, right) {
      return index_10.TypeGuard.IsLiteral(left) && index_10.ValueGuard.IsString(left.const) ? ExtendsResult2.True : index_10.TypeGuard.IsString(left) ? ExtendsResult2.True : ExtendsResult2.False;
    }
    function FromString6(left, right) {
      return IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight2(left, right) : index_10.TypeGuard.IsString(right) ? ExtendsResult2.True : ExtendsResult2.False;
    }
    function FromSymbol6(left, right) {
      return IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight2(left, right) : index_10.TypeGuard.IsSymbol(right) ? ExtendsResult2.True : ExtendsResult2.False;
    }
    function FromTemplateLiteral7(left, right) {
      return index_10.TypeGuard.IsTemplateLiteral(left) ? Visit17((0, index_6.TemplateLiteralToUnion)(left), right) : index_10.TypeGuard.IsTemplateLiteral(right) ? Visit17(left, (0, index_6.TemplateLiteralToUnion)(right)) : Throw2("Invalid fallthrough for TemplateLiteral");
    }
    function IsArrayOfTuple2(left, right) {
      return index_10.TypeGuard.IsArray(right) && left.items !== void 0 && left.items.every((schema) => Visit17(schema, right.items) === ExtendsResult2.True);
    }
    function FromTupleRight2(left, right) {
      return index_10.TypeGuard.IsNever(left) ? ExtendsResult2.True : index_10.TypeGuard.IsUnknown(left) ? ExtendsResult2.False : index_10.TypeGuard.IsAny(left) ? ExtendsResult2.Union : ExtendsResult2.False;
    }
    function FromTuple15(left, right) {
      return IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) && IsObjectArrayLike2(right) ? ExtendsResult2.True : index_10.TypeGuard.IsArray(right) && IsArrayOfTuple2(left, right) ? ExtendsResult2.True : !index_10.TypeGuard.IsTuple(right) ? ExtendsResult2.False : index_10.ValueGuard.IsUndefined(left.items) && !index_10.ValueGuard.IsUndefined(right.items) || !index_10.ValueGuard.IsUndefined(left.items) && index_10.ValueGuard.IsUndefined(right.items) ? ExtendsResult2.False : index_10.ValueGuard.IsUndefined(left.items) && !index_10.ValueGuard.IsUndefined(right.items) ? ExtendsResult2.True : left.items.every((schema, index3) => Visit17(schema, right.items[index3]) === ExtendsResult2.True) ? ExtendsResult2.True : ExtendsResult2.False;
    }
    function FromUint8Array5(left, right) {
      return IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight2(left, right) : index_10.TypeGuard.IsUint8Array(right) ? ExtendsResult2.True : ExtendsResult2.False;
    }
    function FromUndefined6(left, right) {
      return IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight2(left, right) : index_10.TypeGuard.IsVoid(right) ? FromVoidRight2(left, right) : index_10.TypeGuard.IsUndefined(right) ? ExtendsResult2.True : ExtendsResult2.False;
    }
    function FromUnionRight2(left, right) {
      return right.anyOf.some((schema) => Visit17(left, schema) === ExtendsResult2.True) ? ExtendsResult2.True : ExtendsResult2.False;
    }
    function FromUnion20(left, right) {
      return left.anyOf.every((schema) => Visit17(schema, right) === ExtendsResult2.True) ? ExtendsResult2.True : ExtendsResult2.False;
    }
    function FromUnknownRight2(left, right) {
      return ExtendsResult2.True;
    }
    function FromUnknown5(left, right) {
      return index_10.TypeGuard.IsNever(right) ? FromNeverRight2(left, right) : index_10.TypeGuard.IsIntersect(right) ? FromIntersectRight2(left, right) : index_10.TypeGuard.IsUnion(right) ? FromUnionRight2(left, right) : index_10.TypeGuard.IsAny(right) ? FromAnyRight2(left, right) : index_10.TypeGuard.IsString(right) ? FromStringRight2(left, right) : index_10.TypeGuard.IsNumber(right) ? FromNumberRight2(left, right) : index_10.TypeGuard.IsInteger(right) ? FromIntegerRight2(left, right) : index_10.TypeGuard.IsBoolean(right) ? FromBooleanRight2(left, right) : index_10.TypeGuard.IsArray(right) ? FromArrayRight2(left, right) : index_10.TypeGuard.IsTuple(right) ? FromTupleRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : index_10.TypeGuard.IsUnknown(right) ? ExtendsResult2.True : ExtendsResult2.False;
    }
    function FromVoidRight2(left, right) {
      return index_10.TypeGuard.IsUndefined(left) ? ExtendsResult2.True : index_10.TypeGuard.IsUndefined(left) ? ExtendsResult2.True : ExtendsResult2.False;
    }
    function FromVoid5(left, right) {
      return index_10.TypeGuard.IsIntersect(right) ? FromIntersectRight2(left, right) : index_10.TypeGuard.IsUnion(right) ? FromUnionRight2(left, right) : index_10.TypeGuard.IsUnknown(right) ? FromUnknownRight2(left, right) : index_10.TypeGuard.IsAny(right) ? FromAnyRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : index_10.TypeGuard.IsVoid(right) ? ExtendsResult2.True : ExtendsResult2.False;
    }
    function Visit17(left, right) {
      return (
        // resolvable
        index_10.TypeGuard.IsTemplateLiteral(left) || index_10.TypeGuard.IsTemplateLiteral(right) ? FromTemplateLiteral7(left, right) : index_10.TypeGuard.IsRegExp(left) || index_10.TypeGuard.IsRegExp(right) ? FromRegExp5(left, right) : index_10.TypeGuard.IsNot(left) || index_10.TypeGuard.IsNot(right) ? FromNot8(left, right) : (
          // standard
          index_10.TypeGuard.IsAny(left) ? FromAny5(left, right) : index_10.TypeGuard.IsArray(left) ? FromArray16(left, right) : index_10.TypeGuard.IsBigInt(left) ? FromBigInt6(left, right) : index_10.TypeGuard.IsBoolean(left) ? FromBoolean6(left, right) : index_10.TypeGuard.IsAsyncIterator(left) ? FromAsyncIterator7(left, right) : index_10.TypeGuard.IsConstructor(left) ? FromConstructor8(left, right) : index_10.TypeGuard.IsDate(left) ? FromDate6(left, right) : index_10.TypeGuard.IsFunction(left) ? FromFunction7(left, right) : index_10.TypeGuard.IsInteger(left) ? FromInteger6(left, right) : index_10.TypeGuard.IsIntersect(left) ? FromIntersect18(left, right) : index_10.TypeGuard.IsIterator(left) ? FromIterator7(left, right) : index_10.TypeGuard.IsLiteral(left) ? FromLiteral7(left, right) : index_10.TypeGuard.IsNever(left) ? FromNever6(left, right) : index_10.TypeGuard.IsNull(left) ? FromNull6(left, right) : index_10.TypeGuard.IsNumber(left) ? FromNumber6(left, right) : index_10.TypeGuard.IsObject(left) ? FromObject13(left, right) : index_10.TypeGuard.IsRecord(left) ? FromRecord12(left, right) : index_10.TypeGuard.IsString(left) ? FromString6(left, right) : index_10.TypeGuard.IsSymbol(left) ? FromSymbol6(left, right) : index_10.TypeGuard.IsTuple(left) ? FromTuple15(left, right) : index_10.TypeGuard.IsPromise(left) ? FromPromise8(left, right) : index_10.TypeGuard.IsUint8Array(left) ? FromUint8Array5(left, right) : index_10.TypeGuard.IsUndefined(left) ? FromUndefined6(left, right) : index_10.TypeGuard.IsUnion(left) ? FromUnion20(left, right) : index_10.TypeGuard.IsUnknown(left) ? FromUnknown5(left, right) : index_10.TypeGuard.IsVoid(left) ? FromVoid5(left, right) : Throw2(`Unknown left type operand '${left[index_8.Kind]}'`)
        )
      );
    }
    function ExtendsCheck2(left, right) {
      return Visit17(left, right);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extends/extends-from-mapped-result.js
var require_extends_from_mapped_result = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/extends/extends-from-mapped-result.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExtendsFromMappedResult = ExtendsFromMappedResult2;
    var index_1 = require_mapped2();
    var extends_1 = require_extends();
    function FromProperties20(P2, Right, True, False, options) {
      const Acc = {};
      for (const K2 of globalThis.Object.getOwnPropertyNames(P2))
        Acc[K2] = (0, extends_1.Extends)(P2[K2], Right, True, False, options);
      return Acc;
    }
    function FromMappedResult13(Left, Right, True, False, options) {
      return FromProperties20(Left.properties, Right, True, False, options);
    }
    function ExtendsFromMappedResult2(Left, Right, True, False, options) {
      const P2 = FromMappedResult13(Left, Right, True, False, options);
      return (0, index_1.MappedResult)(P2);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extends/extends.js
var require_extends = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/extends/extends.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Extends = Extends2;
    var index_1 = require_union2();
    var extends_check_1 = require_extends_check();
    var type_1 = require_type2();
    var extends_from_mapped_key_1 = require_extends_from_mapped_key();
    var extends_from_mapped_result_1 = require_extends_from_mapped_result();
    var kind_1 = require_kind();
    function ExtendsResolve2(left, right, trueType, falseType) {
      const R2 = (0, extends_check_1.ExtendsCheck)(left, right);
      return R2 === extends_check_1.ExtendsResult.Union ? (0, index_1.Union)([trueType, falseType]) : R2 === extends_check_1.ExtendsResult.True ? trueType : falseType;
    }
    function Extends2(L2, R2, T2, F2, options = {}) {
      return (0, kind_1.IsMappedResult)(L2) ? (0, extends_from_mapped_result_1.ExtendsFromMappedResult)(L2, R2, T2, F2, options) : (0, kind_1.IsMappedKey)(L2) ? (0, type_1.CloneType)((0, extends_from_mapped_key_1.ExtendsFromMappedKey)(L2, R2, T2, F2, options)) : (0, type_1.CloneType)(ExtendsResolve2(L2, R2, T2, F2), options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extends/extends-from-mapped-key.js
var require_extends_from_mapped_key = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/extends/extends-from-mapped-key.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExtendsFromMappedKey = ExtendsFromMappedKey2;
    var index_1 = require_mapped2();
    var index_2 = require_literal2();
    var extends_1 = require_extends();
    function FromPropertyKey4(K2, U2, L2, R2, options) {
      return {
        [K2]: (0, extends_1.Extends)((0, index_2.Literal)(K2), U2, L2, R2, options)
      };
    }
    function FromPropertyKeys4(K2, U2, L2, R2, options) {
      return K2.reduce((Acc, LK) => {
        return { ...Acc, ...FromPropertyKey4(LK, U2, L2, R2, options) };
      }, {});
    }
    function FromMappedKey5(K2, U2, L2, R2, options) {
      return FromPropertyKeys4(K2.keys, U2, L2, R2, options);
    }
    function ExtendsFromMappedKey2(T2, U2, L2, R2, options) {
      const P2 = FromMappedKey5(T2, U2, L2, R2, options);
      return (0, index_1.MappedResult)(P2);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extends/index.js
var require_extends2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/extends/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_extends_check(), exports);
    __exportStar(require_extends_from_mapped_key(), exports);
    __exportStar(require_extends_from_mapped_result(), exports);
    __exportStar(require_extends_undefined(), exports);
    __exportStar(require_extends(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/check/check.js
var require_check = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/value/check/check.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueCheckUnknownTypeError = void 0;
    exports.Check = Check3;
    var index_1 = require_system2();
    var index_2 = require_deref2();
    var index_3 = require_hash2();
    var index_4 = require_symbols2();
    var index_5 = require_keyof2();
    var index_6 = require_extends2();
    var index_7 = require_registry();
    var index_8 = require_error2();
    var index_9 = require_never2();
    var index_10 = require_guard2();
    var type_1 = require_type3();
    var ValueCheckUnknownTypeError2 = class extends index_8.TypeBoxError {
      constructor(schema) {
        super(`Unknown type`);
        this.schema = schema;
      }
    };
    exports.ValueCheckUnknownTypeError = ValueCheckUnknownTypeError2;
    function IsAnyOrUnknown2(schema) {
      return schema[index_4.Kind] === "Any" || schema[index_4.Kind] === "Unknown";
    }
    function IsDefined3(value) {
      return value !== void 0;
    }
    function FromAny5(schema, references, value) {
      return true;
    }
    function FromArray16(schema, references, value) {
      if (!(0, index_10.IsArray)(value))
        return false;
      if (IsDefined3(schema.minItems) && !(value.length >= schema.minItems)) {
        return false;
      }
      if (IsDefined3(schema.maxItems) && !(value.length <= schema.maxItems)) {
        return false;
      }
      if (!value.every((value2) => Visit17(schema.items, references, value2))) {
        return false;
      }
      if (schema.uniqueItems === true && !function() {
        const set = /* @__PURE__ */ new Set();
        for (const element2 of value) {
          const hashed = (0, index_3.Hash)(element2);
          if (set.has(hashed)) {
            return false;
          } else {
            set.add(hashed);
          }
        }
        return true;
      }()) {
        return false;
      }
      if (!(IsDefined3(schema.contains) || (0, index_10.IsNumber)(schema.minContains) || (0, index_10.IsNumber)(schema.maxContains))) {
        return true;
      }
      const containsSchema = IsDefined3(schema.contains) ? schema.contains : (0, index_9.Never)();
      const containsCount = value.reduce((acc, value2) => Visit17(containsSchema, references, value2) ? acc + 1 : acc, 0);
      if (containsCount === 0) {
        return false;
      }
      if ((0, index_10.IsNumber)(schema.minContains) && containsCount < schema.minContains) {
        return false;
      }
      if ((0, index_10.IsNumber)(schema.maxContains) && containsCount > schema.maxContains) {
        return false;
      }
      return true;
    }
    function FromAsyncIterator7(schema, references, value) {
      return (0, index_10.IsAsyncIterator)(value);
    }
    function FromBigInt6(schema, references, value) {
      if (!(0, index_10.IsBigInt)(value))
        return false;
      if (IsDefined3(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
        return false;
      }
      if (IsDefined3(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
        return false;
      }
      if (IsDefined3(schema.maximum) && !(value <= schema.maximum)) {
        return false;
      }
      if (IsDefined3(schema.minimum) && !(value >= schema.minimum)) {
        return false;
      }
      if (IsDefined3(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
        return false;
      }
      return true;
    }
    function FromBoolean6(schema, references, value) {
      return (0, index_10.IsBoolean)(value);
    }
    function FromConstructor8(schema, references, value) {
      return Visit17(schema.returns, references, value.prototype);
    }
    function FromDate6(schema, references, value) {
      if (!(0, index_10.IsDate)(value))
        return false;
      if (IsDefined3(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
        return false;
      }
      if (IsDefined3(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
        return false;
      }
      if (IsDefined3(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
        return false;
      }
      if (IsDefined3(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
        return false;
      }
      if (IsDefined3(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
        return false;
      }
      return true;
    }
    function FromFunction7(schema, references, value) {
      return (0, index_10.IsFunction)(value);
    }
    function FromInteger6(schema, references, value) {
      if (!(0, index_10.IsInteger)(value)) {
        return false;
      }
      if (IsDefined3(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
        return false;
      }
      if (IsDefined3(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
        return false;
      }
      if (IsDefined3(schema.maximum) && !(value <= schema.maximum)) {
        return false;
      }
      if (IsDefined3(schema.minimum) && !(value >= schema.minimum)) {
        return false;
      }
      if (IsDefined3(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
        return false;
      }
      return true;
    }
    function FromIntersect18(schema, references, value) {
      const check1 = schema.allOf.every((schema2) => Visit17(schema2, references, value));
      if (schema.unevaluatedProperties === false) {
        const keyPattern = new RegExp((0, index_5.KeyOfPattern)(schema));
        const check2 = Object.getOwnPropertyNames(value).every((key2) => keyPattern.test(key2));
        return check1 && check2;
      } else if ((0, type_1.IsSchema)(schema.unevaluatedProperties)) {
        const keyCheck = new RegExp((0, index_5.KeyOfPattern)(schema));
        const check2 = Object.getOwnPropertyNames(value).every((key2) => keyCheck.test(key2) || Visit17(schema.unevaluatedProperties, references, value[key2]));
        return check1 && check2;
      } else {
        return check1;
      }
    }
    function FromIterator7(schema, references, value) {
      return (0, index_10.IsIterator)(value);
    }
    function FromLiteral7(schema, references, value) {
      return value === schema.const;
    }
    function FromNever6(schema, references, value) {
      return false;
    }
    function FromNot8(schema, references, value) {
      return !Visit17(schema.not, references, value);
    }
    function FromNull6(schema, references, value) {
      return (0, index_10.IsNull)(value);
    }
    function FromNumber6(schema, references, value) {
      if (!index_1.TypeSystemPolicy.IsNumberLike(value))
        return false;
      if (IsDefined3(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
        return false;
      }
      if (IsDefined3(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
        return false;
      }
      if (IsDefined3(schema.minimum) && !(value >= schema.minimum)) {
        return false;
      }
      if (IsDefined3(schema.maximum) && !(value <= schema.maximum)) {
        return false;
      }
      if (IsDefined3(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
        return false;
      }
      return true;
    }
    function FromObject13(schema, references, value) {
      if (!index_1.TypeSystemPolicy.IsObjectLike(value))
        return false;
      if (IsDefined3(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
        return false;
      }
      if (IsDefined3(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
        return false;
      }
      const knownKeys = Object.getOwnPropertyNames(schema.properties);
      for (const knownKey of knownKeys) {
        const property = schema.properties[knownKey];
        if (schema.required && schema.required.includes(knownKey)) {
          if (!Visit17(property, references, value[knownKey])) {
            return false;
          }
          if (((0, index_6.ExtendsUndefinedCheck)(property) || IsAnyOrUnknown2(property)) && !(knownKey in value)) {
            return false;
          }
        } else {
          if (index_1.TypeSystemPolicy.IsExactOptionalProperty(value, knownKey) && !Visit17(property, references, value[knownKey])) {
            return false;
          }
        }
      }
      if (schema.additionalProperties === false) {
        const valueKeys = Object.getOwnPropertyNames(value);
        if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {
          return true;
        } else {
          return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
        }
      } else if (typeof schema.additionalProperties === "object") {
        const valueKeys = Object.getOwnPropertyNames(value);
        return valueKeys.every((key2) => knownKeys.includes(key2) || Visit17(schema.additionalProperties, references, value[key2]));
      } else {
        return true;
      }
    }
    function FromPromise8(schema, references, value) {
      return (0, index_10.IsPromise)(value);
    }
    function FromRecord12(schema, references, value) {
      if (!index_1.TypeSystemPolicy.IsRecordLike(value)) {
        return false;
      }
      if (IsDefined3(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
        return false;
      }
      if (IsDefined3(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
        return false;
      }
      const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
      const regex2 = new RegExp(patternKey);
      const check1 = Object.entries(value).every(([key2, value2]) => {
        return regex2.test(key2) ? Visit17(patternSchema, references, value2) : true;
      });
      const check2 = typeof schema.additionalProperties === "object" ? Object.entries(value).every(([key2, value2]) => {
        return !regex2.test(key2) ? Visit17(schema.additionalProperties, references, value2) : true;
      }) : true;
      const check3 = schema.additionalProperties === false ? Object.getOwnPropertyNames(value).every((key2) => {
        return regex2.test(key2);
      }) : true;
      return check1 && check2 && check3;
    }
    function FromRef12(schema, references, value) {
      return Visit17((0, index_2.Deref)(schema, references), references, value);
    }
    function FromRegExp5(schema, references, value) {
      const regex2 = new RegExp(schema.source, schema.flags);
      if (IsDefined3(schema.minLength)) {
        if (!(value.length >= schema.minLength))
          return false;
      }
      if (IsDefined3(schema.maxLength)) {
        if (!(value.length <= schema.maxLength))
          return false;
      }
      return regex2.test(value);
    }
    function FromString6(schema, references, value) {
      if (!(0, index_10.IsString)(value)) {
        return false;
      }
      if (IsDefined3(schema.minLength)) {
        if (!(value.length >= schema.minLength))
          return false;
      }
      if (IsDefined3(schema.maxLength)) {
        if (!(value.length <= schema.maxLength))
          return false;
      }
      if (IsDefined3(schema.pattern)) {
        const regex2 = new RegExp(schema.pattern);
        if (!regex2.test(value))
          return false;
      }
      if (IsDefined3(schema.format)) {
        if (!index_7.FormatRegistry.Has(schema.format))
          return false;
        const func = index_7.FormatRegistry.Get(schema.format);
        return func(value);
      }
      return true;
    }
    function FromSymbol6(schema, references, value) {
      return (0, index_10.IsSymbol)(value);
    }
    function FromTemplateLiteral7(schema, references, value) {
      return (0, index_10.IsString)(value) && new RegExp(schema.pattern).test(value);
    }
    function FromThis11(schema, references, value) {
      return Visit17((0, index_2.Deref)(schema, references), references, value);
    }
    function FromTuple15(schema, references, value) {
      if (!(0, index_10.IsArray)(value)) {
        return false;
      }
      if (schema.items === void 0 && !(value.length === 0)) {
        return false;
      }
      if (!(value.length === schema.maxItems)) {
        return false;
      }
      if (!schema.items) {
        return true;
      }
      for (let i2 = 0; i2 < schema.items.length; i2++) {
        if (!Visit17(schema.items[i2], references, value[i2]))
          return false;
      }
      return true;
    }
    function FromUndefined6(schema, references, value) {
      return (0, index_10.IsUndefined)(value);
    }
    function FromUnion20(schema, references, value) {
      return schema.anyOf.some((inner) => Visit17(inner, references, value));
    }
    function FromUint8Array5(schema, references, value) {
      if (!(0, index_10.IsUint8Array)(value)) {
        return false;
      }
      if (IsDefined3(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
        return false;
      }
      if (IsDefined3(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
        return false;
      }
      return true;
    }
    function FromUnknown5(schema, references, value) {
      return true;
    }
    function FromVoid5(schema, references, value) {
      return index_1.TypeSystemPolicy.IsVoidLike(value);
    }
    function FromKind4(schema, references, value) {
      if (!index_7.TypeRegistry.Has(schema[index_4.Kind]))
        return false;
      const func = index_7.TypeRegistry.Get(schema[index_4.Kind]);
      return func(schema, value);
    }
    function Visit17(schema, references, value) {
      const references_ = IsDefined3(schema.$id) ? [...references, schema] : references;
      const schema_ = schema;
      switch (schema_[index_4.Kind]) {
        case "Any":
          return FromAny5(schema_, references_, value);
        case "Array":
          return FromArray16(schema_, references_, value);
        case "AsyncIterator":
          return FromAsyncIterator7(schema_, references_, value);
        case "BigInt":
          return FromBigInt6(schema_, references_, value);
        case "Boolean":
          return FromBoolean6(schema_, references_, value);
        case "Constructor":
          return FromConstructor8(schema_, references_, value);
        case "Date":
          return FromDate6(schema_, references_, value);
        case "Function":
          return FromFunction7(schema_, references_, value);
        case "Integer":
          return FromInteger6(schema_, references_, value);
        case "Intersect":
          return FromIntersect18(schema_, references_, value);
        case "Iterator":
          return FromIterator7(schema_, references_, value);
        case "Literal":
          return FromLiteral7(schema_, references_, value);
        case "Never":
          return FromNever6(schema_, references_, value);
        case "Not":
          return FromNot8(schema_, references_, value);
        case "Null":
          return FromNull6(schema_, references_, value);
        case "Number":
          return FromNumber6(schema_, references_, value);
        case "Object":
          return FromObject13(schema_, references_, value);
        case "Promise":
          return FromPromise8(schema_, references_, value);
        case "Record":
          return FromRecord12(schema_, references_, value);
        case "Ref":
          return FromRef12(schema_, references_, value);
        case "RegExp":
          return FromRegExp5(schema_, references_, value);
        case "String":
          return FromString6(schema_, references_, value);
        case "Symbol":
          return FromSymbol6(schema_, references_, value);
        case "TemplateLiteral":
          return FromTemplateLiteral7(schema_, references_, value);
        case "This":
          return FromThis11(schema_, references_, value);
        case "Tuple":
          return FromTuple15(schema_, references_, value);
        case "Undefined":
          return FromUndefined6(schema_, references_, value);
        case "Union":
          return FromUnion20(schema_, references_, value);
        case "Uint8Array":
          return FromUint8Array5(schema_, references_, value);
        case "Unknown":
          return FromUnknown5(schema_, references_, value);
        case "Void":
          return FromVoid5(schema_, references_, value);
        default:
          if (!index_7.TypeRegistry.Has(schema_[index_4.Kind]))
            throw new ValueCheckUnknownTypeError2(schema_);
          return FromKind4(schema_, references_, value);
      }
    }
    function Check3(...args) {
      return args.length === 3 ? Visit17(args[0], args[1], args[2]) : Visit17(args[0], [], args[1]);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/check/index.js
var require_check2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/value/check/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_check(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/clone/clone.js
var require_clone = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/value/clone/clone.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Clone = Clone4;
    var index_1 = require_guard2();
    function ObjectType7(value) {
      const Acc = {};
      for (const key2 of Object.getOwnPropertyNames(value)) {
        Acc[key2] = Clone4(value[key2]);
      }
      for (const key2 of Object.getOwnPropertySymbols(value)) {
        Acc[key2] = Clone4(value[key2]);
      }
      return Acc;
    }
    function ArrayType7(value) {
      return value.map((element2) => Clone4(element2));
    }
    function TypedArrayType5(value) {
      return value.slice();
    }
    function DateType5(value) {
      return new Date(value.toISOString());
    }
    function ValueType5(value) {
      return value;
    }
    function Clone4(value) {
      if ((0, index_1.IsArray)(value))
        return ArrayType7(value);
      if ((0, index_1.IsDate)(value))
        return DateType5(value);
      if ((0, index_1.IsStandardObject)(value))
        return ObjectType7(value);
      if ((0, index_1.IsTypedArray)(value))
        return TypedArrayType5(value);
      if ((0, index_1.IsValueType)(value))
        return ValueType5(value);
      throw new Error("ValueClone: Unable to clone value");
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/clone/index.js
var require_clone2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/value/clone/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_clone(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/create/create.js
var require_create = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/value/create/create.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueCreateError = void 0;
    exports.Create = Create4;
    var index_1 = require_guard2();
    var index_2 = require_check2();
    var index_3 = require_clone2();
    var index_4 = require_deref2();
    var index_5 = require_template_literal2();
    var index_6 = require_patterns2();
    var index_7 = require_registry();
    var index_8 = require_symbols2();
    var index_9 = require_error2();
    var ValueCreateError2 = class extends index_9.TypeBoxError {
      constructor(schema, message2) {
        super(message2);
        this.schema = schema;
      }
    };
    exports.ValueCreateError = ValueCreateError2;
    function FromDefault2(value) {
      return typeof value === "function" ? value : (0, index_3.Clone)(value);
    }
    function FromAny5(schema, references) {
      if ((0, index_1.HasPropertyKey)(schema, "default")) {
        return FromDefault2(schema.default);
      } else {
        return {};
      }
    }
    function FromArray16(schema, references) {
      if (schema.uniqueItems === true && !(0, index_1.HasPropertyKey)(schema, "default")) {
        throw new ValueCreateError2(schema, "Array with the uniqueItems constraint requires a default value");
      } else if ("contains" in schema && !(0, index_1.HasPropertyKey)(schema, "default")) {
        throw new ValueCreateError2(schema, "Array with the contains constraint requires a default value");
      } else if ("default" in schema) {
        return FromDefault2(schema.default);
      } else if (schema.minItems !== void 0) {
        return Array.from({ length: schema.minItems }).map((item) => {
          return Visit17(schema.items, references);
        });
      } else {
        return [];
      }
    }
    function FromAsyncIterator7(schema, references) {
      if ((0, index_1.HasPropertyKey)(schema, "default")) {
        return FromDefault2(schema.default);
      } else {
        return async function* () {
        }();
      }
    }
    function FromBigInt6(schema, references) {
      if ((0, index_1.HasPropertyKey)(schema, "default")) {
        return FromDefault2(schema.default);
      } else {
        return BigInt(0);
      }
    }
    function FromBoolean6(schema, references) {
      if ((0, index_1.HasPropertyKey)(schema, "default")) {
        return FromDefault2(schema.default);
      } else {
        return false;
      }
    }
    function FromConstructor8(schema, references) {
      if ((0, index_1.HasPropertyKey)(schema, "default")) {
        return FromDefault2(schema.default);
      } else {
        const value = Visit17(schema.returns, references);
        if (typeof value === "object" && !Array.isArray(value)) {
          return class {
            constructor() {
              for (const [key2, val2] of Object.entries(value)) {
                const self2 = this;
                self2[key2] = val2;
              }
            }
          };
        } else {
          return class {
          };
        }
      }
    }
    function FromDate6(schema, references) {
      if ((0, index_1.HasPropertyKey)(schema, "default")) {
        return FromDefault2(schema.default);
      } else if (schema.minimumTimestamp !== void 0) {
        return new Date(schema.minimumTimestamp);
      } else {
        return /* @__PURE__ */ new Date();
      }
    }
    function FromFunction7(schema, references) {
      if ((0, index_1.HasPropertyKey)(schema, "default")) {
        return FromDefault2(schema.default);
      } else {
        return () => Visit17(schema.returns, references);
      }
    }
    function FromInteger6(schema, references) {
      if ((0, index_1.HasPropertyKey)(schema, "default")) {
        return FromDefault2(schema.default);
      } else if (schema.minimum !== void 0) {
        return schema.minimum;
      } else {
        return 0;
      }
    }
    function FromIntersect18(schema, references) {
      if ((0, index_1.HasPropertyKey)(schema, "default")) {
        return FromDefault2(schema.default);
      } else {
        const value = schema.allOf.reduce((acc, schema2) => {
          const next = Visit17(schema2, references);
          return typeof next === "object" ? { ...acc, ...next } : next;
        }, {});
        if (!(0, index_2.Check)(schema, references, value))
          throw new ValueCreateError2(schema, "Intersect produced invalid value. Consider using a default value.");
        return value;
      }
    }
    function FromIterator7(schema, references) {
      if ((0, index_1.HasPropertyKey)(schema, "default")) {
        return FromDefault2(schema.default);
      } else {
        return function* () {
        }();
      }
    }
    function FromLiteral7(schema, references) {
      if ((0, index_1.HasPropertyKey)(schema, "default")) {
        return FromDefault2(schema.default);
      } else {
        return schema.const;
      }
    }
    function FromNever6(schema, references) {
      if ((0, index_1.HasPropertyKey)(schema, "default")) {
        return FromDefault2(schema.default);
      } else {
        throw new ValueCreateError2(schema, "Never types cannot be created. Consider using a default value.");
      }
    }
    function FromNot8(schema, references) {
      if ((0, index_1.HasPropertyKey)(schema, "default")) {
        return FromDefault2(schema.default);
      } else {
        throw new ValueCreateError2(schema, "Not types must have a default value");
      }
    }
    function FromNull6(schema, references) {
      if ((0, index_1.HasPropertyKey)(schema, "default")) {
        return FromDefault2(schema.default);
      } else {
        return null;
      }
    }
    function FromNumber6(schema, references) {
      if ((0, index_1.HasPropertyKey)(schema, "default")) {
        return FromDefault2(schema.default);
      } else if (schema.minimum !== void 0) {
        return schema.minimum;
      } else {
        return 0;
      }
    }
    function FromObject13(schema, references) {
      if ((0, index_1.HasPropertyKey)(schema, "default")) {
        return FromDefault2(schema.default);
      } else {
        const required = new Set(schema.required);
        const Acc = {};
        for (const [key2, subschema] of Object.entries(schema.properties)) {
          if (!required.has(key2))
            continue;
          Acc[key2] = Visit17(subschema, references);
        }
        return Acc;
      }
    }
    function FromPromise8(schema, references) {
      if ((0, index_1.HasPropertyKey)(schema, "default")) {
        return FromDefault2(schema.default);
      } else {
        return Promise.resolve(Visit17(schema.item, references));
      }
    }
    function FromRecord12(schema, references) {
      const [keyPattern, valueSchema] = Object.entries(schema.patternProperties)[0];
      if ((0, index_1.HasPropertyKey)(schema, "default")) {
        return FromDefault2(schema.default);
      } else if (!(keyPattern === index_6.PatternStringExact || keyPattern === index_6.PatternNumberExact)) {
        const propertyKeys = keyPattern.slice(1, keyPattern.length - 1).split("|");
        const Acc = {};
        for (const key2 of propertyKeys)
          Acc[key2] = Visit17(valueSchema, references);
        return Acc;
      } else {
        return {};
      }
    }
    function FromRef12(schema, references) {
      if ((0, index_1.HasPropertyKey)(schema, "default")) {
        return FromDefault2(schema.default);
      } else {
        return Visit17((0, index_4.Deref)(schema, references), references);
      }
    }
    function FromRegExp5(schema, references) {
      if ((0, index_1.HasPropertyKey)(schema, "default")) {
        return FromDefault2(schema.default);
      } else {
        throw new ValueCreateError2(schema, "RegExp types cannot be created. Consider using a default value.");
      }
    }
    function FromString6(schema, references) {
      if (schema.pattern !== void 0) {
        if (!(0, index_1.HasPropertyKey)(schema, "default")) {
          throw new ValueCreateError2(schema, "String types with patterns must specify a default value");
        } else {
          return FromDefault2(schema.default);
        }
      } else if (schema.format !== void 0) {
        if (!(0, index_1.HasPropertyKey)(schema, "default")) {
          throw new ValueCreateError2(schema, "String types with formats must specify a default value");
        } else {
          return FromDefault2(schema.default);
        }
      } else {
        if ((0, index_1.HasPropertyKey)(schema, "default")) {
          return FromDefault2(schema.default);
        } else if (schema.minLength !== void 0) {
          return Array.from({ length: schema.minLength }).map(() => " ").join("");
        } else {
          return "";
        }
      }
    }
    function FromSymbol6(schema, references) {
      if ((0, index_1.HasPropertyKey)(schema, "default")) {
        return FromDefault2(schema.default);
      } else if ("value" in schema) {
        return Symbol.for(schema.value);
      } else {
        return Symbol();
      }
    }
    function FromTemplateLiteral7(schema, references) {
      if ((0, index_1.HasPropertyKey)(schema, "default")) {
        return FromDefault2(schema.default);
      }
      if (!(0, index_5.IsTemplateLiteralFinite)(schema))
        throw new ValueCreateError2(schema, "Can only create template literals that produce a finite variants. Consider using a default value.");
      const generated = (0, index_5.TemplateLiteralGenerate)(schema);
      return generated[0];
    }
    function FromThis11(schema, references) {
      if (recursiveDepth2++ > recursiveMaxDepth2)
        throw new ValueCreateError2(schema, "Cannot create recursive type as it appears possibly infinite. Consider using a default.");
      if ((0, index_1.HasPropertyKey)(schema, "default")) {
        return FromDefault2(schema.default);
      } else {
        return Visit17((0, index_4.Deref)(schema, references), references);
      }
    }
    function FromTuple15(schema, references) {
      if ((0, index_1.HasPropertyKey)(schema, "default")) {
        return FromDefault2(schema.default);
      }
      if (schema.items === void 0) {
        return [];
      } else {
        return Array.from({ length: schema.minItems }).map((_, index3) => Visit17(schema.items[index3], references));
      }
    }
    function FromUndefined6(schema, references) {
      if ((0, index_1.HasPropertyKey)(schema, "default")) {
        return FromDefault2(schema.default);
      } else {
        return void 0;
      }
    }
    function FromUnion20(schema, references) {
      if ((0, index_1.HasPropertyKey)(schema, "default")) {
        return FromDefault2(schema.default);
      } else if (schema.anyOf.length === 0) {
        throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
      } else {
        return Visit17(schema.anyOf[0], references);
      }
    }
    function FromUint8Array5(schema, references) {
      if ((0, index_1.HasPropertyKey)(schema, "default")) {
        return FromDefault2(schema.default);
      } else if (schema.minByteLength !== void 0) {
        return new Uint8Array(schema.minByteLength);
      } else {
        return new Uint8Array(0);
      }
    }
    function FromUnknown5(schema, references) {
      if ((0, index_1.HasPropertyKey)(schema, "default")) {
        return FromDefault2(schema.default);
      } else {
        return {};
      }
    }
    function FromVoid5(schema, references) {
      if ((0, index_1.HasPropertyKey)(schema, "default")) {
        return FromDefault2(schema.default);
      } else {
        return void 0;
      }
    }
    function FromKind4(schema, references) {
      if ((0, index_1.HasPropertyKey)(schema, "default")) {
        return FromDefault2(schema.default);
      } else {
        throw new Error("User defined types must specify a default value");
      }
    }
    function Visit17(schema, references) {
      const references_ = (0, index_1.IsString)(schema.$id) ? [...references, schema] : references;
      const schema_ = schema;
      switch (schema_[index_8.Kind]) {
        case "Any":
          return FromAny5(schema_, references_);
        case "Array":
          return FromArray16(schema_, references_);
        case "AsyncIterator":
          return FromAsyncIterator7(schema_, references_);
        case "BigInt":
          return FromBigInt6(schema_, references_);
        case "Boolean":
          return FromBoolean6(schema_, references_);
        case "Constructor":
          return FromConstructor8(schema_, references_);
        case "Date":
          return FromDate6(schema_, references_);
        case "Function":
          return FromFunction7(schema_, references_);
        case "Integer":
          return FromInteger6(schema_, references_);
        case "Intersect":
          return FromIntersect18(schema_, references_);
        case "Iterator":
          return FromIterator7(schema_, references_);
        case "Literal":
          return FromLiteral7(schema_, references_);
        case "Never":
          return FromNever6(schema_, references_);
        case "Not":
          return FromNot8(schema_, references_);
        case "Null":
          return FromNull6(schema_, references_);
        case "Number":
          return FromNumber6(schema_, references_);
        case "Object":
          return FromObject13(schema_, references_);
        case "Promise":
          return FromPromise8(schema_, references_);
        case "Record":
          return FromRecord12(schema_, references_);
        case "Ref":
          return FromRef12(schema_, references_);
        case "RegExp":
          return FromRegExp5(schema_, references_);
        case "String":
          return FromString6(schema_, references_);
        case "Symbol":
          return FromSymbol6(schema_, references_);
        case "TemplateLiteral":
          return FromTemplateLiteral7(schema_, references_);
        case "This":
          return FromThis11(schema_, references_);
        case "Tuple":
          return FromTuple15(schema_, references_);
        case "Undefined":
          return FromUndefined6(schema_, references_);
        case "Union":
          return FromUnion20(schema_, references_);
        case "Uint8Array":
          return FromUint8Array5(schema_, references_);
        case "Unknown":
          return FromUnknown5(schema_, references_);
        case "Void":
          return FromVoid5(schema_, references_);
        default:
          if (!index_7.TypeRegistry.Has(schema_[index_8.Kind]))
            throw new ValueCreateError2(schema_, "Unknown type");
          return FromKind4(schema_, references_);
      }
    }
    var recursiveMaxDepth2 = 512;
    var recursiveDepth2 = 0;
    function Create4(...args) {
      recursiveDepth2 = 0;
      return args.length === 2 ? Visit17(args[0], args[1]) : Visit17(args[0], []);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/create/index.js
var require_create2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/value/create/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_create(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/cast/cast.js
var require_cast = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/value/cast/cast.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueCastError = void 0;
    exports.Cast = Cast3;
    var index_1 = require_guard2();
    var index_2 = require_error2();
    var index_3 = require_symbols2();
    var index_4 = require_create2();
    var index_5 = require_check2();
    var index_6 = require_clone2();
    var index_7 = require_deref2();
    var ValueCastError2 = class extends index_2.TypeBoxError {
      constructor(schema, message2) {
        super(message2);
        this.schema = schema;
      }
    };
    exports.ValueCastError = ValueCastError2;
    function ScoreUnion2(schema, references, value) {
      if (schema[index_3.Kind] === "Object" && typeof value === "object" && !(0, index_1.IsNull)(value)) {
        const object = schema;
        const keys3 = Object.getOwnPropertyNames(value);
        const entries = Object.entries(object.properties);
        const [point5, max] = [1 / entries.length, entries.length];
        return entries.reduce((acc, [key2, schema2]) => {
          const literal = schema2[index_3.Kind] === "Literal" && schema2.const === value[key2] ? max : 0;
          const checks2 = (0, index_5.Check)(schema2, references, value[key2]) ? point5 : 0;
          const exists2 = keys3.includes(key2) ? point5 : 0;
          return acc + (literal + checks2 + exists2);
        }, 0);
      } else {
        return (0, index_5.Check)(schema, references, value) ? 1 : 0;
      }
    }
    function SelectUnion2(union2, references, value) {
      const schemas = union2.anyOf.map((schema) => (0, index_7.Deref)(schema, references));
      let [select, best] = [schemas[0], 0];
      for (const schema of schemas) {
        const score = ScoreUnion2(schema, references, value);
        if (score > best) {
          select = schema;
          best = score;
        }
      }
      return select;
    }
    function CastUnion2(union2, references, value) {
      if ("default" in union2) {
        return typeof value === "function" ? union2.default : (0, index_6.Clone)(union2.default);
      } else {
        const schema = SelectUnion2(union2, references, value);
        return Cast3(schema, references, value);
      }
    }
    function DefaultClone2(schema, references, value) {
      return (0, index_5.Check)(schema, references, value) ? (0, index_6.Clone)(value) : (0, index_4.Create)(schema, references);
    }
    function Default7(schema, references, value) {
      return (0, index_5.Check)(schema, references, value) ? value : (0, index_4.Create)(schema, references);
    }
    function FromArray16(schema, references, value) {
      if ((0, index_5.Check)(schema, references, value))
        return (0, index_6.Clone)(value);
      const created = (0, index_1.IsArray)(value) ? (0, index_6.Clone)(value) : (0, index_4.Create)(schema, references);
      const minimum = (0, index_1.IsNumber)(schema.minItems) && created.length < schema.minItems ? [...created, ...Array.from({ length: schema.minItems - created.length }, () => null)] : created;
      const maximum = (0, index_1.IsNumber)(schema.maxItems) && minimum.length > schema.maxItems ? minimum.slice(0, schema.maxItems) : minimum;
      const casted = maximum.map((value2) => Visit17(schema.items, references, value2));
      if (schema.uniqueItems !== true)
        return casted;
      const unique = [...new Set(casted)];
      if (!(0, index_5.Check)(schema, references, unique))
        throw new ValueCastError2(schema, "Array cast produced invalid data due to uniqueItems constraint");
      return unique;
    }
    function FromConstructor8(schema, references, value) {
      if ((0, index_5.Check)(schema, references, value))
        return (0, index_4.Create)(schema, references);
      const required = new Set(schema.returns.required || []);
      const result = function() {
      };
      for (const [key2, property] of Object.entries(schema.returns.properties)) {
        if (!required.has(key2) && value.prototype[key2] === void 0)
          continue;
        result.prototype[key2] = Visit17(property, references, value.prototype[key2]);
      }
      return result;
    }
    function FromIntersect18(schema, references, value) {
      const created = (0, index_4.Create)(schema, references);
      const mapped = (0, index_1.IsStandardObject)(created) && (0, index_1.IsStandardObject)(value) ? { ...created, ...value } : value;
      return (0, index_5.Check)(schema, references, mapped) ? mapped : (0, index_4.Create)(schema, references);
    }
    function FromNever6(schema, references, value) {
      throw new ValueCastError2(schema, "Never types cannot be cast");
    }
    function FromObject13(schema, references, value) {
      if ((0, index_5.Check)(schema, references, value))
        return value;
      if (value === null || typeof value !== "object")
        return (0, index_4.Create)(schema, references);
      const required = new Set(schema.required || []);
      const result = {};
      for (const [key2, property] of Object.entries(schema.properties)) {
        if (!required.has(key2) && value[key2] === void 0)
          continue;
        result[key2] = Visit17(property, references, value[key2]);
      }
      if (typeof schema.additionalProperties === "object") {
        const propertyNames = Object.getOwnPropertyNames(schema.properties);
        for (const propertyName of Object.getOwnPropertyNames(value)) {
          if (propertyNames.includes(propertyName))
            continue;
          result[propertyName] = Visit17(schema.additionalProperties, references, value[propertyName]);
        }
      }
      return result;
    }
    function FromRecord12(schema, references, value) {
      if ((0, index_5.Check)(schema, references, value))
        return (0, index_6.Clone)(value);
      if (value === null || typeof value !== "object" || Array.isArray(value) || value instanceof Date)
        return (0, index_4.Create)(schema, references);
      const subschemaPropertyName = Object.getOwnPropertyNames(schema.patternProperties)[0];
      const subschema = schema.patternProperties[subschemaPropertyName];
      const result = {};
      for (const [propKey, propValue] of Object.entries(value)) {
        result[propKey] = Visit17(subschema, references, propValue);
      }
      return result;
    }
    function FromRef12(schema, references, value) {
      return Visit17((0, index_7.Deref)(schema, references), references, value);
    }
    function FromThis11(schema, references, value) {
      return Visit17((0, index_7.Deref)(schema, references), references, value);
    }
    function FromTuple15(schema, references, value) {
      if ((0, index_5.Check)(schema, references, value))
        return (0, index_6.Clone)(value);
      if (!(0, index_1.IsArray)(value))
        return (0, index_4.Create)(schema, references);
      if (schema.items === void 0)
        return [];
      return schema.items.map((schema2, index3) => Visit17(schema2, references, value[index3]));
    }
    function FromUnion20(schema, references, value) {
      return (0, index_5.Check)(schema, references, value) ? (0, index_6.Clone)(value) : CastUnion2(schema, references, value);
    }
    function Visit17(schema, references, value) {
      const references_ = (0, index_1.IsString)(schema.$id) ? [...references, schema] : references;
      const schema_ = schema;
      switch (schema[index_3.Kind]) {
        case "Array":
          return FromArray16(schema_, references_, value);
        case "Constructor":
          return FromConstructor8(schema_, references_, value);
        case "Intersect":
          return FromIntersect18(schema_, references_, value);
        case "Never":
          return FromNever6(schema_, references_, value);
        case "Object":
          return FromObject13(schema_, references_, value);
        case "Record":
          return FromRecord12(schema_, references_, value);
        case "Ref":
          return FromRef12(schema_, references_, value);
        case "This":
          return FromThis11(schema_, references_, value);
        case "Tuple":
          return FromTuple15(schema_, references_, value);
        case "Union":
          return FromUnion20(schema_, references_, value);
        case "Date":
        case "Symbol":
        case "Uint8Array":
          return DefaultClone2(schema, references, value);
        default:
          return Default7(schema_, references_, value);
      }
    }
    function Cast3(...args) {
      return args.length === 3 ? Visit17(args[0], args[1], args[2]) : Visit17(args[0], [], args[1]);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/cast/index.js
var require_cast2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/value/cast/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_cast(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/clean/clean.js
var require_clean = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/value/clean/clean.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Clean = Clean3;
    var index_1 = require_keyof2();
    var index_2 = require_check2();
    var index_3 = require_clone2();
    var index_4 = require_deref2();
    var index_5 = require_symbols2();
    var index_6 = require_guard2();
    var type_1 = require_type3();
    function IsCheckable3(schema) {
      return (0, type_1.IsSchema)(schema) && schema[index_5.Kind] !== "Unsafe";
    }
    function FromArray16(schema, references, value) {
      if (!(0, index_6.IsArray)(value))
        return value;
      return value.map((value2) => Visit17(schema.items, references, value2));
    }
    function FromIntersect18(schema, references, value) {
      const unevaluatedProperties = schema.unevaluatedProperties;
      const intersections = schema.allOf.map((schema2) => Visit17(schema2, references, (0, index_3.Clone)(value)));
      const composite = intersections.reduce((acc, value2) => (0, index_6.IsObject)(value2) ? { ...acc, ...value2 } : value2, {});
      if (!(0, index_6.IsObject)(value) || !(0, index_6.IsObject)(composite) || !(0, type_1.IsSchema)(unevaluatedProperties))
        return composite;
      const knownkeys = (0, index_1.KeyOfPropertyKeys)(schema);
      for (const key2 of Object.getOwnPropertyNames(value)) {
        if (knownkeys.includes(key2))
          continue;
        if ((0, index_2.Check)(unevaluatedProperties, references, value[key2])) {
          composite[key2] = Visit17(unevaluatedProperties, references, value[key2]);
        }
      }
      return composite;
    }
    function FromObject13(schema, references, value) {
      if (!(0, index_6.IsObject)(value) || (0, index_6.IsArray)(value))
        return value;
      const additionalProperties = schema.additionalProperties;
      for (const key2 of Object.getOwnPropertyNames(value)) {
        if (key2 in schema.properties) {
          value[key2] = Visit17(schema.properties[key2], references, value[key2]);
          continue;
        }
        if ((0, type_1.IsSchema)(additionalProperties) && (0, index_2.Check)(additionalProperties, references, value[key2])) {
          value[key2] = Visit17(additionalProperties, references, value[key2]);
          continue;
        }
        delete value[key2];
      }
      return value;
    }
    function FromRecord12(schema, references, value) {
      if (!(0, index_6.IsObject)(value))
        return value;
      const additionalProperties = schema.additionalProperties;
      const propertyKeys = Object.getOwnPropertyNames(value);
      const [propertyKey, propertySchema] = Object.entries(schema.patternProperties)[0];
      const propertyKeyTest = new RegExp(propertyKey);
      for (const key2 of propertyKeys) {
        if (propertyKeyTest.test(key2)) {
          value[key2] = Visit17(propertySchema, references, value[key2]);
          continue;
        }
        if ((0, type_1.IsSchema)(additionalProperties) && (0, index_2.Check)(additionalProperties, references, value[key2])) {
          value[key2] = Visit17(additionalProperties, references, value[key2]);
          continue;
        }
        delete value[key2];
      }
      return value;
    }
    function FromRef12(schema, references, value) {
      return Visit17((0, index_4.Deref)(schema, references), references, value);
    }
    function FromThis11(schema, references, value) {
      return Visit17((0, index_4.Deref)(schema, references), references, value);
    }
    function FromTuple15(schema, references, value) {
      if (!(0, index_6.IsArray)(value))
        return value;
      if ((0, index_6.IsUndefined)(schema.items))
        return [];
      const length = Math.min(value.length, schema.items.length);
      for (let i2 = 0; i2 < length; i2++) {
        value[i2] = Visit17(schema.items[i2], references, value[i2]);
      }
      return value.length > length ? value.slice(0, length) : value;
    }
    function FromUnion20(schema, references, value) {
      for (const inner of schema.anyOf) {
        if (IsCheckable3(inner) && (0, index_2.Check)(inner, references, value)) {
          return Visit17(inner, references, value);
        }
      }
      return value;
    }
    function Visit17(schema, references, value) {
      const references_ = (0, index_6.IsString)(schema.$id) ? [...references, schema] : references;
      const schema_ = schema;
      switch (schema_[index_5.Kind]) {
        case "Array":
          return FromArray16(schema_, references_, value);
        case "Intersect":
          return FromIntersect18(schema_, references_, value);
        case "Object":
          return FromObject13(schema_, references_, value);
        case "Record":
          return FromRecord12(schema_, references_, value);
        case "Ref":
          return FromRef12(schema_, references_, value);
        case "This":
          return FromThis11(schema_, references_, value);
        case "Tuple":
          return FromTuple15(schema_, references_, value);
        case "Union":
          return FromUnion20(schema_, references_, value);
        default:
          return value;
      }
    }
    function Clean3(...args) {
      return args.length === 3 ? Visit17(args[0], args[1], args[2]) : Visit17(args[0], [], args[1]);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/clean/index.js
var require_clean2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/value/clean/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_clean(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/convert/convert.js
var require_convert = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/value/convert/convert.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Convert = Convert3;
    var index_1 = require_clone2();
    var index_2 = require_check2();
    var index_3 = require_deref2();
    var index_4 = require_symbols2();
    var index_5 = require_guard2();
    function IsStringNumeric2(value) {
      return (0, index_5.IsString)(value) && !isNaN(value) && !isNaN(parseFloat(value));
    }
    function IsValueToString2(value) {
      return (0, index_5.IsBigInt)(value) || (0, index_5.IsBoolean)(value) || (0, index_5.IsNumber)(value);
    }
    function IsValueTrue2(value) {
      return value === true || (0, index_5.IsNumber)(value) && value === 1 || (0, index_5.IsBigInt)(value) && value === BigInt("1") || (0, index_5.IsString)(value) && (value.toLowerCase() === "true" || value === "1");
    }
    function IsValueFalse2(value) {
      return value === false || (0, index_5.IsNumber)(value) && (value === 0 || Object.is(value, -0)) || (0, index_5.IsBigInt)(value) && value === BigInt("0") || (0, index_5.IsString)(value) && (value.toLowerCase() === "false" || value === "0" || value === "-0");
    }
    function IsTimeStringWithTimeZone2(value) {
      return (0, index_5.IsString)(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
    }
    function IsTimeStringWithoutTimeZone2(value) {
      return (0, index_5.IsString)(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
    }
    function IsDateTimeStringWithTimeZone2(value) {
      return (0, index_5.IsString)(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
    }
    function IsDateTimeStringWithoutTimeZone2(value) {
      return (0, index_5.IsString)(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
    }
    function IsDateString2(value) {
      return (0, index_5.IsString)(value) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(value);
    }
    function TryConvertLiteralString2(value, target) {
      const conversion = TryConvertString2(value);
      return conversion === target ? conversion : value;
    }
    function TryConvertLiteralNumber2(value, target) {
      const conversion = TryConvertNumber2(value);
      return conversion === target ? conversion : value;
    }
    function TryConvertLiteralBoolean2(value, target) {
      const conversion = TryConvertBoolean2(value);
      return conversion === target ? conversion : value;
    }
    function TryConvertLiteral2(schema, value) {
      return (0, index_5.IsString)(schema.const) ? TryConvertLiteralString2(value, schema.const) : (0, index_5.IsNumber)(schema.const) ? TryConvertLiteralNumber2(value, schema.const) : (0, index_5.IsBoolean)(schema.const) ? TryConvertLiteralBoolean2(value, schema.const) : (0, index_1.Clone)(value);
    }
    function TryConvertBoolean2(value) {
      return IsValueTrue2(value) ? true : IsValueFalse2(value) ? false : value;
    }
    function TryConvertBigInt2(value) {
      return IsStringNumeric2(value) ? BigInt(parseInt(value)) : (0, index_5.IsNumber)(value) ? BigInt(value | 0) : IsValueFalse2(value) ? BigInt(0) : IsValueTrue2(value) ? BigInt(1) : value;
    }
    function TryConvertString2(value) {
      return IsValueToString2(value) ? value.toString() : (0, index_5.IsSymbol)(value) && value.description !== void 0 ? value.description.toString() : value;
    }
    function TryConvertNumber2(value) {
      return IsStringNumeric2(value) ? parseFloat(value) : IsValueTrue2(value) ? 1 : IsValueFalse2(value) ? 0 : value;
    }
    function TryConvertInteger2(value) {
      return IsStringNumeric2(value) ? parseInt(value) : (0, index_5.IsNumber)(value) ? value | 0 : IsValueTrue2(value) ? 1 : IsValueFalse2(value) ? 0 : value;
    }
    function TryConvertNull2(value) {
      return (0, index_5.IsString)(value) && value.toLowerCase() === "null" ? null : value;
    }
    function TryConvertUndefined2(value) {
      return (0, index_5.IsString)(value) && value === "undefined" ? void 0 : value;
    }
    function TryConvertDate2(value) {
      return (0, index_5.IsDate)(value) ? value : (0, index_5.IsNumber)(value) ? new Date(value) : IsValueTrue2(value) ? /* @__PURE__ */ new Date(1) : IsValueFalse2(value) ? /* @__PURE__ */ new Date(0) : IsStringNumeric2(value) ? new Date(parseInt(value)) : IsTimeStringWithoutTimeZone2(value) ? /* @__PURE__ */ new Date(`1970-01-01T${value}.000Z`) : IsTimeStringWithTimeZone2(value) ? /* @__PURE__ */ new Date(`1970-01-01T${value}`) : IsDateTimeStringWithoutTimeZone2(value) ? /* @__PURE__ */ new Date(`${value}.000Z`) : IsDateTimeStringWithTimeZone2(value) ? new Date(value) : IsDateString2(value) ? /* @__PURE__ */ new Date(`${value}T00:00:00.000Z`) : value;
    }
    function Default7(value) {
      return value;
    }
    function FromArray16(schema, references, value) {
      const elements = (0, index_5.IsArray)(value) ? value : [value];
      return elements.map((element2) => Visit17(schema.items, references, element2));
    }
    function FromBigInt6(schema, references, value) {
      return TryConvertBigInt2(value);
    }
    function FromBoolean6(schema, references, value) {
      return TryConvertBoolean2(value);
    }
    function FromDate6(schema, references, value) {
      return TryConvertDate2(value);
    }
    function FromInteger6(schema, references, value) {
      return TryConvertInteger2(value);
    }
    function FromIntersect18(schema, references, value) {
      return schema.allOf.reduce((value2, schema2) => Visit17(schema2, references, value2), value);
    }
    function FromLiteral7(schema, references, value) {
      return TryConvertLiteral2(schema, value);
    }
    function FromNull6(schema, references, value) {
      return TryConvertNull2(value);
    }
    function FromNumber6(schema, references, value) {
      return TryConvertNumber2(value);
    }
    function FromObject13(schema, references, value) {
      const isConvertable = (0, index_5.IsObject)(value);
      if (!isConvertable)
        return value;
      const result = {};
      for (const key2 of Object.keys(value)) {
        result[key2] = (0, index_5.HasPropertyKey)(schema.properties, key2) ? Visit17(schema.properties[key2], references, value[key2]) : value[key2];
      }
      return result;
    }
    function FromRecord12(schema, references, value) {
      const propertyKey = Object.getOwnPropertyNames(schema.patternProperties)[0];
      const property = schema.patternProperties[propertyKey];
      const result = {};
      for (const [propKey, propValue] of Object.entries(value)) {
        result[propKey] = Visit17(property, references, propValue);
      }
      return result;
    }
    function FromRef12(schema, references, value) {
      return Visit17((0, index_3.Deref)(schema, references), references, value);
    }
    function FromString6(schema, references, value) {
      return TryConvertString2(value);
    }
    function FromSymbol6(schema, references, value) {
      return (0, index_5.IsString)(value) || (0, index_5.IsNumber)(value) ? Symbol(value) : value;
    }
    function FromThis11(schema, references, value) {
      return Visit17((0, index_3.Deref)(schema, references), references, value);
    }
    function FromTuple15(schema, references, value) {
      const isConvertable = (0, index_5.IsArray)(value) && !(0, index_5.IsUndefined)(schema.items);
      if (!isConvertable)
        return value;
      return value.map((value2, index3) => {
        return index3 < schema.items.length ? Visit17(schema.items[index3], references, value2) : value2;
      });
    }
    function FromUndefined6(schema, references, value) {
      return TryConvertUndefined2(value);
    }
    function FromUnion20(schema, references, value) {
      for (const subschema of schema.anyOf) {
        const converted = Visit17(subschema, references, value);
        if (!(0, index_2.Check)(subschema, references, converted))
          continue;
        return converted;
      }
      return value;
    }
    function Visit17(schema, references, value) {
      const references_ = (0, index_5.IsString)(schema.$id) ? [...references, schema] : references;
      const schema_ = schema;
      switch (schema[index_4.Kind]) {
        case "Array":
          return FromArray16(schema_, references_, value);
        case "BigInt":
          return FromBigInt6(schema_, references_, value);
        case "Boolean":
          return FromBoolean6(schema_, references_, value);
        case "Date":
          return FromDate6(schema_, references_, value);
        case "Integer":
          return FromInteger6(schema_, references_, value);
        case "Intersect":
          return FromIntersect18(schema_, references_, value);
        case "Literal":
          return FromLiteral7(schema_, references_, value);
        case "Null":
          return FromNull6(schema_, references_, value);
        case "Number":
          return FromNumber6(schema_, references_, value);
        case "Object":
          return FromObject13(schema_, references_, value);
        case "Record":
          return FromRecord12(schema_, references_, value);
        case "Ref":
          return FromRef12(schema_, references_, value);
        case "String":
          return FromString6(schema_, references_, value);
        case "Symbol":
          return FromSymbol6(schema_, references_, value);
        case "This":
          return FromThis11(schema_, references_, value);
        case "Tuple":
          return FromTuple15(schema_, references_, value);
        case "Undefined":
          return FromUndefined6(schema_, references_, value);
        case "Union":
          return FromUnion20(schema_, references_, value);
        default:
          return Default7(value);
      }
    }
    function Convert3(...args) {
      return args.length === 3 ? Visit17(args[0], args[1], args[2]) : Visit17(args[0], [], args[1]);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/convert/index.js
var require_convert2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/value/convert/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_convert(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/default/default.js
var require_default = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/value/default/default.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Default = Default7;
    var index_1 = require_check2();
    var index_2 = require_clone2();
    var index_3 = require_deref2();
    var index_4 = require_symbols2();
    var index_5 = require_guard2();
    var type_1 = require_type3();
    function ValueOrDefault2(schema, value) {
      return value === void 0 && "default" in schema ? (0, index_2.Clone)(schema.default) : value;
    }
    function IsCheckable3(schema) {
      return (0, type_1.IsSchema)(schema) && schema[index_4.Kind] !== "Unsafe";
    }
    function IsDefaultSchema2(value) {
      return (0, type_1.IsSchema)(value) && "default" in value;
    }
    function FromArray16(schema, references, value) {
      const defaulted = ValueOrDefault2(schema, value);
      if (!(0, index_5.IsArray)(defaulted))
        return defaulted;
      for (let i2 = 0; i2 < defaulted.length; i2++) {
        defaulted[i2] = Visit17(schema.items, references, defaulted[i2]);
      }
      return defaulted;
    }
    function FromIntersect18(schema, references, value) {
      const defaulted = ValueOrDefault2(schema, value);
      return schema.allOf.reduce((acc, schema2) => {
        const next = Visit17(schema2, references, defaulted);
        return (0, index_5.IsObject)(next) ? { ...acc, ...next } : next;
      }, {});
    }
    function FromObject13(schema, references, value) {
      const defaulted = ValueOrDefault2(schema, value);
      if (!(0, index_5.IsObject)(defaulted))
        return defaulted;
      const additionalPropertiesSchema = schema.additionalProperties;
      const knownPropertyKeys = Object.getOwnPropertyNames(schema.properties);
      for (const key2 of knownPropertyKeys) {
        if (!IsDefaultSchema2(schema.properties[key2]))
          continue;
        defaulted[key2] = Visit17(schema.properties[key2], references, defaulted[key2]);
      }
      if (!IsDefaultSchema2(additionalPropertiesSchema))
        return defaulted;
      for (const key2 of Object.getOwnPropertyNames(defaulted)) {
        if (knownPropertyKeys.includes(key2))
          continue;
        defaulted[key2] = Visit17(additionalPropertiesSchema, references, defaulted[key2]);
      }
      return defaulted;
    }
    function FromRecord12(schema, references, value) {
      const defaulted = ValueOrDefault2(schema, value);
      if (!(0, index_5.IsObject)(defaulted))
        return defaulted;
      const additionalPropertiesSchema = schema.additionalProperties;
      const [propertyKeyPattern, propertySchema] = Object.entries(schema.patternProperties)[0];
      const knownPropertyKey = new RegExp(propertyKeyPattern);
      for (const key2 of Object.getOwnPropertyNames(defaulted)) {
        if (!(knownPropertyKey.test(key2) && IsDefaultSchema2(propertySchema)))
          continue;
        defaulted[key2] = Visit17(propertySchema, references, defaulted[key2]);
      }
      if (!IsDefaultSchema2(additionalPropertiesSchema))
        return defaulted;
      for (const key2 of Object.getOwnPropertyNames(defaulted)) {
        if (knownPropertyKey.test(key2))
          continue;
        defaulted[key2] = Visit17(additionalPropertiesSchema, references, defaulted[key2]);
      }
      return defaulted;
    }
    function FromRef12(schema, references, value) {
      return Visit17((0, index_3.Deref)(schema, references), references, ValueOrDefault2(schema, value));
    }
    function FromThis11(schema, references, value) {
      return Visit17((0, index_3.Deref)(schema, references), references, value);
    }
    function FromTuple15(schema, references, value) {
      const defaulted = ValueOrDefault2(schema, value);
      if (!(0, index_5.IsArray)(defaulted) || (0, index_5.IsUndefined)(schema.items))
        return defaulted;
      const [items, max] = [schema.items, Math.max(schema.items.length, defaulted.length)];
      for (let i2 = 0; i2 < max; i2++) {
        if (i2 < items.length)
          defaulted[i2] = Visit17(items[i2], references, defaulted[i2]);
      }
      return defaulted;
    }
    function FromUnion20(schema, references, value) {
      const defaulted = ValueOrDefault2(schema, value);
      for (const inner of schema.anyOf) {
        const result = Visit17(inner, references, defaulted);
        if (IsCheckable3(inner) && (0, index_1.Check)(inner, result)) {
          return result;
        }
      }
      return defaulted;
    }
    function Visit17(schema, references, value) {
      const references_ = (0, index_5.IsString)(schema.$id) ? [...references, schema] : references;
      const schema_ = schema;
      switch (schema_[index_4.Kind]) {
        case "Array":
          return FromArray16(schema_, references_, value);
        case "Intersect":
          return FromIntersect18(schema_, references_, value);
        case "Object":
          return FromObject13(schema_, references_, value);
        case "Record":
          return FromRecord12(schema_, references_, value);
        case "Ref":
          return FromRef12(schema_, references_, value);
        case "This":
          return FromThis11(schema_, references_, value);
        case "Tuple":
          return FromTuple15(schema_, references_, value);
        case "Union":
          return FromUnion20(schema_, references_, value);
        default:
          return ValueOrDefault2(schema_, value);
      }
    }
    function Default7(...args) {
      return args.length === 3 ? Visit17(args[0], args[1], args[2]) : Visit17(args[0], [], args[1]);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/default/index.js
var require_default2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/value/default/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_default(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/pointer/pointer.js
var require_pointer = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/value/pointer/pointer.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValuePointerRootDeleteError = exports.ValuePointerRootSetError = void 0;
    exports.Format = Format2;
    exports.Set = Set5;
    exports.Delete = Delete5;
    exports.Has = Has4;
    exports.Get = Get4;
    var index_1 = require_error2();
    var ValuePointerRootSetError2 = class extends index_1.TypeBoxError {
      constructor(value, path2, update) {
        super("Cannot set root value");
        this.value = value;
        this.path = path2;
        this.update = update;
      }
    };
    exports.ValuePointerRootSetError = ValuePointerRootSetError2;
    var ValuePointerRootDeleteError2 = class extends index_1.TypeBoxError {
      constructor(value, path2) {
        super("Cannot delete root value");
        this.value = value;
        this.path = path2;
      }
    };
    exports.ValuePointerRootDeleteError = ValuePointerRootDeleteError2;
    function Escape3(component) {
      return component.indexOf("~") === -1 ? component : component.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    function* Format2(pointer) {
      if (pointer === "")
        return;
      let [start, end] = [0, 0];
      for (let i2 = 0; i2 < pointer.length; i2++) {
        const char = pointer.charAt(i2);
        if (char === "/") {
          if (i2 === 0) {
            start = i2 + 1;
          } else {
            end = i2;
            yield Escape3(pointer.slice(start, end));
            start = i2 + 1;
          }
        } else {
          end = i2;
        }
      }
      yield Escape3(pointer.slice(start));
    }
    function Set5(value, pointer, update) {
      if (pointer === "")
        throw new ValuePointerRootSetError2(value, pointer, update);
      let [owner, next, key2] = [null, value, ""];
      for (const component of Format2(pointer)) {
        if (next[component] === void 0)
          next[component] = {};
        owner = next;
        next = next[component];
        key2 = component;
      }
      owner[key2] = update;
    }
    function Delete5(value, pointer) {
      if (pointer === "")
        throw new ValuePointerRootDeleteError2(value, pointer);
      let [owner, next, key2] = [null, value, ""];
      for (const component of Format2(pointer)) {
        if (next[component] === void 0 || next[component] === null)
          return;
        owner = next;
        next = next[component];
        key2 = component;
      }
      if (Array.isArray(owner)) {
        const index3 = parseInt(key2);
        owner.splice(index3, 1);
      } else {
        delete owner[key2];
      }
    }
    function Has4(value, pointer) {
      if (pointer === "")
        return true;
      let [owner, next, key2] = [null, value, ""];
      for (const component of Format2(pointer)) {
        if (next[component] === void 0)
          return false;
        owner = next;
        next = next[component];
        key2 = component;
      }
      return Object.getOwnPropertyNames(owner).includes(key2);
    }
    function Get4(value, pointer) {
      if (pointer === "")
        return value;
      let current = value;
      for (const component of Format2(pointer)) {
        if (current[component] === void 0)
          return void 0;
        current = current[component];
      }
      return current;
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/pointer/index.js
var require_pointer2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/value/pointer/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValuePointer = void 0;
    exports.ValuePointer = require_pointer();
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/delta/delta.js
var require_delta = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/value/delta/delta.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueDeltaSymbolError = exports.ValueDeltaError = exports.Edit = exports.Delete = exports.Update = exports.Insert = void 0;
    exports.Diff = Diff3;
    exports.Patch = Patch3;
    var index_1 = require_guard2();
    var index_2 = require_pointer2();
    var index_3 = require_clone2();
    var index_4 = require_error2();
    var index_5 = require_literal2();
    var index_6 = require_object2();
    var index_7 = require_string2();
    var index_8 = require_unknown2();
    var index_9 = require_union2();
    exports.Insert = (0, index_6.Object)({
      type: (0, index_5.Literal)("insert"),
      path: (0, index_7.String)(),
      value: (0, index_8.Unknown)()
    });
    exports.Update = (0, index_6.Object)({
      type: (0, index_5.Literal)("update"),
      path: (0, index_7.String)(),
      value: (0, index_8.Unknown)()
    });
    exports.Delete = (0, index_6.Object)({
      type: (0, index_5.Literal)("delete"),
      path: (0, index_7.String)()
    });
    exports.Edit = (0, index_9.Union)([exports.Insert, exports.Update, exports.Delete]);
    var ValueDeltaError2 = class extends index_4.TypeBoxError {
      constructor(value, message2) {
        super(message2);
        this.value = value;
      }
    };
    exports.ValueDeltaError = ValueDeltaError2;
    var ValueDeltaSymbolError2 = class extends ValueDeltaError2 {
      constructor(value) {
        super(value, "Cannot diff objects with symbol keys");
        this.value = value;
      }
    };
    exports.ValueDeltaSymbolError = ValueDeltaSymbolError2;
    function CreateUpdate2(path2, value) {
      return { type: "update", path: path2, value };
    }
    function CreateInsert2(path2, value) {
      return { type: "insert", path: path2, value };
    }
    function CreateDelete2(path2) {
      return { type: "delete", path: path2 };
    }
    function* ObjectType7(path2, current, next) {
      if (!(0, index_1.IsStandardObject)(next))
        return yield CreateUpdate2(path2, next);
      const currentKeys = [...globalThis.Object.keys(current), ...globalThis.Object.getOwnPropertySymbols(current)];
      const nextKeys = [...globalThis.Object.keys(next), ...globalThis.Object.getOwnPropertySymbols(next)];
      for (const key2 of currentKeys) {
        if ((0, index_1.IsSymbol)(key2))
          throw new ValueDeltaSymbolError2(key2);
        if ((0, index_1.IsUndefined)(next[key2]) && nextKeys.includes(key2))
          yield CreateUpdate2(`${path2}/${globalThis.String(key2)}`, void 0);
      }
      for (const key2 of nextKeys) {
        if ((0, index_1.IsUndefined)(current[key2]) || (0, index_1.IsUndefined)(next[key2]))
          continue;
        if ((0, index_1.IsSymbol)(key2))
          throw new ValueDeltaSymbolError2(key2);
        yield* Visit17(`${path2}/${globalThis.String(key2)}`, current[key2], next[key2]);
      }
      for (const key2 of nextKeys) {
        if ((0, index_1.IsSymbol)(key2))
          throw new ValueDeltaSymbolError2(key2);
        if ((0, index_1.IsUndefined)(current[key2]))
          yield CreateInsert2(`${path2}/${globalThis.String(key2)}`, next[key2]);
      }
      for (const key2 of currentKeys.reverse()) {
        if ((0, index_1.IsSymbol)(key2))
          throw new ValueDeltaSymbolError2(key2);
        if ((0, index_1.IsUndefined)(next[key2]) && !nextKeys.includes(key2))
          yield CreateDelete2(`${path2}/${globalThis.String(key2)}`);
      }
    }
    function* ArrayType7(path2, current, next) {
      if (!(0, index_1.IsArray)(next))
        return yield CreateUpdate2(path2, next);
      for (let i2 = 0; i2 < Math.min(current.length, next.length); i2++) {
        yield* Visit17(`${path2}/${i2}`, current[i2], next[i2]);
      }
      for (let i2 = 0; i2 < next.length; i2++) {
        if (i2 < current.length)
          continue;
        yield CreateInsert2(`${path2}/${i2}`, next[i2]);
      }
      for (let i2 = current.length - 1; i2 >= 0; i2--) {
        if (i2 < next.length)
          continue;
        yield CreateDelete2(`${path2}/${i2}`);
      }
    }
    function* TypedArrayType5(path2, current, next) {
      if (!(0, index_1.IsTypedArray)(next) || current.length !== next.length || globalThis.Object.getPrototypeOf(current).constructor.name !== globalThis.Object.getPrototypeOf(next).constructor.name)
        return yield CreateUpdate2(path2, next);
      for (let i2 = 0; i2 < Math.min(current.length, next.length); i2++) {
        yield* Visit17(`${path2}/${i2}`, current[i2], next[i2]);
      }
    }
    function* ValueType5(path2, current, next) {
      if (current === next)
        return;
      yield CreateUpdate2(path2, next);
    }
    function* Visit17(path2, current, next) {
      if ((0, index_1.IsStandardObject)(current))
        return yield* ObjectType7(path2, current, next);
      if ((0, index_1.IsArray)(current))
        return yield* ArrayType7(path2, current, next);
      if ((0, index_1.IsTypedArray)(current))
        return yield* TypedArrayType5(path2, current, next);
      if ((0, index_1.IsValueType)(current))
        return yield* ValueType5(path2, current, next);
      throw new ValueDeltaError2(current, "Unable to create diff edits for unknown value");
    }
    function Diff3(current, next) {
      return [...Visit17("", current, next)];
    }
    function IsRootUpdate2(edits) {
      return edits.length > 0 && edits[0].path === "" && edits[0].type === "update";
    }
    function IsIdentity2(edits) {
      return edits.length === 0;
    }
    function Patch3(current, edits) {
      if (IsRootUpdate2(edits)) {
        return (0, index_3.Clone)(edits[0].value);
      }
      if (IsIdentity2(edits)) {
        return (0, index_3.Clone)(current);
      }
      const clone = (0, index_3.Clone)(current);
      for (const edit of edits) {
        switch (edit.type) {
          case "insert": {
            index_2.ValuePointer.Set(clone, edit.path, edit.value);
            break;
          }
          case "update": {
            index_2.ValuePointer.Set(clone, edit.path, edit.value);
            break;
          }
          case "delete": {
            index_2.ValuePointer.Delete(clone, edit.path);
            break;
          }
        }
      }
      return clone;
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/delta/index.js
var require_delta2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/value/delta/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_delta(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/equal/equal.js
var require_equal = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/value/equal/equal.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Equal = Equal3;
    var index_1 = require_guard2();
    function ObjectType7(left, right) {
      if (!(0, index_1.IsStandardObject)(right))
        return false;
      const leftKeys = [...Object.keys(left), ...Object.getOwnPropertySymbols(left)];
      const rightKeys = [...Object.keys(right), ...Object.getOwnPropertySymbols(right)];
      if (leftKeys.length !== rightKeys.length)
        return false;
      return leftKeys.every((key2) => Equal3(left[key2], right[key2]));
    }
    function DateType5(left, right) {
      return (0, index_1.IsDate)(right) && left.getTime() === right.getTime();
    }
    function ArrayType7(left, right) {
      if (!(0, index_1.IsArray)(right) || left.length !== right.length)
        return false;
      return left.every((value, index3) => Equal3(value, right[index3]));
    }
    function TypedArrayType5(left, right) {
      if (!(0, index_1.IsTypedArray)(right) || left.length !== right.length || Object.getPrototypeOf(left).constructor.name !== Object.getPrototypeOf(right).constructor.name)
        return false;
      return left.every((value, index3) => Equal3(value, right[index3]));
    }
    function ValueType5(left, right) {
      return left === right;
    }
    function Equal3(left, right) {
      if ((0, index_1.IsStandardObject)(left))
        return ObjectType7(left, right);
      if ((0, index_1.IsDate)(left))
        return DateType5(left, right);
      if ((0, index_1.IsTypedArray)(left))
        return TypedArrayType5(left, right);
      if ((0, index_1.IsArray)(left))
        return ArrayType7(left, right);
      if ((0, index_1.IsValueType)(left))
        return ValueType5(left, right);
      throw new Error("ValueEquals: Unable to compare value");
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/equal/index.js
var require_equal2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/value/equal/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_equal(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/mutate/mutate.js
var require_mutate = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/value/mutate/mutate.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueMutateError = void 0;
    exports.Mutate = Mutate3;
    var index_1 = require_guard2();
    var index_2 = require_pointer2();
    var index_3 = require_clone2();
    var index_4 = require_error2();
    var ValueMutateError2 = class extends index_4.TypeBoxError {
      constructor(message2) {
        super(message2);
      }
    };
    exports.ValueMutateError = ValueMutateError2;
    function ObjectType7(root4, path2, current, next) {
      if (!(0, index_1.IsStandardObject)(current)) {
        index_2.ValuePointer.Set(root4, path2, (0, index_3.Clone)(next));
      } else {
        const currentKeys = Object.getOwnPropertyNames(current);
        const nextKeys = Object.getOwnPropertyNames(next);
        for (const currentKey of currentKeys) {
          if (!nextKeys.includes(currentKey)) {
            delete current[currentKey];
          }
        }
        for (const nextKey of nextKeys) {
          if (!currentKeys.includes(nextKey)) {
            current[nextKey] = null;
          }
        }
        for (const nextKey of nextKeys) {
          Visit17(root4, `${path2}/${nextKey}`, current[nextKey], next[nextKey]);
        }
      }
    }
    function ArrayType7(root4, path2, current, next) {
      if (!(0, index_1.IsArray)(current)) {
        index_2.ValuePointer.Set(root4, path2, (0, index_3.Clone)(next));
      } else {
        for (let index3 = 0; index3 < next.length; index3++) {
          Visit17(root4, `${path2}/${index3}`, current[index3], next[index3]);
        }
        current.splice(next.length);
      }
    }
    function TypedArrayType5(root4, path2, current, next) {
      if ((0, index_1.IsTypedArray)(current) && current.length === next.length) {
        for (let i2 = 0; i2 < current.length; i2++) {
          current[i2] = next[i2];
        }
      } else {
        index_2.ValuePointer.Set(root4, path2, (0, index_3.Clone)(next));
      }
    }
    function ValueType5(root4, path2, current, next) {
      if (current === next)
        return;
      index_2.ValuePointer.Set(root4, path2, next);
    }
    function Visit17(root4, path2, current, next) {
      if ((0, index_1.IsArray)(next))
        return ArrayType7(root4, path2, current, next);
      if ((0, index_1.IsTypedArray)(next))
        return TypedArrayType5(root4, path2, current, next);
      if ((0, index_1.IsStandardObject)(next))
        return ObjectType7(root4, path2, current, next);
      if ((0, index_1.IsValueType)(next))
        return ValueType5(root4, path2, current, next);
    }
    function IsNonMutableValue2(value) {
      return (0, index_1.IsTypedArray)(value) || (0, index_1.IsValueType)(value);
    }
    function IsMismatchedValue2(current, next) {
      return (0, index_1.IsStandardObject)(current) && (0, index_1.IsArray)(next) || (0, index_1.IsArray)(current) && (0, index_1.IsStandardObject)(next);
    }
    function Mutate3(current, next) {
      if (IsNonMutableValue2(current) || IsNonMutableValue2(next))
        throw new ValueMutateError2("Only object and array types can be mutated at the root level");
      if (IsMismatchedValue2(current, next))
        throw new ValueMutateError2("Cannot assign due type mismatch of assignable values");
      Visit17(current, "", current, next);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/mutate/index.js
var require_mutate2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/value/mutate/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_mutate(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/transform/decode.js
var require_decode = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/value/transform/decode.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TransformDecodeError = exports.TransformDecodeCheckError = void 0;
    exports.TransformDecode = TransformDecode2;
    var index_1 = require_symbols2();
    var index_2 = require_error2();
    var index_3 = require_keyof2();
    var index_4 = require_deref2();
    var index_5 = require_check2();
    var index_6 = require_guard2();
    var type_1 = require_type3();
    var TransformDecodeCheckError2 = class extends index_2.TypeBoxError {
      constructor(schema, value, error3) {
        super(`Unable to decode value as it does not match the expected schema`);
        this.schema = schema;
        this.value = value;
        this.error = error3;
      }
    };
    exports.TransformDecodeCheckError = TransformDecodeCheckError2;
    var TransformDecodeError2 = class extends index_2.TypeBoxError {
      constructor(schema, path2, value, error3) {
        super(error3 instanceof Error ? error3.message : "Unknown error");
        this.schema = schema;
        this.path = path2;
        this.value = value;
        this.error = error3;
      }
    };
    exports.TransformDecodeError = TransformDecodeError2;
    function Default7(schema, path2, value) {
      try {
        return (0, type_1.IsTransform)(schema) ? schema[index_1.TransformKind].Decode(value) : value;
      } catch (error3) {
        throw new TransformDecodeError2(schema, path2, value, error3);
      }
    }
    function FromArray16(schema, references, path2, value) {
      return (0, index_6.IsArray)(value) ? Default7(schema, path2, value.map((value2, index3) => Visit17(schema.items, references, `${path2}/${index3}`, value2))) : Default7(schema, path2, value);
    }
    function FromIntersect18(schema, references, path2, value) {
      if (!(0, index_6.IsStandardObject)(value) || (0, index_6.IsValueType)(value))
        return Default7(schema, path2, value);
      const knownEntries = (0, index_3.KeyOfPropertyEntries)(schema);
      const knownKeys = knownEntries.map((entry) => entry[0]);
      const knownProperties = { ...value };
      for (const [knownKey, knownSchema] of knownEntries)
        if (knownKey in knownProperties) {
          knownProperties[knownKey] = Visit17(knownSchema, references, `${path2}/${knownKey}`, knownProperties[knownKey]);
        }
      if (!(0, type_1.IsTransform)(schema.unevaluatedProperties)) {
        return Default7(schema, path2, knownProperties);
      }
      const unknownKeys = Object.getOwnPropertyNames(knownProperties);
      const unevaluatedProperties = schema.unevaluatedProperties;
      const unknownProperties = { ...knownProperties };
      for (const key2 of unknownKeys)
        if (!knownKeys.includes(key2)) {
          unknownProperties[key2] = Default7(unevaluatedProperties, `${path2}/${key2}`, unknownProperties[key2]);
        }
      return Default7(schema, path2, unknownProperties);
    }
    function FromNot8(schema, references, path2, value) {
      return Default7(schema, path2, Visit17(schema.not, references, path2, value));
    }
    function FromObject13(schema, references, path2, value) {
      if (!(0, index_6.IsStandardObject)(value))
        return Default7(schema, path2, value);
      const knownKeys = (0, index_3.KeyOfPropertyKeys)(schema);
      const knownProperties = { ...value };
      for (const key2 of knownKeys)
        if (key2 in knownProperties) {
          knownProperties[key2] = Visit17(schema.properties[key2], references, `${path2}/${key2}`, knownProperties[key2]);
        }
      if (!(0, type_1.IsSchema)(schema.additionalProperties)) {
        return Default7(schema, path2, knownProperties);
      }
      const unknownKeys = Object.getOwnPropertyNames(knownProperties);
      const additionalProperties = schema.additionalProperties;
      const unknownProperties = { ...knownProperties };
      for (const key2 of unknownKeys)
        if (!knownKeys.includes(key2)) {
          unknownProperties[key2] = Default7(additionalProperties, `${path2}/${key2}`, unknownProperties[key2]);
        }
      return Default7(schema, path2, unknownProperties);
    }
    function FromRecord12(schema, references, path2, value) {
      if (!(0, index_6.IsStandardObject)(value))
        return Default7(schema, path2, value);
      const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
      const knownKeys = new RegExp(pattern);
      const knownProperties = { ...value };
      for (const key2 of Object.getOwnPropertyNames(value))
        if (knownKeys.test(key2)) {
          knownProperties[key2] = Visit17(schema.patternProperties[pattern], references, `${path2}/${key2}`, knownProperties[key2]);
        }
      if (!(0, type_1.IsSchema)(schema.additionalProperties)) {
        return Default7(schema, path2, knownProperties);
      }
      const unknownKeys = Object.getOwnPropertyNames(knownProperties);
      const additionalProperties = schema.additionalProperties;
      const unknownProperties = { ...knownProperties };
      for (const key2 of unknownKeys)
        if (!knownKeys.test(key2)) {
          unknownProperties[key2] = Default7(additionalProperties, `${path2}/${key2}`, unknownProperties[key2]);
        }
      return Default7(schema, path2, unknownProperties);
    }
    function FromRef12(schema, references, path2, value) {
      const target = (0, index_4.Deref)(schema, references);
      return Default7(schema, path2, Visit17(target, references, path2, value));
    }
    function FromThis11(schema, references, path2, value) {
      const target = (0, index_4.Deref)(schema, references);
      return Default7(schema, path2, Visit17(target, references, path2, value));
    }
    function FromTuple15(schema, references, path2, value) {
      return (0, index_6.IsArray)(value) && (0, index_6.IsArray)(schema.items) ? Default7(schema, path2, schema.items.map((schema2, index3) => Visit17(schema2, references, `${path2}/${index3}`, value[index3]))) : Default7(schema, path2, value);
    }
    function FromUnion20(schema, references, path2, value) {
      for (const subschema of schema.anyOf) {
        if (!(0, index_5.Check)(subschema, references, value))
          continue;
        const decoded = Visit17(subschema, references, path2, value);
        return Default7(schema, path2, decoded);
      }
      return Default7(schema, path2, value);
    }
    function Visit17(schema, references, path2, value) {
      const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
      const schema_ = schema;
      switch (schema[index_1.Kind]) {
        case "Array":
          return FromArray16(schema_, references_, path2, value);
        case "Intersect":
          return FromIntersect18(schema_, references_, path2, value);
        case "Not":
          return FromNot8(schema_, references_, path2, value);
        case "Object":
          return FromObject13(schema_, references_, path2, value);
        case "Record":
          return FromRecord12(schema_, references_, path2, value);
        case "Ref":
          return FromRef12(schema_, references_, path2, value);
        case "Symbol":
          return Default7(schema_, path2, value);
        case "This":
          return FromThis11(schema_, references_, path2, value);
        case "Tuple":
          return FromTuple15(schema_, references_, path2, value);
        case "Union":
          return FromUnion20(schema_, references_, path2, value);
        default:
          return Default7(schema_, path2, value);
      }
    }
    function TransformDecode2(schema, references, value) {
      return Visit17(schema, references, "", value);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/transform/encode.js
var require_encode = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/value/transform/encode.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TransformEncodeError = exports.TransformEncodeCheckError = void 0;
    exports.TransformEncode = TransformEncode2;
    var index_1 = require_symbols2();
    var index_2 = require_error2();
    var index_3 = require_keyof2();
    var index_4 = require_deref2();
    var index_5 = require_check2();
    var index_6 = require_guard2();
    var type_1 = require_type3();
    var TransformEncodeCheckError2 = class extends index_2.TypeBoxError {
      constructor(schema, value, error3) {
        super(`The encoded value does not match the expected schema`);
        this.schema = schema;
        this.value = value;
        this.error = error3;
      }
    };
    exports.TransformEncodeCheckError = TransformEncodeCheckError2;
    var TransformEncodeError2 = class extends index_2.TypeBoxError {
      constructor(schema, path2, value, error3) {
        super(`${error3 instanceof Error ? error3.message : "Unknown error"}`);
        this.schema = schema;
        this.path = path2;
        this.value = value;
        this.error = error3;
      }
    };
    exports.TransformEncodeError = TransformEncodeError2;
    function Default7(schema, path2, value) {
      try {
        return (0, type_1.IsTransform)(schema) ? schema[index_1.TransformKind].Encode(value) : value;
      } catch (error3) {
        throw new TransformEncodeError2(schema, path2, value, error3);
      }
    }
    function FromArray16(schema, references, path2, value) {
      const defaulted = Default7(schema, path2, value);
      return (0, index_6.IsArray)(defaulted) ? defaulted.map((value2, index3) => Visit17(schema.items, references, `${path2}/${index3}`, value2)) : defaulted;
    }
    function FromIntersect18(schema, references, path2, value) {
      const defaulted = Default7(schema, path2, value);
      if (!(0, index_6.IsStandardObject)(value) || (0, index_6.IsValueType)(value))
        return defaulted;
      const knownEntries = (0, index_3.KeyOfPropertyEntries)(schema);
      const knownKeys = knownEntries.map((entry) => entry[0]);
      const knownProperties = { ...defaulted };
      for (const [knownKey, knownSchema] of knownEntries)
        if (knownKey in knownProperties) {
          knownProperties[knownKey] = Visit17(knownSchema, references, `${path2}/${knownKey}`, knownProperties[knownKey]);
        }
      if (!(0, type_1.IsTransform)(schema.unevaluatedProperties)) {
        return Default7(schema, path2, knownProperties);
      }
      const unknownKeys = Object.getOwnPropertyNames(knownProperties);
      const unevaluatedProperties = schema.unevaluatedProperties;
      const properties = { ...knownProperties };
      for (const key2 of unknownKeys)
        if (!knownKeys.includes(key2)) {
          properties[key2] = Default7(unevaluatedProperties, `${path2}/${key2}`, properties[key2]);
        }
      return properties;
    }
    function FromNot8(schema, references, path2, value) {
      return Default7(schema.not, path2, Default7(schema, path2, value));
    }
    function FromObject13(schema, references, path2, value) {
      const defaulted = Default7(schema, path2, value);
      if (!(0, index_6.IsStandardObject)(defaulted))
        return defaulted;
      const knownKeys = (0, index_3.KeyOfPropertyKeys)(schema);
      const knownProperties = { ...defaulted };
      for (const key2 of knownKeys)
        if (key2 in knownProperties) {
          knownProperties[key2] = Visit17(schema.properties[key2], references, `${path2}/${key2}`, knownProperties[key2]);
        }
      if (!(0, type_1.IsSchema)(schema.additionalProperties)) {
        return knownProperties;
      }
      const unknownKeys = Object.getOwnPropertyNames(knownProperties);
      const additionalProperties = schema.additionalProperties;
      const properties = { ...knownProperties };
      for (const key2 of unknownKeys)
        if (!knownKeys.includes(key2)) {
          properties[key2] = Default7(additionalProperties, `${path2}/${key2}`, properties[key2]);
        }
      return properties;
    }
    function FromRecord12(schema, references, path2, value) {
      const defaulted = Default7(schema, path2, value);
      if (!(0, index_6.IsStandardObject)(value))
        return defaulted;
      const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
      const knownKeys = new RegExp(pattern);
      const knownProperties = { ...defaulted };
      for (const key2 of Object.getOwnPropertyNames(value))
        if (knownKeys.test(key2)) {
          knownProperties[key2] = Visit17(schema.patternProperties[pattern], references, `${path2}/${key2}`, knownProperties[key2]);
        }
      if (!(0, type_1.IsSchema)(schema.additionalProperties)) {
        return Default7(schema, path2, knownProperties);
      }
      const unknownKeys = Object.getOwnPropertyNames(knownProperties);
      const additionalProperties = schema.additionalProperties;
      const properties = { ...knownProperties };
      for (const key2 of unknownKeys)
        if (!knownKeys.test(key2)) {
          properties[key2] = Default7(additionalProperties, `${path2}/${key2}`, properties[key2]);
        }
      return properties;
    }
    function FromRef12(schema, references, path2, value) {
      const target = (0, index_4.Deref)(schema, references);
      const resolved = Visit17(target, references, path2, value);
      return Default7(schema, path2, resolved);
    }
    function FromThis11(schema, references, path2, value) {
      const target = (0, index_4.Deref)(schema, references);
      const resolved = Visit17(target, references, path2, value);
      return Default7(schema, path2, resolved);
    }
    function FromTuple15(schema, references, path2, value) {
      const value1 = Default7(schema, path2, value);
      return (0, index_6.IsArray)(schema.items) ? schema.items.map((schema2, index3) => Visit17(schema2, references, `${path2}/${index3}`, value1[index3])) : [];
    }
    function FromUnion20(schema, references, path2, value) {
      for (const subschema of schema.anyOf) {
        if (!(0, index_5.Check)(subschema, references, value))
          continue;
        const value1 = Visit17(subschema, references, path2, value);
        return Default7(schema, path2, value1);
      }
      for (const subschema of schema.anyOf) {
        const value1 = Visit17(subschema, references, path2, value);
        if (!(0, index_5.Check)(schema, references, value1))
          continue;
        return Default7(schema, path2, value1);
      }
      return Default7(schema, path2, value);
    }
    function Visit17(schema, references, path2, value) {
      const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
      const schema_ = schema;
      switch (schema[index_1.Kind]) {
        case "Array":
          return FromArray16(schema_, references_, path2, value);
        case "Intersect":
          return FromIntersect18(schema_, references_, path2, value);
        case "Not":
          return FromNot8(schema_, references_, path2, value);
        case "Object":
          return FromObject13(schema_, references_, path2, value);
        case "Record":
          return FromRecord12(schema_, references_, path2, value);
        case "Ref":
          return FromRef12(schema_, references_, path2, value);
        case "This":
          return FromThis11(schema_, references_, path2, value);
        case "Tuple":
          return FromTuple15(schema_, references_, path2, value);
        case "Union":
          return FromUnion20(schema_, references_, path2, value);
        default:
          return Default7(schema_, path2, value);
      }
    }
    function TransformEncode2(schema, references, value) {
      return Visit17(schema, references, "", value);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/transform/has.js
var require_has = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/value/transform/has.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HasTransform = HasTransform2;
    var index_1 = require_deref2();
    var index_2 = require_symbols2();
    var type_1 = require_type3();
    var index_3 = require_guard2();
    function FromArray16(schema, references) {
      return (0, type_1.IsTransform)(schema) || Visit17(schema.items, references);
    }
    function FromAsyncIterator7(schema, references) {
      return (0, type_1.IsTransform)(schema) || Visit17(schema.items, references);
    }
    function FromConstructor8(schema, references) {
      return (0, type_1.IsTransform)(schema) || Visit17(schema.returns, references) || schema.parameters.some((schema2) => Visit17(schema2, references));
    }
    function FromFunction7(schema, references) {
      return (0, type_1.IsTransform)(schema) || Visit17(schema.returns, references) || schema.parameters.some((schema2) => Visit17(schema2, references));
    }
    function FromIntersect18(schema, references) {
      return (0, type_1.IsTransform)(schema) || (0, type_1.IsTransform)(schema.unevaluatedProperties) || schema.allOf.some((schema2) => Visit17(schema2, references));
    }
    function FromIterator7(schema, references) {
      return (0, type_1.IsTransform)(schema) || Visit17(schema.items, references);
    }
    function FromNot8(schema, references) {
      return (0, type_1.IsTransform)(schema) || Visit17(schema.not, references);
    }
    function FromObject13(schema, references) {
      return (0, type_1.IsTransform)(schema) || Object.values(schema.properties).some((schema2) => Visit17(schema2, references)) || (0, type_1.IsSchema)(schema.additionalProperties) && Visit17(schema.additionalProperties, references);
    }
    function FromPromise8(schema, references) {
      return (0, type_1.IsTransform)(schema) || Visit17(schema.item, references);
    }
    function FromRecord12(schema, references) {
      const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
      const property = schema.patternProperties[pattern];
      return (0, type_1.IsTransform)(schema) || Visit17(property, references) || (0, type_1.IsSchema)(schema.additionalProperties) && (0, type_1.IsTransform)(schema.additionalProperties);
    }
    function FromRef12(schema, references) {
      if ((0, type_1.IsTransform)(schema))
        return true;
      return Visit17((0, index_1.Deref)(schema, references), references);
    }
    function FromThis11(schema, references) {
      if ((0, type_1.IsTransform)(schema))
        return true;
      return Visit17((0, index_1.Deref)(schema, references), references);
    }
    function FromTuple15(schema, references) {
      return (0, type_1.IsTransform)(schema) || !(0, index_3.IsUndefined)(schema.items) && schema.items.some((schema2) => Visit17(schema2, references));
    }
    function FromUnion20(schema, references) {
      return (0, type_1.IsTransform)(schema) || schema.anyOf.some((schema2) => Visit17(schema2, references));
    }
    function Visit17(schema, references) {
      const references_ = (0, index_3.IsString)(schema.$id) ? [...references, schema] : references;
      const schema_ = schema;
      if (schema.$id && visited2.has(schema.$id))
        return false;
      if (schema.$id)
        visited2.add(schema.$id);
      switch (schema[index_2.Kind]) {
        case "Array":
          return FromArray16(schema_, references_);
        case "AsyncIterator":
          return FromAsyncIterator7(schema_, references_);
        case "Constructor":
          return FromConstructor8(schema_, references_);
        case "Function":
          return FromFunction7(schema_, references_);
        case "Intersect":
          return FromIntersect18(schema_, references_);
        case "Iterator":
          return FromIterator7(schema_, references_);
        case "Not":
          return FromNot8(schema_, references_);
        case "Object":
          return FromObject13(schema_, references_);
        case "Promise":
          return FromPromise8(schema_, references_);
        case "Record":
          return FromRecord12(schema_, references_);
        case "Ref":
          return FromRef12(schema_, references_);
        case "This":
          return FromThis11(schema_, references_);
        case "Tuple":
          return FromTuple15(schema_, references_);
        case "Union":
          return FromUnion20(schema_, references_);
        default:
          return (0, type_1.IsTransform)(schema);
      }
    }
    var visited2 = /* @__PURE__ */ new Set();
    function HasTransform2(schema, references) {
      visited2.clear();
      return Visit17(schema, references);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/transform/index.js
var require_transform = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/value/transform/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_decode(), exports);
    __exportStar(require_encode(), exports);
    __exportStar(require_has(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/value/value.js
var require_value3 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/value/value/value.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Cast = Cast3;
    exports.Create = Create4;
    exports.Check = Check3;
    exports.Clean = Clean3;
    exports.Convert = Convert3;
    exports.Clone = Clone4;
    exports.Decode = Decode2;
    exports.Default = Default7;
    exports.Encode = Encode2;
    exports.Errors = Errors3;
    exports.Equal = Equal3;
    exports.Diff = Diff3;
    exports.Hash = Hash3;
    exports.Patch = Patch3;
    exports.Mutate = Mutate3;
    var index_1 = require_transform();
    var index_2 = require_mutate2();
    var index_3 = require_hash2();
    var index_4 = require_equal2();
    var index_5 = require_cast2();
    var index_6 = require_clone2();
    var index_7 = require_convert2();
    var index_8 = require_create2();
    var index_9 = require_clean2();
    var index_10 = require_check2();
    var index_11 = require_default2();
    var index_12 = require_delta2();
    var index_13 = require_errors2();
    function Cast3(...args) {
      return index_5.Cast.apply(index_5.Cast, args);
    }
    function Create4(...args) {
      return index_8.Create.apply(index_8.Create, args);
    }
    function Check3(...args) {
      return index_10.Check.apply(index_10.Check, args);
    }
    function Clean3(...args) {
      return index_9.Clean.apply(index_9.Clean, args);
    }
    function Convert3(...args) {
      return index_7.Convert.apply(index_7.Convert, args);
    }
    function Clone4(value) {
      return (0, index_6.Clone)(value);
    }
    function Decode2(...args) {
      const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
      if (!Check3(schema, references, value))
        throw new index_1.TransformDecodeCheckError(schema, value, Errors3(schema, references, value).First());
      return (0, index_1.HasTransform)(schema, references) ? (0, index_1.TransformDecode)(schema, references, value) : value;
    }
    function Default7(...args) {
      return index_11.Default.apply(index_11.Default, args);
    }
    function Encode2(...args) {
      const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
      const encoded = (0, index_1.HasTransform)(schema, references) ? (0, index_1.TransformEncode)(schema, references, value) : value;
      if (!Check3(schema, references, encoded))
        throw new index_1.TransformEncodeCheckError(schema, encoded, Errors3(schema, references, encoded).First());
      return encoded;
    }
    function Errors3(...args) {
      return index_13.Errors.apply(index_13.Errors, args);
    }
    function Equal3(left, right) {
      return (0, index_4.Equal)(left, right);
    }
    function Diff3(current, next) {
      return (0, index_12.Diff)(current, next);
    }
    function Hash3(value) {
      return (0, index_3.Hash)(value);
    }
    function Patch3(current, edits) {
      return (0, index_12.Patch)(current, edits);
    }
    function Mutate3(current, next) {
      (0, index_2.Mutate)(current, next);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/value/index.js
var require_value4 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/value/value/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Value = void 0;
    exports.Value = require_value3();
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/index.js
var require_value5 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/value/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Value = exports.ValueErrorIterator = exports.ValueErrorType = void 0;
    var index_1 = require_errors2();
    Object.defineProperty(exports, "ValueErrorType", { enumerable: true, get: function() {
      return index_1.ValueErrorType;
    } });
    Object.defineProperty(exports, "ValueErrorIterator", { enumerable: true, get: function() {
      return index_1.ValueErrorIterator;
    } });
    __exportStar(require_guard2(), exports);
    __exportStar(require_cast2(), exports);
    __exportStar(require_check2(), exports);
    __exportStar(require_clean2(), exports);
    __exportStar(require_clone2(), exports);
    __exportStar(require_convert2(), exports);
    __exportStar(require_create2(), exports);
    __exportStar(require_default2(), exports);
    __exportStar(require_delta2(), exports);
    __exportStar(require_equal2(), exports);
    __exportStar(require_hash2(), exports);
    __exportStar(require_mutate2(), exports);
    __exportStar(require_pointer2(), exports);
    __exportStar(require_transform(), exports);
    var index_2 = require_value4();
    Object.defineProperty(exports, "Value", { enumerable: true, get: function() {
      return index_2.Value;
    } });
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/clone/index.js
var require_clone3 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/clone/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_type2(), exports);
    __exportStar(require_value2(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/helpers/helpers.js
var require_helpers = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/helpers/helpers.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Increment = Increment;
    function Increment(T2) {
      return (parseInt(T2) + 1).toString();
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/helpers/index.js
var require_helpers2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/helpers/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_helpers(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/awaited/awaited.js
var require_awaited = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/awaited/awaited.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Awaited = Awaited2;
    var index_1 = require_intersect2();
    var index_2 = require_union2();
    var type_1 = require_type2();
    var kind_1 = require_kind();
    function FromRest9(T2) {
      return T2.map((L2) => AwaitedResolve2(L2));
    }
    function FromIntersect18(T2) {
      return (0, index_1.Intersect)(FromRest9(T2));
    }
    function FromUnion20(T2) {
      return (0, index_2.Union)(FromRest9(T2));
    }
    function FromPromise8(T2) {
      return AwaitedResolve2(T2);
    }
    function AwaitedResolve2(T2) {
      return (0, kind_1.IsIntersect)(T2) ? FromIntersect18(T2.allOf) : (0, kind_1.IsUnion)(T2) ? FromUnion20(T2.anyOf) : (0, kind_1.IsPromise)(T2) ? FromPromise8(T2.item) : T2;
    }
    function Awaited2(T2, options = {}) {
      return (0, type_1.CloneType)(AwaitedResolve2(T2), options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/awaited/index.js
var require_awaited2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/awaited/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_awaited(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/composite/composite.js
var require_composite = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/composite/composite.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Composite = Composite2;
    var index_1 = require_intersect2();
    var index_2 = require_indexed2();
    var index_3 = require_keyof2();
    var index_4 = require_object2();
    var index_5 = require_sets();
    var kind_1 = require_kind();
    function CompositeKeys2(T2) {
      const Acc = [];
      for (const L2 of T2)
        Acc.push(...(0, index_3.KeyOfPropertyKeys)(L2));
      return (0, index_5.SetDistinct)(Acc);
    }
    function FilterNever2(T2) {
      return T2.filter((L2) => !(0, kind_1.IsNever)(L2));
    }
    function CompositeProperty2(T2, K2) {
      const Acc = [];
      for (const L2 of T2)
        Acc.push(...(0, index_2.IndexFromPropertyKeys)(L2, [K2]));
      return FilterNever2(Acc);
    }
    function CompositeProperties2(T2, K2) {
      const Acc = {};
      for (const L2 of K2) {
        Acc[L2] = (0, index_1.IntersectEvaluated)(CompositeProperty2(T2, L2));
      }
      return Acc;
    }
    function Composite2(T2, options = {}) {
      const K2 = CompositeKeys2(T2);
      const P2 = CompositeProperties2(T2, K2);
      const R2 = (0, index_4.Object)(P2, options);
      return R2;
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/composite/index.js
var require_composite2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/composite/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_composite(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/date/date.js
var require_date = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/date/date.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Date = Date3;
    var index_1 = require_symbols2();
    function Date3(options = {}) {
      return {
        ...options,
        [index_1.Kind]: "Date",
        type: "Date"
      };
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/date/index.js
var require_date2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/date/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_date(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/null/null.js
var require_null = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/null/null.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Null = Null2;
    var index_1 = require_symbols2();
    function Null2(options = {}) {
      return {
        ...options,
        [index_1.Kind]: "Null",
        type: "null"
      };
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/null/index.js
var require_null2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/null/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_null(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/symbol/symbol.js
var require_symbol = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/symbol/symbol.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Symbol = Symbol3;
    var index_1 = require_symbols2();
    function Symbol3(options) {
      return { ...options, [index_1.Kind]: "Symbol", type: "symbol" };
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/symbol/index.js
var require_symbol2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/symbol/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_symbol(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/undefined/undefined.js
var require_undefined = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/undefined/undefined.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Undefined = Undefined2;
    var index_1 = require_symbols2();
    function Undefined2(options = {}) {
      return { ...options, [index_1.Kind]: "Undefined", type: "undefined" };
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/undefined/index.js
var require_undefined2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/undefined/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_undefined(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/uint8array/uint8array.js
var require_uint8array = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/uint8array/uint8array.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Uint8Array = Uint8Array3;
    var index_1 = require_symbols2();
    function Uint8Array3(options = {}) {
      return { ...options, [index_1.Kind]: "Uint8Array", type: "Uint8Array" };
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/uint8array/index.js
var require_uint8array2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/uint8array/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_uint8array(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/const/const.js
var require_const = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/const/const.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Const = Const2;
    var index_1 = require_any2();
    var index_2 = require_bigint2();
    var index_3 = require_date2();
    var index_4 = require_function2();
    var index_5 = require_literal2();
    var index_6 = require_null2();
    var index_7 = require_object2();
    var index_8 = require_symbol2();
    var index_9 = require_tuple2();
    var index_10 = require_readonly2();
    var index_11 = require_undefined2();
    var index_12 = require_uint8array2();
    var index_13 = require_unknown2();
    var index_14 = require_clone3();
    var value_1 = require_value();
    function FromArray16(T2) {
      return T2.map((L2) => FromValue2(L2, false));
    }
    function FromProperties20(value) {
      const Acc = {};
      for (const K2 of globalThis.Object.getOwnPropertyNames(value))
        Acc[K2] = (0, index_10.Readonly)(FromValue2(value[K2], false));
      return Acc;
    }
    function ConditionalReadonly2(T2, root4) {
      return root4 === true ? T2 : (0, index_10.Readonly)(T2);
    }
    function FromValue2(value, root4) {
      return (0, value_1.IsAsyncIterator)(value) ? ConditionalReadonly2((0, index_1.Any)(), root4) : (0, value_1.IsIterator)(value) ? ConditionalReadonly2((0, index_1.Any)(), root4) : (0, value_1.IsArray)(value) ? (0, index_10.Readonly)((0, index_9.Tuple)(FromArray16(value))) : (0, value_1.IsUint8Array)(value) ? (0, index_12.Uint8Array)() : (0, value_1.IsDate)(value) ? (0, index_3.Date)() : (0, value_1.IsObject)(value) ? ConditionalReadonly2((0, index_7.Object)(FromProperties20(value)), root4) : (0, value_1.IsFunction)(value) ? ConditionalReadonly2((0, index_4.Function)([], (0, index_13.Unknown)()), root4) : (0, value_1.IsUndefined)(value) ? (0, index_11.Undefined)() : (0, value_1.IsNull)(value) ? (0, index_6.Null)() : (0, value_1.IsSymbol)(value) ? (0, index_8.Symbol)() : (0, value_1.IsBigInt)(value) ? (0, index_2.BigInt)() : (0, value_1.IsNumber)(value) ? (0, index_5.Literal)(value) : (0, value_1.IsBoolean)(value) ? (0, index_5.Literal)(value) : (0, value_1.IsString)(value) ? (0, index_5.Literal)(value) : (0, index_7.Object)({});
    }
    function Const2(T2, options = {}) {
      return (0, index_14.CloneType)(FromValue2(T2, true), options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/const/index.js
var require_const2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/const/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_const(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/constructor-parameters/constructor-parameters.js
var require_constructor_parameters = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/constructor-parameters/constructor-parameters.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConstructorParameters = ConstructorParameters2;
    var index_1 = require_tuple2();
    var type_1 = require_type2();
    function ConstructorParameters2(schema, options = {}) {
      return (0, index_1.Tuple)((0, type_1.CloneRest)(schema.parameters), { ...options });
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/constructor-parameters/index.js
var require_constructor_parameters2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/constructor-parameters/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_constructor_parameters(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/deref/deref.js
var require_deref3 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/deref/deref.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Deref = Deref3;
    var type_1 = require_type2();
    var index_1 = require_discard2();
    var value_1 = require_value();
    var kind_1 = require_kind();
    function FromRest9(schema, references) {
      return schema.map((schema2) => Deref3(schema2, references));
    }
    function FromProperties20(properties, references) {
      const Acc = {};
      for (const K2 of globalThis.Object.getOwnPropertyNames(properties)) {
        Acc[K2] = Deref3(properties[K2], references);
      }
      return Acc;
    }
    function FromConstructor8(schema, references) {
      schema.parameters = FromRest9(schema.parameters, references);
      schema.returns = Deref3(schema.returns, references);
      return schema;
    }
    function FromFunction7(schema, references) {
      schema.parameters = FromRest9(schema.parameters, references);
      schema.returns = Deref3(schema.returns, references);
      return schema;
    }
    function FromIntersect18(schema, references) {
      schema.allOf = FromRest9(schema.allOf, references);
      return schema;
    }
    function FromUnion20(schema, references) {
      schema.anyOf = FromRest9(schema.anyOf, references);
      return schema;
    }
    function FromTuple15(schema, references) {
      if ((0, value_1.IsUndefined)(schema.items))
        return schema;
      schema.items = FromRest9(schema.items, references);
      return schema;
    }
    function FromArray16(schema, references) {
      schema.items = Deref3(schema.items, references);
      return schema;
    }
    function FromObject13(schema, references) {
      schema.properties = FromProperties20(schema.properties, references);
      return schema;
    }
    function FromPromise8(schema, references) {
      schema.item = Deref3(schema.item, references);
      return schema;
    }
    function FromAsyncIterator7(schema, references) {
      schema.items = Deref3(schema.items, references);
      return schema;
    }
    function FromIterator7(schema, references) {
      schema.items = Deref3(schema.items, references);
      return schema;
    }
    function FromRef12(schema, references) {
      const target = references.find((remote) => remote.$id === schema.$ref);
      if (target === void 0)
        throw Error(`Unable to dereference schema with $id ${schema.$ref}`);
      const discard = (0, index_1.Discard)(target, ["$id"]);
      return Deref3(discard, references);
    }
    function DerefResolve2(schema, references) {
      return (0, kind_1.IsConstructor)(schema) ? FromConstructor8(schema, references) : (0, kind_1.IsFunction)(schema) ? FromFunction7(schema, references) : (0, kind_1.IsIntersect)(schema) ? FromIntersect18(schema, references) : (0, kind_1.IsUnion)(schema) ? FromUnion20(schema, references) : (0, kind_1.IsTuple)(schema) ? FromTuple15(schema, references) : (0, kind_1.IsArray)(schema) ? FromArray16(schema, references) : (0, kind_1.IsObject)(schema) ? FromObject13(schema, references) : (0, kind_1.IsPromise)(schema) ? FromPromise8(schema, references) : (0, kind_1.IsAsyncIterator)(schema) ? FromAsyncIterator7(schema, references) : (0, kind_1.IsIterator)(schema) ? FromIterator7(schema, references) : (0, kind_1.IsRef)(schema) ? FromRef12(schema, references) : schema;
    }
    function Deref3(schema, references) {
      return DerefResolve2((0, type_1.CloneType)(schema), (0, type_1.CloneRest)(references));
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/deref/index.js
var require_deref4 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/deref/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_deref3(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/enum/enum.js
var require_enum = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/enum/enum.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Enum = Enum2;
    var index_1 = require_literal2();
    var index_2 = require_symbols2();
    var index_3 = require_union2();
    var value_1 = require_value();
    function Enum2(item, options = {}) {
      if ((0, value_1.IsUndefined)(item))
        throw new Error("Enum undefined or empty");
      const values1 = globalThis.Object.getOwnPropertyNames(item).filter((key2) => isNaN(key2)).map((key2) => item[key2]);
      const values2 = [...new Set(values1)];
      const anyOf = values2.map((value) => (0, index_1.Literal)(value));
      return (0, index_3.Union)(anyOf, { ...options, [index_2.Hint]: "Enum" });
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/enum/index.js
var require_enum2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/enum/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_enum(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/exclude/exclude-from-template-literal.js
var require_exclude_from_template_literal = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/exclude/exclude-from-template-literal.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExcludeFromTemplateLiteral = ExcludeFromTemplateLiteral2;
    var exclude_1 = require_exclude();
    var index_1 = require_template_literal2();
    function ExcludeFromTemplateLiteral2(L2, R2) {
      return (0, exclude_1.Exclude)((0, index_1.TemplateLiteralToUnion)(L2), R2);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/exclude/exclude.js
var require_exclude = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/exclude/exclude.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Exclude = Exclude2;
    var index_1 = require_union2();
    var index_2 = require_never2();
    var index_3 = require_extends2();
    var type_1 = require_type2();
    var exclude_from_mapped_result_1 = require_exclude_from_mapped_result();
    var exclude_from_template_literal_1 = require_exclude_from_template_literal();
    var kind_1 = require_kind();
    function ExcludeRest2(L2, R2) {
      const excluded = L2.filter((inner) => (0, index_3.ExtendsCheck)(inner, R2) === index_3.ExtendsResult.False);
      return excluded.length === 1 ? excluded[0] : (0, index_1.Union)(excluded);
    }
    function Exclude2(L2, R2, options = {}) {
      if ((0, kind_1.IsTemplateLiteral)(L2))
        return (0, type_1.CloneType)((0, exclude_from_template_literal_1.ExcludeFromTemplateLiteral)(L2, R2), options);
      if ((0, kind_1.IsMappedResult)(L2))
        return (0, type_1.CloneType)((0, exclude_from_mapped_result_1.ExcludeFromMappedResult)(L2, R2), options);
      return (0, type_1.CloneType)((0, kind_1.IsUnion)(L2) ? ExcludeRest2(L2.anyOf, R2) : (0, index_3.ExtendsCheck)(L2, R2) !== index_3.ExtendsResult.False ? (0, index_2.Never)() : L2, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/exclude/exclude-from-mapped-result.js
var require_exclude_from_mapped_result = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/exclude/exclude-from-mapped-result.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExcludeFromMappedResult = ExcludeFromMappedResult2;
    var index_1 = require_mapped2();
    var exclude_1 = require_exclude();
    function FromProperties20(P2, U2) {
      const Acc = {};
      for (const K2 of globalThis.Object.getOwnPropertyNames(P2))
        Acc[K2] = (0, exclude_1.Exclude)(P2[K2], U2);
      return Acc;
    }
    function FromMappedResult13(R2, T2) {
      return FromProperties20(R2.properties, T2);
    }
    function ExcludeFromMappedResult2(R2, T2) {
      const P2 = FromMappedResult13(R2, T2);
      return (0, index_1.MappedResult)(P2);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/exclude/index.js
var require_exclude2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/exclude/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_exclude_from_mapped_result(), exports);
    __exportStar(require_exclude_from_template_literal(), exports);
    __exportStar(require_exclude(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extract/extract-from-template-literal.js
var require_extract_from_template_literal = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/extract/extract-from-template-literal.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExtractFromTemplateLiteral = ExtractFromTemplateLiteral2;
    var extract_1 = require_extract();
    var index_1 = require_template_literal2();
    function ExtractFromTemplateLiteral2(L2, R2) {
      return (0, extract_1.Extract)((0, index_1.TemplateLiteralToUnion)(L2), R2);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extract/extract.js
var require_extract = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/extract/extract.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Extract = Extract2;
    var index_1 = require_union2();
    var index_2 = require_never2();
    var index_3 = require_extends2();
    var type_1 = require_type2();
    var extract_from_mapped_result_1 = require_extract_from_mapped_result();
    var extract_from_template_literal_1 = require_extract_from_template_literal();
    var kind_1 = require_kind();
    function ExtractRest2(L2, R2) {
      const extracted = L2.filter((inner) => (0, index_3.ExtendsCheck)(inner, R2) !== index_3.ExtendsResult.False);
      return extracted.length === 1 ? extracted[0] : (0, index_1.Union)(extracted);
    }
    function Extract2(L2, R2, options = {}) {
      if ((0, kind_1.IsTemplateLiteral)(L2))
        return (0, type_1.CloneType)((0, extract_from_template_literal_1.ExtractFromTemplateLiteral)(L2, R2), options);
      if ((0, kind_1.IsMappedResult)(L2))
        return (0, type_1.CloneType)((0, extract_from_mapped_result_1.ExtractFromMappedResult)(L2, R2), options);
      return (0, type_1.CloneType)((0, kind_1.IsUnion)(L2) ? ExtractRest2(L2.anyOf, R2) : (0, index_3.ExtendsCheck)(L2, R2) !== index_3.ExtendsResult.False ? L2 : (0, index_2.Never)(), options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extract/extract-from-mapped-result.js
var require_extract_from_mapped_result = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/extract/extract-from-mapped-result.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExtractFromMappedResult = ExtractFromMappedResult2;
    var index_1 = require_mapped2();
    var extract_1 = require_extract();
    function FromProperties20(P2, T2) {
      const Acc = {};
      for (const K2 of globalThis.Object.getOwnPropertyNames(P2))
        Acc[K2] = (0, extract_1.Extract)(P2[K2], T2);
      return Acc;
    }
    function FromMappedResult13(R2, T2) {
      return FromProperties20(R2.properties, T2);
    }
    function ExtractFromMappedResult2(R2, T2) {
      const P2 = FromMappedResult13(R2, T2);
      return (0, index_1.MappedResult)(P2);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extract/index.js
var require_extract2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/extract/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_extract_from_mapped_result(), exports);
    __exportStar(require_extract_from_template_literal(), exports);
    __exportStar(require_extract(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/instance-type/instance-type.js
var require_instance_type = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/instance-type/instance-type.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InstanceType = InstanceType2;
    var type_1 = require_type2();
    function InstanceType2(schema, options = {}) {
      return (0, type_1.CloneType)(schema.returns, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/instance-type/index.js
var require_instance_type2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/instance-type/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_instance_type(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/integer/integer.js
var require_integer = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/integer/integer.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Integer = Integer2;
    var index_1 = require_symbols2();
    function Integer2(options = {}) {
      return {
        ...options,
        [index_1.Kind]: "Integer",
        type: "integer"
      };
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/integer/index.js
var require_integer2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/integer/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_integer(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intrinsic/intrinsic-from-mapped-key.js
var require_intrinsic_from_mapped_key = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/intrinsic/intrinsic-from-mapped-key.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IntrinsicFromMappedKey = IntrinsicFromMappedKey2;
    var index_1 = require_mapped2();
    var intrinsic_1 = require_intrinsic();
    var index_2 = require_literal2();
    function MappedIntrinsicPropertyKey2(K2, M2, options) {
      return {
        [K2]: (0, intrinsic_1.Intrinsic)((0, index_2.Literal)(K2), M2, options)
      };
    }
    function MappedIntrinsicPropertyKeys2(K2, M2, options) {
      return K2.reduce((Acc, L2) => {
        return { ...Acc, ...MappedIntrinsicPropertyKey2(L2, M2, options) };
      }, {});
    }
    function MappedIntrinsicProperties2(T2, M2, options) {
      return MappedIntrinsicPropertyKeys2(T2["keys"], M2, options);
    }
    function IntrinsicFromMappedKey2(T2, M2, options) {
      const P2 = MappedIntrinsicProperties2(T2, M2, options);
      return (0, index_1.MappedResult)(P2);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intrinsic/intrinsic.js
var require_intrinsic = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/intrinsic/intrinsic.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Intrinsic = Intrinsic2;
    var index_1 = require_template_literal2();
    var intrinsic_from_mapped_key_1 = require_intrinsic_from_mapped_key();
    var index_2 = require_literal2();
    var index_3 = require_union2();
    var kind_1 = require_kind();
    function ApplyUncapitalize2(value) {
      const [first, rest] = [value.slice(0, 1), value.slice(1)];
      return [first.toLowerCase(), rest].join("");
    }
    function ApplyCapitalize2(value) {
      const [first, rest] = [value.slice(0, 1), value.slice(1)];
      return [first.toUpperCase(), rest].join("");
    }
    function ApplyUppercase2(value) {
      return value.toUpperCase();
    }
    function ApplyLowercase2(value) {
      return value.toLowerCase();
    }
    function FromTemplateLiteral7(schema, mode, options) {
      const expression = (0, index_1.TemplateLiteralParseExact)(schema.pattern);
      const finite = (0, index_1.IsTemplateLiteralExpressionFinite)(expression);
      if (!finite)
        return { ...schema, pattern: FromLiteralValue2(schema.pattern, mode) };
      const strings = [...(0, index_1.TemplateLiteralExpressionGenerate)(expression)];
      const literals = strings.map((value) => (0, index_2.Literal)(value));
      const mapped = FromRest9(literals, mode);
      const union2 = (0, index_3.Union)(mapped);
      return (0, index_1.TemplateLiteral)([union2], options);
    }
    function FromLiteralValue2(value, mode) {
      return typeof value === "string" ? mode === "Uncapitalize" ? ApplyUncapitalize2(value) : mode === "Capitalize" ? ApplyCapitalize2(value) : mode === "Uppercase" ? ApplyUppercase2(value) : mode === "Lowercase" ? ApplyLowercase2(value) : value : value.toString();
    }
    function FromRest9(T2, M2) {
      return T2.map((L2) => Intrinsic2(L2, M2));
    }
    function Intrinsic2(schema, mode, options = {}) {
      return (
        // Intrinsic-Mapped-Inference
        (0, kind_1.IsMappedKey)(schema) ? (0, intrinsic_from_mapped_key_1.IntrinsicFromMappedKey)(schema, mode, options) : (
          // Standard-Inference
          (0, kind_1.IsTemplateLiteral)(schema) ? FromTemplateLiteral7(schema, mode, schema) : (0, kind_1.IsUnion)(schema) ? (0, index_3.Union)(FromRest9(schema.anyOf, mode), options) : (0, kind_1.IsLiteral)(schema) ? (0, index_2.Literal)(FromLiteralValue2(schema.const, mode), options) : schema
        )
      );
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intrinsic/capitalize.js
var require_capitalize = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/intrinsic/capitalize.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Capitalize = Capitalize2;
    var intrinsic_1 = require_intrinsic();
    function Capitalize2(T2, options = {}) {
      return (0, intrinsic_1.Intrinsic)(T2, "Capitalize", options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intrinsic/lowercase.js
var require_lowercase = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/intrinsic/lowercase.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Lowercase = Lowercase2;
    var intrinsic_1 = require_intrinsic();
    function Lowercase2(T2, options = {}) {
      return (0, intrinsic_1.Intrinsic)(T2, "Lowercase", options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intrinsic/uncapitalize.js
var require_uncapitalize = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/intrinsic/uncapitalize.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Uncapitalize = Uncapitalize2;
    var intrinsic_1 = require_intrinsic();
    function Uncapitalize2(T2, options = {}) {
      return (0, intrinsic_1.Intrinsic)(T2, "Uncapitalize", options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intrinsic/uppercase.js
var require_uppercase = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/intrinsic/uppercase.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Uppercase = Uppercase2;
    var intrinsic_1 = require_intrinsic();
    function Uppercase2(T2, options = {}) {
      return (0, intrinsic_1.Intrinsic)(T2, "Uppercase", options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intrinsic/index.js
var require_intrinsic2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/intrinsic/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_capitalize(), exports);
    __exportStar(require_intrinsic_from_mapped_key(), exports);
    __exportStar(require_intrinsic(), exports);
    __exportStar(require_lowercase(), exports);
    __exportStar(require_uncapitalize(), exports);
    __exportStar(require_uppercase(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/not/not.js
var require_not = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/not/not.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Not = Not3;
    var type_1 = require_type2();
    var index_1 = require_symbols2();
    function Not3(schema, options) {
      return {
        ...options,
        [index_1.Kind]: "Not",
        not: (0, type_1.CloneType)(schema)
      };
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/not/index.js
var require_not2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/not/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_not(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/omit/omit-from-mapped-result.js
var require_omit_from_mapped_result = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/omit/omit-from-mapped-result.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OmitFromMappedResult = OmitFromMappedResult2;
    var index_1 = require_mapped2();
    var omit_1 = require_omit();
    function FromProperties20(P2, K2, options) {
      const Acc = {};
      for (const K22 of globalThis.Object.getOwnPropertyNames(P2))
        Acc[K22] = (0, omit_1.Omit)(P2[K22], K2, options);
      return Acc;
    }
    function FromMappedResult13(R2, K2, options) {
      return FromProperties20(R2.properties, K2, options);
    }
    function OmitFromMappedResult2(R2, K2, options) {
      const P2 = FromMappedResult13(R2, K2, options);
      return (0, index_1.MappedResult)(P2);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/omit/omit.js
var require_omit = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/omit/omit.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Omit = Omit2;
    var index_1 = require_intersect2();
    var index_2 = require_union2();
    var index_3 = require_object2();
    var index_4 = require_indexed2();
    var index_5 = require_discard2();
    var index_6 = require_symbols2();
    var type_1 = require_type2();
    var omit_from_mapped_key_1 = require_omit_from_mapped_key();
    var omit_from_mapped_result_1 = require_omit_from_mapped_result();
    var kind_1 = require_kind();
    function FromIntersect18(T2, K2) {
      return T2.map((T3) => OmitResolve2(T3, K2));
    }
    function FromUnion20(T2, K2) {
      return T2.map((T3) => OmitResolve2(T3, K2));
    }
    function FromProperty3(T2, K2) {
      const { [K2]: _, ...R2 } = T2;
      return R2;
    }
    function FromProperties20(T2, K2) {
      return K2.reduce((T3, K22) => FromProperty3(T3, K22), T2);
    }
    function OmitResolve2(T2, K2) {
      return (0, kind_1.IsIntersect)(T2) ? (0, index_1.Intersect)(FromIntersect18(T2.allOf, K2)) : (0, kind_1.IsUnion)(T2) ? (0, index_2.Union)(FromUnion20(T2.anyOf, K2)) : (0, kind_1.IsObject)(T2) ? (0, index_3.Object)(FromProperties20(T2.properties, K2)) : (0, index_3.Object)({});
    }
    function Omit2(T2, K2, options = {}) {
      if ((0, kind_1.IsMappedKey)(K2))
        return (0, omit_from_mapped_key_1.OmitFromMappedKey)(T2, K2, options);
      if ((0, kind_1.IsMappedResult)(T2))
        return (0, omit_from_mapped_result_1.OmitFromMappedResult)(T2, K2, options);
      const I2 = (0, kind_1.IsSchema)(K2) ? (0, index_4.IndexPropertyKeys)(K2) : K2;
      const D2 = (0, index_5.Discard)(T2, [index_6.TransformKind, "$id", "required"]);
      const R2 = (0, type_1.CloneType)(OmitResolve2(T2, I2), options);
      return { ...D2, ...R2 };
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/omit/omit-from-mapped-key.js
var require_omit_from_mapped_key = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/omit/omit-from-mapped-key.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OmitFromMappedKey = OmitFromMappedKey2;
    var index_1 = require_mapped2();
    var omit_1 = require_omit();
    function FromPropertyKey4(T2, K2, options) {
      return {
        [K2]: (0, omit_1.Omit)(T2, [K2], options)
      };
    }
    function FromPropertyKeys4(T2, K2, options) {
      return K2.reduce((Acc, LK) => {
        return { ...Acc, ...FromPropertyKey4(T2, LK, options) };
      }, {});
    }
    function FromMappedKey5(T2, K2, options) {
      return FromPropertyKeys4(T2, K2.keys, options);
    }
    function OmitFromMappedKey2(T2, K2, options) {
      const P2 = FromMappedKey5(T2, K2, options);
      return (0, index_1.MappedResult)(P2);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/omit/index.js
var require_omit2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/omit/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_omit_from_mapped_key(), exports);
    __exportStar(require_omit_from_mapped_result(), exports);
    __exportStar(require_omit(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/parameters/parameters.js
var require_parameters = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/parameters/parameters.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Parameters = Parameters2;
    var index_1 = require_tuple2();
    var type_1 = require_type2();
    function Parameters2(schema, options = {}) {
      return (0, index_1.Tuple)((0, type_1.CloneRest)(schema.parameters), { ...options });
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/parameters/index.js
var require_parameters2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/parameters/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_parameters(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/partial/partial.js
var require_partial = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/partial/partial.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Partial = Partial2;
    var index_1 = require_optional2();
    var index_2 = require_object2();
    var index_3 = require_intersect2();
    var index_4 = require_union2();
    var index_5 = require_discard2();
    var index_6 = require_symbols2();
    var type_1 = require_type2();
    var partial_from_mapped_result_1 = require_partial_from_mapped_result();
    var kind_1 = require_kind();
    function FromRest9(T2) {
      return T2.map((L2) => PartialResolve2(L2));
    }
    function FromProperties20(T2) {
      const Acc = {};
      for (const K2 of globalThis.Object.getOwnPropertyNames(T2))
        Acc[K2] = (0, index_1.Optional)(T2[K2]);
      return Acc;
    }
    function PartialResolve2(T2) {
      return (0, kind_1.IsIntersect)(T2) ? (0, index_3.Intersect)(FromRest9(T2.allOf)) : (0, kind_1.IsUnion)(T2) ? (0, index_4.Union)(FromRest9(T2.anyOf)) : (0, kind_1.IsObject)(T2) ? (0, index_2.Object)(FromProperties20(T2.properties)) : (0, index_2.Object)({});
    }
    function Partial2(T2, options = {}) {
      if ((0, kind_1.IsMappedResult)(T2))
        return (0, partial_from_mapped_result_1.PartialFromMappedResult)(T2, options);
      const D2 = (0, index_5.Discard)(T2, [index_6.TransformKind, "$id", "required"]);
      const R2 = (0, type_1.CloneType)(PartialResolve2(T2), options);
      return { ...D2, ...R2 };
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/partial/partial-from-mapped-result.js
var require_partial_from_mapped_result = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/partial/partial-from-mapped-result.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PartialFromMappedResult = PartialFromMappedResult2;
    var index_1 = require_mapped2();
    var partial_1 = require_partial();
    function FromProperties20(K2, options) {
      const Acc = {};
      for (const K22 of globalThis.Object.getOwnPropertyNames(K2))
        Acc[K22] = (0, partial_1.Partial)(K2[K22], options);
      return Acc;
    }
    function FromMappedResult13(R2, options) {
      return FromProperties20(R2.properties, options);
    }
    function PartialFromMappedResult2(R2, options) {
      const P2 = FromMappedResult13(R2, options);
      return (0, index_1.MappedResult)(P2);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/partial/index.js
var require_partial2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/partial/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_partial_from_mapped_result(), exports);
    __exportStar(require_partial(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/pick/pick-from-mapped-result.js
var require_pick_from_mapped_result = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/pick/pick-from-mapped-result.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PickFromMappedResult = PickFromMappedResult2;
    var index_1 = require_mapped2();
    var pick_1 = require_pick();
    function FromProperties20(P2, K2, options) {
      const Acc = {};
      for (const K22 of globalThis.Object.getOwnPropertyNames(P2))
        Acc[K22] = (0, pick_1.Pick)(P2[K22], K2, options);
      return Acc;
    }
    function FromMappedResult13(R2, K2, options) {
      return FromProperties20(R2.properties, K2, options);
    }
    function PickFromMappedResult2(R2, K2, options) {
      const P2 = FromMappedResult13(R2, K2, options);
      return (0, index_1.MappedResult)(P2);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/pick/pick.js
var require_pick = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/pick/pick.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Pick = Pick2;
    var index_1 = require_intersect2();
    var index_2 = require_union2();
    var index_3 = require_object2();
    var index_4 = require_indexed2();
    var index_5 = require_discard2();
    var index_6 = require_symbols2();
    var type_1 = require_type2();
    var pick_from_mapped_key_1 = require_pick_from_mapped_key();
    var pick_from_mapped_result_1 = require_pick_from_mapped_result();
    var kind_1 = require_kind();
    function FromIntersect18(T2, K2) {
      return T2.map((T3) => PickResolve2(T3, K2));
    }
    function FromUnion20(T2, K2) {
      return T2.map((T3) => PickResolve2(T3, K2));
    }
    function FromProperties20(T2, K2) {
      const Acc = {};
      for (const K22 of K2)
        if (K22 in T2)
          Acc[K22] = T2[K22];
      return Acc;
    }
    function PickResolve2(T2, K2) {
      return (0, kind_1.IsIntersect)(T2) ? (0, index_1.Intersect)(FromIntersect18(T2.allOf, K2)) : (0, kind_1.IsUnion)(T2) ? (0, index_2.Union)(FromUnion20(T2.anyOf, K2)) : (0, kind_1.IsObject)(T2) ? (0, index_3.Object)(FromProperties20(T2.properties, K2)) : (0, index_3.Object)({});
    }
    function Pick2(T2, K2, options = {}) {
      if ((0, kind_1.IsMappedKey)(K2))
        return (0, pick_from_mapped_key_1.PickFromMappedKey)(T2, K2, options);
      if ((0, kind_1.IsMappedResult)(T2))
        return (0, pick_from_mapped_result_1.PickFromMappedResult)(T2, K2, options);
      const I2 = (0, kind_1.IsSchema)(K2) ? (0, index_4.IndexPropertyKeys)(K2) : K2;
      const D2 = (0, index_5.Discard)(T2, [index_6.TransformKind, "$id", "required"]);
      const R2 = (0, type_1.CloneType)(PickResolve2(T2, I2), options);
      return { ...D2, ...R2 };
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/pick/pick-from-mapped-key.js
var require_pick_from_mapped_key = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/pick/pick-from-mapped-key.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PickFromMappedKey = PickFromMappedKey2;
    var index_1 = require_mapped2();
    var pick_1 = require_pick();
    function FromPropertyKey4(T2, K2, options) {
      return {
        [K2]: (0, pick_1.Pick)(T2, [K2], options)
      };
    }
    function FromPropertyKeys4(T2, K2, options) {
      return K2.reduce((Acc, LK) => {
        return { ...Acc, ...FromPropertyKey4(T2, LK, options) };
      }, {});
    }
    function FromMappedKey5(T2, K2, options) {
      return FromPropertyKeys4(T2, K2.keys, options);
    }
    function PickFromMappedKey2(T2, K2, options) {
      const P2 = FromMappedKey5(T2, K2, options);
      return (0, index_1.MappedResult)(P2);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/pick/index.js
var require_pick2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/pick/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_pick_from_mapped_key(), exports);
    __exportStar(require_pick_from_mapped_result(), exports);
    __exportStar(require_pick(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/readonly-optional/readonly-optional.js
var require_readonly_optional = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/readonly-optional/readonly-optional.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReadonlyOptional = ReadonlyOptional2;
    var index_1 = require_readonly2();
    var index_2 = require_optional2();
    function ReadonlyOptional2(schema) {
      return (0, index_1.Readonly)((0, index_2.Optional)(schema));
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/readonly-optional/index.js
var require_readonly_optional2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/readonly-optional/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_readonly_optional(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/record/record.js
var require_record = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/record/record.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Record = Record2;
    var index_1 = require_object2();
    var index_2 = require_never2();
    var index_3 = require_union2();
    var index_4 = require_template_literal2();
    var index_5 = require_patterns2();
    var index_6 = require_indexed2();
    var index_7 = require_symbols2();
    var type_1 = require_type2();
    var value_1 = require_value();
    var kind_1 = require_kind();
    function RecordCreateFromPattern2(pattern, T2, options) {
      return {
        ...options,
        [index_7.Kind]: "Record",
        type: "object",
        patternProperties: { [pattern]: (0, type_1.CloneType)(T2) }
      };
    }
    function RecordCreateFromKeys2(K2, T2, options) {
      const Acc = {};
      for (const K22 of K2)
        Acc[K22] = (0, type_1.CloneType)(T2);
      return (0, index_1.Object)(Acc, { ...options, [index_7.Hint]: "Record" });
    }
    function FromTemplateLiteralKey2(K2, T2, options) {
      return (0, index_4.IsTemplateLiteralFinite)(K2) ? RecordCreateFromKeys2((0, index_6.IndexPropertyKeys)(K2), T2, options) : RecordCreateFromPattern2(K2.pattern, T2, options);
    }
    function FromUnionKey2(K2, T2, options) {
      return RecordCreateFromKeys2((0, index_6.IndexPropertyKeys)((0, index_3.Union)(K2)), T2, options);
    }
    function FromLiteralKey2(K2, T2, options) {
      return RecordCreateFromKeys2([K2.toString()], T2, options);
    }
    function FromRegExpKey2(K2, T2, options) {
      return RecordCreateFromPattern2(K2.source, T2, options);
    }
    function FromStringKey2(K2, T2, options) {
      const pattern = (0, value_1.IsUndefined)(K2.pattern) ? index_5.PatternStringExact : K2.pattern;
      return RecordCreateFromPattern2(pattern, T2, options);
    }
    function FromIntegerKey2(_, T2, options) {
      return RecordCreateFromPattern2(index_5.PatternNumberExact, T2, options);
    }
    function FromNumberKey2(_, T2, options) {
      return RecordCreateFromPattern2(index_5.PatternNumberExact, T2, options);
    }
    function Record2(K2, T2, options = {}) {
      return (0, kind_1.IsUnion)(K2) ? FromUnionKey2(K2.anyOf, T2, options) : (0, kind_1.IsTemplateLiteral)(K2) ? FromTemplateLiteralKey2(K2, T2, options) : (0, kind_1.IsLiteral)(K2) ? FromLiteralKey2(K2.const, T2, options) : (0, kind_1.IsInteger)(K2) ? FromIntegerKey2(K2, T2, options) : (0, kind_1.IsNumber)(K2) ? FromNumberKey2(K2, T2, options) : (0, kind_1.IsRegExp)(K2) ? FromRegExpKey2(K2, T2, options) : (0, kind_1.IsString)(K2) ? FromStringKey2(K2, T2, options) : (0, index_2.Never)(options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/record/index.js
var require_record2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/record/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_record(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/recursive/recursive.js
var require_recursive = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/recursive/recursive.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Recursive = Recursive2;
    var type_1 = require_type2();
    var value_1 = require_value();
    var index_1 = require_symbols2();
    var Ordinal2 = 0;
    function Recursive2(callback, options = {}) {
      if ((0, value_1.IsUndefined)(options.$id))
        options.$id = `T${Ordinal2++}`;
      const thisType = callback({ [index_1.Kind]: "This", $ref: `${options.$id}` });
      thisType.$id = options.$id;
      return (0, type_1.CloneType)({ ...options, [index_1.Hint]: "Recursive", ...thisType });
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/recursive/index.js
var require_recursive2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/recursive/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_recursive(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/ref/ref.js
var require_ref = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/ref/ref.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Ref = Ref2;
    var index_1 = require_symbols2();
    var value_1 = require_value();
    function Ref2(unresolved, options = {}) {
      if ((0, value_1.IsString)(unresolved))
        return { ...options, [index_1.Kind]: "Ref", $ref: unresolved };
      if ((0, value_1.IsUndefined)(unresolved.$id))
        throw new Error("Reference target type must specify an $id");
      return {
        ...options,
        [index_1.Kind]: "Ref",
        $ref: unresolved.$id
      };
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/ref/index.js
var require_ref2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/ref/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_ref(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/regexp/regexp.js
var require_regexp = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/regexp/regexp.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RegExp = RegExp3;
    var value_1 = require_value();
    var index_1 = require_symbols2();
    function RegExp3(unresolved, options = {}) {
      const expr = (0, value_1.IsString)(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
      return { ...options, [index_1.Kind]: "RegExp", type: "RegExp", source: expr.source, flags: expr.flags };
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/regexp/index.js
var require_regexp2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/regexp/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_regexp(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/required/required.js
var require_required = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/required/required.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Required = Required2;
    var index_1 = require_intersect2();
    var index_2 = require_union2();
    var index_3 = require_object2();
    var index_4 = require_symbols2();
    var type_1 = require_type2();
    var index_5 = require_discard2();
    var required_from_mapped_result_1 = require_required_from_mapped_result();
    var kind_1 = require_kind();
    function FromRest9(T2) {
      return T2.map((L2) => RequiredResolve2(L2));
    }
    function FromProperties20(T2) {
      const Acc = {};
      for (const K2 of globalThis.Object.getOwnPropertyNames(T2))
        Acc[K2] = (0, index_5.Discard)(T2[K2], [index_4.OptionalKind]);
      return Acc;
    }
    function RequiredResolve2(T2) {
      return (0, kind_1.IsIntersect)(T2) ? (0, index_1.Intersect)(FromRest9(T2.allOf)) : (0, kind_1.IsUnion)(T2) ? (0, index_2.Union)(FromRest9(T2.anyOf)) : (0, kind_1.IsObject)(T2) ? (0, index_3.Object)(FromProperties20(T2.properties)) : (0, index_3.Object)({});
    }
    function Required2(T2, options = {}) {
      if ((0, kind_1.IsMappedResult)(T2)) {
        return (0, required_from_mapped_result_1.RequiredFromMappedResult)(T2, options);
      } else {
        const D2 = (0, index_5.Discard)(T2, [index_4.TransformKind, "$id", "required"]);
        const R2 = (0, type_1.CloneType)(RequiredResolve2(T2), options);
        return { ...D2, ...R2 };
      }
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/required/required-from-mapped-result.js
var require_required_from_mapped_result = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/required/required-from-mapped-result.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RequiredFromMappedResult = RequiredFromMappedResult2;
    var index_1 = require_mapped2();
    var required_1 = require_required();
    function FromProperties20(P2, options) {
      const Acc = {};
      for (const K2 of globalThis.Object.getOwnPropertyNames(P2))
        Acc[K2] = (0, required_1.Required)(P2[K2], options);
      return Acc;
    }
    function FromMappedResult13(R2, options) {
      return FromProperties20(R2.properties, options);
    }
    function RequiredFromMappedResult2(R2, options) {
      const P2 = FromMappedResult13(R2, options);
      return (0, index_1.MappedResult)(P2);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/required/index.js
var require_required2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/required/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_required_from_mapped_result(), exports);
    __exportStar(require_required(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/rest/rest.js
var require_rest = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/rest/rest.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Rest = Rest2;
    var type_1 = require_type2();
    var kind_1 = require_kind();
    function RestResolve2(T2) {
      return (0, kind_1.IsIntersect)(T2) ? (0, type_1.CloneRest)(T2.allOf) : (0, kind_1.IsUnion)(T2) ? (0, type_1.CloneRest)(T2.anyOf) : (0, kind_1.IsTuple)(T2) ? (0, type_1.CloneRest)(T2.items ?? []) : [];
    }
    function Rest2(T2) {
      return (0, type_1.CloneRest)(RestResolve2(T2));
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/rest/index.js
var require_rest2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/rest/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_rest(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/return-type/return-type.js
var require_return_type = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/return-type/return-type.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReturnType = ReturnType2;
    var type_1 = require_type2();
    function ReturnType2(schema, options = {}) {
      return (0, type_1.CloneType)(schema.returns, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/return-type/index.js
var require_return_type2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/return-type/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_return_type(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/schema/anyschema.js
var require_anyschema = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/schema/anyschema.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/schema/schema.js
var require_schema = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/schema/schema.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_symbols2();
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/schema/index.js
var require_schema2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/schema/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_anyschema(), exports);
    __exportStar(require_schema(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/static/static.js
var require_static = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/static/static.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/static/index.js
var require_static2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/static/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_static(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/strict/strict.js
var require_strict = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/strict/strict.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Strict = Strict2;
    function Strict2(schema) {
      return JSON.parse(JSON.stringify(schema));
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/strict/index.js
var require_strict2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/strict/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_strict(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/transform/transform.js
var require_transform2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/transform/transform.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TransformEncodeBuilder = exports.TransformDecodeBuilder = void 0;
    exports.Transform = Transform3;
    var index_1 = require_symbols2();
    var type_1 = require_type2();
    var kind_1 = require_kind();
    var TransformDecodeBuilder2 = class {
      constructor(schema) {
        this.schema = schema;
      }
      Decode(decode3) {
        return new TransformEncodeBuilder2(this.schema, decode3);
      }
    };
    exports.TransformDecodeBuilder = TransformDecodeBuilder2;
    var TransformEncodeBuilder2 = class {
      constructor(schema, decode3) {
        this.schema = schema;
        this.decode = decode3;
      }
      EncodeTransform(encode3, schema) {
        const Encode2 = (value) => schema[index_1.TransformKind].Encode(encode3(value));
        const Decode2 = (value) => this.decode(schema[index_1.TransformKind].Decode(value));
        const Codec = { Encode: Encode2, Decode: Decode2 };
        return { ...schema, [index_1.TransformKind]: Codec };
      }
      EncodeSchema(encode3, schema) {
        const Codec = { Decode: this.decode, Encode: encode3 };
        return { ...schema, [index_1.TransformKind]: Codec };
      }
      Encode(encode3) {
        const schema = (0, type_1.CloneType)(this.schema);
        return (0, kind_1.IsTransform)(schema) ? this.EncodeTransform(encode3, schema) : this.EncodeSchema(encode3, schema);
      }
    };
    exports.TransformEncodeBuilder = TransformEncodeBuilder2;
    function Transform3(schema) {
      return new TransformDecodeBuilder2(schema);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/transform/index.js
var require_transform3 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/transform/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_transform2(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/void/void.js
var require_void = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/void/void.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Void = Void2;
    var index_1 = require_symbols2();
    function Void2(options = {}) {
      return {
        ...options,
        [index_1.Kind]: "Void",
        type: "void"
      };
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/void/index.js
var require_void2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/void/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_void(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/type/json.js
var require_json = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/type/json.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JsonTypeBuilder = void 0;
    var index_1 = require_any2();
    var index_2 = require_array2();
    var index_3 = require_boolean2();
    var index_4 = require_composite2();
    var index_5 = require_const2();
    var index_6 = require_deref4();
    var index_7 = require_enum2();
    var index_8 = require_exclude2();
    var index_9 = require_extends2();
    var index_10 = require_extract2();
    var index_11 = require_indexed2();
    var index_12 = require_integer2();
    var index_13 = require_intersect2();
    var index_14 = require_intrinsic2();
    var index_15 = require_keyof2();
    var index_16 = require_literal2();
    var index_17 = require_mapped2();
    var index_18 = require_never2();
    var index_19 = require_not2();
    var index_20 = require_null2();
    var index_21 = require_number2();
    var index_22 = require_object2();
    var index_23 = require_omit2();
    var index_24 = require_optional2();
    var index_25 = require_partial2();
    var index_26 = require_pick2();
    var index_27 = require_readonly2();
    var index_28 = require_readonly_optional2();
    var index_29 = require_record2();
    var index_30 = require_recursive2();
    var index_31 = require_ref2();
    var index_32 = require_required2();
    var index_33 = require_rest2();
    var index_34 = require_strict2();
    var index_35 = require_string2();
    var index_36 = require_template_literal2();
    var index_37 = require_transform3();
    var index_38 = require_tuple2();
    var index_39 = require_union2();
    var index_40 = require_unknown2();
    var index_41 = require_unsafe2();
    var JsonTypeBuilder2 = class {
      // ------------------------------------------------------------------------
      // Strict
      // ------------------------------------------------------------------------
      /** `[Json]` Omits compositing symbols from this schema */
      Strict(schema) {
        return (0, index_34.Strict)(schema);
      }
      // ------------------------------------------------------------------------
      // Modifiers
      // ------------------------------------------------------------------------
      /** `[Json]` Creates a Readonly and Optional property */
      ReadonlyOptional(schema) {
        return (0, index_28.ReadonlyOptional)(schema);
      }
      /** `[Json]` Creates a Readonly property */
      Readonly(schema, enable) {
        return (0, index_27.Readonly)(schema, enable ?? true);
      }
      /** `[Json]` Creates a Optional property */
      Optional(schema, enable) {
        return (0, index_24.Optional)(schema, enable ?? true);
      }
      // ------------------------------------------------------------------------
      // Types
      // ------------------------------------------------------------------------
      /** `[Json]` Creates an Any type */
      Any(options = {}) {
        return (0, index_1.Any)(options);
      }
      /** `[Json]` Creates an Array type */
      Array(schema, options = {}) {
        return (0, index_2.Array)(schema, options);
      }
      /** `[Json]` Creates a Boolean type */
      Boolean(options = {}) {
        return (0, index_3.Boolean)(options);
      }
      /** `[Json]` Intrinsic function to Capitalize LiteralString types */
      Capitalize(schema, options = {}) {
        return (0, index_14.Capitalize)(schema, options);
      }
      /** `[Json]` Creates a Composite object type */
      Composite(schemas, options) {
        return (0, index_4.Composite)(schemas, options);
      }
      /** `[JavaScript]` Creates a readonly const type from the given value. */
      Const(value, options = {}) {
        return (0, index_5.Const)(value, options);
      }
      /** `[Json]` Creates a dereferenced type */
      Deref(schema, references) {
        return (0, index_6.Deref)(schema, references);
      }
      /** `[Json]` Creates a Enum type */
      Enum(item, options = {}) {
        return (0, index_7.Enum)(item, options);
      }
      /** `[Json]` Constructs a type by excluding from unionType all union members that are assignable to excludedMembers */
      Exclude(unionType, excludedMembers, options = {}) {
        return (0, index_8.Exclude)(unionType, excludedMembers, options);
      }
      /** `[Json]` Creates a Conditional type */
      Extends(L2, R2, T2, F2, options = {}) {
        return (0, index_9.Extends)(L2, R2, T2, F2, options);
      }
      /** `[Json]` Constructs a type by extracting from type all union members that are assignable to union */
      Extract(type, union2, options = {}) {
        return (0, index_10.Extract)(type, union2, options);
      }
      /** `[Json]` Returns an Indexed property type for the given keys */
      Index(schema, unresolved, options = {}) {
        return (0, index_11.Index)(schema, unresolved, options);
      }
      /** `[Json]` Creates an Integer type */
      Integer(options = {}) {
        return (0, index_12.Integer)(options);
      }
      /** `[Json]` Creates an Intersect type */
      Intersect(T2, options = {}) {
        return (0, index_13.Intersect)(T2, options);
      }
      /** `[Json]` Creates a KeyOf type */
      KeyOf(schema, options = {}) {
        return (0, index_15.KeyOf)(schema, options);
      }
      /** `[Json]` Creates a Literal type */
      Literal(value, options = {}) {
        return (0, index_16.Literal)(value, options);
      }
      /** `[Json]` Intrinsic function to Lowercase LiteralString types */
      Lowercase(schema, options = {}) {
        return (0, index_14.Lowercase)(schema, options);
      }
      /** `[Json]` Creates a Mapped object type */
      Mapped(key2, map9, options = {}) {
        return (0, index_17.Mapped)(key2, map9, options);
      }
      /** `[Json]` Creates a Never type */
      Never(options = {}) {
        return (0, index_18.Never)(options);
      }
      /** `[Json]` Creates a Not type */
      Not(schema, options) {
        return (0, index_19.Not)(schema, options);
      }
      /** `[Json]` Creates a Null type */
      Null(options = {}) {
        return (0, index_20.Null)(options);
      }
      /** `[Json]` Creates a Number type */
      Number(options = {}) {
        return (0, index_21.Number)(options);
      }
      /** `[Json]` Creates an Object type */
      Object(properties, options = {}) {
        return (0, index_22.Object)(properties, options);
      }
      /** `[Json]` Constructs a type whose keys are omitted from the given type */
      Omit(schema, unresolved, options = {}) {
        return (0, index_23.Omit)(schema, unresolved, options);
      }
      /** `[Json]` Constructs a type where all properties are optional */
      Partial(schema, options = {}) {
        return (0, index_25.Partial)(schema, options);
      }
      /** `[Json]` Constructs a type whose keys are picked from the given type */
      Pick(schema, unresolved, options = {}) {
        return (0, index_26.Pick)(schema, unresolved, options);
      }
      /** `[Json]` Creates a Record type */
      Record(key2, schema, options = {}) {
        return (0, index_29.Record)(key2, schema, options);
      }
      /** `[Json]` Creates a Recursive type */
      Recursive(callback, options = {}) {
        return (0, index_30.Recursive)(callback, options);
      }
      /** `[Json]` Creates a Ref type. */
      Ref(unresolved, options = {}) {
        return (0, index_31.Ref)(unresolved, options);
      }
      /** `[Json]` Constructs a type where all properties are required */
      Required(schema, options = {}) {
        return (0, index_32.Required)(schema, options);
      }
      /** `[Json]` Extracts interior Rest elements from Tuple, Intersect and Union types */
      Rest(schema) {
        return (0, index_33.Rest)(schema);
      }
      /** `[Json]` Creates a String type */
      String(options = {}) {
        return (0, index_35.String)(options);
      }
      /** `[Json]` Creates a TemplateLiteral type */
      TemplateLiteral(unresolved, options = {}) {
        return (0, index_36.TemplateLiteral)(unresolved, options);
      }
      /** `[Json]` Creates a Transform type */
      Transform(schema) {
        return (0, index_37.Transform)(schema);
      }
      /** `[Json]` Creates a Tuple type */
      Tuple(items, options = {}) {
        return (0, index_38.Tuple)(items, options);
      }
      /** `[Json]` Intrinsic function to Uncapitalize LiteralString types */
      Uncapitalize(schema, options = {}) {
        return (0, index_14.Uncapitalize)(schema, options);
      }
      /** `[Json]` Creates a Union type */
      Union(schemas, options = {}) {
        return (0, index_39.Union)(schemas, options);
      }
      /** `[Json]` Creates an Unknown type */
      Unknown(options = {}) {
        return (0, index_40.Unknown)(options);
      }
      /** `[Json]` Creates a Unsafe type that will infers as the generic argument T */
      Unsafe(options = {}) {
        return (0, index_41.Unsafe)(options);
      }
      /** `[Json]` Intrinsic function to Uppercase LiteralString types */
      Uppercase(schema, options = {}) {
        return (0, index_14.Uppercase)(schema, options);
      }
    };
    exports.JsonTypeBuilder = JsonTypeBuilder2;
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/type/type.js
var require_type4 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/type/type.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Strict = exports.ReturnType = exports.Rest = exports.Required = exports.RegExp = exports.Ref = exports.Recursive = exports.Record = exports.ReadonlyOptional = exports.Readonly = exports.Promise = exports.Pick = exports.Partial = exports.Parameters = exports.Optional = exports.Omit = exports.Object = exports.Number = exports.Null = exports.Not = exports.Never = exports.Mapped = exports.Literal = exports.KeyOf = exports.Iterator = exports.Uppercase = exports.Lowercase = exports.Uncapitalize = exports.Capitalize = exports.Intersect = exports.Integer = exports.InstanceType = exports.Index = exports.Function = exports.Extract = exports.Extends = exports.Exclude = exports.Enum = exports.Deref = exports.Date = exports.ConstructorParameters = exports.Constructor = exports.Const = exports.Composite = exports.Boolean = exports.BigInt = exports.Awaited = exports.AsyncIterator = exports.Array = exports.Any = void 0;
    exports.Void = exports.Unsafe = exports.Unknown = exports.Union = exports.Undefined = exports.Uint8Array = exports.Tuple = exports.Transform = exports.TemplateLiteral = exports.Symbol = exports.String = void 0;
    var index_1 = require_any2();
    Object.defineProperty(exports, "Any", { enumerable: true, get: function() {
      return index_1.Any;
    } });
    var index_2 = require_array2();
    Object.defineProperty(exports, "Array", { enumerable: true, get: function() {
      return index_2.Array;
    } });
    var index_3 = require_async_iterator2();
    Object.defineProperty(exports, "AsyncIterator", { enumerable: true, get: function() {
      return index_3.AsyncIterator;
    } });
    var index_4 = require_awaited2();
    Object.defineProperty(exports, "Awaited", { enumerable: true, get: function() {
      return index_4.Awaited;
    } });
    var index_5 = require_bigint2();
    Object.defineProperty(exports, "BigInt", { enumerable: true, get: function() {
      return index_5.BigInt;
    } });
    var index_6 = require_boolean2();
    Object.defineProperty(exports, "Boolean", { enumerable: true, get: function() {
      return index_6.Boolean;
    } });
    var index_7 = require_composite2();
    Object.defineProperty(exports, "Composite", { enumerable: true, get: function() {
      return index_7.Composite;
    } });
    var index_8 = require_const2();
    Object.defineProperty(exports, "Const", { enumerable: true, get: function() {
      return index_8.Const;
    } });
    var index_9 = require_constructor2();
    Object.defineProperty(exports, "Constructor", { enumerable: true, get: function() {
      return index_9.Constructor;
    } });
    var index_10 = require_constructor_parameters2();
    Object.defineProperty(exports, "ConstructorParameters", { enumerable: true, get: function() {
      return index_10.ConstructorParameters;
    } });
    var index_11 = require_date2();
    Object.defineProperty(exports, "Date", { enumerable: true, get: function() {
      return index_11.Date;
    } });
    var index_12 = require_deref4();
    Object.defineProperty(exports, "Deref", { enumerable: true, get: function() {
      return index_12.Deref;
    } });
    var index_13 = require_enum2();
    Object.defineProperty(exports, "Enum", { enumerable: true, get: function() {
      return index_13.Enum;
    } });
    var index_14 = require_exclude2();
    Object.defineProperty(exports, "Exclude", { enumerable: true, get: function() {
      return index_14.Exclude;
    } });
    var index_15 = require_extends2();
    Object.defineProperty(exports, "Extends", { enumerable: true, get: function() {
      return index_15.Extends;
    } });
    var index_16 = require_extract2();
    Object.defineProperty(exports, "Extract", { enumerable: true, get: function() {
      return index_16.Extract;
    } });
    var index_17 = require_function2();
    Object.defineProperty(exports, "Function", { enumerable: true, get: function() {
      return index_17.Function;
    } });
    var index_18 = require_indexed2();
    Object.defineProperty(exports, "Index", { enumerable: true, get: function() {
      return index_18.Index;
    } });
    var index_19 = require_instance_type2();
    Object.defineProperty(exports, "InstanceType", { enumerable: true, get: function() {
      return index_19.InstanceType;
    } });
    var index_20 = require_integer2();
    Object.defineProperty(exports, "Integer", { enumerable: true, get: function() {
      return index_20.Integer;
    } });
    var index_21 = require_intersect2();
    Object.defineProperty(exports, "Intersect", { enumerable: true, get: function() {
      return index_21.Intersect;
    } });
    var index_22 = require_intrinsic2();
    Object.defineProperty(exports, "Capitalize", { enumerable: true, get: function() {
      return index_22.Capitalize;
    } });
    Object.defineProperty(exports, "Uncapitalize", { enumerable: true, get: function() {
      return index_22.Uncapitalize;
    } });
    Object.defineProperty(exports, "Lowercase", { enumerable: true, get: function() {
      return index_22.Lowercase;
    } });
    Object.defineProperty(exports, "Uppercase", { enumerable: true, get: function() {
      return index_22.Uppercase;
    } });
    var index_23 = require_iterator2();
    Object.defineProperty(exports, "Iterator", { enumerable: true, get: function() {
      return index_23.Iterator;
    } });
    var index_24 = require_keyof2();
    Object.defineProperty(exports, "KeyOf", { enumerable: true, get: function() {
      return index_24.KeyOf;
    } });
    var index_25 = require_literal2();
    Object.defineProperty(exports, "Literal", { enumerable: true, get: function() {
      return index_25.Literal;
    } });
    var index_26 = require_mapped2();
    Object.defineProperty(exports, "Mapped", { enumerable: true, get: function() {
      return index_26.Mapped;
    } });
    var index_27 = require_never2();
    Object.defineProperty(exports, "Never", { enumerable: true, get: function() {
      return index_27.Never;
    } });
    var index_28 = require_not2();
    Object.defineProperty(exports, "Not", { enumerable: true, get: function() {
      return index_28.Not;
    } });
    var index_29 = require_null2();
    Object.defineProperty(exports, "Null", { enumerable: true, get: function() {
      return index_29.Null;
    } });
    var index_30 = require_number2();
    Object.defineProperty(exports, "Number", { enumerable: true, get: function() {
      return index_30.Number;
    } });
    var index_31 = require_object2();
    Object.defineProperty(exports, "Object", { enumerable: true, get: function() {
      return index_31.Object;
    } });
    var index_32 = require_omit2();
    Object.defineProperty(exports, "Omit", { enumerable: true, get: function() {
      return index_32.Omit;
    } });
    var index_33 = require_optional2();
    Object.defineProperty(exports, "Optional", { enumerable: true, get: function() {
      return index_33.Optional;
    } });
    var index_34 = require_parameters2();
    Object.defineProperty(exports, "Parameters", { enumerable: true, get: function() {
      return index_34.Parameters;
    } });
    var index_35 = require_partial2();
    Object.defineProperty(exports, "Partial", { enumerable: true, get: function() {
      return index_35.Partial;
    } });
    var index_36 = require_pick2();
    Object.defineProperty(exports, "Pick", { enumerable: true, get: function() {
      return index_36.Pick;
    } });
    var index_37 = require_promise2();
    Object.defineProperty(exports, "Promise", { enumerable: true, get: function() {
      return index_37.Promise;
    } });
    var index_38 = require_readonly2();
    Object.defineProperty(exports, "Readonly", { enumerable: true, get: function() {
      return index_38.Readonly;
    } });
    var index_39 = require_readonly_optional2();
    Object.defineProperty(exports, "ReadonlyOptional", { enumerable: true, get: function() {
      return index_39.ReadonlyOptional;
    } });
    var index_40 = require_record2();
    Object.defineProperty(exports, "Record", { enumerable: true, get: function() {
      return index_40.Record;
    } });
    var index_41 = require_recursive2();
    Object.defineProperty(exports, "Recursive", { enumerable: true, get: function() {
      return index_41.Recursive;
    } });
    var index_42 = require_ref2();
    Object.defineProperty(exports, "Ref", { enumerable: true, get: function() {
      return index_42.Ref;
    } });
    var index_43 = require_regexp2();
    Object.defineProperty(exports, "RegExp", { enumerable: true, get: function() {
      return index_43.RegExp;
    } });
    var index_44 = require_required2();
    Object.defineProperty(exports, "Required", { enumerable: true, get: function() {
      return index_44.Required;
    } });
    var index_45 = require_rest2();
    Object.defineProperty(exports, "Rest", { enumerable: true, get: function() {
      return index_45.Rest;
    } });
    var index_46 = require_return_type2();
    Object.defineProperty(exports, "ReturnType", { enumerable: true, get: function() {
      return index_46.ReturnType;
    } });
    var index_47 = require_strict2();
    Object.defineProperty(exports, "Strict", { enumerable: true, get: function() {
      return index_47.Strict;
    } });
    var index_48 = require_string2();
    Object.defineProperty(exports, "String", { enumerable: true, get: function() {
      return index_48.String;
    } });
    var index_49 = require_symbol2();
    Object.defineProperty(exports, "Symbol", { enumerable: true, get: function() {
      return index_49.Symbol;
    } });
    var index_50 = require_template_literal2();
    Object.defineProperty(exports, "TemplateLiteral", { enumerable: true, get: function() {
      return index_50.TemplateLiteral;
    } });
    var index_51 = require_transform3();
    Object.defineProperty(exports, "Transform", { enumerable: true, get: function() {
      return index_51.Transform;
    } });
    var index_52 = require_tuple2();
    Object.defineProperty(exports, "Tuple", { enumerable: true, get: function() {
      return index_52.Tuple;
    } });
    var index_53 = require_uint8array2();
    Object.defineProperty(exports, "Uint8Array", { enumerable: true, get: function() {
      return index_53.Uint8Array;
    } });
    var index_54 = require_undefined2();
    Object.defineProperty(exports, "Undefined", { enumerable: true, get: function() {
      return index_54.Undefined;
    } });
    var index_55 = require_union2();
    Object.defineProperty(exports, "Union", { enumerable: true, get: function() {
      return index_55.Union;
    } });
    var index_56 = require_unknown2();
    Object.defineProperty(exports, "Unknown", { enumerable: true, get: function() {
      return index_56.Unknown;
    } });
    var index_57 = require_unsafe2();
    Object.defineProperty(exports, "Unsafe", { enumerable: true, get: function() {
      return index_57.Unsafe;
    } });
    var index_58 = require_void2();
    Object.defineProperty(exports, "Void", { enumerable: true, get: function() {
      return index_58.Void;
    } });
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/type/javascript.js
var require_javascript = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/type/javascript.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JavaScriptTypeBuilder = void 0;
    var json_1 = require_json();
    var index_1 = require_async_iterator2();
    var index_2 = require_awaited2();
    var index_3 = require_bigint2();
    var index_4 = require_constructor2();
    var index_5 = require_constructor_parameters2();
    var index_6 = require_date2();
    var index_7 = require_function2();
    var index_8 = require_instance_type2();
    var index_9 = require_iterator2();
    var index_10 = require_parameters2();
    var index_11 = require_promise2();
    var index_12 = require_regexp2();
    var index_13 = require_return_type2();
    var index_14 = require_symbol2();
    var index_15 = require_uint8array2();
    var index_16 = require_undefined2();
    var index_17 = require_void2();
    var JavaScriptTypeBuilder2 = class extends json_1.JsonTypeBuilder {
      /** `[JavaScript]` Creates a AsyncIterator type */
      AsyncIterator(items, options = {}) {
        return (0, index_1.AsyncIterator)(items, options);
      }
      /** `[JavaScript]` Constructs a type by recursively unwrapping Promise types */
      Awaited(schema, options = {}) {
        return (0, index_2.Awaited)(schema, options);
      }
      /** `[JavaScript]` Creates a BigInt type */
      BigInt(options = {}) {
        return (0, index_3.BigInt)(options);
      }
      /** `[JavaScript]` Extracts the ConstructorParameters from the given Constructor type */
      ConstructorParameters(schema, options = {}) {
        return (0, index_5.ConstructorParameters)(schema, options);
      }
      /** `[JavaScript]` Creates a Constructor type */
      Constructor(parameters, returns, options) {
        return (0, index_4.Constructor)(parameters, returns, options);
      }
      /** `[JavaScript]` Creates a Date type */
      Date(options = {}) {
        return (0, index_6.Date)(options);
      }
      /** `[JavaScript]` Creates a Function type */
      Function(parameters, returns, options) {
        return (0, index_7.Function)(parameters, returns, options);
      }
      /** `[JavaScript]` Extracts the InstanceType from the given Constructor type */
      InstanceType(schema, options = {}) {
        return (0, index_8.InstanceType)(schema, options);
      }
      /** `[JavaScript]` Creates an Iterator type */
      Iterator(items, options = {}) {
        return (0, index_9.Iterator)(items, options);
      }
      /** `[JavaScript]` Extracts the Parameters from the given Function type */
      Parameters(schema, options = {}) {
        return (0, index_10.Parameters)(schema, options);
      }
      /** `[JavaScript]` Creates a Promise type */
      Promise(item, options = {}) {
        return (0, index_11.Promise)(item, options);
      }
      /** `[JavaScript]` Creates a RegExp type */
      RegExp(unresolved, options = {}) {
        return (0, index_12.RegExp)(unresolved, options);
      }
      /** `[JavaScript]` Extracts the ReturnType from the given Function type */
      ReturnType(schema, options = {}) {
        return (0, index_13.ReturnType)(schema, options);
      }
      /** `[JavaScript]` Creates a Symbol type */
      Symbol(options) {
        return (0, index_14.Symbol)(options);
      }
      /** `[JavaScript]` Creates a Undefined type */
      Undefined(options = {}) {
        return (0, index_16.Undefined)(options);
      }
      /** `[JavaScript]` Creates a Uint8Array type */
      Uint8Array(options = {}) {
        return (0, index_15.Uint8Array)(options);
      }
      /** `[JavaScript]` Creates a Void type */
      Void(options = {}) {
        return (0, index_17.Void)(options);
      }
    };
    exports.JavaScriptTypeBuilder = JavaScriptTypeBuilder2;
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/type/index.js
var require_type5 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/type/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Type = exports.JavaScriptTypeBuilder = exports.JsonTypeBuilder = void 0;
    var json_1 = require_json();
    Object.defineProperty(exports, "JsonTypeBuilder", { enumerable: true, get: function() {
      return json_1.JsonTypeBuilder;
    } });
    var TypeBuilder = require_type4();
    var javascript_1 = require_javascript();
    Object.defineProperty(exports, "JavaScriptTypeBuilder", { enumerable: true, get: function() {
      return javascript_1.JavaScriptTypeBuilder;
    } });
    var Type2 = TypeBuilder;
    exports.Type = Type2;
  }
});

// node_modules/@sinclair/typebox/build/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_clone3(), exports);
    __exportStar(require_error2(), exports);
    __exportStar(require_guard3(), exports);
    __exportStar(require_helpers2(), exports);
    __exportStar(require_patterns2(), exports);
    __exportStar(require_registry(), exports);
    __exportStar(require_sets(), exports);
    __exportStar(require_symbols2(), exports);
    __exportStar(require_any2(), exports);
    __exportStar(require_array2(), exports);
    __exportStar(require_async_iterator2(), exports);
    __exportStar(require_awaited2(), exports);
    __exportStar(require_bigint2(), exports);
    __exportStar(require_boolean2(), exports);
    __exportStar(require_composite2(), exports);
    __exportStar(require_const2(), exports);
    __exportStar(require_constructor2(), exports);
    __exportStar(require_constructor_parameters2(), exports);
    __exportStar(require_date2(), exports);
    __exportStar(require_deref4(), exports);
    __exportStar(require_enum2(), exports);
    __exportStar(require_exclude2(), exports);
    __exportStar(require_extends2(), exports);
    __exportStar(require_extract2(), exports);
    __exportStar(require_function2(), exports);
    __exportStar(require_indexed2(), exports);
    __exportStar(require_instance_type2(), exports);
    __exportStar(require_integer2(), exports);
    __exportStar(require_intersect2(), exports);
    __exportStar(require_iterator2(), exports);
    __exportStar(require_intrinsic2(), exports);
    __exportStar(require_keyof2(), exports);
    __exportStar(require_literal2(), exports);
    __exportStar(require_mapped2(), exports);
    __exportStar(require_never2(), exports);
    __exportStar(require_not2(), exports);
    __exportStar(require_null2(), exports);
    __exportStar(require_number2(), exports);
    __exportStar(require_object2(), exports);
    __exportStar(require_omit2(), exports);
    __exportStar(require_optional2(), exports);
    __exportStar(require_parameters2(), exports);
    __exportStar(require_partial2(), exports);
    __exportStar(require_pick2(), exports);
    __exportStar(require_promise2(), exports);
    __exportStar(require_readonly2(), exports);
    __exportStar(require_readonly_optional2(), exports);
    __exportStar(require_record2(), exports);
    __exportStar(require_recursive2(), exports);
    __exportStar(require_ref2(), exports);
    __exportStar(require_regexp2(), exports);
    __exportStar(require_required2(), exports);
    __exportStar(require_rest2(), exports);
    __exportStar(require_return_type2(), exports);
    __exportStar(require_schema2(), exports);
    __exportStar(require_static2(), exports);
    __exportStar(require_strict2(), exports);
    __exportStar(require_string2(), exports);
    __exportStar(require_symbol2(), exports);
    __exportStar(require_template_literal2(), exports);
    __exportStar(require_transform3(), exports);
    __exportStar(require_tuple2(), exports);
    __exportStar(require_uint8array2(), exports);
    __exportStar(require_undefined2(), exports);
    __exportStar(require_union2(), exports);
    __exportStar(require_unknown2(), exports);
    __exportStar(require_unsafe2(), exports);
    __exportStar(require_void2(), exports);
    __exportStar(require_type5(), exports);
  }
});

// node_modules/@sinclair/typebox/build/cjs/compiler/compiler.js
var require_compiler = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/compiler/compiler.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeCompiler = exports.Policy = exports.TypeCompilerTypeGuardError = exports.TypeCompilerUnknownTypeError = exports.TypeCheck = void 0;
    var index_1 = require_transform();
    var index_2 = require_errors2();
    var index_3 = require_system2();
    var index_4 = require_error2();
    var index_5 = require_deref2();
    var index_6 = require_hash2();
    var index_7 = require_symbols2();
    var index_8 = require_registry();
    var index_9 = require_keyof2();
    var extends_undefined_1 = require_extends_undefined();
    var index_10 = require_never2();
    var index_11 = require_guard2();
    var type_1 = require_type3();
    var TypeCheck2 = class {
      constructor(schema, references, checkFunc, code4) {
        this.schema = schema;
        this.references = references;
        this.checkFunc = checkFunc;
        this.code = code4;
        this.hasTransform = (0, index_1.HasTransform)(schema, references);
      }
      /** Returns the generated assertion code used to validate this type. */
      Code() {
        return this.code;
      }
      /** Returns an iterator for each error in this value. */
      Errors(value) {
        return (0, index_2.Errors)(this.schema, this.references, value);
      }
      /** Returns true if the value matches the compiled type. */
      Check(value) {
        return this.checkFunc(value);
      }
      /** Decodes a value or throws if error */
      Decode(value) {
        if (!this.checkFunc(value))
          throw new index_1.TransformDecodeCheckError(this.schema, value, this.Errors(value).First());
        return this.hasTransform ? (0, index_1.TransformDecode)(this.schema, this.references, value) : value;
      }
      /** Encodes a value or throws if error */
      Encode(value) {
        const encoded = this.hasTransform ? (0, index_1.TransformEncode)(this.schema, this.references, value) : value;
        if (!this.checkFunc(encoded))
          throw new index_1.TransformEncodeCheckError(this.schema, value, this.Errors(value).First());
        return encoded;
      }
    };
    exports.TypeCheck = TypeCheck2;
    var Character2;
    (function(Character3) {
      function DollarSign(code4) {
        return code4 === 36;
      }
      Character3.DollarSign = DollarSign;
      function IsUnderscore(code4) {
        return code4 === 95;
      }
      Character3.IsUnderscore = IsUnderscore;
      function IsAlpha(code4) {
        return code4 >= 65 && code4 <= 90 || code4 >= 97 && code4 <= 122;
      }
      Character3.IsAlpha = IsAlpha;
      function IsNumeric(code4) {
        return code4 >= 48 && code4 <= 57;
      }
      Character3.IsNumeric = IsNumeric;
    })(Character2 || (Character2 = {}));
    var MemberExpression2;
    (function(MemberExpression3) {
      function IsFirstCharacterNumeric(value) {
        if (value.length === 0)
          return false;
        return Character2.IsNumeric(value.charCodeAt(0));
      }
      function IsAccessor(value) {
        if (IsFirstCharacterNumeric(value))
          return false;
        for (let i2 = 0; i2 < value.length; i2++) {
          const code4 = value.charCodeAt(i2);
          const check = Character2.IsAlpha(code4) || Character2.IsNumeric(code4) || Character2.DollarSign(code4) || Character2.IsUnderscore(code4);
          if (!check)
            return false;
        }
        return true;
      }
      function EscapeHyphen(key2) {
        return key2.replace(/'/g, "\\'");
      }
      function Encode2(object, key2) {
        return IsAccessor(key2) ? `${object}.${key2}` : `${object}['${EscapeHyphen(key2)}']`;
      }
      MemberExpression3.Encode = Encode2;
    })(MemberExpression2 || (MemberExpression2 = {}));
    var Identifier2;
    (function(Identifier3) {
      function Encode2($id) {
        const buffer = [];
        for (let i2 = 0; i2 < $id.length; i2++) {
          const code4 = $id.charCodeAt(i2);
          if (Character2.IsNumeric(code4) || Character2.IsAlpha(code4)) {
            buffer.push($id.charAt(i2));
          } else {
            buffer.push(`_${code4}_`);
          }
        }
        return buffer.join("").replace(/__/g, "_");
      }
      Identifier3.Encode = Encode2;
    })(Identifier2 || (Identifier2 = {}));
    var LiteralString2;
    (function(LiteralString3) {
      function Escape3(content3) {
        return content3.replace(/'/g, "\\'");
      }
      LiteralString3.Escape = Escape3;
    })(LiteralString2 || (LiteralString2 = {}));
    var TypeCompilerUnknownTypeError2 = class extends index_4.TypeBoxError {
      constructor(schema) {
        super("Unknown type");
        this.schema = schema;
      }
    };
    exports.TypeCompilerUnknownTypeError = TypeCompilerUnknownTypeError2;
    var TypeCompilerTypeGuardError2 = class extends index_4.TypeBoxError {
      constructor(schema) {
        super("Preflight validation check failed to guard for the given schema");
        this.schema = schema;
      }
    };
    exports.TypeCompilerTypeGuardError = TypeCompilerTypeGuardError2;
    var Policy2;
    (function(Policy3) {
      function IsExactOptionalProperty(value, key2, expression) {
        return index_3.TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${key2}' in ${value} ? ${expression} : true)` : `(${MemberExpression2.Encode(value, key2)} !== undefined ? ${expression} : true)`;
      }
      Policy3.IsExactOptionalProperty = IsExactOptionalProperty;
      function IsObjectLike(value) {
        return !index_3.TypeSystemPolicy.AllowArrayObject ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}))` : `(typeof ${value} === 'object' && ${value} !== null)`;
      }
      Policy3.IsObjectLike = IsObjectLike;
      function IsRecordLike(value) {
        return !index_3.TypeSystemPolicy.AllowArrayObject ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}) && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))` : `(typeof ${value} === 'object' && ${value} !== null && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))`;
      }
      Policy3.IsRecordLike = IsRecordLike;
      function IsNumberLike(value) {
        return index_3.TypeSystemPolicy.AllowNaN ? `typeof ${value} === 'number'` : `Number.isFinite(${value})`;
      }
      Policy3.IsNumberLike = IsNumberLike;
      function IsVoidLike(value) {
        return index_3.TypeSystemPolicy.AllowNullVoid ? `(${value} === undefined || ${value} === null)` : `${value} === undefined`;
      }
      Policy3.IsVoidLike = IsVoidLike;
    })(Policy2 || (exports.Policy = Policy2 = {}));
    var TypeCompiler2;
    (function(TypeCompiler3) {
      function IsAnyOrUnknown2(schema) {
        return schema[index_7.Kind] === "Any" || schema[index_7.Kind] === "Unknown";
      }
      function* FromAny5(schema, references, value) {
        yield "true";
      }
      function* FromArray16(schema, references, value) {
        yield `Array.isArray(${value})`;
        const [parameter, accumulator] = [CreateParameter("value", "any"), CreateParameter("acc", "number")];
        if ((0, index_11.IsNumber)(schema.maxItems))
          yield `${value}.length <= ${schema.maxItems}`;
        if ((0, index_11.IsNumber)(schema.minItems))
          yield `${value}.length >= ${schema.minItems}`;
        const elementExpression = CreateExpression(schema.items, references, "value");
        yield `${value}.every((${parameter}) => ${elementExpression})`;
        if ((0, type_1.IsSchema)(schema.contains) || (0, index_11.IsNumber)(schema.minContains) || (0, index_11.IsNumber)(schema.maxContains)) {
          const containsSchema = (0, type_1.IsSchema)(schema.contains) ? schema.contains : (0, index_10.Never)();
          const checkExpression = CreateExpression(containsSchema, references, "value");
          const checkMinContains = (0, index_11.IsNumber)(schema.minContains) ? [`(count >= ${schema.minContains})`] : [];
          const checkMaxContains = (0, index_11.IsNumber)(schema.maxContains) ? [`(count <= ${schema.maxContains})`] : [];
          const checkCount = `const count = value.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`;
          const check = [`(count > 0)`, ...checkMinContains, ...checkMaxContains].join(" && ");
          yield `((${parameter}) => { ${checkCount}; return ${check}})(${value})`;
        }
        if (schema.uniqueItems === true) {
          const check = `const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true`;
          const block = `const set = new Set(); for(const element of value) { ${check} }`;
          yield `((${parameter}) => { ${block} )(${value})`;
        }
      }
      function* FromAsyncIterator7(schema, references, value) {
        yield `(typeof value === 'object' && Symbol.asyncIterator in ${value})`;
      }
      function* FromBigInt6(schema, references, value) {
        yield `(typeof ${value} === 'bigint')`;
        if ((0, index_11.IsBigInt)(schema.exclusiveMaximum))
          yield `${value} < BigInt(${schema.exclusiveMaximum})`;
        if ((0, index_11.IsBigInt)(schema.exclusiveMinimum))
          yield `${value} > BigInt(${schema.exclusiveMinimum})`;
        if ((0, index_11.IsBigInt)(schema.maximum))
          yield `${value} <= BigInt(${schema.maximum})`;
        if ((0, index_11.IsBigInt)(schema.minimum))
          yield `${value} >= BigInt(${schema.minimum})`;
        if ((0, index_11.IsBigInt)(schema.multipleOf))
          yield `(${value} % BigInt(${schema.multipleOf})) === 0`;
      }
      function* FromBoolean6(schema, references, value) {
        yield `(typeof ${value} === 'boolean')`;
      }
      function* FromConstructor8(schema, references, value) {
        yield* Visit17(schema.returns, references, `${value}.prototype`);
      }
      function* FromDate6(schema, references, value) {
        yield `(${value} instanceof Date) && Number.isFinite(${value}.getTime())`;
        if ((0, index_11.IsNumber)(schema.exclusiveMaximumTimestamp))
          yield `${value}.getTime() < ${schema.exclusiveMaximumTimestamp}`;
        if ((0, index_11.IsNumber)(schema.exclusiveMinimumTimestamp))
          yield `${value}.getTime() > ${schema.exclusiveMinimumTimestamp}`;
        if ((0, index_11.IsNumber)(schema.maximumTimestamp))
          yield `${value}.getTime() <= ${schema.maximumTimestamp}`;
        if ((0, index_11.IsNumber)(schema.minimumTimestamp))
          yield `${value}.getTime() >= ${schema.minimumTimestamp}`;
        if ((0, index_11.IsNumber)(schema.multipleOfTimestamp))
          yield `(${value}.getTime() % ${schema.multipleOfTimestamp}) === 0`;
      }
      function* FromFunction7(schema, references, value) {
        yield `(typeof ${value} === 'function')`;
      }
      function* FromInteger6(schema, references, value) {
        yield `Number.isInteger(${value})`;
        if ((0, index_11.IsNumber)(schema.exclusiveMaximum))
          yield `${value} < ${schema.exclusiveMaximum}`;
        if ((0, index_11.IsNumber)(schema.exclusiveMinimum))
          yield `${value} > ${schema.exclusiveMinimum}`;
        if ((0, index_11.IsNumber)(schema.maximum))
          yield `${value} <= ${schema.maximum}`;
        if ((0, index_11.IsNumber)(schema.minimum))
          yield `${value} >= ${schema.minimum}`;
        if ((0, index_11.IsNumber)(schema.multipleOf))
          yield `(${value} % ${schema.multipleOf}) === 0`;
      }
      function* FromIntersect18(schema, references, value) {
        const check1 = schema.allOf.map((schema2) => CreateExpression(schema2, references, value)).join(" && ");
        if (schema.unevaluatedProperties === false) {
          const keyCheck = CreateVariable(`${new RegExp((0, index_9.KeyOfPattern)(schema))};`);
          const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key))`;
          yield `(${check1} && ${check2})`;
        } else if ((0, type_1.IsSchema)(schema.unevaluatedProperties)) {
          const keyCheck = CreateVariable(`${new RegExp((0, index_9.KeyOfPattern)(schema))};`);
          const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema.unevaluatedProperties, references, `${value}[key]`)})`;
          yield `(${check1} && ${check2})`;
        } else {
          yield `(${check1})`;
        }
      }
      function* FromIterator7(schema, references, value) {
        yield `(typeof value === 'object' && Symbol.iterator in ${value})`;
      }
      function* FromLiteral7(schema, references, value) {
        if (typeof schema.const === "number" || typeof schema.const === "boolean") {
          yield `(${value} === ${schema.const})`;
        } else {
          yield `(${value} === '${LiteralString2.Escape(schema.const)}')`;
        }
      }
      function* FromNever6(schema, references, value) {
        yield `false`;
      }
      function* FromNot8(schema, references, value) {
        const expression = CreateExpression(schema.not, references, value);
        yield `(!${expression})`;
      }
      function* FromNull6(schema, references, value) {
        yield `(${value} === null)`;
      }
      function* FromNumber6(schema, references, value) {
        yield Policy2.IsNumberLike(value);
        if ((0, index_11.IsNumber)(schema.exclusiveMaximum))
          yield `${value} < ${schema.exclusiveMaximum}`;
        if ((0, index_11.IsNumber)(schema.exclusiveMinimum))
          yield `${value} > ${schema.exclusiveMinimum}`;
        if ((0, index_11.IsNumber)(schema.maximum))
          yield `${value} <= ${schema.maximum}`;
        if ((0, index_11.IsNumber)(schema.minimum))
          yield `${value} >= ${schema.minimum}`;
        if ((0, index_11.IsNumber)(schema.multipleOf))
          yield `(${value} % ${schema.multipleOf}) === 0`;
      }
      function* FromObject13(schema, references, value) {
        yield Policy2.IsObjectLike(value);
        if ((0, index_11.IsNumber)(schema.minProperties))
          yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;
        if ((0, index_11.IsNumber)(schema.maxProperties))
          yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;
        const knownKeys = Object.getOwnPropertyNames(schema.properties);
        for (const knownKey of knownKeys) {
          const memberExpression = MemberExpression2.Encode(value, knownKey);
          const property = schema.properties[knownKey];
          if (schema.required && schema.required.includes(knownKey)) {
            yield* Visit17(property, references, memberExpression);
            if ((0, extends_undefined_1.ExtendsUndefinedCheck)(property) || IsAnyOrUnknown2(property))
              yield `('${knownKey}' in ${value})`;
          } else {
            const expression = CreateExpression(property, references, memberExpression);
            yield Policy2.IsExactOptionalProperty(value, knownKey, expression);
          }
        }
        if (schema.additionalProperties === false) {
          if (schema.required && schema.required.length === knownKeys.length) {
            yield `Object.getOwnPropertyNames(${value}).length === ${knownKeys.length}`;
          } else {
            const keys3 = `[${knownKeys.map((key2) => `'${key2}'`).join(", ")}]`;
            yield `Object.getOwnPropertyNames(${value}).every(key => ${keys3}.includes(key))`;
          }
        }
        if (typeof schema.additionalProperties === "object") {
          const expression = CreateExpression(schema.additionalProperties, references, `${value}[key]`);
          const keys3 = `[${knownKeys.map((key2) => `'${key2}'`).join(", ")}]`;
          yield `(Object.getOwnPropertyNames(${value}).every(key => ${keys3}.includes(key) || ${expression}))`;
        }
      }
      function* FromPromise8(schema, references, value) {
        yield `(typeof value === 'object' && typeof ${value}.then === 'function')`;
      }
      function* FromRecord12(schema, references, value) {
        yield Policy2.IsRecordLike(value);
        if ((0, index_11.IsNumber)(schema.minProperties))
          yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;
        if ((0, index_11.IsNumber)(schema.maxProperties))
          yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;
        const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
        const variable = CreateVariable(`${new RegExp(patternKey)}`);
        const check1 = CreateExpression(patternSchema, references, "value");
        const check2 = (0, type_1.IsSchema)(schema.additionalProperties) ? CreateExpression(schema.additionalProperties, references, value) : schema.additionalProperties === false ? "false" : "true";
        const expression = `(${variable}.test(key) ? ${check1} : ${check2})`;
        yield `(Object.entries(${value}).every(([key, value]) => ${expression}))`;
      }
      function* FromRef12(schema, references, value) {
        const target = (0, index_5.Deref)(schema, references);
        if (state.functions.has(schema.$ref))
          return yield `${CreateFunctionName(schema.$ref)}(${value})`;
        yield* Visit17(target, references, value);
      }
      function* FromRegExp5(schema, references, value) {
        const variable = CreateVariable(`${new RegExp(schema.source, schema.flags)};`);
        yield `(typeof ${value} === 'string')`;
        if ((0, index_11.IsNumber)(schema.maxLength))
          yield `${value}.length <= ${schema.maxLength}`;
        if ((0, index_11.IsNumber)(schema.minLength))
          yield `${value}.length >= ${schema.minLength}`;
        yield `${variable}.test(${value})`;
      }
      function* FromString6(schema, references, value) {
        yield `(typeof ${value} === 'string')`;
        if ((0, index_11.IsNumber)(schema.maxLength))
          yield `${value}.length <= ${schema.maxLength}`;
        if ((0, index_11.IsNumber)(schema.minLength))
          yield `${value}.length >= ${schema.minLength}`;
        if (schema.pattern !== void 0) {
          const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
          yield `${variable}.test(${value})`;
        }
        if (schema.format !== void 0) {
          yield `format('${schema.format}', ${value})`;
        }
      }
      function* FromSymbol6(schema, references, value) {
        yield `(typeof ${value} === 'symbol')`;
      }
      function* FromTemplateLiteral7(schema, references, value) {
        yield `(typeof ${value} === 'string')`;
        const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
        yield `${variable}.test(${value})`;
      }
      function* FromThis11(schema, references, value) {
        yield `${CreateFunctionName(schema.$ref)}(${value})`;
      }
      function* FromTuple15(schema, references, value) {
        yield `Array.isArray(${value})`;
        if (schema.items === void 0)
          return yield `${value}.length === 0`;
        yield `(${value}.length === ${schema.maxItems})`;
        for (let i2 = 0; i2 < schema.items.length; i2++) {
          const expression = CreateExpression(schema.items[i2], references, `${value}[${i2}]`);
          yield `${expression}`;
        }
      }
      function* FromUndefined6(schema, references, value) {
        yield `${value} === undefined`;
      }
      function* FromUnion20(schema, references, value) {
        const expressions = schema.anyOf.map((schema2) => CreateExpression(schema2, references, value));
        yield `(${expressions.join(" || ")})`;
      }
      function* FromUint8Array5(schema, references, value) {
        yield `${value} instanceof Uint8Array`;
        if ((0, index_11.IsNumber)(schema.maxByteLength))
          yield `(${value}.length <= ${schema.maxByteLength})`;
        if ((0, index_11.IsNumber)(schema.minByteLength))
          yield `(${value}.length >= ${schema.minByteLength})`;
      }
      function* FromUnknown5(schema, references, value) {
        yield "true";
      }
      function* FromVoid5(schema, references, value) {
        yield Policy2.IsVoidLike(value);
      }
      function* FromKind4(schema, references, value) {
        const instance = state.instances.size;
        state.instances.set(instance, schema);
        yield `kind('${schema[index_7.Kind]}', ${instance}, ${value})`;
      }
      function* Visit17(schema, references, value, useHoisting = true) {
        const references_ = (0, index_11.IsString)(schema.$id) ? [...references, schema] : references;
        const schema_ = schema;
        if (useHoisting && (0, index_11.IsString)(schema.$id)) {
          const functionName = CreateFunctionName(schema.$id);
          if (state.functions.has(functionName)) {
            return yield `${functionName}(${value})`;
          } else {
            const functionCode = CreateFunction(functionName, schema, references, "value", false);
            state.functions.set(functionName, functionCode);
            return yield `${functionName}(${value})`;
          }
        }
        switch (schema_[index_7.Kind]) {
          case "Any":
            return yield* FromAny5(schema_, references_, value);
          case "Array":
            return yield* FromArray16(schema_, references_, value);
          case "AsyncIterator":
            return yield* FromAsyncIterator7(schema_, references_, value);
          case "BigInt":
            return yield* FromBigInt6(schema_, references_, value);
          case "Boolean":
            return yield* FromBoolean6(schema_, references_, value);
          case "Constructor":
            return yield* FromConstructor8(schema_, references_, value);
          case "Date":
            return yield* FromDate6(schema_, references_, value);
          case "Function":
            return yield* FromFunction7(schema_, references_, value);
          case "Integer":
            return yield* FromInteger6(schema_, references_, value);
          case "Intersect":
            return yield* FromIntersect18(schema_, references_, value);
          case "Iterator":
            return yield* FromIterator7(schema_, references_, value);
          case "Literal":
            return yield* FromLiteral7(schema_, references_, value);
          case "Never":
            return yield* FromNever6(schema_, references_, value);
          case "Not":
            return yield* FromNot8(schema_, references_, value);
          case "Null":
            return yield* FromNull6(schema_, references_, value);
          case "Number":
            return yield* FromNumber6(schema_, references_, value);
          case "Object":
            return yield* FromObject13(schema_, references_, value);
          case "Promise":
            return yield* FromPromise8(schema_, references_, value);
          case "Record":
            return yield* FromRecord12(schema_, references_, value);
          case "Ref":
            return yield* FromRef12(schema_, references_, value);
          case "RegExp":
            return yield* FromRegExp5(schema_, references_, value);
          case "String":
            return yield* FromString6(schema_, references_, value);
          case "Symbol":
            return yield* FromSymbol6(schema_, references_, value);
          case "TemplateLiteral":
            return yield* FromTemplateLiteral7(schema_, references_, value);
          case "This":
            return yield* FromThis11(schema_, references_, value);
          case "Tuple":
            return yield* FromTuple15(schema_, references_, value);
          case "Undefined":
            return yield* FromUndefined6(schema_, references_, value);
          case "Union":
            return yield* FromUnion20(schema_, references_, value);
          case "Uint8Array":
            return yield* FromUint8Array5(schema_, references_, value);
          case "Unknown":
            return yield* FromUnknown5(schema_, references_, value);
          case "Void":
            return yield* FromVoid5(schema_, references_, value);
          default:
            if (!index_8.TypeRegistry.Has(schema_[index_7.Kind]))
              throw new TypeCompilerUnknownTypeError2(schema);
            return yield* FromKind4(schema_, references_, value);
        }
      }
      const state = {
        language: "javascript",
        // target language
        functions: /* @__PURE__ */ new Map(),
        // local functions
        variables: /* @__PURE__ */ new Map(),
        // local variables
        instances: /* @__PURE__ */ new Map()
        // exterior kind instances
      };
      function CreateExpression(schema, references, value, useHoisting = true) {
        return `(${[...Visit17(schema, references, value, useHoisting)].join(" && ")})`;
      }
      function CreateFunctionName($id) {
        return `check_${Identifier2.Encode($id)}`;
      }
      function CreateVariable(expression) {
        const variableName = `local_${state.variables.size}`;
        state.variables.set(variableName, `const ${variableName} = ${expression}`);
        return variableName;
      }
      function CreateFunction(name, schema, references, value, useHoisting = true) {
        const [newline, pad] = ["\n", (length) => "".padStart(length, " ")];
        const parameter = CreateParameter("value", "any");
        const returns = CreateReturns("boolean");
        const expression = [...Visit17(schema, references, value, useHoisting)].map((expression2) => `${pad(4)}${expression2}`).join(` &&${newline}`);
        return `function ${name}(${parameter})${returns} {${newline}${pad(2)}return (${newline}${expression}${newline}${pad(2)})
}`;
      }
      function CreateParameter(name, type) {
        const annotation = state.language === "typescript" ? `: ${type}` : "";
        return `${name}${annotation}`;
      }
      function CreateReturns(type) {
        return state.language === "typescript" ? `: ${type}` : "";
      }
      function Build(schema, references, options) {
        const functionCode = CreateFunction("check", schema, references, "value");
        const parameter = CreateParameter("value", "any");
        const returns = CreateReturns("boolean");
        const functions = [...state.functions.values()];
        const variables = [...state.variables.values()];
        const checkFunction = (0, index_11.IsString)(schema.$id) ? `return function check(${parameter})${returns} {
  return ${CreateFunctionName(schema.$id)}(value)
}` : `return ${functionCode}`;
        return [...variables, ...functions, checkFunction].join("\n");
      }
      function Code(...args) {
        const defaults = { language: "javascript" };
        const [schema, references, options] = args.length === 2 && (0, index_11.IsArray)(args[1]) ? [args[0], args[1], defaults] : args.length === 2 && !(0, index_11.IsArray)(args[1]) ? [args[0], [], args[1]] : args.length === 3 ? [args[0], args[1], args[2]] : args.length === 1 ? [args[0], [], defaults] : [null, [], defaults];
        state.language = options.language;
        state.variables.clear();
        state.functions.clear();
        state.instances.clear();
        if (!(0, type_1.IsSchema)(schema))
          throw new TypeCompilerTypeGuardError2(schema);
        for (const schema2 of references)
          if (!(0, type_1.IsSchema)(schema2))
            throw new TypeCompilerTypeGuardError2(schema2);
        return Build(schema, references, options);
      }
      TypeCompiler3.Code = Code;
      function Compile(schema, references = []) {
        const generatedCode = Code(schema, references, { language: "javascript" });
        const compiledFunction = globalThis.Function("kind", "format", "hash", generatedCode);
        const instances = new Map(state.instances);
        function typeRegistryFunction(kind, instance, value) {
          if (!index_8.TypeRegistry.Has(kind) || !instances.has(instance))
            return false;
          const checkFunc = index_8.TypeRegistry.Get(kind);
          const schema2 = instances.get(instance);
          return checkFunc(schema2, value);
        }
        function formatRegistryFunction(format3, value) {
          if (!index_8.FormatRegistry.Has(format3))
            return false;
          const checkFunc = index_8.FormatRegistry.Get(format3);
          return checkFunc(value);
        }
        function hashFunction(value) {
          return (0, index_6.Hash)(value);
        }
        const checkFunction = compiledFunction(typeRegistryFunction, formatRegistryFunction, hashFunction);
        return new TypeCheck2(schema, references, checkFunction, generatedCode);
      }
      TypeCompiler3.Compile = Compile;
    })(TypeCompiler2 || (exports.TypeCompiler = TypeCompiler2 = {}));
  }
});

// node_modules/@sinclair/typebox/build/cjs/compiler/index.js
var require_compiler2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/compiler/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueErrorIterator = exports.ValueErrorType = void 0;
    var index_1 = require_errors2();
    Object.defineProperty(exports, "ValueErrorType", { enumerable: true, get: function() {
      return index_1.ValueErrorType;
    } });
    Object.defineProperty(exports, "ValueErrorIterator", { enumerable: true, get: function() {
      return index_1.ValueErrorIterator;
    } });
    __exportStar(require_compiler(), exports);
  }
});

// node_modules/elysia/dist/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/elysia/dist/cjs/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var __create2 = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getProtoOf2 = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all4) => {
      for (var name in all4)
        __defProp2(target, name, { get: all4[name], enumerable: true });
    };
    var __copyProps2 = (to, from3, except2, desc2) => {
      if (from3 && typeof from3 === "object" || typeof from3 === "function") {
        for (let key2 of __getOwnPropNames2(from3))
          if (!__hasOwnProp2.call(to, key2) && key2 !== except2)
            __defProp2(to, key2, { get: () => from3[key2], enumerable: !(desc2 = __getOwnPropDesc2(from3, key2)) || desc2.enumerable });
      }
      return to;
    };
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      Cookie: () => Cookie2,
      ELYSIA_FORM_DATA: () => ELYSIA_FORM_DATA2,
      ELYSIA_REQUEST_ID: () => ELYSIA_REQUEST_ID2,
      ELYSIA_RESPONSE: () => ELYSIA_RESPONSE2,
      ELYSIA_TRACE: () => ELYSIA_TRACE2,
      ERROR_CODE: () => ERROR_CODE2,
      Elysia: () => Elysia2,
      InternalServerError: () => InternalServerError2,
      InvalidCookieSignature: () => InvalidCookieSignature2,
      InvertedStatusMap: () => InvertedStatusMap2,
      NotFoundError: () => NotFoundError2,
      ParseError: () => ParseError2,
      StatusMap: () => StatusMap2,
      ValidationError: () => ValidationError2,
      checksum: () => checksum2,
      cloneInference: () => cloneInference2,
      deduplicateChecksum: () => deduplicateChecksum2,
      default: () => Elysia2,
      error: () => error3,
      form: () => form2,
      getResponseSchemaValidator: () => getResponseSchemaValidator2,
      getSchemaValidator: () => getSchemaValidator2,
      mapCompactResponse: () => mapCompactResponse2,
      mapEarlyResponse: () => mapEarlyResponse2,
      mapResponse: () => mapResponse2,
      mapValueError: () => mapValueError2,
      mergeHook: () => mergeHook2,
      mergeObjectArray: () => mergeObjectArray2,
      redirect: () => redirect2,
      replaceSchemaType: () => replaceSchemaType2,
      replaceUrlPath: () => replaceUrlPath2,
      t: () => t3
    });
    module.exports = __toCommonJS2(src_exports);
    var createNode2 = (part, inert) => {
      const inertMap = inert?.length ? {} : null;
      if (inertMap)
        for (const child of inert)
          inertMap[child.part.charCodeAt(0)] = child;
      return {
        part,
        store: null,
        inert: inertMap,
        params: null,
        wildcardStore: null
      };
    };
    var cloneNode2 = (node3, part) => ({
      ...node3,
      part
    });
    var createParamNode2 = (name) => ({
      name,
      store: null,
      inert: null
    });
    var _a89;
    var Memoirist2 = (_a89 = class {
      root = {};
      history = [];
      add(method, path2, store, {
        ignoreError = false,
        ignoreHistory = false
      } = {}) {
        if (typeof path2 !== "string")
          throw new TypeError("Route path must be a string");
        if (path2 === "")
          path2 = "/";
        else if (path2[0] !== "/")
          path2 = `/${path2}`;
        const isWildcard = path2[path2.length - 1] === "*";
        const optionalParams = path2.match(_a89.regex.optionalParams);
        if (optionalParams) {
          const originalPath = path2.replaceAll("?", "");
          this.add(method, originalPath, store, {
            ignoreError
          });
          for (let i2 = 0; i2 < optionalParams.length; i2++) {
            let newPath = path2.replace("/" + optionalParams[i2], "");
            this.add(method, newPath, store, {
              ignoreError: true
            });
          }
          return store;
        }
        if (optionalParams)
          path2 = path2.replaceAll("?", "");
        if (this.history.find(([m2, p3, s2]) => m2 === method && p3 === path2))
          return store;
        if (isWildcard || optionalParams && path2.charCodeAt(path2.length - 1) === 63)
          path2 = path2.slice(0, -1);
        if (!ignoreHistory)
          this.history.push([method, path2, store]);
        const inertParts = path2.split(_a89.regex.static);
        const paramParts = path2.match(_a89.regex.params) || [];
        if (inertParts[inertParts.length - 1] === "")
          inertParts.pop();
        let node3;
        if (!this.root[method])
          node3 = this.root[method] = createNode2("/");
        else
          node3 = this.root[method];
        let paramPartsIndex = 0;
        for (let i2 = 0; i2 < inertParts.length; ++i2) {
          let part = inertParts[i2];
          if (i2 > 0) {
            const param = paramParts[paramPartsIndex++].slice(1);
            if (node3.params === null)
              node3.params = createParamNode2(param);
            else if (node3.params.name !== param) {
              if (ignoreError)
                return store;
              else
                throw new Error(
                  `Cannot create route "${path2}" with parameter "${param}" because a route already exists with a different parameter name ("${node3.params.name}") in the same location`
                );
            }
            const params = node3.params;
            if (params.inert === null) {
              node3 = params.inert = createNode2(part);
              continue;
            }
            node3 = params.inert;
          }
          for (let j2 = 0; ; ) {
            if (j2 === part.length) {
              if (j2 < node3.part.length) {
                const childNode = cloneNode2(node3, node3.part.slice(j2));
                Object.assign(node3, createNode2(part, [childNode]));
              }
              break;
            }
            if (j2 === node3.part.length) {
              if (node3.inert === null)
                node3.inert = {};
              const inert = node3.inert[part.charCodeAt(j2)];
              if (inert) {
                node3 = inert;
                part = part.slice(j2);
                j2 = 0;
                continue;
              }
              const childNode = createNode2(part.slice(j2));
              node3.inert[part.charCodeAt(j2)] = childNode;
              node3 = childNode;
              break;
            }
            if (part[j2] !== node3.part[j2]) {
              const existingChild = cloneNode2(node3, node3.part.slice(j2));
              const newChild = createNode2(part.slice(j2));
              Object.assign(
                node3,
                createNode2(node3.part.slice(0, j2), [
                  existingChild,
                  newChild
                ])
              );
              node3 = newChild;
              break;
            }
            ++j2;
          }
        }
        if (paramPartsIndex < paramParts.length) {
          const param = paramParts[paramPartsIndex];
          const name = param.slice(1);
          if (node3.params === null)
            node3.params = createParamNode2(name);
          else if (node3.params.name !== name) {
            if (ignoreError)
              return store;
            else
              throw new Error(
                `Cannot create route "${path2}" with parameter "${name}" because a route already exists with a different parameter name ("${node3.params.name}") in the same location`
              );
          }
          if (node3.params.store === null)
            node3.params.store = store;
          return node3.params.store;
        }
        if (isWildcard) {
          if (node3.wildcardStore === null)
            node3.wildcardStore = store;
          return node3.wildcardStore;
        }
        if (node3.store === null)
          node3.store = store;
        return node3.store;
      }
      find(method, url) {
        const root4 = this.root[method];
        if (!root4)
          return null;
        return matchRoute2(url, url.length, root4, 0);
      }
    }, __publicField(_a89, "regex", {
      static: /:.+?(?=\/|$)/,
      params: /:.+?(?=\/|$)/g,
      optionalParams: /:.+?\?(?=\/|$)/g
    }), _a89);
    var matchRoute2 = (url, urlLength, node3, startIndex) => {
      const part = node3.part;
      const length = part.length;
      const endIndex = startIndex + length;
      if (length > 1) {
        if (endIndex > urlLength)
          return null;
        if (length < 15) {
          for (let i2 = 1, j2 = startIndex + 1; i2 < length; ++i2, ++j2)
            if (part.charCodeAt(i2) !== url.charCodeAt(j2))
              return null;
        } else if (url.slice(startIndex, endIndex) !== part)
          return null;
      }
      if (endIndex === urlLength) {
        if (node3.store !== null)
          return {
            store: node3.store,
            params: {}
          };
        if (node3.wildcardStore !== null)
          return {
            store: node3.wildcardStore,
            params: { "*": "" }
          };
        return null;
      }
      if (node3.inert !== null) {
        const inert = node3.inert[url.charCodeAt(endIndex)];
        if (inert !== void 0) {
          const route = matchRoute2(url, urlLength, inert, endIndex);
          if (route !== null)
            return route;
        }
      }
      if (node3.params !== null) {
        const { store, name, inert } = node3.params;
        const slashIndex = url.indexOf("/", endIndex);
        if (slashIndex !== endIndex) {
          if (slashIndex === -1 || slashIndex >= urlLength) {
            if (store !== null) {
              const params = {};
              params[name] = url.substring(endIndex, urlLength);
              return {
                store,
                params
              };
            }
          } else if (inert !== null) {
            const route = matchRoute2(url, urlLength, inert, slashIndex);
            if (route !== null) {
              route.params[name] = url.substring(endIndex, slashIndex);
              return route;
            }
          }
        }
      }
      if (node3.wildcardStore !== null)
        return {
          store: node3.wildcardStore,
          params: {
            "*": url.substring(endIndex, urlLength)
          }
        };
      return null;
    };
    var hasReturn2 = (fn) => {
      const fnLiteral = typeof fn === "object" ? fn.fn.toString() : typeof fn === "string" ? fn.toString() : fn;
      const parenthesisEnd = fnLiteral.indexOf(")");
      if (fnLiteral.charCodeAt(parenthesisEnd + 2) === 61 && fnLiteral.charCodeAt(parenthesisEnd + 5) !== 123) {
        return true;
      }
      return fnLiteral.includes("return");
    };
    var separateFunction2 = (code4) => {
      if (code4.startsWith("async"))
        code4 = code4.slice(5);
      code4 = code4.trimStart();
      let index3 = -1;
      if (code4.charCodeAt(0) === 40) {
        index3 = code4.indexOf("=>", code4.indexOf(")"));
        if (index3 !== -1) {
          let bracketEndIndex = index3;
          while (bracketEndIndex > 0)
            if (code4.charCodeAt(--bracketEndIndex) === 41)
              break;
          let body3 = code4.slice(index3 + 2);
          if (body3.charCodeAt(0) === 32)
            body3 = body3.trimStart();
          return [
            code4.slice(1, bracketEndIndex),
            body3,
            {
              isArrowReturn: body3.charCodeAt(0) !== 123
            }
          ];
        }
      }
      if (code4.startsWith("function")) {
        index3 = code4.indexOf("(");
        const end = code4.indexOf(")");
        return [
          code4.slice(index3 + 1, end),
          code4.slice(end + 2),
          {
            isArrowReturn: false
          }
        ];
      }
      const start = code4.indexOf("(");
      if (start !== -1) {
        const sep2 = code4.indexOf("\n", 2);
        const parameter = code4.slice(0, sep2);
        const end = parameter.lastIndexOf(")") + 1;
        const body3 = code4.slice(sep2 + 1);
        return [
          parameter.slice(start, end),
          "{" + body3,
          {
            isArrowReturn: false
          }
        ];
      }
      const x2 = code4.split("\n", 2);
      return [x2[0], x2[1], { isArrowReturn: false }];
    };
    var bracketPairRange2 = (parameter) => {
      const start = parameter.indexOf("{");
      if (start === -1)
        return [-1, 0];
      let end = start + 1;
      let deep = 1;
      for (; end < parameter.length; end++) {
        const char = parameter.charCodeAt(end);
        if (char === 123)
          deep++;
        else if (char === 125)
          deep--;
        if (deep === 0)
          break;
      }
      if (deep !== 0)
        return [0, parameter.length];
      return [start, end + 1];
    };
    var bracketPairRangeReverse2 = (parameter) => {
      const end = parameter.lastIndexOf("}");
      if (end === -1)
        return [-1, 0];
      let start = end - 1;
      let deep = 1;
      for (; start >= 0; start--) {
        const char = parameter.charCodeAt(start);
        if (char === 125)
          deep++;
        else if (char === 123)
          deep--;
        if (deep === 0)
          break;
      }
      if (deep !== 0)
        return [-1, 0];
      return [start, end + 1];
    };
    var removeColonAlias2 = (parameter) => {
      while (true) {
        const start = parameter.indexOf(":");
        if (start === -1)
          break;
        let end = parameter.indexOf(",", start);
        if (end === -1)
          end = parameter.indexOf("}", start) - 1;
        if (end === -2)
          end = parameter.length;
        parameter = parameter.slice(0, start) + parameter.slice(end);
      }
      return parameter;
    };
    var retrieveRootParamters2 = (parameter) => {
      let hasParenthesis = false;
      if (parameter.charCodeAt(0) === 40)
        parameter = parameter.slice(1, -1);
      if (parameter.charCodeAt(0) === 123) {
        hasParenthesis = true;
        parameter = parameter.slice(1, -1);
      }
      parameter = parameter.replace(/( |\t|\n)/g, "").trim();
      let parameters = [];
      while (true) {
        let [start, end] = bracketPairRange2(parameter);
        if (start === -1)
          break;
        parameters.push(parameter.slice(0, start - 1));
        if (parameter.charCodeAt(end) === 44)
          end++;
        parameter = parameter.slice(end);
      }
      parameter = removeColonAlias2(parameter);
      if (parameter)
        parameters = parameters.concat(parameter.split(","));
      const newParameters = [];
      for (const p3 of parameters) {
        if (p3.indexOf(",") === -1) {
          newParameters.push(p3);
          continue;
        }
        for (const q2 of p3.split(","))
          newParameters.push(q2.trim());
      }
      parameters = newParameters;
      return {
        hasParenthesis,
        parameters
      };
    };
    var findParameterReference2 = (parameter, inference) => {
      const { parameters, hasParenthesis } = retrieveRootParamters2(parameter);
      if (!inference.query && parameters.includes("query"))
        inference.query = true;
      if (!inference.headers && parameters.includes("headers"))
        inference.headers = true;
      if (!inference.body && parameters.includes("body"))
        inference.body = true;
      if (!inference.cookie && parameters.includes("cookie"))
        inference.cookie = true;
      if (!inference.set && parameters.includes("set"))
        inference.set = true;
      if (!inference.server && parameters.includes("server"))
        inference.server = true;
      if (hasParenthesis)
        return `{ ${parameters.join(", ")} }`;
      return parameters.join(", ");
    };
    var findEndIndex2 = (type, content3, index3) => {
      const newLineIndex = content3.indexOf(type + "\n", index3);
      const newTabIndex = content3.indexOf(type + "	", index3);
      const commaIndex = content3.indexOf(type + ",", index3);
      const semicolonIndex = content3.indexOf(type + ";", index3);
      const emptyIndex = content3.indexOf(type + " ", index3);
      return [newLineIndex, newTabIndex, commaIndex, semicolonIndex, emptyIndex].filter((i2) => i2 > 0).sort((a2, b2) => a2 - b2)[0] || -1;
    };
    var findAlias2 = (type, body3, depth = 0) => {
      if (depth > 5)
        return [];
      const aliases = [];
      let content3 = body3;
      while (true) {
        let index3 = findEndIndex2(" = " + type, content3);
        if (index3 === -1) {
          const lastIndex = content3.indexOf(" = " + type);
          if (lastIndex + 3 + type.length !== content3.length)
            break;
          index3 = lastIndex;
        }
        const part = content3.slice(0, index3);
        let variable = part.slice(part.lastIndexOf(" ") + 1);
        if (variable === "}") {
          const [start, end] = bracketPairRangeReverse2(part);
          aliases.push(removeColonAlias2(content3.slice(start, end)));
          content3 = content3.slice(index3 + 3 + type.length);
          continue;
        }
        while (variable.charCodeAt(0) === 44)
          variable = variable.slice(1);
        while (variable.charCodeAt(0) === 9)
          variable = variable.slice(1);
        if (!variable.includes("("))
          aliases.push(variable);
        content3 = content3.slice(index3 + 3 + type.length);
      }
      for (const alias of aliases) {
        if (alias.charCodeAt(0) === 123)
          continue;
        const deepAlias = findAlias2(alias, body3);
        if (deepAlias.length > 0)
          aliases.push(...deepAlias);
      }
      return aliases;
    };
    var extractMainParameter2 = (parameter) => {
      if (!parameter)
        return;
      if (parameter.charCodeAt(0) !== 123)
        return parameter;
      parameter = parameter.slice(2, -2);
      const hasComma = parameter.includes(",");
      if (!hasComma) {
        if (parameter.includes("..."))
          return parameter.slice(parameter.indexOf("...") + 3);
        return;
      }
      const spreadIndex = parameter.indexOf("...");
      if (spreadIndex === -1)
        return;
      return parameter.slice(spreadIndex + 3).trimEnd();
    };
    var inferBodyReference2 = (code4, aliases, inference) => {
      const access = (type, alias) => code4.includes(alias + "." + type) || code4.includes(alias + '["' + type + '"]') || code4.includes(alias + "['" + type + "']");
      for (const alias of aliases) {
        if (!alias)
          continue;
        if (alias.charCodeAt(0) === 123) {
          const parameters = retrieveRootParamters2(alias).parameters;
          if (!inference.query && parameters.includes("query"))
            inference.query = true;
          if (!inference.headers && parameters.includes("headers"))
            inference.headers = true;
          if (!inference.body && parameters.includes("body"))
            inference.body = true;
          if (!inference.cookie && parameters.includes("cookie"))
            inference.cookie = true;
          if (!inference.set && parameters.includes("set"))
            inference.set = true;
          if (!inference.query && parameters.includes("server"))
            inference.server = true;
          continue;
        }
        if (!inference.query && access("query", alias))
          inference.query = true;
        if (code4.includes("return " + alias) || code4.includes("return " + alias + ".query"))
          inference.query = true;
        if (!inference.headers && access("headers", alias))
          inference.headers = true;
        if (!inference.body && access("body", alias))
          inference.body = true;
        if (!inference.cookie && access("cookie", alias))
          inference.cookie = true;
        if (!inference.set && access("set", alias))
          inference.set = true;
        if (!inference.server && access("server", alias))
          inference.server = true;
        if (inference.query && inference.headers && inference.body && inference.cookie && inference.set && inference.server)
          break;
      }
      return aliases;
    };
    var isContextPassToFunction2 = (context, body3, inference) => {
      try {
        const captureFunction = new RegExp(`(?:\\w)\\((?:.*)?${context}`, "gs");
        captureFunction.test(body3);
        const nextChar = body3.charCodeAt(captureFunction.lastIndex);
        if (nextChar === 41 || nextChar === 44) {
          inference.query = true;
          inference.headers = true;
          inference.body = true;
          inference.cookie = true;
          inference.set = true;
          inference.server = true;
          return true;
        }
        return false;
      } catch (error22) {
        console.log(
          "[Sucrose] warning: unexpected isContextPassToFunction error, you may continue development as usual but please report the following to maintainers:"
        );
        console.log("--- body ---");
        console.log(body3);
        console.log("--- context ---");
        console.log(context);
        return true;
      }
    };
    var sucrose2 = (lifeCycle, inference = {
      query: false,
      headers: false,
      body: false,
      cookie: false,
      set: false,
      server: false
    }) => {
      const events = [];
      if (lifeCycle.handler && typeof lifeCycle.handler === "function")
        events.push(lifeCycle.handler);
      if (lifeCycle.request?.length)
        events.push(...lifeCycle.request);
      if (lifeCycle.beforeHandle?.length)
        events.push(...lifeCycle.beforeHandle);
      if (lifeCycle.parse?.length)
        events.push(...lifeCycle.parse);
      if (lifeCycle.error?.length)
        events.push(...lifeCycle.error);
      if (lifeCycle.transform?.length)
        events.push(...lifeCycle.transform);
      if (lifeCycle.afterHandle?.length)
        events.push(...lifeCycle.afterHandle);
      if (lifeCycle.mapResponse?.length)
        events.push(...lifeCycle.mapResponse);
      if (lifeCycle.afterResponse?.length)
        events.push(...lifeCycle.afterResponse);
      for (const e2 of events) {
        if (!e2)
          continue;
        const event = "fn" in e2 ? e2.fn : e2;
        const [parameter, body3, { isArrowReturn }] = separateFunction2(
          event.toString()
        );
        const rootParameters = findParameterReference2(parameter, inference);
        const mainParameter = extractMainParameter2(rootParameters);
        if (mainParameter) {
          const aliases = findAlias2(mainParameter, body3);
          aliases.splice(0, -1, mainParameter);
          if (!isContextPassToFunction2(mainParameter, body3, inference))
            inferBodyReference2(body3, aliases, inference);
          if (!inference.query && body3.includes("return " + mainParameter + ".query"))
            inference.query = true;
        }
        if (inference.query && inference.headers && inference.body && inference.cookie && inference.set && inference.server)
          break;
      }
      return inference;
    };
    var import_value32 = require_value5();
    var import_typebox32 = require_cjs();
    var import_value22 = require_value5();
    var import_compiler32 = require_compiler2();
    var import_typebox5 = require_cjs();
    var import_system6 = require_system2();
    var import_typebox22 = require_cjs();
    var import_compiler4 = require_compiler2();
    var import_value15 = require_value5();
    var fullFormats2 = {
      // date: http://tools.ietf.org/html/rfc3339#section-5.6
      date: date2,
      // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
      time: getTime2(true),
      "date-time": getDateTime2(true),
      "iso-time": getTime2(false),
      "iso-date-time": getDateTime2(false),
      // duration: https://tools.ietf.org/html/rfc3339#appendix-A
      duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
      uri: uri2,
      "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
      // uri-template: https://tools.ietf.org/html/rfc6570
      "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
      // For the source: https://gist.github.com/dperini/729294
      // For test cases: https://mathiasbynens.be/demo/url-regex
      url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
      email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
      // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
      ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
      regex: regex2,
      // uuid: http://tools.ietf.org/html/rfc4122
      uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
      // JSON-pointer: https://tools.ietf.org/html/rfc6901
      // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
      "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
      "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
      // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
      "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
      // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
      // byte: https://github.com/miguelmota/is-base64
      byte: byte2,
      // signed 32 bit integer
      int32: { type: "number", validate: validateInt322 },
      // signed 64 bit integer
      int64: { type: "number", validate: validateInt642 },
      // C-type float
      float: { type: "number", validate: validateNumber2 },
      // C-type double
      double: { type: "number", validate: validateNumber2 },
      // hint to the UI to hide input strings
      password: true,
      // unchecked string payload
      binary: true
    };
    function isLeapYear3(year2) {
      return year2 % 4 === 0 && (year2 % 100 !== 0 || year2 % 400 === 0);
    }
    var DATE3 = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
    var DAYS3 = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    function date2(str) {
      const matches = DATE3.exec(str);
      if (!matches)
        return false;
      const year2 = +matches[1];
      const month = +matches[2];
      const day2 = +matches[3];
      return month >= 1 && month <= 12 && day2 >= 1 && day2 <= (month === 2 && isLeapYear3(year2) ? 29 : DAYS3[month]);
    }
    var TIME2 = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
    function getTime2(strictTimeZone) {
      return function time(str) {
        const matches = TIME2.exec(str);
        if (!matches)
          return false;
        const hr = +matches[1];
        const min = +matches[2];
        const sec = +matches[3];
        const tz = matches[4];
        const tzSign = matches[5] === "-" ? -1 : 1;
        const tzH = +(matches[6] || 0);
        const tzM = +(matches[7] || 0);
        if (tzH > 23 || tzM > 59 || strictTimeZone && !tz)
          return false;
        if (hr <= 23 && min <= 59 && sec < 60)
          return true;
        const utcMin = min - tzM * tzSign;
        const utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
        return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
      };
    }
    var DATE_TIME_SEPARATOR2 = /t|\s/i;
    function getDateTime2(strictTimeZone) {
      const time = getTime2(strictTimeZone);
      return function date_time(str) {
        const dateTime = str.split(DATE_TIME_SEPARATOR2);
        return dateTime.length === 2 && date2(dateTime[0]) && time(dateTime[1]);
      };
    }
    var NOT_URI_FRAGMENT2 = /\/|:/;
    var URI2 = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    function uri2(str) {
      return NOT_URI_FRAGMENT2.test(str) && URI2.test(str);
    }
    var BYTE2 = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
    function byte2(str) {
      BYTE2.lastIndex = 0;
      return BYTE2.test(str);
    }
    var MIN_INT322 = -(2 ** 31);
    var MAX_INT323 = 2 ** 31 - 1;
    function validateInt322(value) {
      return Number.isInteger(value) && value <= MAX_INT323 && value >= MIN_INT322;
    }
    function validateInt642(value) {
      return Number.isInteger(value);
    }
    function validateNumber2() {
      return true;
    }
    var Z_ANCHOR2 = /[^\\]\\Z/;
    function regex2(str) {
      if (Z_ANCHOR2.test(str))
        return false;
      try {
        new RegExp(str);
        return true;
      } catch (e2) {
        return false;
      }
    }
    var import_system22 = require_system2();
    var import_compiler22 = require_compiler2();
    var isISO86012 = /(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))/;
    var isFormalDate2 = /(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s\d{2}\s\d{4}\s\d{2}:\d{2}:\d{2}\sGMT(?:\+|-)\d{4}\s\([^)]+\)/;
    var isShortenDate2 = /^(?:(?:(?:(?:0?[1-9]|[12][0-9]|3[01])[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:19|20)\d{2})|(?:(?:19|20)\d{2}[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:0?[1-9]|[12][0-9]|3[01]))))(?:\s(?:1[012]|0?[1-9]):[0-5][0-9](?::[0-5][0-9])?(?:\s[AP]M)?)?$/;
    var _validateDate2 = fullFormats2.date;
    var _validateDateTime2 = fullFormats2["date-time"];
    if (!import_typebox22.FormatRegistry.Has("date"))
      import_system6.TypeSystem.Format("date", (value) => {
        const temp = value.replace(/"/g, "");
        if (isISO86012.test(temp) || isFormalDate2.test(temp) || isShortenDate2.test(temp) || _validateDate2(temp)) {
          const date22 = new Date(temp);
          if (!Number.isNaN(date22.getTime()))
            return true;
        }
        return false;
      });
    if (!import_typebox22.FormatRegistry.Has("date-time"))
      import_system6.TypeSystem.Format("date-time", (value) => {
        const temp = value.replace(/"/g, "");
        if (isISO86012.test(temp) || isFormalDate2.test(temp) || isShortenDate2.test(temp) || _validateDateTime2(temp)) {
          const date22 = new Date(temp);
          if (!Number.isNaN(date22.getTime()))
            return true;
        }
        return false;
      });
    Object.entries(fullFormats2).forEach((formatEntry) => {
      const [formatName, formatValue2] = formatEntry;
      if (!import_typebox22.FormatRegistry.Has(formatName)) {
        if (formatValue2 instanceof RegExp)
          import_system6.TypeSystem.Format(formatName, (value) => formatValue2.test(value));
        else if (typeof formatValue2 === "function")
          import_system6.TypeSystem.Format(formatName, formatValue2);
      }
    });
    var t3 = Object.assign({}, import_typebox22.Type);
    var parseFileUnit2 = (size) => {
      if (typeof size === "string")
        switch (size.slice(-1)) {
          case "k":
            return +size.slice(0, size.length - 1) * 1024;
          case "m":
            return +size.slice(0, size.length - 1) * 1048576;
          default:
            return +size;
        }
      return size;
    };
    var validateFile2 = (options, value) => {
      if (!(value instanceof Blob))
        return false;
      if (options.minSize && value.size < parseFileUnit2(options.minSize))
        return false;
      if (options.maxSize && value.size > parseFileUnit2(options.maxSize))
        return false;
      if (options.extension)
        if (typeof options.extension === "string") {
          if (!value.type.startsWith(options.extension))
            return false;
        } else {
          for (let i2 = 0; i2 < options.extension.length; i2++)
            if (value.type.startsWith(options.extension[i2]))
              return true;
          return false;
        }
      return true;
    };
    var File22 = import_typebox5.TypeRegistry.Get("Files") ?? import_system6.TypeSystem.Type("File", validateFile2);
    var Files2 = import_typebox5.TypeRegistry.Get("Files") ?? import_system6.TypeSystem.Type(
      "Files",
      (options, value) => {
        if (!Array.isArray(value))
          return validateFile2(options, value);
        if (options.minItems && value.length < options.minItems)
          return false;
        if (options.maxItems && value.length > options.maxItems)
          return false;
        for (let i2 = 0; i2 < value.length; i2++)
          if (!validateFile2(options, value[i2]))
            return false;
        return true;
      }
    );
    if (!import_typebox22.FormatRegistry.Has("numeric"))
      import_typebox22.FormatRegistry.Set("numeric", (value) => !!value && !isNaN(+value));
    if (!import_typebox22.FormatRegistry.Has("boolean"))
      import_typebox22.FormatRegistry.Set(
        "boolean",
        (value) => value === "true" || value === "false"
      );
    if (!import_typebox22.FormatRegistry.Has("ObjectString"))
      import_typebox22.FormatRegistry.Set("ObjectString", (value) => {
        let start = value.charCodeAt(0);
        if (start === 9 || start === 10 || start === 32)
          start = value.trimStart().charCodeAt(0);
        if (start !== 123 && start !== 91)
          return false;
        try {
          JSON.parse(value);
          return true;
        } catch {
          return false;
        }
      });
    if (!import_typebox22.FormatRegistry.Has("ArrayString"))
      import_typebox22.FormatRegistry.Set("ArrayString", (value) => {
        let start = value.charCodeAt(0);
        if (start === 9 || start === 10 || start === 32)
          start = value.trimStart().charCodeAt(0);
        if (start !== 123 && start !== 91)
          return false;
        try {
          JSON.parse(value);
          return true;
        } catch {
          return false;
        }
      });
    var ElysiaType2 = {
      Numeric: (property) => {
        const schema = import_typebox22.Type.Number(property);
        return t3.Transform(
          t3.Union(
            [
              t3.String({
                format: "numeric",
                default: 0
              }),
              t3.Number(property)
            ],
            property
          )
        ).Decode((value) => {
          const number2 = +value;
          if (isNaN(number2))
            return value;
          if (property && !import_value15.Value.Check(schema, number2))
            throw new ValidationError2("property", schema, number2);
          return number2;
        }).Encode((value) => value);
      },
      Date: (property) => {
        const schema = import_typebox22.Type.Date(property);
        return t3.Transform(
          t3.Union(
            [
              import_typebox22.Type.Date(property),
              t3.String({
                format: "date",
                default: (/* @__PURE__ */ new Date()).toISOString()
              }),
              t3.String({
                format: "date-time",
                default: (/* @__PURE__ */ new Date()).toISOString()
              })
            ],
            property
          )
        ).Decode((value) => {
          if (value instanceof Date)
            return value;
          const date22 = new Date(value);
          if (!import_value15.Value.Check(schema, date22))
            throw new ValidationError2("property", schema, date22);
          return date22;
        }).Encode((value) => {
          if (typeof value === "string")
            return new Date(value);
          return value;
        });
      },
      BooleanString: (property) => {
        const schema = import_typebox22.Type.Boolean(property);
        return t3.Transform(
          t3.Union(
            [
              t3.String({
                format: "boolean",
                default: false
              }),
              t3.Boolean(property)
            ],
            property
          )
        ).Decode((value) => {
          if (typeof value === "string")
            return value === "true";
          if (property && !import_value15.Value.Check(schema, value))
            throw new ValidationError2("property", schema, value);
          return value;
        }).Encode((value) => value);
      },
      ObjectString: (properties, options) => {
        const schema = t3.Object(properties, options);
        const defaultValue = JSON.stringify(import_value15.Value.Create(schema));
        let compiler2;
        try {
          compiler2 = import_compiler4.TypeCompiler.Compile(schema);
        } catch {
        }
        return t3.Transform(
          t3.Union([
            t3.String({
              format: "ObjectString",
              default: defaultValue
            }),
            schema
          ])
        ).Decode((value) => {
          if (typeof value === "string") {
            if (value.charCodeAt(0) !== 123)
              throw new ValidationError2("property", schema, value);
            try {
              value = JSON.parse(value);
            } catch {
              throw new ValidationError2("property", schema, value);
            }
            if (compiler2) {
              if (!compiler2.Check(value))
                throw new ValidationError2("property", schema, value);
              return compiler2.Decode(value);
            }
            if (!import_value15.Value.Check(schema, value))
              throw new ValidationError2("property", schema, value);
            return import_value15.Value.Decode(schema, value);
          }
          return value;
        }).Encode((value) => {
          if (typeof value === "string")
            try {
              value = JSON.parse(value);
            } catch {
              throw new ValidationError2("property", schema, value);
            }
          if (!import_value15.Value.Check(schema, value))
            throw new ValidationError2("property", schema, value);
          return JSON.stringify(value);
        });
      },
      ArrayString: (children = {}, options) => {
        const schema = t3.Array(children, options);
        const defaultValue = JSON.stringify(import_value15.Value.Create(schema));
        let compiler2;
        try {
          compiler2 = import_compiler4.TypeCompiler.Compile(schema);
        } catch {
        }
        return t3.Transform(
          t3.Union([
            t3.String({
              format: "ArrayString",
              default: defaultValue
            }),
            schema
          ])
        ).Decode((value) => {
          if (typeof value === "string") {
            if (value.charCodeAt(0) !== 91)
              throw new ValidationError2("property", schema, value);
            try {
              value = JSON.parse(value);
            } catch {
              throw new ValidationError2("property", schema, value);
            }
            if (compiler2) {
              if (!compiler2.Check(value))
                throw new ValidationError2("property", schema, value);
              return compiler2.Decode(value);
            }
            if (!import_value15.Value.Check(schema, value))
              throw new ValidationError2("property", schema, value);
            return import_value15.Value.Decode(schema, value);
          }
          return value;
        }).Encode((value) => {
          if (typeof value === "string")
            try {
              value = JSON.parse(value);
            } catch {
              throw new ValidationError2("property", schema, value);
            }
          if (!import_value15.Value.Check(schema, value))
            throw new ValidationError2("property", schema, value);
          return JSON.stringify(value);
        });
      },
      File: File22,
      Files: (options = {}) => t3.Transform(Files2(options)).Decode((value) => {
        if (Array.isArray(value))
          return value;
        return [value];
      }).Encode((value) => value),
      Nullable: (schema) => t3.Union([schema, t3.Null()]),
      /**
       * Allow Optional, Nullable and Undefined
       */
      MaybeEmpty: (schema) => t3.Union([schema, t3.Null(), t3.Undefined()]),
      Cookie: (properties, {
        domain: domain3,
        expires,
        httpOnly,
        maxAge,
        path: path2,
        priority,
        sameSite,
        secure,
        secrets,
        sign: sign2,
        ...options
      } = {}) => {
        const v2 = t3.Object(properties, options);
        v2.config = {
          domain: domain3,
          expires,
          httpOnly,
          maxAge,
          path: path2,
          priority,
          sameSite,
          secure,
          secrets,
          sign: sign2
        };
        return v2;
      }
    };
    t3.BooleanString = ElysiaType2.BooleanString;
    t3.ObjectString = ElysiaType2.ObjectString;
    t3.ArrayString = ElysiaType2.ArrayString;
    t3.Numeric = ElysiaType2.Numeric;
    t3.File = (arg = {}) => ElysiaType2.File({
      default: "File",
      ...arg,
      extension: arg?.type,
      type: "string",
      format: "binary"
    });
    t3.Files = (arg = {}) => ElysiaType2.Files({
      ...arg,
      elysiaMeta: "Files",
      default: "Files",
      extension: arg?.type,
      type: "array",
      items: {
        ...arg,
        default: "Files",
        type: "string",
        format: "binary"
      }
    });
    t3.Nullable = (schema) => ElysiaType2.Nullable(schema);
    t3.MaybeEmpty = ElysiaType2.MaybeEmpty;
    t3.Cookie = ElysiaType2.Cookie;
    t3.Date = ElysiaType2.Date;
    var import_cookie22 = require_cookie();
    var import_cookie3 = require_cookie();
    var import_fast_decode_uri_component4 = __toESM2(require_fast_decode_uri_component());
    var Cookie2 = class {
      constructor(name, jar, initial = {}) {
        this.name = name;
        this.jar = jar;
        this.initial = initial;
      }
      get cookie() {
        if (!(this.name in this.jar))
          return this.initial;
        return this.jar[this.name];
      }
      set cookie(jar) {
        if (!(this.name in this.jar))
          this.jar[this.name] = this.initial;
        this.jar[this.name] = jar;
      }
      get value() {
        return this.cookie.value;
      }
      set value(value) {
        if (!(this.name in this.jar))
          this.jar[this.name] = this.initial;
        this.jar[this.name].value = value;
      }
      get expires() {
        return this.cookie.expires;
      }
      set expires(expires) {
        this.cookie.expires = expires;
      }
      get maxAge() {
        return this.cookie.maxAge;
      }
      set maxAge(maxAge) {
        this.cookie.maxAge = maxAge;
      }
      get domain() {
        return this.cookie.domain;
      }
      set domain(domain3) {
        this.cookie.domain = domain3;
      }
      get path() {
        return this.cookie.path;
      }
      set path(path2) {
        this.cookie.path = path2;
      }
      get secure() {
        return this.cookie.secure;
      }
      set secure(secure) {
        this.cookie.secure = secure;
      }
      get httpOnly() {
        return this.cookie.httpOnly;
      }
      set httpOnly(httpOnly) {
        this.cookie.httpOnly = httpOnly;
      }
      get sameSite() {
        return this.cookie.sameSite;
      }
      set sameSite(sameSite) {
        this.cookie.sameSite = sameSite;
      }
      get priority() {
        return this.cookie.priority;
      }
      set priority(priority) {
        this.cookie.priority = priority;
      }
      get partitioned() {
        return this.cookie.partitioned;
      }
      set partitioned(partitioned) {
        this.cookie.partitioned = partitioned;
      }
      get secrets() {
        return this.cookie.secrets;
      }
      set secrets(secrets) {
        this.cookie.secrets = secrets;
      }
      update(config3) {
        this.cookie = Object.assign(
          this.cookie,
          typeof config3 === "function" ? config3(this.cookie) : config3
        );
        return this;
      }
      set(config3) {
        this.cookie = Object.assign(
          {
            ...this.initial,
            value: this.value
          },
          typeof config3 === "function" ? config3(this.cookie) : config3
        );
        return this;
      }
      remove() {
        if (this.value === void 0)
          return;
        this.set({
          expires: /* @__PURE__ */ new Date(0),
          maxAge: 0,
          value: ""
        });
        return this;
      }
      toString() {
        return typeof this.value === "object" ? JSON.stringify(this.value) : this.value?.toString() ?? "";
      }
    };
    var createCookieJar2 = (set, store, initial) => {
      if (!set.cookie)
        set.cookie = {};
      return new Proxy(store, {
        get(_, key2) {
          if (key2 in store)
            return new Cookie2(
              key2,
              set.cookie,
              Object.assign({}, initial ?? {}, store[key2])
            );
          return new Cookie2(
            key2,
            set.cookie,
            Object.assign({}, initial)
          );
        }
      });
    };
    var parseCookie2 = async (set, cookieString, {
      secrets,
      sign: sign2,
      ...initial
    } = {}) => {
      if (!cookieString)
        return createCookieJar2(set, {}, initial);
      const isStringKey = typeof secrets === "string";
      if (sign2 && sign2 !== true && !Array.isArray(sign2))
        sign2 = [sign2];
      const jar = {};
      const cookies = (0, import_cookie3.parse)(cookieString);
      for (const [name, v2] of Object.entries(cookies)) {
        let value = (0, import_fast_decode_uri_component4.default)(v2);
        if (sign2 === true || sign2?.includes(name)) {
          if (!secrets)
            throw new Error("No secret is provided to cookie plugin");
          if (isStringKey) {
            const temp = await unsignCookie2(value, secrets);
            if (temp === false)
              throw new InvalidCookieSignature2(name);
            value = temp;
          } else {
            let decoded = true;
            for (let i2 = 0; i2 < secrets.length; i2++) {
              const temp = await unsignCookie2(value, secrets[i2]);
              if (temp !== false) {
                decoded = true;
                value = temp;
                break;
              }
            }
            if (!decoded)
              throw new InvalidCookieSignature2(name);
          }
        }
        jar[name] = {
          value
        };
      }
      return createCookieJar2(set, jar, initial);
    };
    var hasHeaderShorthand2 = "toJSON" in new Headers();
    var isNotEmpty2 = (obj) => {
      if (!obj)
        return false;
      for (const x2 in obj)
        return true;
      return false;
    };
    var handleFile2 = (response, set) => {
      const size = response.size;
      if (!set && size || size && set && set.status !== 206 && set.status !== 304 && set.status !== 412 && set.status !== 416) {
        if (set) {
          if (set.headers instanceof Headers) {
            if (hasHeaderShorthand2)
              set.headers = set.headers.toJSON();
            else
              for (const [key2, value] of set.headers.entries())
                if (key2 in set.headers)
                  set.headers[key2] = value;
          }
          return new Response(response, {
            status: set.status,
            headers: Object.assign(
              {
                "accept-ranges": "bytes",
                "content-range": `bytes 0-${size - 1}/${size}`
              },
              set.headers
            )
          });
        }
        return new Response(response, {
          headers: {
            "accept-ranges": "bytes",
            "content-range": `bytes 0-${size - 1}/${size}`
          }
        });
      }
      return new Response(response);
    };
    var parseSetCookies2 = (headers, setCookie) => {
      if (!headers)
        return headers;
      headers.delete("set-cookie");
      for (let i2 = 0; i2 < setCookie.length; i2++) {
        const index3 = setCookie[i2].indexOf("=");
        headers.append(
          "set-cookie",
          `${setCookie[i2].slice(0, index3)}=${setCookie[i2].slice(index3 + 1) || ""}`
        );
      }
      return headers;
    };
    var serializeCookie2 = (cookies) => {
      if (!cookies || !isNotEmpty2(cookies))
        return void 0;
      const set = [];
      for (const [key2, property] of Object.entries(cookies)) {
        if (!key2 || !property)
          continue;
        const value = property.value;
        if (value === void 0 || value === null)
          continue;
        set.push(
          (0, import_cookie22.serialize)(
            key2,
            typeof value === "object" ? JSON.stringify(value) : value + "",
            property
          )
        );
      }
      if (set.length === 0)
        return void 0;
      if (set.length === 1)
        return set[0];
      return set;
    };
    var handleStream2 = async (generator, set, request) => {
      let init3 = generator.next();
      if (init3 instanceof Promise)
        init3 = await init3;
      if (init3.done) {
        if (set)
          return mapResponse2(init3.value, set, request);
        return mapCompactResponse2(init3.value, request);
      }
      return new Response(
        new ReadableStream({
          async start(controller) {
            let end = false;
            request?.signal.addEventListener("abort", () => {
              end = true;
              try {
                controller.close();
              } catch {
              }
            });
            if (init3.value !== void 0 && init3.value !== null) {
              if (typeof init3.value === "object")
                try {
                  controller.enqueue(
                    Buffer2.from(JSON.stringify(init3.value))
                  );
                } catch {
                  controller.enqueue(Buffer2.from(init3.value.toString()));
                }
              else
                controller.enqueue(Buffer2.from(init3.value.toString()));
            }
            for await (const chunk of generator) {
              if (end)
                break;
              if (chunk === void 0 || chunk === null)
                continue;
              if (typeof chunk === "object")
                try {
                  controller.enqueue(
                    Buffer2.from(JSON.stringify(chunk))
                  );
                } catch {
                  controller.enqueue(Buffer2.from(chunk.toString()));
                }
              else
                controller.enqueue(Buffer2.from(chunk.toString()));
              await new Promise(
                (resolve2) => setTimeout(() => resolve2(), 0)
              );
            }
            try {
              controller.close();
            } catch {
            }
          }
        }),
        {
          ...set,
          headers: {
            // Manually set transfer-encoding for direct response, eg. app.handle, eden
            "transfer-encoding": "chunked",
            "content-type": "text/event-stream; charset=utf-8",
            ...set?.headers
          }
        }
      );
    };
    var mapResponse2 = (response, set, request) => {
      if (isNotEmpty2(set.headers) || set.status !== 200 || set.redirect || set.cookie) {
        if (typeof set.status === "string")
          set.status = StatusMap2[set.status];
        if (set.redirect) {
          set.headers.Location = set.redirect;
          if (!set.status || set.status < 300 || set.status >= 400)
            set.status = 302;
        }
        if (set.cookie && isNotEmpty2(set.cookie)) {
          const cookie = serializeCookie2(set.cookie);
          if (cookie)
            set.headers["set-cookie"] = cookie;
        }
        if (set.headers["set-cookie"] && Array.isArray(set.headers["set-cookie"])) {
          set.headers = parseSetCookies2(
            new Headers(set.headers),
            set.headers["set-cookie"]
          );
        }
        switch (response?.constructor?.name) {
          case "String":
            return new Response(response, set);
          case "Blob":
            return handleFile2(response, set);
          case "Array":
            return Response.json(response, set);
          case "Object":
            const status = response[ELYSIA_RESPONSE2];
            if (status) {
              set.status = status;
              return mapResponse2(response.response, set, request);
            }
            for (const value in Object.values(response)) {
              switch (value?.constructor?.name) {
                case "Blob":
                case "File":
                case "ArrayBuffer":
                case "FileRef":
                  return new Response(form2(response));
                default:
                  break;
              }
            }
            return Response.json(response, set);
          case "ReadableStream":
            if (!set.headers["content-type"]?.startsWith(
              "text/event-stream"
            ))
              set.headers["content-type"] = "text/event-stream; charset=utf-8";
            request?.signal.addEventListener(
              "abort",
              {
                handleEvent() {
                  if (!request?.signal.aborted)
                    response.cancel(request);
                }
              },
              {
                once: true
              }
            );
            return new Response(
              response,
              set
            );
          case void 0:
            if (!response)
              return new Response("", set);
            return Response.json(response, set);
          case "Response":
            let isCookieSet = false;
            if (set.headers instanceof Headers)
              for (const key2 of set.headers.keys()) {
                if (key2 === "set-cookie") {
                  if (isCookieSet)
                    continue;
                  isCookieSet = true;
                  for (const cookie of set.headers.getSetCookie()) {
                    ;
                    response.headers.append(
                      "set-cookie",
                      cookie
                    );
                  }
                } else
                  response.headers.append(
                    key2,
                    set.headers?.get(key2) ?? ""
                  );
              }
            else
              for (const key2 in set.headers)
                response.headers.append(
                  key2,
                  set.headers[key2]
                );
            if (response.status !== set.status)
              set.status = response.status;
            return response;
          case "Error":
            return errorToResponse2(response, set);
          case "Promise":
            return response.then(
              (x2) => mapResponse2(x2, set)
            );
          case "Function":
            return mapResponse2(response(), set);
          case "Number":
          case "Boolean":
            return new Response(
              response.toString(),
              set
            );
          case "Cookie":
            if (response instanceof Cookie2)
              return new Response(response.value, set);
            return new Response(response?.toString(), set);
          case "FormData":
            return new Response(response, set);
          default:
            if (response instanceof Response) {
              let isCookieSet2 = false;
              if (set.headers instanceof Headers)
                for (const key2 of set.headers.keys()) {
                  if (key2 === "set-cookie") {
                    if (isCookieSet2)
                      continue;
                    isCookieSet2 = true;
                    for (const cookie of set.headers.getSetCookie()) {
                      ;
                      response.headers.append(
                        "set-cookie",
                        cookie
                      );
                    }
                  } else
                    response.headers.append(
                      key2,
                      set.headers?.get(key2) ?? ""
                    );
                }
              else
                for (const key2 in set.headers)
                  response.headers.append(
                    key2,
                    set.headers[key2]
                  );
              if (hasHeaderShorthand2)
                set.headers = response.headers.toJSON();
              else
                for (const [key2, value] of response.headers.entries())
                  if (key2 in set.headers)
                    set.headers[key2] = value;
              return response;
            }
            if (response instanceof Promise)
              return response.then((x2) => mapResponse2(x2, set));
            if (response instanceof Error)
              return errorToResponse2(response, set);
            if (typeof response?.next === "function")
              return handleStream2(response, set, request);
            if ("toResponse" in response)
              return mapResponse2(response.toResponse(), set);
            if ("charCodeAt" in response) {
              const code4 = response.charCodeAt(0);
              if (code4 === 123 || code4 === 91) {
                if (!set.headers["Content-Type"])
                  set.headers["Content-Type"] = "application/json";
                return new Response(
                  JSON.stringify(response),
                  set
                );
              }
            }
            return new Response(response, set);
        }
      } else
        switch (response?.constructor?.name) {
          case "String":
            return new Response(response);
          case "Blob":
            return handleFile2(response, set);
          case "Array":
            return Response.json(response);
          case "Object":
            const status = response[ELYSIA_RESPONSE2];
            if (status) {
              set.status = status;
              return mapResponse2(response.response, set, request);
            }
            for (const value in Object.values(response)) {
              switch (value?.constructor?.name) {
                case "Blob":
                case "File":
                case "ArrayBuffer":
                case "FileRef":
                  return new Response(
                    form2(response),
                    set
                  );
                default:
                  break;
              }
            }
            return Response.json(response, set);
          case "ReadableStream":
            request?.signal.addEventListener(
              "abort",
              {
                handleEvent() {
                  if (!request?.signal.aborted)
                    response.cancel(request);
                }
              },
              {
                once: true
              }
            );
            return new Response(response, {
              headers: {
                "Content-Type": "text/event-stream; charset=utf-8"
              }
            });
          case void 0:
            if (!response)
              return new Response("");
            return new Response(JSON.stringify(response), {
              headers: {
                "content-type": "application/json"
              }
            });
          case "Response":
            return response;
          case "Error":
            return errorToResponse2(response, set);
          case "Promise":
            return response.then((x2) => {
              const r2 = mapCompactResponse2(x2, request);
              if (r2 !== void 0)
                return r2;
              return new Response("");
            });
          case "Function":
            return mapCompactResponse2(response(), request);
          case "Number":
          case "Boolean":
            return new Response(response.toString());
          case "Cookie":
            if (response instanceof Cookie2)
              return new Response(response.value, set);
            return new Response(response?.toString(), set);
          case "FormData":
            return new Response(response, set);
          default:
            if (response instanceof Response)
              return new Response(response.body, {
                headers: {
                  "Content-Type": "application/json"
                }
              });
            if (response instanceof Promise)
              return response.then((x2) => mapResponse2(x2, set));
            if (response instanceof Error)
              return errorToResponse2(response, set);
            if (typeof response?.next === "function")
              return handleStream2(response, set, request);
            if ("toResponse" in response)
              return mapResponse2(response.toResponse(), set);
            if ("charCodeAt" in response) {
              const code4 = response.charCodeAt(0);
              if (code4 === 123 || code4 === 91) {
                if (!set.headers["Content-Type"])
                  set.headers["Content-Type"] = "application/json";
                return new Response(
                  JSON.stringify(response),
                  set
                );
              }
            }
            return new Response(response);
        }
    };
    var mapEarlyResponse2 = (response, set, request) => {
      if (response === void 0 || response === null)
        return;
      if (isNotEmpty2(set.headers) || set.status !== 200 || set.redirect || set.cookie) {
        if (typeof set.status === "string")
          set.status = StatusMap2[set.status];
        if (set.redirect) {
          set.headers.Location = set.redirect;
          if (!set.status || set.status < 300 || set.status >= 400)
            set.status = 302;
        }
        if (set.cookie && isNotEmpty2(set.cookie)) {
          const cookie = serializeCookie2(set.cookie);
          if (cookie)
            set.headers["set-cookie"] = cookie;
        }
        if (set.headers["set-cookie"] && Array.isArray(set.headers["set-cookie"]))
          set.headers = parseSetCookies2(
            new Headers(set.headers),
            set.headers["set-cookie"]
          );
        switch (response?.constructor?.name) {
          case "String":
            return new Response(response, set);
          case "Blob":
            return handleFile2(response, set);
          case "Array":
            return Response.json(response, set);
          case "Object":
            const status = response[ELYSIA_RESPONSE2];
            if (status) {
              set.status = status;
              return mapEarlyResponse2(response.response, set, request);
            }
            for (const value in Object.values(response)) {
              switch (value?.constructor?.name) {
                case "Blob":
                case "File":
                case "ArrayBuffer":
                case "FileRef":
                  return new Response(
                    form2(response),
                    set
                  );
                default:
                  break;
              }
            }
            return Response.json(response, set);
          case "ReadableStream":
            if (!set.headers["content-type"]?.startsWith(
              "text/event-stream"
            ))
              set.headers["content-type"] = "text/event-stream; charset=utf-8";
            request?.signal.addEventListener(
              "abort",
              {
                handleEvent() {
                  if (!request?.signal.aborted)
                    response.cancel(request);
                }
              },
              {
                once: true
              }
            );
            return new Response(
              response,
              set
            );
          case void 0:
            if (!response)
              return;
            return Response.json(response, set);
          case "Response":
            let isCookieSet = false;
            if (set.headers instanceof Headers)
              for (const key2 of set.headers.keys()) {
                if (key2 === "set-cookie") {
                  if (isCookieSet)
                    continue;
                  isCookieSet = true;
                  for (const cookie of set.headers.getSetCookie()) {
                    ;
                    response.headers.append(
                      "set-cookie",
                      cookie
                    );
                  }
                } else
                  response.headers.append(
                    key2,
                    set.headers?.get(key2) ?? ""
                  );
              }
            else
              for (const key2 in set.headers)
                response.headers.append(
                  key2,
                  set.headers[key2]
                );
            if (response.status !== set.status)
              set.status = response.status;
            return response;
          case "Promise":
            return response.then((x2) => {
              const r2 = mapEarlyResponse2(x2, set);
              if (r2 !== void 0)
                return r2;
            });
          case "Error":
            return errorToResponse2(response, set);
          case "Function":
            return mapEarlyResponse2(response(), set);
          case "Number":
          case "Boolean":
            return new Response(
              response.toString(),
              set
            );
          case "FormData":
            return new Response(response);
          case "Cookie":
            if (response instanceof Cookie2)
              return new Response(response.value, set);
            return new Response(response?.toString(), set);
          default:
            if (response instanceof Response) {
              let isCookieSet2 = false;
              if (set.headers instanceof Headers)
                for (const key2 of set.headers.keys()) {
                  if (key2 === "set-cookie") {
                    if (isCookieSet2)
                      continue;
                    isCookieSet2 = true;
                    for (const cookie of set.headers.getSetCookie()) {
                      ;
                      response.headers.append(
                        "set-cookie",
                        cookie
                      );
                    }
                  } else
                    response.headers.append(
                      key2,
                      set.headers?.get(key2) ?? ""
                    );
                }
              else
                for (const key2 in set.headers)
                  response.headers.append(
                    key2,
                    set.headers[key2]
                  );
              if (response.status !== set.status)
                set.status = response.status;
              return response;
            }
            if (response instanceof Promise)
              return response.then((x2) => mapEarlyResponse2(x2, set));
            if (response instanceof Error)
              return errorToResponse2(response, set);
            if (typeof response?.next === "function")
              return handleStream2(response, set, request);
            if ("toResponse" in response)
              return mapEarlyResponse2(response.toResponse(), set);
            if ("charCodeAt" in response) {
              const code4 = response.charCodeAt(0);
              if (code4 === 123 || code4 === 91) {
                if (!set.headers["Content-Type"])
                  set.headers["Content-Type"] = "application/json";
                return new Response(
                  JSON.stringify(response),
                  set
                );
              }
            }
            return new Response(response, set);
        }
      } else
        switch (response?.constructor?.name) {
          case "String":
            return new Response(response);
          case "Blob":
            return handleFile2(response, set);
          case "Array":
            return Response.json(response);
          case "Object":
            const status = response[ELYSIA_RESPONSE2];
            if (status) {
              set.status = status;
              return mapEarlyResponse2(response.response, set, request);
            }
            for (const value in Object.values(response)) {
              switch (value?.constructor?.name) {
                case "Blob":
                case "File":
                case "ArrayBuffer":
                case "FileRef":
                  return new Response(
                    form2(response),
                    set
                  );
                default:
                  break;
              }
            }
            return Response.json(response, set);
          case "ReadableStream":
            request?.signal.addEventListener(
              "abort",
              {
                handleEvent() {
                  if (!request?.signal.aborted)
                    response.cancel(request);
                }
              },
              {
                once: true
              }
            );
            return new Response(response, {
              headers: {
                "Content-Type": "text/event-stream; charset=utf-8"
              }
            });
          case void 0:
            if (!response)
              return new Response("");
            return new Response(JSON.stringify(response), {
              headers: {
                "content-type": "application/json"
              }
            });
          case "Response":
            return response;
          case "Promise":
            return response.then((x2) => {
              const r2 = mapEarlyResponse2(x2, set);
              if (r2 !== void 0)
                return r2;
            });
          case "Error":
            return errorToResponse2(response, set);
          case "Function":
            return mapCompactResponse2(response(), request);
          case "Number":
          case "Boolean":
            return new Response(response.toString());
          case "Cookie":
            if (response instanceof Cookie2)
              return new Response(response.value, set);
            return new Response(response?.toString(), set);
          case "FormData":
            return new Response(response);
          default:
            if (response instanceof Response)
              return new Response(response.body, {
                headers: {
                  "Content-Type": "application/json"
                }
              });
            if (response instanceof Promise)
              return response.then((x2) => mapEarlyResponse2(x2, set));
            if (response instanceof Error)
              return errorToResponse2(response, set);
            if (typeof response?.next === "function")
              return handleStream2(response, set, request);
            if ("toResponse" in response)
              return mapEarlyResponse2(response.toResponse(), set);
            if ("charCodeAt" in response) {
              const code4 = response.charCodeAt(0);
              if (code4 === 123 || code4 === 91) {
                if (!set.headers["Content-Type"])
                  set.headers["Content-Type"] = "application/json";
                return new Response(
                  JSON.stringify(response),
                  set
                );
              }
            }
            return new Response(response);
        }
    };
    var mapCompactResponse2 = (response, request) => {
      switch (response?.constructor?.name) {
        case "String":
          return new Response(response);
        case "Blob":
          return handleFile2(response);
        case "Array":
          return Response.json(response);
        case "Object":
          if (response[ELYSIA_RESPONSE2])
            return mapResponse2(response.response, {
              // @ts-ignore
              status: response[ELYSIA_RESPONSE2],
              headers: {}
            });
          form:
            for (const value of Object.values(response))
              switch (value?.constructor?.name) {
                case "Blob":
                case "File":
                case "ArrayBuffer":
                case "FileRef":
                  return new Response(form2(response));
                case "Object":
                  break form;
                default:
                  break;
              }
          return Response.json(response);
        case "ReadableStream":
          request?.signal.addEventListener(
            "abort",
            {
              handleEvent() {
                if (!request?.signal.aborted)
                  response.cancel(request);
              }
            },
            {
              once: true
            }
          );
          return new Response(response, {
            headers: {
              "Content-Type": "text/event-stream; charset=utf-8"
            }
          });
        case void 0:
          if (!response)
            return new Response("");
          return new Response(JSON.stringify(response), {
            headers: {
              "content-type": "application/json"
            }
          });
        case "Response":
          return response;
        case "Error":
          return errorToResponse2(response);
        case "Promise":
          return response.then(
            (x2) => mapCompactResponse2(x2, request)
          );
        case "Function":
          return mapCompactResponse2(response(), request);
        case "Number":
        case "Boolean":
          return new Response(response.toString());
        case "FormData":
          return new Response(response);
        default:
          if (response instanceof Response)
            return new Response(response.body, {
              headers: {
                "Content-Type": "application/json"
              }
            });
          if (response instanceof Promise)
            return response.then(
              (x2) => mapCompactResponse2(x2, request)
            );
          if (response instanceof Error)
            return errorToResponse2(response);
          if (typeof response?.next === "function")
            return handleStream2(response, void 0, request);
          if ("toResponse" in response)
            return mapCompactResponse2(response.toResponse());
          if ("charCodeAt" in response) {
            const code4 = response.charCodeAt(0);
            if (code4 === 123 || code4 === 91) {
              return new Response(JSON.stringify(response), {
                headers: {
                  "Content-Type": "application/json"
                }
              });
            }
          }
          return new Response(response);
      }
    };
    var errorToResponse2 = (error22, set) => new Response(
      JSON.stringify({
        name: error22?.name,
        message: error22?.message,
        cause: error22?.cause
      }),
      {
        status: set?.status !== 200 ? set?.status ?? 500 : 500,
        headers: set?.headers
      }
    );
    var replaceUrlPath2 = (url, pathname) => {
      const urlObject = new URL(url);
      urlObject.pathname = pathname;
      return urlObject.toString();
    };
    var isClass2 = (v2) => typeof v2 === "function" && /^\s*class\s+/.test(v2.toString()) || // Handle import * as Sentry from '@sentry/bun'
    // This also handle [object Date], [object Array]
    // and FFI value like [object Prisma]
    v2.toString().startsWith("[object ") && v2.toString() !== "[object Object]" || // If object prototype is not pure, then probably a class-like object
    isNotEmpty2(Object.getPrototypeOf(v2));
    var isObject4 = (item) => item && typeof item === "object" && !Array.isArray(item);
    var mergeDeep2 = (target, source, {
      skipKeys,
      override = true
    } = {}) => {
      if (!isObject4(target) || !isObject4(source))
        return target;
      for (const [key2, value] of Object.entries(source)) {
        if (skipKeys?.includes(key2))
          continue;
        if (!isObject4(value) || !(key2 in target) || isClass2(value)) {
          if (override || !(key2 in target))
            target[key2] = value;
          continue;
        }
        target[key2] = mergeDeep2(
          target[key2],
          value,
          { skipKeys, override }
        );
      }
      return target;
    };
    var mergeCookie2 = (a2, b2) => {
      const { properties: _, ...target } = a2 ?? {};
      const { properties: __, ...source } = b2 ?? {};
      return mergeDeep2(target, source);
    };
    var mergeObjectArray2 = (a2 = [], b2 = []) => {
      if (!a2)
        return [];
      if (!b2)
        return a2;
      const array = [];
      const checksums = [];
      if (!Array.isArray(a2))
        a2 = [a2];
      if (!Array.isArray(b2))
        b2 = [b2];
      for (const item of a2) {
        array.push(item);
        if (item.checksum)
          checksums.push(item.checksum);
      }
      for (const item of b2)
        if (!checksums.includes(item.checksum))
          array.push(item);
      return array;
    };
    var primitiveHooks2 = [
      "start",
      "request",
      "parse",
      "transform",
      "resolve",
      "beforeHandle",
      "afterHandle",
      "mapResponse",
      "afterResponse",
      "trace",
      "error",
      "stop",
      "body",
      "headers",
      "params",
      "query",
      "response",
      "type",
      "detail"
    ];
    var primitiveHookMap2 = primitiveHooks2.reduce(
      (acc, x2) => (acc[x2] = true, acc),
      {}
    );
    var mergeResponse2 = (a2, b2) => {
      const isRecordNumber = (x2) => typeof x2 === "object" && Object.keys(x2).every(isNumericString2);
      if (isRecordNumber(a2) && isRecordNumber(b2))
        return { ...a2, ...b2 };
      return b2 ?? a2;
    };
    var mergeSchemaValidator2 = (a2, b2) => {
      return {
        body: b2?.body ?? a2?.body,
        headers: b2?.headers ?? a2?.headers,
        params: b2?.params ?? a2?.params,
        query: b2?.query ?? a2?.query,
        cookie: b2?.cookie ?? a2?.cookie,
        // @ts-ignore ? This order is correct - SaltyAom
        response: mergeResponse2(
          // @ts-ignore
          a2?.response,
          // @ts-ignore
          b2?.response
        )
      };
    };
    var mergeHook2 = (a2, b2) => {
      return {
        ...a2,
        ...b2,
        // Merge local hook first
        // @ts-ignore
        body: b2?.body ?? a2?.body,
        // @ts-ignore
        headers: b2?.headers ?? a2?.headers,
        // @ts-ignore
        params: b2?.params ?? a2?.params,
        // @ts-ignore
        query: b2?.query ?? a2?.query,
        // @ts-ignore
        cookie: b2?.cookie ?? a2?.cookie,
        // ? This order is correct - SaltyAom
        response: mergeResponse2(
          // @ts-ignore
          a2?.response,
          // @ts-ignore
          b2?.response
        ),
        type: a2?.type || b2?.type,
        detail: mergeDeep2(
          // @ts-ignore
          b2?.detail ?? {},
          // @ts-ignore
          a2?.detail ?? {}
        ),
        parse: mergeObjectArray2(a2?.parse, b2?.parse),
        transform: mergeObjectArray2(a2?.transform, b2?.transform),
        beforeHandle: mergeObjectArray2(a2?.beforeHandle, b2?.beforeHandle),
        afterHandle: mergeObjectArray2(a2?.afterHandle, b2?.afterHandle),
        mapResponse: mergeObjectArray2(a2?.mapResponse, b2?.mapResponse),
        afterResponse: mergeObjectArray2(
          a2?.afterResponse,
          b2?.afterResponse
        ),
        trace: mergeObjectArray2(a2?.trace, b2?.trace),
        error: mergeObjectArray2(a2?.error, b2?.error)
      };
    };
    var replaceSchemaType2 = (schema, options, root4 = true) => {
      if (!Array.isArray(options))
        return _replaceSchemaType2(schema, options, root4);
      for (const option2 of options)
        schema = _replaceSchemaType2(schema, option2, root4);
      return schema;
    };
    var _replaceSchemaType2 = (schema, options, root4 = true) => {
      if (!schema)
        return schema;
      if (options.untilObjectFound && !root4 && schema.type === "object")
        return schema;
      const fromSymbol = options.from[import_typebox32.Kind];
      if (schema.oneOf) {
        for (let i2 = 0; i2 < schema.oneOf.length; i2++)
          schema.oneOf[i2] = _replaceSchemaType2(schema.oneOf[i2], options, root4);
        return schema;
      }
      if (schema.anyOf) {
        for (let i2 = 0; i2 < schema.anyOf.length; i2++)
          schema.anyOf[i2] = _replaceSchemaType2(schema.anyOf[i2], options, root4);
        return schema;
      }
      if (schema.allOf) {
        for (let i2 = 0; i2 < schema.allOf.length; i2++)
          schema.allOf[i2] = _replaceSchemaType2(schema.allOf[i2], options, root4);
        return schema;
      }
      if (schema.not) {
        for (let i2 = 0; i2 < schema.not.length; i2++)
          schema.not[i2] = _replaceSchemaType2(schema.not[i2], options, root4);
        return schema;
      }
      const isRoot = root4 && !!options.excludeRoot;
      if (schema[import_typebox32.Kind] === fromSymbol) {
        const { anyOf, oneOf, allOf, not: not3, properties: properties2, items, ...rest } = schema;
        const to = options.to();
        let transform;
        const composeProperties = (v2) => {
          if (properties2 && v2.type === "object") {
            const newProperties = {};
            for (const [key2, value2] of Object.entries(properties2))
              newProperties[key2] = _replaceSchemaType2(
                value2,
                options,
                false
              );
            return {
              ...rest,
              ...v2,
              properties: newProperties
            };
          }
          if (items && v2.type === "array")
            return {
              ...rest,
              ...v2,
              items: _replaceSchemaType2(items, options, false)
            };
          const value = {
            ...rest,
            ...v2
          };
          delete value["required"];
          if (properties2 && v2.type === "string" && v2.format === "ObjectString" && v2.default === "{}") {
            transform = t3.ObjectString(properties2, rest);
            value.default = JSON.stringify(
              import_value22.Value.Create(t3.Object(properties2))
            );
            value.properties = properties2;
          }
          if (items && v2.type === "string" && v2.format === "ArrayString" && v2.default === "[]") {
            transform = t3.ArrayString(items, rest);
            value.default = JSON.stringify(import_value22.Value.Create(t3.Array(items)));
            value.items = items;
          }
          return value;
        };
        if (isRoot) {
          if (properties2) {
            const newProperties = {};
            for (const [key2, value] of Object.entries(properties2))
              newProperties[key2] = _replaceSchemaType2(
                value,
                options,
                false
              );
            return {
              ...rest,
              properties: newProperties
            };
          } else if (items?.map)
            return {
              ...rest,
              items: items.map(
                (v2) => _replaceSchemaType2(v2, options, false)
              )
            };
          return rest;
        }
        if (to.anyOf)
          for (let i2 = 0; i2 < to.anyOf.length; i2++)
            to.anyOf[i2] = composeProperties(to.anyOf[i2]);
        else if (to.oneOf)
          for (let i2 = 0; i2 < to.oneOf.length; i2++)
            to.oneOf[i2] = composeProperties(to.oneOf[i2]);
        else if (to.allOf)
          for (let i2 = 0; i2 < to.allOf.length; i2++)
            to.allOf[i2] = composeProperties(to.allOf[i2]);
        else if (to.not)
          for (let i2 = 0; i2 < to.not.length; i2++)
            to.not[i2] = composeProperties(to.not[i2]);
        if (transform)
          to[import_typebox32.TransformKind] = transform[import_typebox32.TransformKind];
        if (to.anyOf || to.oneOf || to.allOf || to.not)
          return to;
        if (properties2) {
          const newProperties = {};
          for (const [key2, value] of Object.entries(properties2))
            newProperties[key2] = _replaceSchemaType2(
              value,
              options,
              false
            );
          return {
            ...rest,
            ...to,
            properties: newProperties
          };
        } else if (items?.map)
          return {
            ...rest,
            ...to,
            items: items.map(
              (v2) => _replaceSchemaType2(v2, options, false)
            )
          };
        return {
          ...rest,
          ...to
        };
      }
      const properties = schema?.properties;
      if (properties)
        for (const [key2, value] of Object.entries(properties)) {
          switch (value[import_typebox32.Kind]) {
            case fromSymbol:
              const { anyOf, oneOf, allOf, not: not3, type, ...rest } = value;
              const to = options.to();
              if (to.anyOf)
                for (let i2 = 0; i2 < to.anyOf.length; i2++)
                  to.anyOf[i2] = { ...rest, ...to.anyOf[i2] };
              else if (to.oneOf)
                for (let i2 = 0; i2 < to.oneOf.length; i2++)
                  to.oneOf[i2] = { ...rest, ...to.oneOf[i2] };
              else if (to.allOf)
                for (let i2 = 0; i2 < to.allOf.length; i2++)
                  to.allOf[i2] = { ...rest, ...to.allOf[i2] };
              else if (to.not)
                for (let i2 = 0; i2 < to.not.length; i2++)
                  to.not[i2] = { ...rest, ...to.not[i2] };
              properties[key2] = {
                ...rest,
                ..._replaceSchemaType2(rest, options, false)
              };
              break;
            case "Object":
            case "Union":
              properties[key2] = _replaceSchemaType2(value, options, false);
              break;
            default:
              if (value.items)
                for (let i2 = 0; i2 < value.items.length; i2++) {
                  value.items[i2] = _replaceSchemaType2(
                    value.items[i2],
                    options,
                    false
                  );
                }
              else if (value.anyOf || value.oneOf || value.allOf || value.not)
                properties[key2] = _replaceSchemaType2(
                  value,
                  options,
                  false
                );
              break;
          }
        }
      return schema;
    };
    var getSchemaValidator2 = (s2, {
      models = {},
      dynamic = false,
      normalize: normalize4 = false,
      additionalProperties = false,
      coerce = false,
      additionalCoerce = []
    } = {}) => {
      if (!s2)
        return void 0;
      if (typeof s2 === "string" && !(s2 in models))
        return void 0;
      let schema = typeof s2 === "string" ? models[s2] : s2;
      if (coerce)
        schema = replaceSchemaType2(schema, [
          {
            from: t3.Number(),
            to: () => t3.Numeric(),
            untilObjectFound: true
          },
          {
            from: t3.Boolean(),
            to: () => t3.BooleanString(),
            untilObjectFound: true
          },
          ...Array.isArray(additionalCoerce) ? additionalCoerce : [additionalCoerce]
        ]);
      if (schema.type === "object" && "additionalProperties" in schema === false)
        schema.additionalProperties = additionalProperties;
      const cleaner = (value) => import_value22.Value.Clean(schema, value);
      if (dynamic) {
        const validator = {
          schema,
          references: "",
          checkFunc: () => {
          },
          code: "",
          Check: (value) => import_value22.Value.Check(schema, value),
          Errors: (value) => import_value22.Value.Errors(schema, value),
          Code: () => "",
          Clean: cleaner
        };
        if (normalize4 && schema.additionalProperties === false)
          validator.Clean = cleaner;
        if (schema.config) {
          validator.config = schema.config;
          if (validator?.schema?.config)
            delete validator.schema.config;
        }
        validator.parse = (v2) => {
          try {
            return validator.Decode(v2);
          } catch (error22) {
            throw [...validator.Errors(v2)].map(mapValueError2);
          }
        };
        validator.safeParse = (v2) => {
          try {
            return { success: true, data: validator.Decode(v2), error: null };
          } catch (error22) {
            const errors2 = [...compiled.Errors(v2)].map(mapValueError2);
            return {
              success: false,
              data: null,
              error: errors2[0]?.summary,
              errors: errors2
            };
          }
        };
        return validator;
      }
      const compiled = import_compiler32.TypeCompiler.Compile(schema, Object.values(models));
      compiled.Clean = cleaner;
      if (schema.config) {
        compiled.config = schema.config;
        if (compiled?.schema?.config)
          delete compiled.schema.config;
      }
      compiled.parse = (v2) => {
        try {
          return compiled.Decode(v2);
        } catch (error22) {
          throw [...compiled.Errors(v2)].map(mapValueError2);
        }
      };
      compiled.safeParse = (v2) => {
        try {
          return { success: true, data: compiled.Decode(v2), error: null };
        } catch (error22) {
          const errors2 = [...compiled.Errors(v2)].map(mapValueError2);
          return {
            success: false,
            data: null,
            error: errors2[0]?.summary,
            errors: errors2
          };
        }
      };
      return compiled;
    };
    var getResponseSchemaValidator2 = (s2, {
      models = {},
      dynamic = false,
      normalize: normalize4 = false,
      additionalProperties = false
    }) => {
      if (!s2)
        return;
      if (typeof s2 === "string" && !(s2 in models))
        return;
      const maybeSchemaOrRecord = typeof s2 === "string" ? models[s2] : s2;
      const compile = (schema, references) => {
        const cleaner = (value) => {
          if (!value || typeof value !== "object") {
            return import_value22.Value.Clean(schema, value);
          }
          let touched = false;
          const visited2 = /* @__PURE__ */ new Set();
          const retrieveAllFieldsOfObjectOrArray = (value2) => {
            if (visited2.has(value2)) {
              return value2;
            }
            visited2.add(value2);
            if (Array.isArray(value2)) {
              return value2.map((x2) => retrieveAllFieldsOfObjectOrArray(x2));
            }
            const retrievedArrayFields = {};
            for (const [key2, val2] of Object.entries(value2)) {
              if (Array.isArray(val2)) {
                retrievedArrayFields[key2] = retrieveAllFieldsOfObjectOrArray(val2);
                delete value2[key2];
              }
            }
            Object.assign(value2, retrievedArrayFields);
            const retrievedFields = {};
            let currentObj = value2;
            while (currentObj !== null) {
              for (const name of Object.getOwnPropertyNames(currentObj)) {
                const descriptor = Object.getOwnPropertyDescriptor(
                  currentObj,
                  name
                );
                if (descriptor && typeof descriptor.get === "function" && name !== "__proto__") {
                  retrievedFields[name] = value2[name];
                  delete currentObj[name];
                  touched = true;
                }
              }
              currentObj = Object.getPrototypeOf(currentObj);
            }
            Object.assign(value2, retrievedFields);
            return value2;
          };
          value = retrieveAllFieldsOfObjectOrArray(value);
          if (!touched) {
            return import_value22.Value.Clean(schema, value);
          }
          if (Array.isArray(value)) {
            value = import_value22.Value.Clean(schema, value);
          } else {
            value = { ...import_value22.Value.Clean(schema, value) };
          }
          return value;
        };
        if (dynamic)
          return {
            schema,
            references: "",
            checkFunc: () => {
            },
            code: "",
            Check: (value) => import_value22.Value.Check(schema, value),
            Errors: (value) => import_value22.Value.Errors(schema, value),
            Code: () => ""
          };
        const compiledValidator = import_compiler32.TypeCompiler.Compile(schema, references);
        if (normalize4 && schema.additionalProperties === false)
          compiledValidator.Clean = cleaner;
        return compiledValidator;
      };
      if (import_typebox32.Kind in maybeSchemaOrRecord) {
        if ("additionalProperties" in maybeSchemaOrRecord === false)
          maybeSchemaOrRecord.additionalProperties = additionalProperties;
        return {
          200: compile(maybeSchemaOrRecord, Object.values(models))
        };
      }
      const record = {};
      Object.keys(maybeSchemaOrRecord).forEach((status) => {
        const maybeNameOrSchema = maybeSchemaOrRecord[+status];
        if (typeof maybeNameOrSchema === "string") {
          if (maybeNameOrSchema in models) {
            const schema = models[maybeNameOrSchema];
            schema.type === "object" && "additionalProperties" in schema === false;
            record[+status] = import_typebox32.Kind in schema ? compile(schema, Object.values(models)) : schema;
          }
          return void 0;
        }
        if (maybeNameOrSchema.type === "object" && "additionalProperties" in maybeNameOrSchema === false)
          maybeNameOrSchema.additionalProperties = additionalProperties;
        record[+status] = import_typebox32.Kind in maybeNameOrSchema ? compile(maybeNameOrSchema, Object.values(models)) : maybeNameOrSchema;
      });
      return record;
    };
    var isBun2 = typeof Bun !== "undefined";
    var hasHash2 = isBun2 && typeof Bun.hash === "function";
    var checksum2 = (s2) => {
      if (hasHash2)
        return Bun.hash(s2);
      let h2 = 9;
      for (let i2 = 0; i2 < s2.length; )
        h2 = Math.imul(h2 ^ s2.charCodeAt(i2++), 9 ** 9);
      return h2 = h2 ^ h2 >>> 9;
    };
    var _stringToStructureCoercions2;
    var stringToStructureCoercions2 = () => {
      if (!_stringToStructureCoercions2) {
        _stringToStructureCoercions2 = [
          {
            from: t3.Object({}),
            to: () => t3.ObjectString({}),
            excludeRoot: true
          },
          {
            from: t3.Array(t3.Any()),
            to: () => t3.ArrayString(t3.Any())
          }
        ];
      }
      return _stringToStructureCoercions2;
    };
    var getCookieValidator2 = ({
      validator,
      defaultConfig = {},
      config: config3,
      dynamic,
      models
    }) => {
      let cookieValidator = getSchemaValidator2(validator, {
        dynamic,
        models,
        additionalProperties: true,
        coerce: true,
        additionalCoerce: stringToStructureCoercions2()
      });
      if (isNotEmpty2(defaultConfig)) {
        if (cookieValidator) {
          cookieValidator.config = mergeCookie2(
            // @ts-expect-error private
            cookieValidator.config,
            config3
          );
        } else {
          cookieValidator = getSchemaValidator2(t3.Cookie({}), {
            dynamic,
            models,
            additionalProperties: true
          });
          cookieValidator.config = defaultConfig;
        }
      }
      return cookieValidator;
    };
    var injectChecksum2 = (checksum22, x2) => {
      if (!x2)
        return;
      if (!Array.isArray(x2)) {
        const fn = x2;
        if (checksum22 && !fn.checksum)
          fn.checksum = checksum22;
        if (fn.scope === "scoped")
          fn.scope = "local";
        return fn;
      }
      const fns = [...x2];
      for (const fn of fns) {
        if (checksum22 && !fn.checksum)
          fn.checksum = checksum22;
        if (fn.scope === "scoped")
          fn.scope = "local";
      }
      return fns;
    };
    var mergeLifeCycle2 = (a2, b2, checksum22) => {
      return {
        // ...a,
        // ...b,
        start: mergeObjectArray2(
          a2.start,
          injectChecksum2(checksum22, b2?.start)
        ),
        request: mergeObjectArray2(
          a2.request,
          injectChecksum2(checksum22, b2?.request)
        ),
        parse: mergeObjectArray2(
          a2.parse,
          injectChecksum2(checksum22, b2?.parse)
        ),
        transform: mergeObjectArray2(
          a2.transform,
          injectChecksum2(checksum22, b2?.transform)
        ),
        beforeHandle: mergeObjectArray2(
          a2.beforeHandle,
          injectChecksum2(checksum22, b2?.beforeHandle)
        ),
        afterHandle: mergeObjectArray2(
          a2.afterHandle,
          injectChecksum2(checksum22, b2?.afterHandle)
        ),
        mapResponse: mergeObjectArray2(
          a2.mapResponse,
          injectChecksum2(checksum22, b2?.mapResponse)
        ),
        afterResponse: mergeObjectArray2(
          a2.afterResponse,
          injectChecksum2(checksum22, b2?.afterResponse)
        ),
        // Already merged on Elysia._use, also logic is more complicated, can't directly merge
        trace: mergeObjectArray2(
          a2.trace,
          injectChecksum2(checksum22, b2?.trace)
        ),
        error: mergeObjectArray2(
          a2.error,
          injectChecksum2(checksum22, b2?.error)
        ),
        stop: mergeObjectArray2(
          a2.stop,
          injectChecksum2(checksum22, b2?.stop)
        )
      };
    };
    var asHookType2 = (fn, inject, { skipIfHasType = false } = {}) => {
      if (!fn)
        return fn;
      if (!Array.isArray(fn)) {
        if (skipIfHasType)
          fn.scope ??= inject;
        else
          fn.scope = inject;
        return fn;
      }
      for (const x2 of fn)
        if (skipIfHasType)
          x2.scope ??= inject;
        else
          x2.scope = inject;
      return fn;
    };
    var filterGlobal2 = (fn) => {
      if (!fn)
        return fn;
      if (!Array.isArray(fn))
        switch (fn.scope) {
          case "global":
          case "scoped":
            return { ...fn };
          default:
            return { fn };
        }
      const array = [];
      for (const x2 of fn)
        switch (x2.scope) {
          case "global":
          case "scoped":
            array.push({
              ...x2
            });
            break;
        }
      return array;
    };
    var filterGlobalHook2 = (hook) => {
      return {
        // rest is validator
        ...hook,
        type: hook?.type,
        detail: hook?.detail,
        parse: filterGlobal2(hook?.parse),
        transform: filterGlobal2(hook?.transform),
        beforeHandle: filterGlobal2(hook?.beforeHandle),
        afterHandle: filterGlobal2(hook?.afterHandle),
        mapResponse: filterGlobal2(hook?.mapResponse),
        afterResponse: filterGlobal2(hook?.afterResponse),
        error: filterGlobal2(hook?.error),
        trace: filterGlobal2(hook?.trace)
      };
    };
    var StatusMap2 = {
      Continue: 100,
      "Switching Protocols": 101,
      Processing: 102,
      "Early Hints": 103,
      OK: 200,
      Created: 201,
      Accepted: 202,
      "Non-Authoritative Information": 203,
      "No Content": 204,
      "Reset Content": 205,
      "Partial Content": 206,
      "Multi-Status": 207,
      "Already Reported": 208,
      "Multiple Choices": 300,
      "Moved Permanently": 301,
      Found: 302,
      "See Other": 303,
      "Not Modified": 304,
      "Temporary Redirect": 307,
      "Permanent Redirect": 308,
      "Bad Request": 400,
      Unauthorized: 401,
      "Payment Required": 402,
      Forbidden: 403,
      "Not Found": 404,
      "Method Not Allowed": 405,
      "Not Acceptable": 406,
      "Proxy Authentication Required": 407,
      "Request Timeout": 408,
      Conflict: 409,
      Gone: 410,
      "Length Required": 411,
      "Precondition Failed": 412,
      "Payload Too Large": 413,
      "URI Too Long": 414,
      "Unsupported Media Type": 415,
      "Range Not Satisfiable": 416,
      "Expectation Failed": 417,
      "I'm a teapot": 418,
      "Misdirected Request": 421,
      "Unprocessable Content": 422,
      Locked: 423,
      "Failed Dependency": 424,
      "Too Early": 425,
      "Upgrade Required": 426,
      "Precondition Required": 428,
      "Too Many Requests": 429,
      "Request Header Fields Too Large": 431,
      "Unavailable For Legal Reasons": 451,
      "Internal Server Error": 500,
      "Not Implemented": 501,
      "Bad Gateway": 502,
      "Service Unavailable": 503,
      "Gateway Timeout": 504,
      "HTTP Version Not Supported": 505,
      "Variant Also Negotiates": 506,
      "Insufficient Storage": 507,
      "Loop Detected": 508,
      "Not Extended": 510,
      "Network Authentication Required": 511
    };
    var InvertedStatusMap2 = Object.fromEntries(
      Object.entries(StatusMap2).map(([k2, v2]) => [v2, k2])
    );
    function removeTrailingEquals2(digest) {
      let trimmedDigest = digest;
      while (trimmedDigest.endsWith("=")) {
        trimmedDigest = trimmedDigest.slice(0, -1);
      }
      return trimmedDigest;
    }
    var encoder3 = new TextEncoder();
    var signCookie2 = async (val2, secret) => {
      if (typeof val2 !== "string")
        throw new TypeError("Cookie value must be provided as a string.");
      if (secret === null)
        throw new TypeError("Secret key must be provided.");
      const secretKey = await crypto.subtle.importKey(
        "raw",
        encoder3.encode(secret),
        { name: "HMAC", hash: "SHA-256" },
        false,
        ["sign"]
      );
      const hmacBuffer = await crypto.subtle.sign(
        "HMAC",
        secretKey,
        encoder3.encode(val2)
      );
      return val2 + "." + removeTrailingEquals2(Buffer2.from(hmacBuffer).toString("base64"));
    };
    var unsignCookie2 = async (input, secret) => {
      if (typeof input !== "string")
        throw new TypeError("Signed cookie string must be provided.");
      if (null === secret)
        throw new TypeError("Secret key must be provided.");
      const tentativeValue = input.slice(0, input.lastIndexOf("."));
      const expectedInput = await signCookie2(tentativeValue, secret);
      return expectedInput === input ? tentativeValue : false;
    };
    var traceBackMacro2 = (extension2, property) => {
      if (!extension2 || typeof extension2 !== "object" || !property)
        return;
      for (const [key2, value] of Object.entries(property)) {
        if (key2 in primitiveHookMap2 || !(key2 in extension2))
          continue;
        const v2 = extension2[key2];
        if (typeof v2 === "function") {
          v2(value);
          delete property[key2];
        }
      }
    };
    var createMacroManager2 = ({
      globalHook,
      localHook
    }) => (stackName) => (type, fn) => {
      if (typeof type === "function")
        type = {
          fn: type
        };
      if ("fn" in type || Array.isArray(type)) {
        if (!localHook[stackName])
          localHook[stackName] = [];
        if (typeof localHook[stackName] === "function")
          localHook[stackName] = [localHook[stackName]];
        if (Array.isArray(type))
          localHook[stackName] = localHook[stackName].concat(type);
        else
          localHook[stackName].push(type);
        return;
      }
      const { insert = "after", stack = "local" } = type;
      if (typeof fn === "function")
        fn = { fn };
      if (stack === "global") {
        if (!Array.isArray(fn)) {
          if (insert === "before") {
            ;
            globalHook[stackName].unshift(fn);
          } else {
            ;
            globalHook[stackName].push(fn);
          }
        } else {
          if (insert === "before") {
            globalHook[stackName] = fn.concat(
              globalHook[stackName]
            );
          } else {
            globalHook[stackName] = globalHook[stackName].concat(fn);
          }
        }
      } else {
        if (!localHook[stackName])
          localHook[stackName] = [];
        if (typeof localHook[stackName] === "function")
          localHook[stackName] = [localHook[stackName]];
        if (!Array.isArray(fn)) {
          if (insert === "before") {
            ;
            localHook[stackName].unshift(fn);
          } else {
            ;
            localHook[stackName].push(fn);
          }
        } else {
          if (insert === "before") {
            localHook[stackName] = fn.concat(localHook[stackName]);
          } else {
            localHook[stackName] = localHook[stackName].concat(fn);
          }
        }
      }
    };
    var parseNumericString2 = (message2) => {
      if (typeof message2 === "number")
        return message2;
      if (message2.length < 16) {
        if (message2.trim().length === 0)
          return null;
        const length = Number(message2);
        if (Number.isNaN(length))
          return null;
        return length;
      }
      if (message2.length === 16) {
        if (message2.trim().length === 0)
          return null;
        const number2 = Number(message2);
        if (Number.isNaN(number2) || number2.toString() !== message2)
          return null;
        return number2;
      }
      return null;
    };
    var isNumericString2 = (message2) => parseNumericString2(message2) !== null;
    var PromiseGroup2 = class {
      constructor(onError = console.error) {
        this.onError = onError;
        this.root = null;
        this.promises = [];
      }
      /**
       * The number of promises still being awaited.
       */
      get size() {
        return this.promises.length;
      }
      /**
       * Add a promise to the group.
       * @returns The promise that was added.
       */
      add(promise) {
        this.promises.push(promise);
        this.root ||= this.drain();
        return promise;
      }
      async drain() {
        while (this.promises.length > 0) {
          try {
            await this.promises[0];
          } catch (error22) {
            this.onError(error22);
          }
          this.promises.shift();
        }
        this.root = null;
      }
      // Allow the group to be awaited.
      then(onfulfilled, onrejected) {
        return (this.root ?? Promise.resolve()).then(onfulfilled, onrejected);
      }
    };
    var fnToContainer2 = (fn) => {
      if (!fn)
        return fn;
      if (!Array.isArray(fn)) {
        if (typeof fn === "function")
          return { fn };
        else if ("fn" in fn)
          return fn;
      }
      const fns = [];
      for (const x2 of fn) {
        if (typeof x2 === "function")
          fns.push({ fn: x2 });
        else if ("fn" in x2)
          fns.push(x2);
      }
      return fns;
    };
    var localHookToLifeCycleStore2 = (a2) => {
      return {
        ...a2,
        start: fnToContainer2(a2?.start),
        request: fnToContainer2(a2?.request),
        parse: fnToContainer2(a2?.parse),
        transform: fnToContainer2(a2?.transform),
        beforeHandle: fnToContainer2(a2?.beforeHandle),
        afterHandle: fnToContainer2(a2?.afterHandle),
        mapResponse: fnToContainer2(a2?.mapResponse),
        afterResponse: fnToContainer2(a2?.afterResponse),
        trace: fnToContainer2(a2?.trace),
        error: fnToContainer2(a2?.error),
        stop: fnToContainer2(a2?.stop)
      };
    };
    var lifeCycleToFn2 = (a2) => {
      return {
        ...a2,
        start: a2.start?.map((x2) => x2.fn),
        request: a2.request?.map((x2) => x2.fn),
        parse: a2.parse?.map((x2) => x2.fn),
        transform: a2.transform?.map((x2) => x2.fn),
        beforeHandle: a2.beforeHandle?.map((x2) => x2.fn),
        afterHandle: a2.afterHandle?.map((x2) => x2.fn),
        afterResponse: a2.afterResponse?.map((x2) => x2.fn),
        mapResponse: a2.mapResponse?.map((x2) => x2.fn),
        trace: a2.trace?.map((x2) => x2.fn),
        error: a2.error?.map((x2) => x2.fn),
        stop: a2.stop?.map((x2) => x2.fn)
      };
    };
    var cloneInference2 = (inference) => ({
      body: inference.body,
      cookie: inference.cookie,
      headers: inference.headers,
      query: inference.query,
      set: inference.set,
      server: inference.server
    });
    var redirect2 = (url, status = 302) => Response.redirect(url, status);
    var ELYSIA_FORM_DATA2 = Symbol("ElysiaFormData");
    var ELYSIA_REQUEST_ID2 = Symbol("ElysiaRequestId");
    var form2 = (items) => {
      const formData = new FormData();
      for (const [key2, value] of Object.entries(items)) {
        if (Array.isArray(value)) {
          for (const v2 of value) {
            if (value instanceof File)
              formData.append(key2, value, value.name);
            formData.append(key2, v2);
          }
          continue;
        }
        if (value instanceof File)
          formData.append(key2, value, value.name);
        formData.append(key2, value);
      }
      return formData;
    };
    var randomId2 = () => crypto.getRandomValues(new Uint32Array(1))[0];
    var deduplicateChecksum2 = (array) => {
      const hashes = [];
      for (let i2 = 0; i2 < array.length; i2++) {
        const item = array[i2];
        if (item.checksum) {
          if (hashes.includes(item.checksum)) {
            array.splice(i2, 1);
            i2--;
          }
          hashes.push(item.checksum);
        }
      }
      return array;
    };
    var promoteEvent2 = (events, as2 = "scoped") => {
      if (as2 === "scoped") {
        for (const event of events)
          if ("scope" in event && event.scope === "local")
            event.scope = "scoped";
        return;
      }
      for (const event of events)
        if ("scope" in event)
          event.scope = "global";
    };
    var env5 = typeof Bun !== "undefined" ? Bun.env : typeof process !== "undefined" ? process?.env : void 0;
    var ERROR_CODE2 = Symbol("ElysiaErrorCode");
    var ELYSIA_RESPONSE2 = Symbol("ElysiaResponse");
    var isProduction2 = (env5?.NODE_ENV ?? env5?.ENV) === "production";
    var error3 = (code4, response) => {
      const res = response ?? (code4 in InvertedStatusMap2 ? (
        // @ts-expect-error Always correct
        InvertedStatusMap2[code4]
      ) : code4);
      return {
        // @ts-expect-error trust me bro
        [ELYSIA_RESPONSE2]: StatusMap2[code4] ?? code4,
        response: res,
        _type: void 0,
        error: new Error(res)
      };
    };
    var InternalServerError2 = class extends Error {
      constructor(message2) {
        super(message2 ?? "INTERNAL_SERVER_ERROR");
        this.code = "INTERNAL_SERVER_ERROR";
        this.status = 500;
      }
    };
    var NotFoundError2 = class extends Error {
      constructor(message2) {
        super(message2 ?? "NOT_FOUND");
        this.code = "NOT_FOUND";
        this.status = 404;
      }
    };
    var ParseError2 = class extends Error {
      constructor() {
        super("Failed to parse body");
        this.code = "PARSE";
        this.status = 400;
      }
    };
    var InvalidCookieSignature2 = class extends Error {
      constructor(key2, message2) {
        super(message2 ?? `"${key2}" has invalid cookie signature`);
        this.key = key2;
        this.code = "INVALID_COOKIE_SIGNATURE";
        this.status = 400;
      }
    };
    var mapValueError2 = (error22) => {
      const { message: message2, path: path2, value, type } = error22;
      const property = path2.slice(1).replaceAll("/", ".");
      const isRoot = path2 === "";
      switch (type) {
        case 42:
          return {
            ...error22,
            summary: isRoot ? `Value should not be provided` : `Property '${property}' should not be provided`
          };
        case 45:
          return {
            ...error22,
            summary: isRoot ? `Value is missing` : `Property '${property}' is missing`
          };
        case 50:
          const quoteIndex = message2.indexOf("'");
          const format3 = message2.slice(
            quoteIndex + 1,
            message2.indexOf("'", quoteIndex + 1)
          );
          return {
            ...error22,
            summary: isRoot ? `Value should be an email` : `Property '${property}' should be ${format3}`
          };
        case 54:
          return {
            ...error22,
            summary: `${message2.slice(
              0,
              9
            )} property '${property}' to be ${message2.slice(
              8
            )} but found: ${value}`
          };
        case 62:
          const union2 = error22.schema.anyOf.map((x2) => `'${x2?.format ?? x2.type}'`).join(", ");
          return {
            ...error22,
            summary: isRoot ? `Value should be one of ${union2}` : `Property '${property}' should be one of: ${union2}`
          };
        default:
          return { summary: message2, ...error22 };
      }
    };
    var ValidationError2 = class _ValidationError2 extends Error {
      constructor(type, validator, value) {
        if (value && typeof value === "object" && ELYSIA_RESPONSE2 in value)
          value = value.response;
        const error22 = isProduction2 ? void 0 : "Errors" in validator ? validator.Errors(value).First() : import_value32.Value.Errors(validator, value).First();
        const customError = error22?.schema.error !== void 0 ? typeof error22.schema.error === "function" ? error22.schema.error({
          type,
          validator,
          value,
          get errors() {
            return [...validator.Errors(value)].map(
              mapValueError2
            );
          }
        }) : error22.schema.error : void 0;
        const accessor = error22?.path || "root";
        let message2 = "";
        if (customError !== void 0) {
          message2 = typeof customError === "object" ? JSON.stringify(customError) : customError + "";
        } else if (isProduction2) {
          message2 = JSON.stringify({
            type: "validation",
            on: type,
            summary: mapValueError2(error22).summary,
            message: error22?.message,
            found: value
          });
        } else {
          const schema = validator?.schema ?? validator;
          const errors2 = "Errors" in validator ? [...validator.Errors(value)].map(mapValueError2) : [...import_value32.Value.Errors(validator, value)].map(mapValueError2);
          let expected;
          try {
            expected = import_value32.Value.Create(schema);
          } catch (error32) {
            expected = {
              type: "Could not create expected value",
              // @ts-expect-error
              message: error32?.message,
              error: error32
            };
          }
          message2 = JSON.stringify(
            {
              type: "validation",
              on: type,
              summary: errors2[0]?.summary,
              property: accessor,
              message: error22?.message,
              expected,
              found: value,
              errors: errors2
            },
            null,
            2
          );
        }
        super(message2);
        this.type = type;
        this.validator = validator;
        this.value = value;
        this.code = "VALIDATION";
        this.status = 422;
        Object.setPrototypeOf(this, _ValidationError2.prototype);
      }
      get all() {
        return "Errors" in this.validator ? [...this.validator.Errors(this.value)].map(mapValueError2) : (
          // @ts-ignore
          [...import_value32.Value.Errors(this.validator, this.value)].map(mapValueError2)
        );
      }
      static simplifyModel(validator) {
        const model = "schema" in validator ? validator.schema : validator;
        try {
          return import_value32.Value.Create(model);
        } catch {
          return model;
        }
      }
      get model() {
        return _ValidationError2.simplifyModel(this.validator);
      }
      toResponse(headers) {
        return new Response(this.message, {
          status: 400,
          headers: {
            ...headers,
            "content-type": "application/json"
          }
        });
      }
    };
    var websocket2 = {
      open(ws) {
        ws.data.open?.(ws);
      },
      message(ws, message2) {
        ws.data.message?.(ws, message2);
      },
      drain(ws) {
        ws.data.drain?.(ws);
      },
      close(ws, code4, reason) {
        ws.data.close?.(ws, code4, reason);
      }
    };
    var ElysiaWS2 = class {
      constructor(raw2, data) {
        this.raw = raw2;
        this.data = data;
        this.validator = raw2.data.validator;
        if (raw2.data.id) {
          this.id = raw2.data.id;
        } else {
          this.id = randomId2().toString();
        }
      }
      get id() {
        return this.raw.data.id;
      }
      set id(newID) {
        this.raw.data.id = newID;
      }
      get publish() {
        return (topic, data = void 0, compress) => {
          if (this.validator?.Check(data) === false)
            throw new ValidationError2("message", this.validator, data);
          if (typeof data === "object")
            data = JSON.stringify(data);
          this.raw.publish(topic, data, compress);
          return this;
        };
      }
      get send() {
        return (data) => {
          if (this.validator?.Check(data) === false)
            throw new ValidationError2("message", this.validator, data);
          if (Buffer2.isBuffer(data)) {
            this.raw.send(data);
            return this;
          }
          if (typeof data === "object")
            data = JSON.stringify(data);
          this.raw.send(data);
          return this;
        };
      }
      get subscribe() {
        return (room) => {
          this.raw.subscribe(room);
          return this;
        };
      }
      get unsubscribe() {
        return (room) => {
          this.raw.unsubscribe(room);
          return this;
        };
      }
      get cork() {
        return (callback) => {
          this.raw.cork(callback);
          return this;
        };
      }
      get close() {
        return () => {
          this.raw.close();
          return this;
        };
      }
      get terminate() {
        return this.raw.terminate.bind(this.raw);
      }
      get isSubscribed() {
        return this.raw.isSubscribed.bind(this.raw);
      }
      get remoteAddress() {
        return this.raw.remoteAddress;
      }
    };
    var version5 = "1.1.5";
    var import_value42 = require_value5();
    var import_fast_decode_uri_component22 = __toESM2(require_fast_decode_uri_component());
    var plusRegex2 = /\+/g;
    function parseQuery2(input) {
      const result = {};
      if (typeof input !== "string")
        return result;
      let key2 = "";
      let value = "";
      let startingIndex = -1;
      let equalityIndex = -1;
      let flags = 0;
      const l2 = input.length;
      for (let i2 = 0; i2 < l2; i2++) {
        switch (input.charCodeAt(i2)) {
          case 38:
            const hasBothKeyValuePair = equalityIndex > startingIndex;
            if (!hasBothKeyValuePair)
              equalityIndex = i2;
            key2 = input.slice(startingIndex + 1, equalityIndex);
            if (hasBothKeyValuePair || key2.length > 0) {
              if (flags & 1)
                key2 = key2.replace(plusRegex2, " ");
              if (flags & 2)
                key2 = (0, import_fast_decode_uri_component22.default)(key2) || key2;
              if (!result[key2]) {
                if (hasBothKeyValuePair) {
                  value = input.slice(equalityIndex + 1, i2);
                  if (flags & 4)
                    value = value.replace(plusRegex2, " ");
                  if (flags & 8)
                    value = (0, import_fast_decode_uri_component22.default)(value) || value;
                }
                result[key2] = value;
              }
            }
            key2 = "";
            value = "";
            startingIndex = i2;
            equalityIndex = i2;
            flags = 0;
            break;
          case 61:
            if (equalityIndex <= startingIndex)
              equalityIndex = i2;
            else
              flags |= 8;
            break;
          case 43:
            if (equalityIndex > startingIndex)
              flags |= 4;
            else
              flags |= 1;
            break;
          case 37:
            if (equalityIndex > startingIndex)
              flags |= 8;
            else
              flags |= 2;
            break;
        }
      }
      if (startingIndex < l2) {
        const hasBothKeyValuePair = equalityIndex > startingIndex;
        key2 = input.slice(
          startingIndex + 1,
          hasBothKeyValuePair ? equalityIndex : l2
        );
        if (hasBothKeyValuePair || key2.length > 0) {
          if (flags & 1)
            key2 = key2.replace(plusRegex2, " ");
          if (flags & 2)
            key2 = (0, import_fast_decode_uri_component22.default)(key2) || key2;
          if (!result[key2]) {
            if (hasBothKeyValuePair) {
              value = input.slice(equalityIndex + 1, l2);
              if (flags & 4)
                value = value.replace(plusRegex2, " ");
              if (flags & 8)
                value = (0, import_fast_decode_uri_component22.default)(value) || value;
            }
            result[key2] = value;
          }
        }
      }
      return result;
    }
    var import_fast_decode_uri_component32 = __toESM2(require_fast_decode_uri_component());
    var ELYSIA_TRACE2 = Symbol("ElysiaTrace");
    var createProcess2 = () => {
      const { promise, resolve: resolve2 } = Promise.withResolvers();
      const { promise: end, resolve: resolveEnd } = Promise.withResolvers();
      const { promise: error22, resolve: resolveError } = Promise.withResolvers();
      const callbacks = [];
      const callbacksEnd = [];
      return [
        (callback) => {
          if (callback)
            callbacks.push(callback);
          return promise;
        },
        (process2) => {
          const processes = [];
          const resolvers = [];
          let groupError = null;
          for (let i2 = 0; i2 < (process2.total ?? 0); i2++) {
            const { promise: promise2, resolve: resolve22 } = Promise.withResolvers();
            const { promise: end2, resolve: resolveEnd2 } = Promise.withResolvers();
            const { promise: error32, resolve: resolveError2 } = Promise.withResolvers();
            const callbacks2 = [];
            const callbacksEnd2 = [];
            processes.push((callback) => {
              if (callback)
                callbacks2.push(callback);
              return promise2;
            });
            resolvers.push((process3) => {
              const result2 = {
                ...process3,
                end: end2,
                error: error32,
                index: i2,
                onStop(callback) {
                  if (callback)
                    callbacksEnd2.push(callback);
                  return end2;
                }
              };
              resolve22(result2);
              for (let i22 = 0; i22 < callbacks2.length; i22++)
                callbacks2[i22](result2);
              return (error4 = null) => {
                const end3 = performance.now();
                if (error4)
                  groupError = error4;
                const detail = {
                  end: end3,
                  error: error4,
                  get elapsed() {
                    return end3 - process3.begin;
                  }
                };
                for (let i22 = 0; i22 < callbacksEnd2.length; i22++)
                  callbacksEnd2[i22](detail);
                resolveEnd2(end3);
                resolveError2(error4);
              };
            });
          }
          const result = {
            ...process2,
            end,
            error: error22,
            onEvent(callback) {
              for (let i2 = 0; i2 < processes.length; i2++)
                processes[i2](callback);
            },
            onStop(callback) {
              if (callback)
                callbacksEnd.push(callback);
              return end;
            }
          };
          resolve2(result);
          for (let i2 = 0; i2 < callbacks.length; i2++)
            callbacks[i2](result);
          return {
            resolveChild: resolvers,
            resolve(error32 = null) {
              const end2 = performance.now();
              if (!error32 && groupError)
                error32 = groupError;
              const detail = {
                end: end2,
                error: error32,
                get elapsed() {
                  return end2 - process2.begin;
                }
              };
              for (let i2 = 0; i2 < callbacksEnd.length; i2++)
                callbacksEnd[i2](detail);
              resolveEnd(end2);
              resolveError(error32);
            }
          };
        }
      ];
    };
    var createTracer2 = (traceListener) => {
      return (context) => {
        const [onRequest, resolveRequest] = createProcess2();
        const [onParse, resolveParse] = createProcess2();
        const [onTransform, resolveTransform] = createProcess2();
        const [onBeforeHandle, resolveBeforeHandle] = createProcess2();
        const [onHandle, resolveHandle] = createProcess2();
        const [onAfterHandle, resolveAfterHandle] = createProcess2();
        const [onError, resolveError] = createProcess2();
        const [onMapResponse, resolveMapResponse] = createProcess2();
        const [onAfterResponse, resolveAfterResponse] = createProcess2();
        traceListener({
          // @ts-ignore
          id: context[ELYSIA_REQUEST_ID2],
          context,
          set: context.set,
          // @ts-ignore
          onRequest,
          // @ts-ignore
          onParse,
          // @ts-ignore
          onTransform,
          // @ts-ignore
          onBeforeHandle,
          // @ts-ignore
          onHandle,
          // @ts-ignore
          onAfterHandle,
          // @ts-ignore
          onMapResponse,
          // @ts-ignore
          onAfterResponse,
          // @ts-ignore
          onError
        });
        return {
          request: resolveRequest,
          parse: resolveParse,
          transform: resolveTransform,
          beforeHandle: resolveBeforeHandle,
          handle: resolveHandle,
          afterHandle: resolveAfterHandle,
          error: resolveError,
          mapResponse: resolveMapResponse,
          afterResponse: resolveAfterResponse
        };
      };
    };
    var headersHasToJSON2 = new Headers().toJSON;
    var TypeBoxSymbol2 = {
      optional: Symbol.for("TypeBox.Optional"),
      kind: Symbol.for("TypeBox.Kind")
    };
    var isOptional2 = (validator) => {
      if (!validator)
        return false;
      const schema = validator?.schema;
      return !!schema && TypeBoxSymbol2.optional in schema;
    };
    var hasAdditionalProperties2 = (_schema) => {
      if (!_schema)
        return false;
      const schema = _schema?.schema ?? _schema;
      if (schema.anyOf)
        return schema.anyOf.some(hasAdditionalProperties2);
      if (schema.someOf)
        return schema.someOf.some(hasAdditionalProperties2);
      if (schema.allOf)
        return schema.allOf.some(hasAdditionalProperties2);
      if (schema.not)
        return schema.not.some(hasAdditionalProperties2);
      if (schema.type === "object") {
        const properties = schema.properties;
        if ("additionalProperties" in schema)
          return schema.additionalProperties;
        for (const key2 of Object.keys(properties)) {
          const property = properties[key2];
          if (property.type === "object") {
            if (hasAdditionalProperties2(property))
              return true;
          } else if (property.anyOf) {
            for (let i2 = 0; i2 < property.anyOf.length; i2++)
              if (hasAdditionalProperties2(property.anyOf[i2]))
                return true;
          }
          return property.additionalProperties;
        }
        return false;
      }
      return false;
    };
    var createReport2 = ({
      context = "c",
      trace,
      addFn
    }) => {
      if (!trace.length)
        return () => {
          return {
            resolveChild() {
              return () => {
              };
            },
            resolve() {
            }
          };
        };
      for (let i2 = 0; i2 < trace.length; i2++)
        addFn(
          `let report${i2}, reportChild${i2}, reportErr${i2}, reportErrChild${i2}; let trace${i2} = ${context}[ELYSIA_TRACE]?.[${i2}] ?? trace[${i2}](${context});
`
        );
      return (event, {
        name,
        total = 0
      } = {}) => {
        if (!name)
          name = "anonymous";
        const reporter = event === "error" ? "reportErr" : "report";
        for (let i2 = 0; i2 < trace.length; i2++)
          addFn(
            `
${reporter}${i2} = trace${i2}.${event}({id,event: '${event}',name: '${name}',begin: performance.now(),total: ${total}})
`
          );
        return {
          resolve() {
            for (let i2 = 0; i2 < trace.length; i2++)
              addFn(`
${reporter}${i2}.resolve()
`);
          },
          resolveChild(name2) {
            for (let i2 = 0; i2 < trace.length; i2++)
              addFn(
                `${reporter}Child${i2} = ${reporter}${i2}.resolveChild?.shift()?.({id,event: '${event}',name: '${name2}',begin: performance.now()})
`
              );
            return (binding3) => {
              for (let i2 = 0; i2 < trace.length; i2++) {
                if (binding3)
                  addFn(`
                             	if (${binding3} instanceof Error)
                    				${reporter}Child${i2}?.(${binding3})
                           		else
                             		${reporter}Child${i2}?.()
`);
                else
                  addFn(`${reporter}Child${i2}?.()
`);
              }
            };
          }
        };
      };
    };
    var composeValidationFactory2 = ({
      injectResponse = "",
      normalize: normalize4 = false,
      validator
    }) => ({
      composeValidation: (type, value = `c.${type}`) => `c.set.status = 422; throw new ValidationError('${type}', validator.${type}, ${value})`,
      composeResponseValidation: (name = "r") => {
        let code4 = "\n" + injectResponse + "\n";
        code4 += `if(typeof ${name} === "object" && ${name} && ELYSIA_RESPONSE in ${name}) {
			c.set.status = ${name}[ELYSIA_RESPONSE]
			${name} = ${name}.response
		}

		const isResponse = ${name} instanceof Response

`;
        code4 += `switch(c.set.status) {
`;
        for (const [status, value] of Object.entries(
          validator.response
        )) {
          code4 += `	case ${status}:
				if (!isResponse) {
`;
          if (normalize4 && "Clean" in value && !hasAdditionalProperties2(value))
            code4 += `${name} = validator.response['${status}'].Clean(${name})
`;
          code4 += `if(validator.response['${status}'].Check(${name}) === false) {
					c.set.status = 422

					throw new ValidationError('response', validator.response['${status}'], ${name})
				}

				c.set.status = ${status}
			}

			break

`;
        }
        code4 += "\n}\n";
        return code4;
      }
    });
    var KindSymbol2 = Symbol.for("TypeBox.Kind");
    var hasProperty2 = (expectedProperty, schema) => {
      if (!schema)
        return;
      if (schema.type === "object") {
        const properties = schema.properties;
        if (!properties)
          return false;
        for (const key2 of Object.keys(properties)) {
          const property = properties[key2];
          if (expectedProperty in property)
            return true;
          if (property.type === "object") {
            if (hasProperty2(expectedProperty, property))
              return true;
          } else if (property.anyOf) {
            for (let i2 = 0; i2 < property.anyOf.length; i2++) {
              if (hasProperty2(expectedProperty, property.anyOf[i2]))
                return true;
            }
          }
        }
        return false;
      }
      return expectedProperty in schema;
    };
    var TransformSymbol2 = Symbol.for("TypeBox.Transform");
    var hasTransform2 = (schema) => {
      if (!schema)
        return;
      if (schema.type === "object" && schema.properties) {
        const properties = schema.properties;
        for (const key2 of Object.keys(properties)) {
          const property = properties[key2];
          if (property.type === "object") {
            if (hasTransform2(property))
              return true;
          } else if (property.anyOf) {
            for (let i2 = 0; i2 < property.anyOf.length; i2++)
              if (hasTransform2(property.anyOf[i2]))
                return true;
          }
          const hasTransformSymbol = TransformSymbol2 in property;
          if (hasTransformSymbol)
            return true;
        }
        return false;
      }
      return TransformSymbol2 in schema || schema.properties && TransformSymbol2 in schema.properties;
    };
    var matchFnReturn2 = /(?:return|=>) \S+\(/g;
    var isAsyncName2 = (v2) => {
      const fn = v2?.fn ?? v2;
      return fn.constructor.name === "AsyncFunction";
    };
    var isAsync2 = (v2) => {
      const fn = v2?.fn ?? v2;
      if (fn.constructor.name === "AsyncFunction")
        return true;
      const literal = fn.toString();
      if (literal.includes("=> response.clone("))
        return false;
      if (literal.includes("await"))
        return true;
      if (literal.includes("async"))
        return true;
      return !!literal.match(matchFnReturn2);
    };
    var isGenerator2 = (v2) => {
      const fn = v2?.fn ?? v2;
      return fn.constructor.name === "AsyncGeneratorFunction" || fn.constructor.name === "GeneratorFunction";
    };
    var composeHandler2 = ({
      app: app2,
      path: path2,
      method,
      localHook,
      hooks,
      validator,
      handler,
      allowMeta = false,
      inference
    }) => {
      const isHandleFn = typeof handler === "function";
      if (!isHandleFn)
        handler = mapResponse2(handler, {
          // @ts-expect-error private property
          headers: app2.setHeaders ?? {}
        });
      const handle3 = isHandleFn ? `handler(c)` : `handler`;
      const hasAfterResponse = hooks.afterResponse.length > 0;
      const hasTrace = hooks.trace.length > 0;
      let fnLiteral = "";
      inference = sucrose2(
        Object.assign(localHook, {
          handler
        }),
        inference
      );
      if (inference.server)
        fnLiteral += `
Object.defineProperty(c, 'server', {
			get: function() { return getServer() }
		})
`;
      if (inference.body)
        fnLiteral += `let isParsing = false
`;
      validator.createBody?.();
      validator.createQuery?.();
      validator.createHeaders?.();
      validator.createParams?.();
      validator.createCookie?.();
      validator.createResponse?.();
      const hasQuery = inference.query || !!validator.query;
      const hasBody = method !== "$INTERNALWS" && method !== "GET" && method !== "HEAD" && (inference.body || !!validator.body || hooks.parse.length);
      const defaultHeaders = app2.setHeaders;
      const hasDefaultHeaders = defaultHeaders && !!Object.keys(defaultHeaders).length;
      const hasHeaders = inference.headers || validator.headers;
      const hasCookie = inference.cookie || !!validator.cookie;
      const cookieValidator = hasCookie ? getCookieValidator2({
        validator: validator.cookie,
        defaultConfig: app2.config.cookie,
        dynamic: !!app2.config.aot,
        // @ts-expect-error
        config: validator.cookie?.config ?? {},
        // @ts-expect-error
        models: app2.definitions.type
      }) : void 0;
      const cookieMeta = cookieValidator?.config;
      let encodeCookie = "";
      if (cookieMeta?.sign) {
        if (!cookieMeta.secrets)
          throw new Error(
            `t.Cookie required secret which is not set in (${method}) ${path2}.`
          );
        const secret = !cookieMeta.secrets ? void 0 : typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets[0];
        encodeCookie += `const _setCookie = c.set.cookie
		if(_setCookie) {`;
        if (cookieMeta.sign === true) {
          encodeCookie += `for(const [key, cookie] of Object.entries(_setCookie)) {
				c.set.cookie[key].value = await signCookie(cookie.value, '${secret}')
			}`;
        } else
          for (const name of cookieMeta.sign) {
            encodeCookie += `if(_setCookie['${name}']?.value) { c.set.cookie['${name}'].value = await signCookie(_setCookie['${name}'].value, '${secret}') }
`;
          }
        encodeCookie += "}\n";
      }
      const normalize4 = app2.config.normalize;
      const { composeValidation, composeResponseValidation } = composeValidationFactory2({
        normalize: normalize4,
        validator
      });
      if (hasHeaders) {
        fnLiteral += headersHasToJSON2 ? `c.headers = c.request.headers.toJSON()
` : `c.headers = {}
                for (const [key, value] of c.request.headers.entries())
					c.headers[key] = value
				`;
      }
      if (hasCookie) {
        const get = (name, defaultValue) => {
          const value = cookieMeta?.[name] ?? defaultValue;
          if (!value)
            return typeof defaultValue === "string" ? `${name}: "${defaultValue}",` : `${name}: ${defaultValue},`;
          if (typeof value === "string")
            return `${name}: '${value}',`;
          if (value instanceof Date)
            return `${name}: new Date(${value.getTime()}),`;
          return `${name}: ${value},`;
        };
        const options = cookieMeta ? `{
			secrets: ${cookieMeta.secrets !== void 0 ? typeof cookieMeta.secrets === "string" ? `'${cookieMeta.secrets}'` : "[" + cookieMeta.secrets.reduce(
          (a2, b2) => a2 + `'${b2}',`,
          ""
        ) + "]" : "undefined"},
			sign: ${cookieMeta.sign === true ? true : cookieMeta.sign !== void 0 ? "[" + cookieMeta.sign.reduce(
          (a2, b2) => a2 + `'${b2}',`,
          ""
        ) + "]" : "undefined"},
			${get("domain")}
			${get("expires")}
			${get("httpOnly")}
			${get("maxAge")}
			${get("path", "/")}
			${get("priority")}
			${get("sameSite")}
			${get("secure")}
		}` : "undefined";
        if (hasHeaders)
          fnLiteral += `
c.cookie = await parseCookie(c.set, c.headers.cookie, ${options})
`;
        else
          fnLiteral += `
c.cookie = await parseCookie(c.set, c.request.headers.get('cookie'), ${options})
`;
      }
      if (hasQuery) {
        const destructured = [];
        if (validator.query && validator.query.schema.type === "object") {
          const properties = validator.query.schema.properties;
          if (!hasAdditionalProperties2(validator.query))
            for (let [key2, _value] of Object.entries(properties)) {
              let value = _value;
              if (value && TypeBoxSymbol2.optional in value && value.type === "array" && value.items)
                value = value.items;
              const { type, anyOf } = value;
              const isArray4 = type === "array" || anyOf?.some(
                (v2) => v2.type === "string" && v2.format === "ArrayString"
              );
              destructured.push({
                key: key2,
                isArray: isArray4,
                isNestedObjectArray: isArray4 && value.items?.type === "object" || !!value.items?.anyOf?.some(
                  // @ts-expect-error
                  (x2) => x2.type === "object" || x2.type === "array"
                ),
                isObject: type === "object" || anyOf?.some(
                  (v2) => v2.type === "string" && v2.format === "ArrayString"
                ),
                anyOf: !!anyOf
              });
            }
        }
        if (!destructured.length) {
          fnLiteral += `if(c.qi === -1) {
				c.query = {}
			} else {
				c.query = parseQuery(c.url.slice(c.qi + 1))
			}`;
        } else {
          fnLiteral += `if(c.qi !== -1) {
				let url = '&' + c.url.slice(c.qi + 1)

				${destructured.map(
            ({
              key: key2,
              isArray: isArray4,
              isObject: isObject22,
              isNestedObjectArray,
              anyOf
            }, index3) => {
              const init3 = `${index3 === 0 ? "let" : ""} memory = url.indexOf('&${key2}=')
							let a${index3}
`;
              if (isArray4)
                return init3 + (isNestedObjectArray ? `while (memory !== -1) {
											const start = memory + ${key2.length + 2}
											memory = url.indexOf('&', start)

											if(a${index3} === undefined)
												a${index3} = ''
											else
												a${index3} += ','

											let temp

											if(memory === -1) temp = decodeURIComponent(url.slice(start))
											else temp = decodeURIComponent(url.slice(start, memory))

											const charCode = temp.charCodeAt(0)
											if(charCode !== 91 && charCode !== 123)
												temp = '"' + temp + '"'

											a${index3} += temp

											if(memory === -1) break

											memory = url.indexOf('&${key2}=', memory)
											if(memory === -1) break
										}

										try {
										    if(a${index3}.charCodeAt(0) === 91)
												a${index3} = JSON.parse(a${index3})
											else
												a${index3} = JSON.parse('[' + a${index3} + ']')
										} catch {}
` : `while (memory !== -1) {
											const start = memory + ${key2.length + 2}
											memory = url.indexOf('&', start)

											if(a${index3} === undefined)
												a${index3} = []

											if(memory === -1) {
												a${index3}.push(decodeURIComponent(url.slice(start)))
												break
											}
											else a${index3}.push(decodeURIComponent(url.slice(start, memory)))

											memory = url.indexOf('&${key2}=', memory)
											if(memory === -1) break
										}
`);
              if (isObject22)
                return init3 + `if (memory !== -1) {
										const start = memory + ${key2.length + 2}
										memory = url.indexOf('&', start)

										if(memory === -1) a${index3} = decodeURIComponent(url.slice(start))
										else a${index3} = decodeURIComponent(url.slice(start, memory))

										if (a${index3} !== undefined) {
											try {
												a${index3} = JSON.parse(a${index3})
											} catch {}
										}
									}`;
              return init3 + `if (memory !== -1) {
										const start = memory + ${key2.length + 2}
										memory = url.indexOf('&', start)

										if(memory === -1) a${index3} = decodeURIComponent(url.slice(start))
										else {
											a${index3} = decodeURIComponent(url.slice(start, memory))

											${anyOf ? `
											let deepMemory = url.indexOf('&${key2}=', memory)

											if(deepMemory !== -1) {
												a${index3} = [a${index3}]
												let first = true

												while(true) {
													const start = deepMemory + ${key2.length + 2}
													if(first)
														first = false
													else
														deepMemory = url.indexOf('&', start)

													let value
													if(deepMemory === -1) value = decodeURIComponent(url.slice(start))
													else value = decodeURIComponent(url.slice(start, deepMemory))

													const vStart = value.charCodeAt(0)
													const vEnd = value.charCodeAt(value.length - 1)

													if((vStart === 91 && vEnd === 93) || (vStart === 123 && vEnd === 125))
														try {
															a${index3}.push(JSON.parse(value))
														} catch {
														 	a${index3}.push(value)
														}

													if(deepMemory === -1) break
												}
											}
												` : ""}
										}
									}`;
            }
          ).join("\n")}

				c.query = {
					${destructured.map(({ key: key2 }, index3) => `'${key2}': a${index3}`).join(", ")}
				}
			} else {
				c.query = {}
			}`;
        }
      }
      if (hasTrace)
        fnLiteral += "\nconst id = c[ELYSIA_REQUEST_ID]\n";
      const report = createReport2({
        trace: hooks.trace,
        addFn: (word) => {
          fnLiteral += word;
        }
      });
      fnLiteral += "\ntry {\n";
      const isAsyncHandler = typeof handler === "function" && isAsync2(handler);
      const saveResponse = hasTrace || hooks.afterResponse.length > 0 ? "c.response = " : "";
      const maybeAsync = hasCookie || hasBody || isAsyncHandler || hooks.parse.length > 0 || hooks.afterHandle.some(isAsync2) || hooks.beforeHandle.some(isAsync2) || hooks.transform.some(isAsync2) || hooks.mapResponse.some(isAsync2);
      const maybeStream = (typeof handler === "function" ? isGenerator2(handler) : false) || hooks.beforeHandle.some(isGenerator2) || hooks.afterHandle.some(isGenerator2) || hooks.transform.some(isGenerator2);
      const hasSet = inference.cookie || inference.set || hasHeaders || hasTrace || validator.response || isHandleFn && hasDefaultHeaders || maybeStream;
      const requestMapper = `, c.request`;
      fnLiteral += `c.route = \`${path2}\`
`;
      const parseReporter = report("parse", {
        total: hooks.parse.length
      });
      if (hasBody) {
        const hasBodyInference = hooks.parse.length || inference.body || validator.body;
        fnLiteral += "isParsing = true\n";
        if (hooks.type && !hooks.parse.length) {
          switch (hooks.type) {
            case "json":
            case "application/json":
              fnLiteral += `c.body = await c.request.json()`;
              break;
            case "text":
            case "text/plain":
              fnLiteral += `c.body = await c.request.text()
`;
              break;
            case "urlencoded":
            case "application/x-www-form-urlencoded":
              fnLiteral += `c.body = parseQuery(await c.request.text())
`;
              break;
            case "arrayBuffer":
            case "application/octet-stream":
              fnLiteral += `c.body = await c.request.arrayBuffer()
`;
              break;
            case "formdata":
            case "multipart/form-data":
              fnLiteral += `c.body = {}

						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue

							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}
`;
              break;
          }
        } else if (hasBodyInference) {
          fnLiteral += "\n";
          fnLiteral += hasHeaders ? `let contentType = c.headers['content-type']` : `let contentType = c.request.headers.get('content-type')`;
          fnLiteral += `
				if (contentType) {
					const index = contentType.indexOf(';')
					if (index !== -1) contentType = contentType.substring(0, index)

					c.contentType = contentType
`;
          if (hooks.parse.length) {
            fnLiteral += `let used = false
`;
            const reporter = report("parse", {
              total: hooks.parse.length
            });
            for (let i2 = 0; i2 < hooks.parse.length; i2++) {
              const endUnit = reporter.resolveChild(
                hooks.parse[i2].fn.name
              );
              const name = `bo${i2}`;
              if (i2 !== 0)
                fnLiteral += `if(!used) {
`;
              fnLiteral += `let ${name} = parse[${i2}](c, contentType)
`;
              fnLiteral += `if(${name} instanceof Promise) ${name} = await ${name}
`;
              fnLiteral += `if(${name} !== undefined) { c.body = ${name}; used = true }
`;
              endUnit();
              if (i2 !== 0)
                fnLiteral += `}`;
            }
            reporter.resolve();
          }
          fnLiteral += "\ndelete c.contentType\n";
          if (hooks.parse.length)
            fnLiteral += `if (!used) {`;
          if (hooks.type && !Array.isArray(hooks.type)) {
            switch (hooks.type) {
              case "json":
              case "application/json":
                fnLiteral += `c.body = await c.request.json()`;
                break;
              case "text":
              case "text/plain":
                fnLiteral += `c.body = await c.request.text()
`;
                break;
              case "urlencoded":
              case "application/x-www-form-urlencoded":
                fnLiteral += `c.body = parseQuery(await c.request.text())
`;
                break;
              case "arrayBuffer":
              case "application/octet-stream":
                fnLiteral += `c.body = await c.request.arrayBuffer()
`;
                break;
              case "formdata":
              case "multipart/form-data":
                fnLiteral += `c.body = {}

							const form = await c.request.formData()
							for (const key of form.keys()) {
								if (c.body[key])
									continue

								const value = form.getAll(key)
								if (value.length === 1)
									c.body[key] = value[0]
								else c.body[key] = value
							}
`;
                break;
            }
          } else {
            fnLiteral += `
					switch (contentType) {
						case 'application/json':
							c.body = await c.request.json()
							break

						case 'text/plain':
							c.body = await c.request.text()
							break

						case 'application/x-www-form-urlencoded':
							c.body = parseQuery(await c.request.text())
							break

						case 'application/octet-stream':
							c.body = await c.request.arrayBuffer();
							break

						case 'multipart/form-data':
							c.body = {}

							const form = await c.request.formData()
							for (const key of form.keys()) {
								if (c.body[key])
									continue

								const value = form.getAll(key)
								if (value.length === 1)
									c.body[key] = value[0]
								else c.body[key] = value
							}

							break
					}`;
          }
          if (hooks.parse.length)
            fnLiteral += `}`;
          fnLiteral += "}\n";
        }
        fnLiteral += "\nisParsing = false\n";
      }
      parseReporter.resolve();
      if (hooks?.transform) {
        const reporter = report("transform", {
          total: hooks.transform.length
        });
        if (hooks.transform.length)
          fnLiteral += "\nlet transformed\n";
        for (let i2 = 0; i2 < hooks.transform.length; i2++) {
          const transform = hooks.transform[i2];
          const endUnit = reporter.resolveChild(transform.fn.name);
          fnLiteral += isAsync2(transform) ? `transformed = await transform[${i2}](c)
` : `transformed = transform[${i2}](c)
`;
          if (transform.subType === "mapDerive")
            fnLiteral += `if(transformed?.[ELYSIA_RESPONSE])
					throw transformed
				else {
					transformed.request = c.request
					transformed.store = c.store
					transformed.qi = c.qi
					transformed.path = c.path
					transformed.url = c.url
					transformed.redirect = c.redirect
					transformed.set = c.set
					transformed.error = c.error

					c = transformed
			}`;
          else
            fnLiteral += `if(transformed?.[ELYSIA_RESPONSE])
					throw transformed
				else
					Object.assign(c, transformed)
`;
          endUnit();
        }
        reporter.resolve();
      }
      if (validator) {
        fnLiteral += "\n";
        if (validator.headers) {
          if (normalize4 && "Clean" in validator.headers && !hasAdditionalProperties2(validator.headers))
            fnLiteral += "c.headers = validator.headers.Clean(c.headers);\n";
          if (hasProperty2("default", validator.headers.schema))
            for (const [key2, value] of Object.entries(
              import_value42.Value.Default(
                // @ts-ignore
                validator.headers.schema,
                {}
              )
            )) {
              const parsed = typeof value === "object" ? JSON.stringify(value) : typeof value === "string" ? `'${value}'` : value;
              if (parsed !== void 0)
                fnLiteral += `c.headers['${key2}'] ??= ${parsed}
`;
            }
          if (isOptional2(validator.headers))
            fnLiteral += `if(isNotEmpty(c.headers)) {`;
          fnLiteral += `if(validator.headers.Check(c.headers) === false) {
				${composeValidation("headers")}
			}`;
          if (hasTransform2(validator.headers.schema))
            fnLiteral += `c.headers = validator.headers.Decode(c.headers)
`;
          if (isOptional2(validator.headers))
            fnLiteral += "}";
        }
        if (validator.params) {
          if (hasProperty2("default", validator.params.schema))
            for (const [key2, value] of Object.entries(
              import_value42.Value.Default(
                // @ts-ignore
                validator.params.schema,
                {}
              )
            )) {
              const parsed = typeof value === "object" ? JSON.stringify(value) : typeof value === "string" ? `'${value}'` : value;
              if (parsed !== void 0)
                fnLiteral += `c.params['${key2}'] ??= ${parsed}
`;
            }
          fnLiteral += `if(validator.params.Check(c.params) === false) {
				${composeValidation("params")}
			}`;
          if (hasTransform2(validator.params.schema))
            fnLiteral += `
c.params = validator.params.Decode(c.params)
`;
        }
        if (validator.query) {
          if (normalize4 && "Clean" in validator.query && !hasAdditionalProperties2(validator.query))
            fnLiteral += "c.query = validator.query.Clean(c.query);\n";
          if (hasProperty2("default", validator.query.schema))
            for (const [key2, value] of Object.entries(
              import_value42.Value.Default(
                // @ts-ignore
                validator.query.schema,
                {}
              )
            )) {
              const parsed = typeof value === "object" ? JSON.stringify(value) : typeof value === "string" ? `'${value}'` : value;
              if (parsed !== void 0)
                fnLiteral += `if(c.query['${key2}'] === undefined) c.query['${key2}'] = ${parsed}
`;
            }
          if (isOptional2(validator.query))
            fnLiteral += `if(isNotEmpty(c.query)) {`;
          fnLiteral += `if(validator.query.Check(c.query) === false) {
          		${composeValidation("query")}
			}`;
          if (hasTransform2(validator.query.schema))
            fnLiteral += `
c.query = validator.query.Decode(Object.assign({}, c.query))
`;
          if (isOptional2(validator.query))
            fnLiteral += `}`;
        }
        if (validator.body) {
          if (normalize4 && "Clean" in validator.body && !hasAdditionalProperties2(validator.body))
            fnLiteral += "c.body = validator.body.Clean(c.body);\n";
          const doesHaveTransform = hasTransform2(validator.body.schema);
          if (doesHaveTransform || isOptional2(validator.body))
            fnLiteral += `
const isNotEmptyObject = c.body && (typeof c.body === "object" && isNotEmpty(c.body))
`;
          if (hasProperty2("default", validator.body.schema)) {
            const value = import_value42.Value.Default(
              // @ts-expect-error private property
              validator.body.schema,
              // @ts-expect-error private property
              validator.body.schema.type === "object" ? {} : void 0
            );
            const parsed = typeof value === "object" ? JSON.stringify(value) : typeof value === "string" ? `'${value}'` : value;
            fnLiteral += `if(validator.body.Check(c.body) === false) {
					if (typeof c.body === 'object') {
						c.body = Object.assign(${parsed}, c.body)
					} else { c.body = ${parsed} }`;
            if (isOptional2(validator.body))
              fnLiteral += `
					    if(isNotEmptyObject && validator.body.Check(c.body) === false) {
            				${composeValidation("body")}
             			}
                    }`;
            else
              fnLiteral += `
    				if(validator.body.Check(c.body) === false) {
        				${composeValidation("body")}
         			}
                }`;
          } else {
            if (isOptional2(validator.body))
              fnLiteral += `if(isNotEmptyObject && validator.body.Check(c.body) === false) {
         			${composeValidation("body")}
          		}`;
            else
              fnLiteral += `if(validator.body.Check(c.body) === false) {
         			${composeValidation("body")}
          		}`;
          }
          if (doesHaveTransform)
            fnLiteral += `
if(isNotEmptyObject) c.body = validator.body.Decode(c.body)
`;
        }
        if (isNotEmpty2(
          // @ts-ignore
          cookieValidator?.schema?.properties ?? // @ts-ignore
          cookieValidator?.schema?.schema ?? {}
        )) {
          fnLiteral += `const cookieValue = {}
    			for(const [key, value] of Object.entries(c.cookie))
    				cookieValue[key] = value.value
`;
          if (hasProperty2("default", cookieValidator.schema))
            for (const [key2, value] of Object.entries(
              import_value42.Value.Default(
                // @ts-ignore
                cookieValidator.schema,
                {}
              )
            )) {
              fnLiteral += `cookieValue['${key2}'] = ${typeof value === "object" ? JSON.stringify(value) : value}
`;
            }
          if (isOptional2(validator.cookie))
            fnLiteral += `if(isNotEmpty(c.cookie)) {`;
          fnLiteral += `if(validator.cookie.Check(cookieValue) === false) {
				${composeValidation("cookie", "cookieValue")}
			}`;
          if (hasTransform2(validator.cookie.schema))
            fnLiteral += `
for(const [key, value] of Object.entries(validator.cookie.Decode(cookieValue)))
					c.cookie[key].value = value
`;
          if (isOptional2(validator.cookie))
            fnLiteral += `}`;
        }
      }
      if (hooks?.beforeHandle) {
        const reporter = report("beforeHandle", {
          total: hooks.beforeHandle.length
        });
        let hasResolve = false;
        for (let i2 = 0; i2 < hooks.beforeHandle.length; i2++) {
          const beforeHandle = hooks.beforeHandle[i2];
          const endUnit = reporter.resolveChild(beforeHandle.fn.name);
          const returning = hasReturn2(beforeHandle);
          const isResolver = beforeHandle.subType === "resolve" || beforeHandle.subType === "mapResolve";
          if (isResolver) {
            if (!hasResolve) {
              hasResolve = true;
              fnLiteral += "\nlet resolved\n";
            }
            fnLiteral += isAsync2(beforeHandle) ? `resolved = await beforeHandle[${i2}](c);
` : `resolved = beforeHandle[${i2}](c);
`;
            if (beforeHandle.subType === "mapResolve")
              fnLiteral += `if(resolved[ELYSIA_RESPONSE])
						throw resolved
					else {
						resolved.request = c.request
						resolved.store = c.store
						resolved.qi = c.qi
						resolved.path = c.path
						resolved.url = c.url
						resolved.redirect = c.redirect
						resolved.set = c.set
						resolved.error = c.error

						c = resolved
					}`;
            else
              fnLiteral += `if(resolved[ELYSIA_RESPONSE])
						throw resolved
					else
						Object.assign(c, resolved)
`;
          } else if (!returning) {
            fnLiteral += isAsync2(beforeHandle) ? `await beforeHandle[${i2}](c);
` : `beforeHandle[${i2}](c);
`;
            endUnit();
          } else {
            fnLiteral += isAsync2(beforeHandle) ? `be = await beforeHandle[${i2}](c);
` : `be = beforeHandle[${i2}](c);
`;
            endUnit("be");
            fnLiteral += `if(be !== undefined) {
`;
            reporter.resolve();
            if (hooks.afterHandle?.length) {
              report("handle", {
                name: isHandleFn ? handler.name : void 0
              }).resolve();
              const reporter2 = report("afterHandle", {
                total: hooks.afterHandle.length
              });
              for (let i22 = 0; i22 < hooks.afterHandle.length; i22++) {
                const hook = hooks.afterHandle[i22];
                const returning2 = hasReturn2(hook);
                const endUnit2 = reporter2.resolveChild(hook.fn.name);
                fnLiteral += `c.response = be
`;
                if (!returning2) {
                  fnLiteral += isAsync2(hook.fn) ? `await afterHandle[${i22}](c, be)
` : `afterHandle[${i22}](c, be)
`;
                } else {
                  fnLiteral += isAsync2(hook.fn) ? `af = await afterHandle[${i22}](c)
` : `af = afterHandle[${i22}](c)
`;
                  fnLiteral += `if(af !== undefined) { c.response = be = af }
`;
                }
                endUnit2("af");
              }
              reporter2.resolve();
            }
            if (validator.response)
              fnLiteral += composeResponseValidation("be");
            const mapResponseReporter = report("mapResponse", {
              total: hooks.mapResponse.length
            });
            if (hooks.mapResponse.length) {
              fnLiteral += `
c.response = be
`;
              for (let i22 = 0; i22 < hooks.mapResponse.length; i22++) {
                const mapResponse22 = hooks.mapResponse[i22];
                const endUnit2 = mapResponseReporter.resolveChild(
                  mapResponse22.fn.name
                );
                fnLiteral += `
if(mr === undefined) {
							mr = ${isAsyncName2(mapResponse22) ? "await" : ""} onMapResponse[${i22}](c)
							if(mr !== undefined) be = c.response = mr
						}
`;
                endUnit2();
              }
            }
            mapResponseReporter.resolve();
            fnLiteral += encodeCookie;
            fnLiteral += `return mapEarlyResponse(${saveResponse} be, c.set ${requestMapper})}
`;
          }
        }
        reporter.resolve();
      }
      if (hooks?.afterHandle.length) {
        const handleReporter = report("handle", {
          name: isHandleFn ? handler.name : void 0
        });
        if (hooks.afterHandle.length)
          fnLiteral += isAsyncHandler ? `let r = c.response = await ${handle3};
` : `let r = c.response = ${handle3};
`;
        else
          fnLiteral += isAsyncHandler ? `let r = await ${handle3};
` : `let r = ${handle3};
`;
        handleReporter.resolve();
        const reporter = report("afterHandle", {
          total: hooks.afterHandle.length
        });
        for (let i2 = 0; i2 < hooks.afterHandle.length; i2++) {
          const hook = hooks.afterHandle[i2];
          const returning = hasReturn2(hook);
          const endUnit = reporter.resolveChild(hook.fn.name);
          if (!returning) {
            fnLiteral += isAsync2(hook.fn) ? `await afterHandle[${i2}](c)
` : `afterHandle[${i2}](c)
`;
            endUnit();
          } else {
            fnLiteral += isAsync2(hook.fn) ? `af = await afterHandle[${i2}](c)
` : `af = afterHandle[${i2}](c)
`;
            endUnit("af");
            if (validator.response) {
              fnLiteral += `if(af !== undefined) {`;
              reporter.resolve();
              fnLiteral += composeResponseValidation("af");
              fnLiteral += `c.response = af }`;
            } else {
              fnLiteral += `if(af !== undefined) {`;
              reporter.resolve();
              fnLiteral += `c.response = af}
`;
            }
          }
        }
        reporter.resolve();
        fnLiteral += `r = c.response
`;
        if (validator.response)
          fnLiteral += composeResponseValidation();
        fnLiteral += encodeCookie;
        const mapResponseReporter = report("mapResponse", {
          total: hooks.mapResponse.length
        });
        if (hooks.mapResponse.length) {
          for (let i2 = 0; i2 < hooks.mapResponse.length; i2++) {
            const mapResponse22 = hooks.mapResponse[i2];
            const endUnit = mapResponseReporter.resolveChild(
              mapResponse22.fn.name
            );
            fnLiteral += `
mr = ${isAsyncName2(mapResponse22) ? "await" : ""} onMapResponse[${i2}](c)
				if(mr !== undefined) r = c.response = mr
`;
            endUnit();
          }
        }
        mapResponseReporter.resolve();
        if (hasSet)
          fnLiteral += `return mapResponse(${saveResponse} r, c.set ${requestMapper})
`;
        else
          fnLiteral += `return mapCompactResponse(${saveResponse} r ${requestMapper})
`;
      } else {
        const handleReporter = report("handle", {
          name: isHandleFn ? handler.name : void 0
        });
        if (validator.response || hooks.mapResponse.length) {
          fnLiteral += isAsyncHandler ? `let r = await ${handle3};
` : `let r = ${handle3};
`;
          handleReporter.resolve();
          if (validator.response)
            fnLiteral += composeResponseValidation();
          report("afterHandle").resolve();
          const mapResponseReporter = report("mapResponse", {
            total: hooks.mapResponse.length
          });
          if (hooks.mapResponse.length) {
            fnLiteral += "\nc.response = r\n";
            for (let i2 = 0; i2 < hooks.mapResponse.length; i2++) {
              const mapResponse22 = hooks.mapResponse[i2];
              const endUnit = mapResponseReporter.resolveChild(
                mapResponse22.fn.name
              );
              fnLiteral += `
if(mr === undefined) {
						mr = ${isAsyncName2(mapResponse22) ? "await" : ""} onMapResponse[${i2}](c)
    					if(mr !== undefined) r = c.response = mr
					}
`;
              endUnit();
            }
          }
          mapResponseReporter.resolve();
          fnLiteral += encodeCookie;
          if (handler instanceof Response) {
            fnLiteral += inference.set ? `if(
					isNotEmpty(c.set.headers) ||
					c.set.status !== 200 ||
					c.set.redirect ||
					c.set.cookie
				)
					return mapResponse(${saveResponse} ${handle3}.clone(), c.set ${requestMapper})
				else
					return ${handle3}.clone()` : `return ${handle3}.clone()`;
            fnLiteral += "\n";
          } else if (hasSet)
            fnLiteral += `return mapResponse(${saveResponse} r, c.set ${requestMapper})
`;
          else
            fnLiteral += `return mapCompactResponse(${saveResponse} r ${requestMapper})
`;
        } else if (hasCookie || hasTrace) {
          fnLiteral += isAsyncHandler ? `let r = await ${handle3};
` : `let r = ${handle3};
`;
          handleReporter.resolve();
          report("afterHandle").resolve();
          const mapResponseReporter = report("mapResponse", {
            total: hooks.mapResponse.length
          });
          if (hooks.mapResponse.length) {
            fnLiteral += "\nc.response = r\n";
            for (let i2 = 0; i2 < hooks.mapResponse.length; i2++) {
              const mapResponse22 = hooks.mapResponse[i2];
              const endUnit = mapResponseReporter.resolveChild(
                mapResponse22.fn.name
              );
              fnLiteral += `
if(mr === undefined) {
							mr = ${isAsyncName2(mapResponse22) ? "await" : ""} onMapResponse[${i2}](c)
    						if(mr !== undefined) r = c.response = mr
						}
`;
              endUnit();
            }
          }
          mapResponseReporter.resolve();
          fnLiteral += encodeCookie;
          if (hasSet)
            fnLiteral += `return mapResponse(${saveResponse} r, c.set ${requestMapper})
`;
          else
            fnLiteral += `return mapCompactResponse(${saveResponse} r ${requestMapper})
`;
        } else {
          handleReporter.resolve();
          const handled = isAsyncHandler ? `await ${handle3}` : handle3;
          report("afterHandle").resolve();
          if (handler instanceof Response) {
            fnLiteral += inference.set ? `if(
					isNotEmpty(c.set.headers) ||
					c.set.status !== 200 ||
					c.set.redirect ||
					c.set.cookie
				)
					return mapResponse(${saveResponse} ${handle3}.clone(), c.set ${requestMapper})
				else
					return ${handle3}.clone()` : `return ${handle3}.clone()`;
            fnLiteral += "\n";
          } else if (hasSet)
            fnLiteral += `return mapResponse(${saveResponse} ${handled}, c.set ${requestMapper})
`;
          else
            fnLiteral += `return mapCompactResponse(${saveResponse} ${handled} ${requestMapper})
`;
        }
      }
      fnLiteral += `
} catch(error) {`;
      if (hasBody)
        fnLiteral += `
if(isParsing) error = new ParseError()
`;
      if (!maybeAsync)
        fnLiteral += `
return (async () => {
`;
      fnLiteral += `
const set = c.set
if (!set.status || set.status < 300) set.status = error?.status || 500
`;
      if (hasTrace)
        for (let i2 = 0; i2 < hooks.trace.length; i2++)
          fnLiteral += `report${i2}?.resolve(error);reportChild${i2}?.(error);
`;
      const errorReporter = report("error", {
        total: hooks.error.length
      });
      if (hooks.error.length) {
        fnLiteral += `
				c.error = error
				c.code = error.code ?? error[ERROR_CODE] ?? "UNKNOWN"
				let er
			`;
        for (let i2 = 0; i2 < hooks.error.length; i2++) {
          const endUnit = errorReporter.resolveChild(hooks.error[i2].fn.name);
          if (isAsync2(hooks.error[i2]))
            fnLiteral += `
er = await handleErrors[${i2}](c)
`;
          else
            fnLiteral += `
er = handleErrors[${i2}](c)
if (er instanceof Promise) er = await er
`;
          endUnit();
          const mapResponseReporter = report("mapResponse", {
            total: hooks.mapResponse.length
          });
          if (hooks.mapResponse.length) {
            for (let i22 = 0; i22 < hooks.mapResponse.length; i22++) {
              const mapResponse22 = hooks.mapResponse[i22];
              const endUnit2 = mapResponseReporter.resolveChild(
                mapResponse22.fn.name
              );
              fnLiteral += `
c.response = er

							er = ${isAsyncName2(mapResponse22) ? "await" : ""} onMapResponse[${i22}](c)
							if(er instanceof Promise) er = await er
`;
              endUnit2();
            }
          }
          mapResponseReporter.resolve();
          fnLiteral += `er = mapEarlyResponse(er, set ${requestMapper})
`;
          fnLiteral += `if (er) {`;
          if (hasTrace) {
            for (let i22 = 0; i22 < hooks.trace.length; i22++)
              fnLiteral += `
report${i22}.resolve()
`;
            errorReporter.resolve();
          }
          fnLiteral += `return er
}
`;
        }
      }
      errorReporter.resolve();
      fnLiteral += `return handleError(c, error, true)
`;
      if (!maybeAsync)
        fnLiteral += "})()";
      fnLiteral += "}";
      if (hasAfterResponse || hasTrace) {
        fnLiteral += ` finally { `;
        if (!maybeAsync)
          fnLiteral += ";(async () => {";
        const reporter = report("afterResponse", {
          total: hooks.afterResponse.length
        });
        if (hasAfterResponse) {
          for (let i2 = 0; i2 < hooks.afterResponse.length; i2++) {
            const endUnit = reporter.resolveChild(
              hooks.afterResponse[i2].fn.name
            );
            fnLiteral += `
await afterResponse[${i2}](c);
`;
            endUnit();
          }
        }
        reporter.resolve();
        if (!maybeAsync)
          fnLiteral += "})();";
        fnLiteral += `}`;
      }
      fnLiteral = `const {
		handler,
		handleError,
		hooks: {
			transform,
			resolve,
			beforeHandle,
			afterHandle,
			mapResponse: onMapResponse,
			parse,
			error: handleErrors,
			afterResponse,
			trace: _trace
		},
		validator,
		utils: {
			mapResponse,
			mapCompactResponse,
			mapEarlyResponse,
			parseQuery,
			isNotEmpty
		},
		error: {
			NotFoundError,
			ValidationError,
			InternalServerError,
			ParseError
		},
		schema,
		definitions,
		ERROR_CODE,
		parseCookie,
		signCookie,
		decodeURIComponent,
		ELYSIA_RESPONSE,
		ELYSIA_TRACE,
		ELYSIA_REQUEST_ID,
		getServer
	} = hooks

	const trace = _trace.map(x => typeof x === 'function' ? x : x.fn)

	return ${maybeAsync ? "async" : ""} function handle(c) {
		${hooks.beforeHandle.length ? "let be" : ""}
		${hooks.afterHandle.length ? "let af" : ""}
		${hooks.mapResponse.length ? "let mr" : ""}

		${allowMeta ? "c.schema = schema; c.defs = definitions" : ""}
		${fnLiteral}
	}`;
      try {
        return Function(
          "hooks",
          fnLiteral
        )({
          handler,
          hooks: lifeCycleToFn2(hooks),
          validator,
          // @ts-expect-error
          handleError: app2.handleError,
          utils: {
            mapResponse: mapResponse2,
            mapCompactResponse: mapCompactResponse2,
            mapEarlyResponse: mapEarlyResponse2,
            parseQuery: parseQuery2,
            isNotEmpty: isNotEmpty2
          },
          error: {
            NotFoundError: NotFoundError2,
            ValidationError: ValidationError2,
            InternalServerError: InternalServerError2,
            ParseError: ParseError2
          },
          schema: app2.router.history,
          // @ts-expect-error
          definitions: app2.definitions.type,
          ERROR_CODE: ERROR_CODE2,
          parseCookie: parseCookie2,
          signCookie: signCookie2,
          decodeURIComponent: import_fast_decode_uri_component32.default,
          ELYSIA_RESPONSE: ELYSIA_RESPONSE2,
          ELYSIA_TRACE: ELYSIA_TRACE2,
          ELYSIA_REQUEST_ID: ELYSIA_REQUEST_ID2,
          // @ts-expect-error private property
          getServer: () => app2.getServer()
        });
      } catch {
        const debugHooks = lifeCycleToFn2(hooks);
        console.log("[Composer] failed to generate optimized handler");
        console.log(
          "Please report the following to SaltyAom privately as it may include sensitive information about your codebase:"
        );
        console.log("---");
        console.log({
          handler: typeof handler === "function" ? handler.toString() : handler,
          hooks: {
            ...debugHooks,
            // @ts-expect-error
            transform: debugHooks?.transform?.map?.((x2) => x2.toString()),
            // @ts-expect-error
            resolve: debugHooks?.resolve?.map?.((x2) => x2.toString()),
            // @ts-expect-error
            beforeHandle: debugHooks?.beforeHandle?.map?.(
              (x2) => x2.toString()
            ),
            // @ts-expect-error
            afterHandle: debugHooks?.afterHandle?.map?.(
              (x2) => x2.toString()
            ),
            // @ts-expect-error
            mapResponse: debugHooks?.mapResponse?.map?.(
              (x2) => x2.toString()
            ),
            // @ts-expect-error
            parse: debugHooks?.parse?.map?.((x2) => x2.toString()),
            // @ts-expect-error
            error: debugHooks?.error?.map?.((x2) => x2.toString()),
            // @ts-expect-error
            afterResponse: debugHooks?.afterResponse?.map?.(
              (x2) => x2.toString()
            ),
            // @ts-expect-error
            stop: debugHooks?.stop?.map?.((x2) => x2.toString())
          },
          validator,
          // @ts-expect-error
          definitions: app2.definitions.type
        });
        console.log("---");
        process.exit(1);
      }
    };
    var composeGeneralHandler2 = (app2) => {
      let decoratorsLiteral = "";
      let fnLiteral = "";
      const defaultHeaders = app2.setHeaders;
      for (const key2 of Object.keys(app2.singleton.decorator))
        decoratorsLiteral += `,${key2}: app.singleton.decorator.${key2}`;
      const router = app2.router;
      const hasTrace = app2.event.trace.length > 0;
      let findDynamicRoute = `
	const route = router.find(request.method, path) ${router.http.root.ALL ? '?? router.find("ALL", path)' : ""}

	if (route === null)
		return ${app2.event.error.length ? `app.handleError(ctx, notFound)` : app2.event.request.length ? `new Response(error404Message, {
					status: ctx.set.status === 200 ? 404 : ctx.set.status,
					headers: ctx.set.headers
				})` : `error404.clone()`}

	ctx.params = route.params
`;
      findDynamicRoute += `if(route.store.handler) return route.store.handler(ctx)
	return (route.store.handler = route.store.compile())(ctx)
`;
      let switchMap = ``;
      for (const [path2, { code: code4, all: all4 }] of Object.entries(router.static.http.map))
        switchMap += `case '${path2}':
switch(request.method) {
${code4}
${all4 ?? `default: break map`}}

`;
      const maybeAsync = app2.event.request.some(isAsync2);
      fnLiteral += `const {
		app,
		mapEarlyResponse,
		NotFoundError,
		randomId,
		handleError,
		error,
		redirect,
		ELYSIA_TRACE,
		ELYSIA_REQUEST_ID,
		getServer
	} = data

	const store = app.singleton.store
	const staticRouter = app.router.static.http
	const st = staticRouter.handlers
	const wsRouter = app.router.ws
	const router = app.router.http
	const trace = app.event.trace.map(x => typeof x === 'function' ? x : x.fn)

	const notFound = new NotFoundError()
	const hoc = app.extender.higherOrderFunctions.map(x => x.fn)

	${app2.event.request.length ? `const onRequest = app.event.request.map(x => x.fn)` : ""}
	${app2.event.error.length ? "" : `
const error404Message = notFound.message.toString()
	const error404 = new Response(error404Message, { status: 404 });
`}

	${app2.event.trace.length ? `const ${app2.event.trace.map((_, i2) => `tr${i2} = app.event.trace[${i2}].fn`).join(",")}` : ""}

	${maybeAsync ? "async" : ""} function map(request) {
`;
      if (app2.event.request.length)
        fnLiteral += `let re`;
      fnLiteral += `
const url = request.url
		const s = url.indexOf('/', 11)
		const qi = url.indexOf('?', s + 1)
		let path
		if(qi === -1)
			path = url.substring(s)
		else
			path = url.substring(s, qi)
`;
      fnLiteral += `${hasTrace ? "const id = randomId()" : ""}
		const ctx = {
			request,
			store,
			qi,
			path,
			url,
			redirect,
			set: {
				headers: ${Object.keys(defaultHeaders ?? {}).length ? "Object.assign({}, app.setHeaders)" : "{}"},
				status: 200
			},
			error
			${// @ts-expect-error private property
      app2.inference.server ? `, get server() {
							return getServer()
						}` : ""}
			${hasTrace ? ",[ELYSIA_REQUEST_ID]: id" : ""}
			${decoratorsLiteral}
		}
`;
      if (app2.event.trace.length)
        fnLiteral += `
ctx[ELYSIA_TRACE] = [${app2.event.trace.map((_, i2) => `tr${i2}(ctx)`).join(",")}]
`;
      const report = createReport2({
        context: "ctx",
        trace: app2.event.trace,
        addFn: (word) => {
          fnLiteral += word;
        }
      });
      const reporter = report("request", {
        attribute: "ctx",
        total: app2.event.request.length
      });
      if (app2.event.request.length) {
        fnLiteral += `
 try {
`;
        for (let i2 = 0; i2 < app2.event.request.length; i2++) {
          const hook = app2.event.request[i2];
          const withReturn = hasReturn2(hook);
          const maybeAsync2 = isAsync2(hook);
          const endUnit = reporter.resolveChild(app2.event.request[i2].fn.name);
          if (withReturn) {
            fnLiteral += `re = mapEarlyResponse(
					${maybeAsync2 ? "await" : ""} onRequest[${i2}](ctx),
					ctx.set,
					request
				)
`;
            endUnit("re");
            fnLiteral += `if(re !== undefined) return re
`;
          } else {
            fnLiteral += `${maybeAsync2 ? "await" : ""} onRequest[${i2}](ctx)
`;
            endUnit();
          }
        }
        fnLiteral += `} catch (error) {
			return app.handleError(ctx, error)
		}`;
      }
      reporter.resolve();
      const wsPaths = app2.router.static.ws;
      const wsRouter = app2.router.ws;
      if (Object.keys(wsPaths).length || wsRouter.history.length) {
        fnLiteral += `
			if(request.method === 'GET') {
				switch(path) {`;
        for (const [path2, index3] of Object.entries(wsPaths)) {
          fnLiteral += `
					case '${path2}':
						if(request.headers.get('upgrade') === 'websocket')
							return st[${index3}](ctx)

						break`;
        }
        fnLiteral += `
				default:
					if(request.headers.get('upgrade') === 'websocket') {
						const route = wsRouter.find('ws', path)

						if(route) {
							ctx.params = route.params

							if(route.store.handler)
							    return route.store.handler(ctx)

							return (route.store.handler = route.store.compile())(ctx)
						}
					}

					break
			}
		}
`;
      }
      fnLiteral += `
		map: switch(path) {
			${switchMap}

			default:
				break
		}

		${findDynamicRoute}
	}
`;
      if (app2.extender.higherOrderFunctions.length) {
        let handler = "map";
        for (let i2 = 0; i2 < app2.extender.higherOrderFunctions.length; i2++)
          handler = `hoc[${i2}](${handler}, request)`;
        fnLiteral += `return function hocMap(request) { return ${handler}(request) }`;
      } else
        fnLiteral += `return map`;
      const handleError = composeErrorHandler2(app2);
      app2.handleError = handleError;
      return Function(
        "data",
        fnLiteral
      )({
        app: app2,
        mapEarlyResponse: mapEarlyResponse2,
        NotFoundError: NotFoundError2,
        randomId: randomId2,
        handleError,
        error: error3,
        redirect: redirect2,
        ELYSIA_TRACE: ELYSIA_TRACE2,
        ELYSIA_REQUEST_ID: ELYSIA_REQUEST_ID2,
        // @ts-expect-error private property
        getServer: () => app2.getServer()
      });
    };
    var composeErrorHandler2 = (app2) => {
      const hooks = app2.event;
      let fnLiteral = "";
      fnLiteral += `const {
		app: { event: { error: onErrorContainer, afterResponse: resContainer, mapResponse: _onMapResponse, trace: _trace } },
		mapResponse,
		ERROR_CODE,
		ELYSIA_RESPONSE,
		ELYSIA_TRACE,
		ELYSIA_REQUEST_ID
	} = inject

	const trace = _trace.map(x => typeof x === 'function' ? x : x.fn)
	const onMapResponse = []

	for(let i = 0; i < _onMapResponse.length; i++)
		onMapResponse.push(_onMapResponse[i].fn ?? _onMapResponse[i])

	delete _onMapResponse

	const onError = onErrorContainer.map(x => x.fn)
	const res = resContainer.map(x => x.fn)

	return ${app2.event.error.find(isAsync2) || app2.event.mapResponse.find(isAsync2) ? "async" : ""} function(context, error, skipGlobal) {`;
      const hasTrace = app2.event.trace.length > 0;
      if (hasTrace)
        fnLiteral += "\nconst id = context[ELYSIA_REQUEST_ID]\n";
      const report = createReport2({
        context: "context",
        trace: hooks.trace,
        addFn: (word) => {
          fnLiteral += word;
        }
      });
      fnLiteral += `
		const set = context.set
		let r

		context.code = error.code
		context.error = error

		if(typeof error === "object" && error && ELYSIA_RESPONSE in error) {
			error.status = error[ELYSIA_RESPONSE]
			error.message = error.response
		}
`;
      const saveResponse = hasTrace || hooks.afterResponse.length > 0 || hooks.afterResponse.length > 0 ? "context.response = " : "";
      for (let i2 = 0; i2 < app2.event.error.length; i2++) {
        const handler = app2.event.error[i2];
        const response = `${isAsync2(handler) ? "await " : ""}onError[${i2}](context)`;
        fnLiteral += "\nif(skipGlobal !== true) {\n";
        if (hasReturn2(handler)) {
          fnLiteral += `r = ${response}; if(r !== undefined) {
				if(r instanceof Response) return r

				if(r[ELYSIA_RESPONSE]) {
					error.status = error[ELYSIA_RESPONSE]
					error.message = error.response
				}

				if(set.status === 200) set.status = error.status
`;
          const mapResponseReporter2 = report("mapResponse", {
            total: hooks.mapResponse.length,
            name: "context"
          });
          if (hooks.mapResponse.length) {
            for (let i22 = 0; i22 < hooks.mapResponse.length; i22++) {
              const mapResponse22 = hooks.mapResponse[i22];
              const endUnit = mapResponseReporter2.resolveChild(
                mapResponse22.fn.name
              );
              fnLiteral += `
context.response = r
						r = ${isAsyncName2(mapResponse22) ? "await" : ""} onMapResponse[${i22}](context)
`;
              endUnit();
            }
          }
          mapResponseReporter2.resolve();
          fnLiteral += `return mapResponse(${saveResponse} r, set, context.request)}
`;
        } else
          fnLiteral += response + "\n";
        fnLiteral += "\n}\n";
      }
      fnLiteral += `if(error.constructor.name === "ValidationError" || error.constructor.name === "TransformDecodeError") {
		set.status = error.status ?? 422
		return new Response(
			error.message,
			{
				headers: Object.assign(
					{ 'content-type': 'application/json'},
					set.headers
				),
				status: set.status
			}
		)
	} else {
		if(error.code && typeof error.status === "number")
			return new Response(
				error.message,
				{ headers: set.headers, status: error.status }
			)
`;
      const mapResponseReporter = report("mapResponse", {
        total: hooks.mapResponse.length,
        name: "context"
      });
      if (hooks.mapResponse.length) {
        for (let i2 = 0; i2 < hooks.mapResponse.length; i2++) {
          const mapResponse22 = hooks.mapResponse[i2];
          const endUnit = mapResponseReporter.resolveChild(
            mapResponse22.fn.name
          );
          fnLiteral += `
context.response = error
			error = ${isAsyncName2(mapResponse22) ? "await" : ""} onMapResponse[${i2}](context)
`;
          endUnit();
        }
      }
      mapResponseReporter.resolve();
      fnLiteral += `
return mapResponse(${saveResponse} error, set, context.request)
}
}`;
      return Function(
        "inject",
        fnLiteral
      )({
        app: app2,
        mapResponse: mapResponse2,
        ERROR_CODE: ERROR_CODE2,
        ELYSIA_RESPONSE: ELYSIA_RESPONSE2,
        ELYSIA_TRACE: ELYSIA_TRACE2,
        ELYSIA_REQUEST_ID: ELYSIA_REQUEST_ID2
      });
    };
    var createDynamicHandler2 = (app2) => async (request) => {
      const url = request.url, s2 = url.indexOf("/", 11), qi = url.indexOf("?", s2 + 1), path2 = qi === -1 ? url.substring(s2) : url.substring(s2, qi);
      const set = {
        cookie: {},
        status: 200,
        headers: {}
      };
      const context = Object.assign(
        {},
        // @ts-expect-error
        app2.singleton.decorator,
        {
          set,
          // @ts-expect-error
          store: app2.singleton.store,
          request,
          path: path2,
          qi,
          redirect: redirect2
        }
      );
      try {
        for (let i2 = 0; i2 < app2.event.request.length; i2++) {
          const onRequest = app2.event.request[i2].fn;
          let response2 = onRequest(context);
          if (response2 instanceof Promise)
            response2 = await response2;
          response2 = mapEarlyResponse2(response2, set);
          if (response2)
            return context.response = response2;
        }
        const handler = app2.router.dynamic.find(request.method, path2) ?? app2.router.dynamic.find("ALL", path2);
        if (!handler)
          throw new NotFoundError2();
        const { handle: handle3, hooks, validator, content: content3 } = handler.store;
        let body3;
        if (request.method !== "GET" && request.method !== "HEAD") {
          if (content3) {
            switch (content3) {
              case "application/json":
                body3 = await request.json();
                break;
              case "text/plain":
                body3 = await request.text();
                break;
              case "application/x-www-form-urlencoded":
                body3 = parseQuery2(await request.text());
                break;
              case "application/octet-stream":
                body3 = await request.arrayBuffer();
                break;
              case "multipart/form-data":
                body3 = {};
                const form22 = await request.formData();
                for (const key2 of form22.keys()) {
                  if (body3[key2])
                    continue;
                  const value = form22.getAll(key2);
                  if (value.length === 1)
                    body3[key2] = value[0];
                  else
                    body3[key2] = value;
                }
                break;
            }
          } else {
            let contentType = request.headers.get("content-type");
            if (contentType) {
              const index3 = contentType.indexOf(";");
              if (index3 !== -1)
                contentType = contentType.slice(0, index3);
              context.contentType = contentType;
              for (let i2 = 0; i2 < hooks.parse.length; i2++) {
                const hook = hooks.parse[i2].fn;
                let temp = hook(context, contentType);
                if (temp instanceof Promise)
                  temp = await temp;
                if (temp) {
                  body3 = temp;
                  break;
                }
              }
              delete context.contentType;
              if (body3 === void 0) {
                switch (contentType) {
                  case "application/json":
                    body3 = await request.json();
                    break;
                  case "text/plain":
                    body3 = await request.text();
                    break;
                  case "application/x-www-form-urlencoded":
                    body3 = parseQuery2(await request.text());
                    break;
                  case "application/octet-stream":
                    body3 = await request.arrayBuffer();
                    break;
                  case "multipart/form-data":
                    body3 = {};
                    const form22 = await request.formData();
                    for (const key2 of form22.keys()) {
                      if (body3[key2])
                        continue;
                      const value = form22.getAll(key2);
                      if (value.length === 1)
                        body3[key2] = value[0];
                      else
                        body3[key2] = value;
                    }
                    break;
                }
              }
            }
          }
        }
        context.body = body3;
        context.params = handler?.params || void 0;
        context.query = qi === -1 ? {} : parseQuery2(url.substring(qi + 1));
        context.headers = {};
        for (const [key2, value] of request.headers.entries())
          context.headers[key2] = value;
        const cookieMeta = Object.assign(
          {},
          app2.config?.cookie,
          // @ts-expect-error
          validator?.cookie?.config
        );
        const cookieHeaderValue = request.headers.get("cookie");
        context.cookie = await parseCookie2(
          context.set,
          cookieHeaderValue,
          cookieMeta ? {
            secrets: cookieMeta.secrets !== void 0 ? typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets.join(",") : void 0,
            sign: cookieMeta.sign === true ? true : cookieMeta.sign !== void 0 ? typeof cookieMeta.sign === "string" ? cookieMeta.sign : cookieMeta.sign.join(",") : void 0
          } : void 0
        );
        for (let i2 = 0; i2 < hooks.transform.length; i2++) {
          const hook = hooks.transform[i2];
          const operation = hook.fn(context);
          if (hook.subType === "derive") {
            if (operation instanceof Promise)
              Object.assign(context, await operation);
            else
              Object.assign(context, operation);
          } else if (operation instanceof Promise)
            await operation;
        }
        if (validator) {
          if (validator.createHeaders?.()) {
            const _header = {};
            for (const key2 in request.headers)
              _header[key2] = request.headers.get(key2);
            if (validator.headers.Check(_header) === false)
              throw new ValidationError2(
                "header",
                validator.headers,
                _header
              );
          }
          if (validator.createParams?.()?.Check(context.params) === false)
            throw new ValidationError2(
              "params",
              validator.params,
              context.params
            );
          if (validator.createQuery?.()?.Check(context.query) === false)
            throw new ValidationError2(
              "query",
              validator.query,
              context.query
            );
          if (validator.createCookie?.()) {
            const cookieValue = {};
            for (const [key2, value] of Object.entries(context.cookie))
              cookieValue[key2] = value.value;
            if (validator.cookie.Check(cookieValue) === false)
              throw new ValidationError2(
                "cookie",
                validator.cookie,
                cookieValue
              );
          }
          if (validator.createBody?.()?.Check(body3) === false)
            throw new ValidationError2("body", validator.body, body3);
        }
        for (let i2 = 0; i2 < hooks.beforeHandle.length; i2++) {
          let response2 = hooks.beforeHandle[i2].fn(context);
          if (response2 instanceof Promise)
            response2 = await response2;
          if (response2 !== void 0) {
            ;
            context.response = response2;
            for (let i22 = 0; i22 < hooks.afterHandle.length; i22++) {
              let newResponse = hooks.afterHandle[i22].fn(
                context
              );
              if (newResponse instanceof Promise)
                newResponse = await newResponse;
              if (newResponse)
                response2 = newResponse;
            }
            const result = mapEarlyResponse2(response2, context.set);
            if (result)
              return context.response = result;
          }
        }
        let response = handle3(context);
        if (response instanceof Promise)
          response = await response;
        if (!hooks.afterHandle.length) {
          const status = response?.[ELYSIA_RESPONSE2] ?? (set.status ? typeof set.status === "string" ? StatusMap2[set.status] : set.status : 200);
          const responseValidator = validator?.createResponse?.()?.[status];
          if (responseValidator?.Check(response) === false)
            throw new ValidationError2(
              "response",
              responseValidator,
              response
            );
        } else {
          ;
          context.response = response;
          for (let i2 = 0; i2 < hooks.afterHandle.length; i2++) {
            let newResponse = hooks.afterHandle[i2].fn(
              context
            );
            if (newResponse instanceof Promise)
              newResponse = await newResponse;
            const result = mapEarlyResponse2(newResponse, context.set);
            if (result !== void 0) {
              const responseValidator = validator?.response?.[result.status];
              if (responseValidator?.Check(result) === false)
                throw new ValidationError2(
                  "response",
                  responseValidator,
                  result
                );
              return context.response = result;
            }
          }
        }
        if (context.set.cookie && cookieMeta?.sign) {
          const secret = !cookieMeta.secrets ? void 0 : typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets[0];
          if (cookieMeta.sign === true)
            for (const [key2, cookie] of Object.entries(
              context.set.cookie
            ))
              context.set.cookie[key2].value = await signCookie2(
                cookie.value,
                "${secret}"
              );
          else {
            const properties = validator?.cookie?.schema?.properties;
            for (const name of cookieMeta.sign) {
              if (!(name in properties))
                continue;
              if (context.set.cookie[name]?.value) {
                context.set.cookie[name].value = await signCookie2(
                  context.set.cookie[name].value,
                  secret
                );
              }
            }
          }
        }
        return context.response = mapResponse2(response, context.set);
      } catch (error22) {
        if (error22.status)
          set.status = error22.status;
        return app2.handleError(context, error22);
      } finally {
        for (const afterResponse of app2.event.afterResponse)
          await afterResponse.fn(context);
      }
    };
    var createDynamicErrorHandler2 = (app2) => async (context, error22) => {
      const errorContext = Object.assign(context, { error: error22, code: error22.code });
      errorContext.set = context.set;
      for (let i2 = 0; i2 < app2.event.error.length; i2++) {
        const hook = app2.event.error[i2];
        let response = hook.fn(errorContext);
        if (response instanceof Promise)
          response = await response;
        if (response !== void 0 && response !== null)
          return context.response = mapResponse2(response, context.set);
      }
      return new Response(
        typeof error22.cause === "string" ? error22.cause : error22.message,
        {
          headers: context.set.headers,
          status: error22.status ?? 500
        }
      );
    };
    var Elysia2 = class _Elysia2 {
      constructor(config3) {
        this.server = null;
        this.dependencies = {};
        this._routes = {};
        this._types = {
          Prefix: "",
          Scoped: false,
          Singleton: {},
          Definitions: {},
          Metadata: {}
        };
        this._ephemeral = {};
        this._volatile = {};
        this.version = version5;
        this.singleton = {
          decorator: {},
          store: {},
          derive: {},
          resolve: {}
        };
        this.definitions = {
          type: {},
          error: {}
        };
        this.extender = {
          macros: [],
          higherOrderFunctions: []
        };
        this.validator = {
          global: null,
          scoped: null,
          local: null,
          getCandidate() {
            return mergeSchemaValidator2(
              mergeSchemaValidator2(this.global, this.scoped),
              this.local
            );
          }
        };
        this.event = {
          start: [],
          request: [],
          parse: [],
          transform: [],
          beforeHandle: [],
          afterHandle: [],
          mapResponse: [],
          afterResponse: [],
          trace: [],
          error: [],
          stop: []
        };
        this.telemetry = {
          stack: void 0
        };
        this.router = {
          http: new Memoirist2(),
          ws: new Memoirist2(),
          // Use in non-AOT mode
          dynamic: new Memoirist2(),
          static: {
            http: {
              handlers: [],
              map: {},
              all: ""
            },
            // Static WS Router is consists of pathname and websocket handler index to compose
            ws: {}
          },
          history: []
        };
        this.routeTree = /* @__PURE__ */ new Map();
        this.inference = {
          body: false,
          cookie: false,
          headers: false,
          query: false,
          set: false,
          server: false
        };
        this.handle = async (request) => this.fetch(request);
        this.fetch = (request) => {
          return (this.fetch = this.config.aot ? composeGeneralHandler2(this) : createDynamicHandler2(this))(request);
        };
        this.handleError = async (context, error22) => (this.handleError = this.config.aot ? composeErrorHandler2(this) : createDynamicErrorHandler2(this))(context, error22);
        this.outerErrorHandler = (error22) => new Response(error22.message || error22.name || "Error", {
          // @ts-ignore
          status: error22?.status ?? 500
        });
        this.listen = (options, callback) => {
          if (typeof Bun === "undefined")
            throw new Error(
              ".listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch"
            );
          this.compile();
          if (typeof options === "string") {
            if (!isNumericString2(options))
              throw new Error("Port must be a numeric value");
            options = parseInt(options);
          }
          const fetch2 = this.fetch;
          const serve = typeof options === "object" ? {
            development: !isProduction2,
            reusePort: true,
            ...this.config.serve || {},
            ...options || {},
            websocket: {
              ...this.config.websocket || {},
              ...websocket2 || {}
            },
            fetch: fetch2,
            error: this.outerErrorHandler
          } : {
            development: !isProduction2,
            reusePort: true,
            ...this.config.serve || {},
            websocket: {
              ...this.config.websocket || {},
              ...websocket2 || {}
            },
            port: options,
            fetch: fetch2,
            error: this.outerErrorHandler
          };
          this.server = Bun?.serve(serve);
          for (let i2 = 0; i2 < this.event.start.length; i2++)
            this.event.start[i2].fn(this);
          if (callback)
            callback(this.server);
          process.on("beforeExit", () => {
            if (this.server) {
              this.server.stop();
              this.server = null;
              for (let i2 = 0; i2 < this.event.stop.length; i2++)
                this.event.stop[i2].fn(this);
            }
          });
          this.promisedModules.then(() => {
            Bun?.gc(false);
          });
          return this;
        };
        this.stop = async () => {
          if (!this.server)
            throw new Error(
              "Elysia isn't running. Call `app.listen` to start the server."
            );
          if (this.server) {
            this.server.stop();
            this.server = null;
            if (this.event.stop.length)
              for (let i2 = 0; i2 < this.event.stop.length; i2++)
                this.event.stop[i2].fn(this);
          }
        };
        if (config3?.tags) {
          if (!config3.detail)
            config3.detail = {
              tags: config3.tags
            };
          else
            config3.detail.tags = config3.tags;
        }
        this.config = {};
        this.applyConfig(config3 ?? {});
        if (config3?.analytic && (config3?.name || config3?.seed !== void 0))
          this.telemetry.stack = new Error().stack;
      }
      static {
        this.version = version5;
      }
      get store() {
        return this.singleton.store;
      }
      get decorator() {
        return this.singleton.decorator;
      }
      get _scoped() {
        return this.config.scoped;
      }
      get routes() {
        return this.router.history;
      }
      getGlobalRoutes() {
        return this.router.history;
      }
      getServer() {
        return this.server;
      }
      get promisedModules() {
        if (!this._promisedModules)
          this._promisedModules = new PromiseGroup2();
        return this._promisedModules;
      }
      env(model, env22 = Bun?.env ?? process.env) {
        const validator = getSchemaValidator2(model, {
          dynamic: true,
          additionalProperties: true,
          coerce: true
        });
        if (validator.Check(env22) === false) {
          const error22 = new ValidationError2("env", model, env22);
          throw new Error(error22.all.map((x2) => x2.summary).join("\n"));
        }
        return this;
      }
      /**
       * @private DO_NOT_USE_OR_YOU_WILL_BE_FIRE
       *
       * ! Do not use unless you now exactly what you are doing
       * ? Add Higher order function to Elysia.fetch
       */
      wrap(fn) {
        this.extender.higherOrderFunctions.push({
          checksum: checksum2(
            JSON.stringify({
              name: this.config.name,
              seed: this.config.seed,
              content: fn.toString()
            })
          ),
          fn
        });
        return this;
      }
      applyMacro(localHook) {
        if (this.extender.macros.length) {
          const manage = createMacroManager2({
            globalHook: this.event,
            localHook
          });
          const manager = {
            events: {
              global: this.event,
              local: localHook
            },
            onParse: manage("parse"),
            onTransform: manage("transform"),
            onBeforeHandle: manage("beforeHandle"),
            onAfterHandle: manage("afterHandle"),
            mapResponse: manage("mapResponse"),
            onAfterResponse: manage("afterResponse"),
            onError: manage("error")
          };
          for (const macro of this.extender.macros)
            traceBackMacro2(macro.fn(manager), localHook);
        }
      }
      applyConfig(config3) {
        this.config = {
          prefix: "",
          aot: true,
          strictPath: false,
          global: false,
          analytic: false,
          normalize: true,
          ...config3,
          cookie: {
            path: "/",
            ...config3?.cookie
          },
          experimental: config3?.experimental ?? {},
          seed: config3?.seed === void 0 ? "" : config3?.seed
        };
        return this;
      }
      get models() {
        const models = {};
        for (const [name, schema] of Object.entries(this.definitions.type))
          models[name] = getSchemaValidator2(
            schema
          );
        return models;
      }
      add(method, path2, handle3, localHook, { allowMeta = false, skipPrefix = false } = {
        allowMeta: false,
        skipPrefix: false
      }) {
        localHook = localHookToLifeCycleStore2(localHook);
        if (path2 !== "" && path2.charCodeAt(0) !== 47)
          path2 = "/" + path2;
        if (this.config.prefix && !skipPrefix && !this.config.scoped)
          path2 = this.config.prefix + path2;
        if (localHook?.type)
          switch (localHook.type) {
            case "text":
              localHook.type = "text/plain";
              break;
            case "json":
              localHook.type = "application/json";
              break;
            case "formdata":
              localHook.type = "multipart/form-data";
              break;
            case "urlencoded":
              localHook.type = "application/x-www-form-urlencoded";
              break;
            case "arrayBuffer":
              localHook.type = "application/octet-stream";
              break;
            default:
              break;
          }
        const models = this.definitions.type;
        const dynamic = !this.config.aot;
        const instanceValidator = { ...this.validator.getCandidate() };
        const cloned = {
          body: localHook?.body ?? instanceValidator?.body,
          headers: localHook?.headers ?? instanceValidator?.headers,
          params: localHook?.params ?? instanceValidator?.params,
          query: localHook?.query ?? instanceValidator?.query,
          cookie: localHook?.cookie ?? instanceValidator?.cookie,
          response: localHook?.response ?? instanceValidator?.response
        };
        const cookieValidator = () => cloned.cookie ? getCookieValidator2({
          validator: cloned.cookie,
          defaultConfig: this.config.cookie,
          config: cloned.cookie?.config ?? {},
          dynamic,
          models
        }) : void 0;
        const normalize4 = this.config.normalize;
        const validator = this.config.precompile === true || typeof this.config.precompile === "object" && this.config.precompile.schema === true ? {
          body: getSchemaValidator2(cloned.body, {
            dynamic,
            models,
            normalize: normalize4
          }),
          headers: getSchemaValidator2(cloned.headers, {
            dynamic,
            models,
            additionalProperties: !this.config.normalize,
            coerce: true,
            additionalCoerce: stringToStructureCoercions2()
          }),
          params: getSchemaValidator2(cloned.params, {
            dynamic,
            models,
            coerce: true,
            additionalCoerce: stringToStructureCoercions2()
          }),
          query: getSchemaValidator2(cloned.query, {
            dynamic,
            models,
            normalize: normalize4,
            coerce: true,
            additionalCoerce: stringToStructureCoercions2()
          }),
          cookie: cookieValidator(),
          response: getResponseSchemaValidator2(cloned.response, {
            dynamic,
            models,
            normalize: normalize4
          })
        } : {
          createBody() {
            if (this.body)
              return this.body;
            return this.body = getSchemaValidator2(
              cloned.body,
              {
                dynamic,
                models,
                normalize: normalize4
              }
            );
          },
          createHeaders() {
            if (this.headers)
              return this.headers;
            return this.headers = getSchemaValidator2(
              cloned.headers,
              {
                dynamic,
                models,
                additionalProperties: !normalize4,
                coerce: true,
                additionalCoerce: stringToStructureCoercions2()
              }
            );
          },
          createParams() {
            if (this.params)
              return this.params;
            return this.params = getSchemaValidator2(
              cloned.params,
              {
                dynamic,
                models,
                coerce: true,
                additionalCoerce: stringToStructureCoercions2()
              }
            );
          },
          createQuery() {
            if (this.query)
              return this.query;
            return this.query = getSchemaValidator2(
              cloned.query,
              {
                dynamic,
                models,
                coerce: true,
                additionalCoerce: stringToStructureCoercions2()
              }
            );
          },
          createCookie() {
            if (this.cookie)
              return this.cookie;
            return this.cookie = cookieValidator();
          },
          createResponse() {
            if (this.response)
              return this.response;
            return this.response = getResponseSchemaValidator2(
              cloned.response,
              {
                dynamic,
                models,
                normalize: normalize4
              }
            );
          }
        };
        const loosePath = path2.endsWith("/") ? path2.slice(0, path2.length - 1) : path2 + "/";
        localHook = mergeHook2(localHook, instanceValidator);
        if (localHook.tags) {
          if (!localHook.detail)
            localHook.detail = {
              tags: localHook.tags
            };
          else
            localHook.detail.tags = localHook.tags;
        }
        if (isNotEmpty2(this.config.detail))
          localHook.detail = mergeDeep2(
            Object.assign({}, this.config.detail),
            localHook.detail
          );
        this.applyMacro(localHook);
        const hooks = mergeHook2(this.event, localHook);
        if (this.config.aot === false) {
          this.router.dynamic.add(method, path2, {
            validator,
            hooks,
            content: localHook?.type,
            handle: handle3
          });
          if (this.config.strictPath === false) {
            this.router.dynamic.add(method, loosePath, {
              validator,
              hooks,
              content: localHook?.type,
              handle: handle3
            });
          }
          this.router.history.push({
            method,
            path: path2,
            composed: null,
            handler: handle3,
            hooks
          });
          return;
        }
        const shouldPrecompile = this.config.precompile === true || typeof this.config.precompile === "object" && this.config.precompile.compose === true;
        const inference = cloneInference2(this.inference);
        const compile = () => composeHandler2({
          app: this,
          path: path2,
          method,
          localHook: mergeHook2(localHook),
          hooks,
          validator,
          handler: handle3,
          allowMeta,
          inference
        });
        const mainHandler = shouldPrecompile ? compile() : (context) => {
          return compile()(context);
        };
        const routeIndex = this.router.history.length;
        if (this.routeTree.has(method + path2))
          for (let i2 = 0; i2 < this.router.history.length; i2++) {
            const route = this.router.history[i2];
            if (route.path === path2 && route.method === method) {
              const removed = this.router.history.splice(i2, 1)[0];
              if (removed && this.routeTree.has(removed?.method + removed?.path))
                this.routeTree.delete(removed.method + removed.path);
            }
          }
        else
          this.routeTree.set(method + path2, routeIndex);
        this.router.history.push({
          method,
          path: path2,
          composed: mainHandler,
          handler: handle3,
          hooks
        });
        const staticRouter = this.router.static.http;
        const handler = {
          handler: shouldPrecompile ? mainHandler : void 0,
          compile
        };
        if (method === "$INTERNALWS") {
          const loose = this.config.strictPath ? void 0 : path2.endsWith("/") ? path2.slice(0, path2.length - 1) : path2 + "/";
          if (path2.indexOf(":") === -1 && path2.indexOf("*") === -1) {
            const index3 = staticRouter.handlers.length;
            staticRouter.handlers.push(
              (ctx) => (staticRouter.handlers[index3] = compile())(ctx)
            );
            this.router.static.ws[path2] = index3;
            if (loose)
              this.router.static.ws[loose] = index3;
          } else {
            this.router.ws.add("ws", path2, handler);
            if (loose)
              this.router.ws.add("ws", loose, handler);
          }
          return;
        }
        if (path2.indexOf(":") === -1 && path2.indexOf("*") === -1) {
          const index3 = staticRouter.handlers.length;
          staticRouter.handlers.push(
            (ctx) => (staticRouter.handlers[index3] = compile())(
              ctx
            )
          );
          if (!staticRouter.map[path2])
            staticRouter.map[path2] = {
              code: ""
            };
          if (method === "ALL")
            staticRouter.map[path2].all = `default: return st[${index3}](ctx)
`;
          else
            staticRouter.map[path2].code = `case '${method}': return st[${index3}](ctx)
${staticRouter.map[path2].code}`;
          if (!this.config.strictPath) {
            if (!staticRouter.map[loosePath])
              staticRouter.map[loosePath] = {
                code: ""
              };
            if (method === "ALL")
              staticRouter.map[loosePath].all = `default: return st[${index3}](ctx)
`;
            else
              staticRouter.map[loosePath].code = `case '${method}': return st[${index3}](ctx)
${staticRouter.map[loosePath].code}`;
          }
        } else {
          this.router.http.add(method, path2, handler);
          if (!this.config.strictPath)
            this.router.http.add(
              method,
              path2.endsWith("/") ? path2.slice(0, path2.length - 1) : path2 + "/",
              handler
            );
        }
      }
      headers(header) {
        if (!header)
          return this;
        if (!this.setHeaders)
          this.setHeaders = {};
        this.setHeaders = mergeDeep2(this.setHeaders, header);
        return this;
      }
      /**
       * ### start | Life cycle event
       * Called after server is ready for serving
       *
       * ---
       * @example
       * ```typescript
       * new Elysia()
       *     .onStart(({ url, port }) => {
       *         console.log("Running at ${url}:${port}")
       *     })
       *     .listen(3000)
       * ```
       */
      onStart(handler) {
        this.on("start", handler);
        return this;
      }
      /**
       * ### request | Life cycle event
       * Called on every new request is accepted
       *
       * ---
       * @example
       * ```typescript
       * new Elysia()
       *     .onRequest(({ method, url }) => {
       *         saveToAnalytic({ method, url })
       *     })
       * ```
       */
      onRequest(handler) {
        this.on("request", handler);
        return this;
      }
      onParse(options, handler) {
        if (!handler)
          return this.on("parse", options);
        return this.on(
          options,
          "parse",
          handler
        );
      }
      onTransform(options, handler) {
        if (!handler)
          return this.on("transform", options);
        return this.on(
          options,
          "transform",
          handler
        );
      }
      resolve(optionsOrResolve, resolve2) {
        if (!resolve2) {
          resolve2 = optionsOrResolve;
          optionsOrResolve = { as: "local" };
        }
        const hook = {
          subType: "resolve",
          fn: resolve2
        };
        return this.onBeforeHandle(optionsOrResolve, hook);
      }
      mapResolve(optionsOrResolve, mapper) {
        if (!mapper) {
          mapper = optionsOrResolve;
          optionsOrResolve = { as: "local" };
        }
        const hook = {
          subType: "mapResolve",
          fn: mapper
        };
        return this.onBeforeHandle(optionsOrResolve, hook);
      }
      onBeforeHandle(options, handler) {
        if (!handler)
          return this.on("beforeHandle", options);
        return this.on(
          options,
          "beforeHandle",
          handler
        );
      }
      onAfterHandle(options, handler) {
        if (!handler)
          return this.on("afterHandle", options);
        return this.on(
          options,
          "afterHandle",
          handler
        );
      }
      mapResponse(options, handler) {
        if (!handler)
          return this.on("mapResponse", options);
        return this.on(
          options,
          "mapResponse",
          handler
        );
      }
      onAfterResponse(options, handler) {
        if (!handler)
          return this.on("afterResponse", options);
        return this.on(
          options,
          "afterResponse",
          handler
        );
      }
      /**
       * ### After Handle | Life cycle event
       * Intercept request **after** main handler is called.
       *
       * If truthy value is returned, will be assigned as `Response`
       *
       * ---
       * @example
       * ```typescript
       * new Elysia()
       *     .onAfterHandle((context, response) => {
       *         if(typeof response === "object")
       *             return JSON.stringify(response)
       *     })
       * ```
       */
      trace(options, handler) {
        if (!handler) {
          handler = options;
          options = { as: "local" };
        }
        if (!Array.isArray(handler))
          handler = [handler];
        for (const fn of handler)
          this.on(
            options,
            "trace",
            createTracer2(fn)
          );
        return this;
      }
      error(name, error22) {
        switch (typeof name) {
          case "string":
            error22.prototype[ERROR_CODE2] = name;
            this.definitions.error[name] = error22;
            return this;
          case "function":
            this.definitions.error = name(this.definitions.error);
            return this;
        }
        for (const [code4, error32] of Object.entries(name)) {
          error32.prototype[ERROR_CODE2] = code4;
          this.definitions.error[code4] = error32;
        }
        return this;
      }
      /**
       * ### Error | Life cycle event
       * Called when error is thrown during processing request
       *
       * ---
       * @example
       * ```typescript
       * new Elysia()
       *     .onError(({ code }) => {
       *         if(code === "NOT_FOUND")
       *             return "Path not found :("
       *     })
       * ```
       */
      onError(options, handler) {
        if (!handler)
          return this.on("error", options);
        return this.on(
          options,
          "error",
          handler
        );
      }
      /**
       * ### stop | Life cycle event
       * Called after server stop serving request
       *
       * ---
       * @example
       * ```typescript
       * new Elysia()
       *     .onStop((app) => {
       *         cleanup()
       *     })
       * ```
       */
      onStop(handler) {
        this.on("stop", handler);
        return this;
      }
      on(optionsOrType, typeOrHandlers, handlers2) {
        let type;
        switch (typeof optionsOrType) {
          case "string":
            type = optionsOrType;
            handlers2 = typeOrHandlers;
            break;
          case "object":
            type = typeOrHandlers;
            if (!Array.isArray(typeOrHandlers) && typeof typeOrHandlers === "object")
              handlers2 = typeOrHandlers;
            break;
        }
        if (Array.isArray(handlers2))
          handlers2 = fnToContainer2(handlers2);
        else {
          if (typeof handlers2 === "function")
            handlers2 = [
              {
                fn: handlers2
              }
            ];
          else
            handlers2 = [handlers2];
        }
        const handles = handlers2;
        for (const handle3 of handles)
          handle3.scope = typeof optionsOrType === "string" ? "local" : optionsOrType?.as ?? "local";
        if (type !== "trace")
          sucrose2(
            {
              [type]: handles.map((x2) => x2.fn)
            },
            this.inference
          );
        for (const handle3 of handles) {
          const fn = asHookType2(handle3, "global", { skipIfHasType: true });
          switch (type) {
            case "start":
              this.event.start.push(fn);
              break;
            case "request":
              this.event.request.push(fn);
              break;
            case "parse":
              this.event.parse.push(fn);
              break;
            case "transform":
              this.event.transform.push(fn);
              break;
            case "beforeHandle":
              this.event.beforeHandle.push(fn);
              break;
            case "afterHandle":
              this.event.afterHandle.push(fn);
              break;
            case "mapResponse":
              this.event.mapResponse.push(fn);
              break;
            case "afterResponse":
              this.event.afterResponse.push(fn);
              break;
            case "trace":
              this.event.trace.push(fn);
              break;
            case "error":
              this.event.error.push(fn);
              break;
            case "stop":
              this.event.stop.push(fn);
              break;
          }
        }
        return this;
      }
      /**
       * @deprecated use `Elysia.as` instead
       *
       * Will be removed in Elysia 1.2
       */
      propagate() {
        promoteEvent2(this.event.parse);
        promoteEvent2(this.event.transform);
        promoteEvent2(this.event.beforeHandle);
        promoteEvent2(this.event.afterHandle);
        promoteEvent2(this.event.mapResponse);
        promoteEvent2(this.event.afterResponse);
        promoteEvent2(this.event.trace);
        promoteEvent2(this.event.error);
        return this;
      }
      as(type) {
        const castType = { plugin: "scoped", global: "global" }[type];
        promoteEvent2(this.event.parse, castType);
        promoteEvent2(this.event.transform, castType);
        promoteEvent2(this.event.beforeHandle, castType);
        promoteEvent2(this.event.afterHandle, castType);
        promoteEvent2(this.event.mapResponse, castType);
        promoteEvent2(this.event.afterResponse, castType);
        promoteEvent2(this.event.trace, castType);
        promoteEvent2(this.event.error, castType);
        if (type === "plugin") {
          this.validator.scoped = mergeSchemaValidator2(
            this.validator.scoped,
            this.validator.local
          );
          this.validator.local = null;
        } else if (type === "global") {
          this.validator.global = mergeSchemaValidator2(
            this.validator.global,
            mergeSchemaValidator2(
              this.validator.scoped,
              this.validator.local
            )
          );
          this.validator.scoped = null;
          this.validator.local = null;
        }
        return this;
      }
      /**
       * ### group
       * Encapsulate and group path with prefix
       *
       * ---
       * @example
       * ```typescript
       * new Elysia()
       *     .group('/v1', app => app
       *         .get('/', () => 'Hi')
       *         .get('/name', () => 'Elysia')
       *     })
       * ```
       */
      group(prefix, schemaOrRun, run) {
        const instance = new _Elysia2({
          ...this.config,
          prefix: ""
        });
        instance.singleton = { ...this.singleton };
        instance.definitions = { ...this.definitions };
        instance.getServer = () => this.getServer();
        instance.inference = cloneInference2(this.inference);
        instance.extender = { ...this.extender };
        const isSchema = typeof schemaOrRun === "object";
        const sandbox = (isSchema ? run : schemaOrRun)(instance);
        this.singleton = mergeDeep2(this.singleton, instance.singleton);
        this.definitions = mergeDeep2(this.definitions, instance.definitions);
        if (sandbox.event.request.length)
          this.event.request = [
            ...this.event.request || [],
            ...sandbox.event.request || []
          ];
        if (sandbox.event.mapResponse.length)
          this.event.mapResponse = [
            ...this.event.mapResponse || [],
            ...sandbox.event.mapResponse || []
          ];
        this.model(sandbox.definitions.type);
        Object.values(instance.router.history).forEach(
          ({ method, path: path2, handler, hooks }) => {
            path2 = (isSchema ? "" : this.config.prefix) + prefix + path2;
            if (isSchema) {
              const hook = schemaOrRun;
              const localHook = hooks;
              this.add(
                method,
                path2,
                handler,
                mergeHook2(hook, {
                  ...localHook || {},
                  error: !localHook.error ? sandbox.event.error : Array.isArray(localHook.error) ? [
                    ...localHook.error || {},
                    ...sandbox.event.error || {}
                  ] : [
                    localHook.error,
                    ...sandbox.event.error || {}
                  ]
                })
              );
            } else {
              this.add(
                method,
                path2,
                handler,
                mergeHook2(
                  hooks,
                  {
                    error: sandbox.event.error
                  }
                ),
                {
                  skipPrefix: true
                }
              );
            }
          }
        );
        return this;
      }
      /**
       * ### guard
       * Encapsulate and pass hook into all child handler
       *
       * ---
       * @example
       * ```typescript
       * import { t } from 'elysia'
       *
       * new Elysia()
       *     .guard({
       *          schema: {
       *              body: t.Object({
       *                  username: t.String(),
       *                  password: t.String()
       *              })
       *          }
       *     }, app => app
       *         .get("/", () => 'Hi')
       *         .get("/name", () => 'Elysia')
       *     })
       * ```
       */
      guard(hook, run) {
        if (!run) {
          if (typeof hook === "object") {
            this.applyMacro(hook);
            const type = hook.as ?? "local";
            this.validator[type] = {
              body: hook.body ?? this.validator[type]?.body,
              headers: hook.headers ?? this.validator[type]?.headers,
              params: hook.params ?? this.validator[type]?.params,
              query: hook.query ?? this.validator[type]?.query,
              response: hook.response ?? this.validator[type]?.response,
              cookie: hook.cookie ?? this.validator[type]?.cookie
            };
            if (hook.parse)
              this.on({ as: type }, "parse", hook.parse);
            if (hook.transform)
              this.on({ as: type }, "transform", hook.transform);
            if (hook.beforeHandle)
              this.on({ as: type }, "beforeHandle", hook.beforeHandle);
            if (hook.afterHandle)
              this.on({ as: type }, "afterHandle", hook.afterHandle);
            if (hook.mapResponse)
              this.on({ as: type }, "mapResponse", hook.mapResponse);
            if (hook.afterResponse)
              this.on({ as: type }, "afterResponse", hook.afterResponse);
            if (hook.error)
              this.on({ as: type }, "error", hook.error);
            if (hook.detail) {
              if (this.config.detail)
                this.config.detail = mergeDeep2(
                  Object.assign({}, this.config.detail),
                  hook.detail
                );
              else
                this.config.detail = hook.detail;
            }
            if (hook?.tags) {
              if (!this.config.detail)
                this.config.detail = {
                  tags: hook.tags
                };
              else
                this.config.detail.tags = hook.tags;
            }
            return this;
          }
          return this.guard({}, hook);
        }
        const instance = new _Elysia2({
          ...this.config,
          prefix: ""
        });
        instance.singleton = { ...this.singleton };
        instance.definitions = { ...this.definitions };
        instance.inference = cloneInference2(this.inference);
        instance.extender = { ...this.extender };
        const sandbox = run(instance);
        this.singleton = mergeDeep2(this.singleton, instance.singleton);
        this.definitions = mergeDeep2(this.definitions, instance.definitions);
        sandbox.getServer = () => this.server;
        if (sandbox.event.request.length)
          this.event.request = [
            ...this.event.request || [],
            ...sandbox.event.request || []
          ];
        if (sandbox.event.mapResponse.length)
          this.event.mapResponse = [
            ...this.event.mapResponse || [],
            ...sandbox.event.mapResponse || []
          ];
        this.model(sandbox.definitions.type);
        Object.values(instance.router.history).forEach(
          ({ method, path: path2, handler, hooks: localHook }) => {
            this.add(
              method,
              path2,
              handler,
              mergeHook2(hook, {
                ...localHook || {},
                error: !localHook.error ? sandbox.event.error : Array.isArray(localHook.error) ? [
                  ...localHook.error || {},
                  ...sandbox.event.error || []
                ] : [
                  localHook.error,
                  ...sandbox.event.error || []
                ]
              })
            );
          }
        );
        return this;
      }
      /**
       * ### use
       * Merge separate logic of Elysia with current
       *
       * ---
       * @example
       * ```typescript
       * const plugin = (app: Elysia) => app
       *     .get('/plugin', () => 'hi')
       *
       * new Elysia()
       *     .use(plugin)
       * ```
       */
      use(plugin, options) {
        if (options?.scoped)
          return this.guard({}, (app2) => app2.use(plugin));
        if (Array.isArray(plugin)) {
          let current = this;
          for (const p3 of plugin)
            current = this.use(p3);
          return current;
        }
        if (plugin instanceof Promise) {
          this.promisedModules.add(
            plugin.then((plugin2) => {
              if (typeof plugin2 === "function")
                return plugin2(this);
              if (plugin2 instanceof _Elysia2)
                return this._use(plugin2);
              if (typeof plugin2.default === "function")
                return plugin2.default(this);
              if (plugin2.default instanceof _Elysia2)
                return this._use(plugin2.default);
              throw new Error(
                'Invalid plugin type. Expected Elysia instance, function, or module with "default" as Elysia instance or function that returns Elysia instance.'
              );
            }).then((x2) => x2.compile())
          );
          return this;
        }
        return this._use(plugin);
      }
      _use(plugin) {
        if (typeof plugin === "function") {
          const instance = plugin(this);
          if (instance instanceof Promise) {
            this.promisedModules.add(
              instance.then((plugin2) => {
                if (plugin2 instanceof _Elysia2) {
                  this.compile();
                  for (const {
                    method,
                    path: path2,
                    handler,
                    hooks
                  } of Object.values(plugin2.router.history)) {
                    this.add(
                      method,
                      path2,
                      handler,
                      mergeHook2(
                        hooks,
                        {
                          error: plugin2.event.error
                        }
                      )
                    );
                  }
                  return plugin2;
                }
                if (typeof plugin2 === "function")
                  return plugin2(
                    this
                  );
                if (typeof plugin2.default === "function")
                  return plugin2.default(
                    this
                  );
                return this._use(plugin2);
              }).then((x2) => x2.compile())
            );
            return this;
          }
          return instance;
        }
        if (plugin.promisedModules.size) {
          this.promisedModules.add(
            plugin.modules.then(() => this._use(plugin)).then((x2) => x2.compile())
          );
          return this;
        }
        const { name, seed } = plugin.config;
        plugin.getServer = () => this.getServer();
        plugin.getGlobalRoutes = () => this.getGlobalRoutes();
        plugin.model(this.definitions.type);
        plugin.error(this.definitions.error);
        const isScoped = plugin.config.scoped;
        if (isScoped) {
          if (name) {
            if (!(name in this.dependencies))
              this.dependencies[name] = [];
            const current = seed !== void 0 ? checksum2(name + JSON.stringify(seed)) : 0;
            if (this.dependencies[name].some(
              ({ checksum: checksum22 }) => current === checksum22
            ))
              return this;
            this.dependencies[name].push(
              !this.config?.analytic ? {
                name: plugin.config.name,
                seed: plugin.config.seed,
                checksum: current,
                dependencies: plugin.dependencies
              } : {
                name: plugin.config.name,
                seed: plugin.config.seed,
                checksum: current,
                dependencies: plugin.dependencies,
                stack: plugin.telemetry.stack,
                routes: plugin.router.history,
                decorators: plugin.singleton.decorator,
                store: plugin.singleton.store,
                type: plugin.definitions.type,
                error: plugin.definitions.error,
                derive: plugin.event.transform.filter((x2) => x2.subType === "derive").map((x2) => ({
                  fn: x2.fn.toString(),
                  stack: new Error().stack ?? ""
                })),
                resolve: plugin.event.transform.filter((x2) => x2.subType === "derive").map((x2) => ({
                  fn: x2.fn.toString(),
                  stack: new Error().stack ?? ""
                }))
              }
            );
          }
          plugin.extender.macros = this.extender.macros.concat(
            plugin.extender.macros
          );
          const macroHashes = [];
          for (let i2 = 0; i2 < plugin.extender.macros.length; i2++) {
            const macro = this.extender.macros[i2];
            if (macroHashes.includes(macro.checksum)) {
              plugin.extender.macros.splice(i2, 1);
              i2--;
            }
            macroHashes.push(macro.checksum);
          }
          plugin.onRequest((context) => {
            Object.assign(context, this.singleton.decorator);
            Object.assign(context.store, this.singleton.store);
          });
          if (plugin.event.trace.length)
            plugin.event.trace.push(...plugin.event.trace);
          if (!plugin.config.prefix)
            console.warn(
              "It's recommended to use scoped instance with a prefix to prevent collision routing with other instance."
            );
          if (plugin.event.error.length)
            plugin.event.error.push(...this.event.error);
          if (plugin.config.aot)
            plugin.compile();
          if (isScoped === true && plugin.config.prefix) {
            this.mount(plugin.config.prefix + "/", plugin.fetch);
            for (const route of plugin.router.history) {
              this.routeTree.set(
                route.method + `${plugin.config.prefix}${route.path}`,
                this.router.history.length
              );
              this.router.history.push({
                ...route,
                path: `${plugin.config.prefix}${route.path}`,
                hooks: mergeHook2(route.hooks, {
                  error: this.event.error
                })
              });
            }
          } else {
            this.mount(plugin.fetch);
            for (const route of plugin.router.history) {
              this.routeTree.set(
                route.method + `${plugin.config.prefix}${route.path}`,
                this.router.history.length
              );
              this.router.history.push({
                ...route,
                path: `${plugin.config.prefix}${route.path}`,
                hooks: mergeHook2(route.hooks, {
                  error: this.event.error
                })
              });
            }
          }
          return this;
        } else {
          this.headers(plugin.setHeaders);
          if (name) {
            if (!(name in this.dependencies))
              this.dependencies[name] = [];
            const current = seed !== void 0 ? checksum2(name + JSON.stringify(seed)) : 0;
            if (!this.dependencies[name].some(
              ({ checksum: checksum22 }) => current === checksum22
            )) {
              this.extender.macros = this.extender.macros.concat(
                plugin.extender.macros
              );
              this.extender.higherOrderFunctions = this.extender.higherOrderFunctions.concat(
                plugin.extender.higherOrderFunctions
              );
            }
          } else {
            this.extender.macros = this.extender.macros.concat(
              plugin.extender.macros
            );
            this.extender.higherOrderFunctions = this.extender.higherOrderFunctions.concat(
              plugin.extender.higherOrderFunctions
            );
          }
          deduplicateChecksum2(this.extender.macros);
          deduplicateChecksum2(this.extender.higherOrderFunctions);
          const hofHashes = [];
          for (let i2 = 0; i2 < this.extender.higherOrderFunctions.length; i2++) {
            const hof = this.extender.higherOrderFunctions[i2];
            if (hof.checksum) {
              if (hofHashes.includes(hof.checksum)) {
                this.extender.higherOrderFunctions.splice(i2, 1);
                i2--;
              }
              hofHashes.push(hof.checksum);
            }
          }
          this.inference = {
            body: this.inference.body || plugin.inference.body,
            cookie: this.inference.cookie || plugin.inference.cookie,
            headers: this.inference.headers || plugin.inference.headers,
            query: this.inference.query || plugin.inference.query,
            set: this.inference.set || plugin.inference.set,
            server: this.inference.server || plugin.inference.server
          };
        }
        this.decorate(plugin.singleton.decorator);
        this.state(plugin.singleton.store);
        this.model(plugin.definitions.type);
        this.error(plugin.definitions.error);
        plugin.extender.macros = this.extender.macros.concat(
          plugin.extender.macros
        );
        for (const { method, path: path2, handler, hooks } of Object.values(
          plugin.router.history
        )) {
          this.add(
            method,
            path2,
            handler,
            mergeHook2(
              hooks,
              {
                error: plugin.event.error
              }
            )
          );
        }
        if (!isScoped)
          if (name) {
            if (!(name in this.dependencies))
              this.dependencies[name] = [];
            const current = seed !== void 0 ? checksum2(name + JSON.stringify(seed)) : 0;
            if (this.dependencies[name].some(
              ({ checksum: checksum22 }) => current === checksum22
            ))
              return this;
            this.dependencies[name].push(
              !this.config?.analytic ? {
                name: plugin.config.name,
                seed: plugin.config.seed,
                checksum: current,
                dependencies: plugin.dependencies
              } : {
                name: plugin.config.name,
                seed: plugin.config.seed,
                checksum: current,
                dependencies: plugin.dependencies,
                stack: plugin.telemetry.stack,
                routes: plugin.router.history,
                decorators: plugin.singleton,
                store: plugin.singleton.store,
                type: plugin.definitions.type,
                error: plugin.definitions.error,
                derive: plugin.event.transform.filter((x2) => x2?.subType === "derive").map((x2) => ({
                  fn: x2.toString(),
                  stack: new Error().stack ?? ""
                })),
                resolve: plugin.event.transform.filter((x2) => x2?.subType === "resolve").map((x2) => ({
                  fn: x2.toString(),
                  stack: new Error().stack ?? ""
                }))
              }
            );
            this.event = mergeLifeCycle2(
              this.event,
              filterGlobalHook2(plugin.event),
              current
            );
          } else {
            this.event = mergeLifeCycle2(
              this.event,
              filterGlobalHook2(plugin.event)
            );
          }
        this.validator.global = mergeHook2(this.validator.global, {
          ...plugin.validator.global
        });
        this.validator.local = mergeHook2(this.validator.local, {
          ...plugin.validator.scoped
        });
        return this;
      }
      macro(macro) {
        const hook = {
          checksum: checksum2(
            JSON.stringify({
              name: this.config.name,
              seed: this.config.seed,
              content: macro.toString()
            })
          ),
          fn: macro
        };
        this.extender.macros.push(hook);
        return this;
      }
      mount(path2, handle3) {
        if (path2 instanceof _Elysia2 || typeof path2 === "function" || path2.length === 0 || path2 === "/") {
          const run = typeof path2 === "function" ? path2 : path2 instanceof _Elysia2 ? path2.compile().fetch : handle3 instanceof _Elysia2 ? handle3.compile().fetch : handle3;
          const handler2 = async ({ request, path: path22 }) => run(
            new Request(
              replaceUrlPath2(request.url, path22 || "/"),
              request
            )
          );
          this.all(
            "/*",
            handler2,
            {
              type: "none"
            }
          );
          return this;
        }
        const length = path2.length;
        if (handle3 instanceof _Elysia2)
          handle3 = handle3.compile().fetch;
        const handler = async ({ request, path: path22 }) => handle3(
          new Request(
            replaceUrlPath2(request.url, path22.slice(length) || "/"),
            request
          )
        );
        this.all(
          path2,
          handler,
          {
            type: "none"
          }
        );
        this.all(
          path2 + (path2.endsWith("/") ? "*" : "/*"),
          handler,
          {
            type: "none"
          }
        );
        return this;
      }
      /**
       * ### get
       * Register handler for path with method [GET]
       *
       * ---
       * @example
       * ```typescript
       * import { Elysia, t } from 'elysia'
       *
       * new Elysia()
       *     .get('/', () => 'hi')
       *     .get('/with-hook', () => 'hi', {
       *         response: t.String()
       *     })
       * ```
       */
      get(path2, handler, hook) {
        this.add("GET", path2, handler, hook);
        return this;
      }
      /**
       * ### post
       * Register handler for path with method [POST]
       *
       * ---
       * @example
       * ```typescript
       * import { Elysia, t } from 'elysia'
       *
       * new Elysia()
       *     .post('/', () => 'hi')
       *     .post('/with-hook', () => 'hi', {
       *         response: t.String()
       *     })
       * ```
       */
      post(path2, handler, hook) {
        this.add("POST", path2, handler, hook);
        return this;
      }
      /**
       * ### put
       * Register handler for path with method [PUT]
       *
       * ---
       * @example
       * ```typescript
       * import { Elysia, t } from 'elysia'
       *
       * new Elysia()
       *     .put('/', () => 'hi')
       *     .put('/with-hook', () => 'hi', {
       *         response: t.String()
       *     })
       * ```
       */
      put(path2, handler, hook) {
        this.add("PUT", path2, handler, hook);
        return this;
      }
      /**
       * ### patch
       * Register handler for path with method [PATCH]
       *
       * ---
       * @example
       * ```typescript
       * import { Elysia, t } from 'elysia'
       *
       * new Elysia()
       *     .patch('/', () => 'hi')
       *     .patch('/with-hook', () => 'hi', {
       *         response: t.String()
       *     })
       * ```
       */
      patch(path2, handler, hook) {
        this.add("PATCH", path2, handler, hook);
        return this;
      }
      /**
       * ### delete
       * Register handler for path with method [DELETE]
       *
       * ---
       * @example
       * ```typescript
       * import { Elysia, t } from 'elysia'
       *
       * new Elysia()
       *     .delete('/', () => 'hi')
       *     .delete('/with-hook', () => 'hi', {
       *         response: t.String()
       *     })
       * ```
       */
      delete(path2, handler, hook) {
        this.add("DELETE", path2, handler, hook);
        return this;
      }
      /**
       * ### options
       * Register handler for path with method [POST]
       *
       * ---
       * @example
       * ```typescript
       * import { Elysia, t } from 'elysia'
       *
       * new Elysia()
       *     .options('/', () => 'hi')
       *     .options('/with-hook', () => 'hi', {
       *         response: t.String()
       *     })
       * ```
       */
      options(path2, handler, hook) {
        this.add("OPTIONS", path2, handler, hook);
        return this;
      }
      /**
       * ### all
       * Register handler for path with method [ALL]
       *
       * ---
       * @example
       * ```typescript
       * import { Elysia, t } from 'elysia'
       *
       * new Elysia()
       *     .all('/', () => 'hi')
       *     .all('/with-hook', () => 'hi', {
       *         response: t.String()
       *     })
       * ```
       */
      all(path2, handler, hook) {
        this.add("ALL", path2, handler, hook);
        return this;
      }
      /**
       * ### head
       * Register handler for path with method [HEAD]
       *
       * ---
       * @example
       * ```typescript
       * import { Elysia, t } from 'elysia'
       *
       * new Elysia()
       *     .head('/', () => 'hi')
       *     .head('/with-hook', () => 'hi', {
       *         response: t.String()
       *     })
       * ```
       */
      head(path2, handler, hook) {
        this.add("HEAD", path2, handler, hook);
        return this;
      }
      /**
       * ### connect
       * Register handler for path with method [CONNECT]
       *
       * ---
       * @example
       * ```typescript
       * import { Elysia, t } from 'elysia'
       *
       * new Elysia()
       *     .connect('/', () => 'hi')
       *     .connect('/with-hook', () => 'hi', {
       *         response: t.String()
       *     })
       * ```
       */
      connect(path2, handler, hook) {
        this.add("CONNECT", path2, handler, hook);
        return this;
      }
      /**
       * ### route
       * Register handler for path with method [ROUTE]
       *
       * ---
       * @example
       * ```typescript
       * import { Elysia, t } from 'elysia'
       *
       * new Elysia()
       *     .route('/', () => 'hi')
       *     .route('/with-hook', () => 'hi', {
       *         response: t.String()
       *     })
       * ```
       */
      route(method, path2, handler, hook) {
        this.add(method.toUpperCase(), path2, handler, hook, hook?.config);
        return this;
      }
      /**
       * ### ws
       * Register handler for path with method [ws]
       *
       * ---
       * @example
       * ```typescript
       * import { Elysia, t } from 'elysia'
       *
       * new Elysia()
       *     .ws('/', {
       *         message(ws, message) {
       *             ws.send(message)
       *         }
       *     })
       * ```
       */
      ws(path2, options) {
        const transform = options.transformMessage ? Array.isArray(options.transformMessage) ? options.transformMessage : [options.transformMessage] : void 0;
        let server = null;
        const validateMessage = getSchemaValidator2(options?.body, {
          models: this.definitions.type,
          normalize: this.config.normalize
        });
        const validateResponse = getSchemaValidator2(options?.response, {
          models: this.definitions.type,
          normalize: this.config.normalize
        });
        const parseMessage = (message2) => {
          if (typeof message2 === "string") {
            const start = message2?.charCodeAt(0);
            if (start === 47 || start === 123)
              try {
                message2 = JSON.parse(message2);
              } catch {
              }
            else if (isNumericString2(message2))
              message2 = +message2;
          }
          if (transform?.length)
            for (let i2 = 0; i2 < transform.length; i2++) {
              const temp = transform[i2](message2);
              if (temp !== void 0)
                message2 = temp;
            }
          return message2;
        };
        this.route(
          "$INTERNALWS",
          path2,
          // @ts-expect-error
          (context) => {
            const { set, path: path22, qi, headers, query, params } = context;
            if (server === null)
              server = this.getServer();
            if (server?.upgrade(context.request, {
              headers: typeof options.upgrade === "function" ? options.upgrade(context) : options.upgrade,
              data: {
                validator: validateResponse,
                open(ws) {
                  options.open?.(new ElysiaWS2(ws, context));
                },
                message: (ws, msg) => {
                  const message2 = parseMessage(msg);
                  if (validateMessage?.Check(message2) === false)
                    return void ws.send(
                      new ValidationError2(
                        "message",
                        validateMessage,
                        message2
                      ).message
                    );
                  options.message?.(
                    new ElysiaWS2(ws, context),
                    message2
                  );
                },
                drain(ws) {
                  options.drain?.(
                    new ElysiaWS2(ws, context)
                  );
                },
                close(ws, code4, reason) {
                  options.close?.(
                    new ElysiaWS2(ws, context),
                    code4,
                    reason
                  );
                }
              }
            }))
              return;
            set.status = 400;
            return "Expected a websocket connection";
          },
          {
            beforeHandle: options.beforeHandle,
            transform: options.transform,
            headers: options.headers,
            params: options.params,
            query: options.query
          }
        );
        return this;
      }
      /**
       * ### state
       * Assign global mutatable state accessible for all handler
       *
       * ---
       * @example
       * ```typescript
       * new Elysia()
       *     .state('counter', 0)
       *     .get('/', (({ counter }) => ++counter)
       * ```
       */
      state(options, name, value) {
        if (name === void 0) {
          value = options;
          options = { as: "append" };
          name = "";
        } else if (value === void 0) {
          if (typeof options === "string") {
            value = name;
            name = options;
            options = { as: "append" };
          } else if (typeof options === "object") {
            value = name;
            name = "";
          }
        }
        const { as: as2 } = options;
        if (typeof name !== "string")
          return this;
        switch (typeof value) {
          case "object":
            if (name) {
              if (name in this.singleton.store)
                this.singleton.store[name] = mergeDeep2(
                  this.singleton.store[name],
                  value,
                  {
                    override: as2 === "override"
                  }
                );
              else
                this.singleton.store[name] = value;
              return this;
            }
            if (value === null)
              return this;
            this.singleton.store = mergeDeep2(this.singleton.store, value, {
              override: as2 === "override"
            });
            return this;
          case "function":
            if (name) {
              if (as2 === "override" || !(name in this.singleton.store))
                this.singleton.store[name] = value;
            } else
              this.singleton.store = value(this.singleton.store);
            return this;
          default:
            if (as2 === "override" || !(name in this.singleton.store))
              this.singleton.store[name] = value;
            return this;
        }
      }
      /**
       * ### decorate
       * Define custom method to `Context` accessible for all handler
       *
       * ---
       * @example
       * ```typescript
       * new Elysia()
       *     .decorate('getDate', () => Date.now())
       *     .get('/', (({ getDate }) => getDate())
       * ```
       */
      decorate(options, name, value) {
        if (name === void 0) {
          value = options;
          options = { as: "append" };
          name = "";
        } else if (value === void 0) {
          if (typeof options === "string") {
            value = name;
            name = options;
            options = { as: "append" };
          } else if (typeof options === "object") {
            value = name;
            name = "";
          }
        }
        const { as: as2 } = options;
        if (typeof name !== "string")
          return this;
        switch (typeof value) {
          case "object":
            if (name) {
              if (name in this.singleton.decorator)
                this.singleton.decorator[name] = mergeDeep2(
                  this.singleton.decorator[name],
                  value,
                  {
                    override: as2 === "override"
                  }
                );
              else
                this.singleton.decorator[name] = value;
              return this;
            }
            if (value === null)
              return this;
            this.singleton.decorator = mergeDeep2(
              this.singleton.decorator,
              value,
              {
                override: as2 === "override"
              }
            );
            return this;
          case "function":
            if (name) {
              if (as2 === "override" || !(name in this.singleton.decorator))
                this.singleton.decorator[name] = value;
            } else
              this.singleton.decorator = value(this.singleton.decorator);
            return this;
          default:
            if (as2 === "override" || !(name in this.singleton.decorator))
              this.singleton.decorator[name] = value;
            return this;
        }
      }
      derive(optionsOrTransform, transform) {
        if (!transform) {
          transform = optionsOrTransform;
          optionsOrTransform = { as: "local" };
        }
        const hook = {
          subType: "derive",
          fn: transform
        };
        return this.onTransform(optionsOrTransform, hook);
      }
      model(name, model) {
        switch (typeof name) {
          case "object":
            Object.entries(name).forEach(([key2, value]) => {
              if (!(key2 in this.definitions.type))
                this.definitions.type[key2] = value;
            });
            return this;
          case "function":
            this.definitions.type = name(this.definitions.type);
            return this;
        }
        ;
        this.definitions.type[name] = model;
        return this;
      }
      mapDerive(optionsOrDerive, mapper) {
        if (!mapper) {
          mapper = optionsOrDerive;
          optionsOrDerive = { as: "local" };
        }
        const hook = {
          subType: "mapDerive",
          fn: mapper
        };
        return this.onTransform(optionsOrDerive, hook);
      }
      affix(base2, type, word) {
        if (word === "")
          return this;
        const delimieter = ["_", "-", " "];
        const capitalize = (word2) => word2[0].toUpperCase() + word2.slice(1);
        const joinKey = base2 === "prefix" ? (prefix, word2) => delimieter.includes(prefix.at(-1) ?? "") ? prefix + word2 : prefix + capitalize(word2) : delimieter.includes(word.at(-1) ?? "") ? (suffix, word2) => word2 + suffix : (suffix, word2) => word2 + capitalize(suffix);
        const remap = (type2) => {
          const store = {};
          switch (type2) {
            case "decorator":
              for (const key2 in this.singleton.decorator) {
                store[joinKey(word, key2)] = this.singleton.decorator[key2];
              }
              this.singleton.decorator = store;
              break;
            case "state":
              for (const key2 in this.singleton.store)
                store[joinKey(word, key2)] = this.singleton.store[key2];
              this.singleton.store = store;
              break;
            case "model":
              for (const key2 in this.definitions.type)
                store[joinKey(word, key2)] = this.definitions.type[key2];
              this.definitions.type = store;
              break;
            case "error":
              for (const key2 in this.definitions.error)
                store[joinKey(word, key2)] = this.definitions.error[key2];
              this.definitions.error = store;
              break;
          }
        };
        const types2 = Array.isArray(type) ? type : [type];
        for (const type2 of types2.some((x2) => x2 === "all") ? ["decorator", "state", "model", "error"] : types2)
          remap(type2);
        return this;
      }
      prefix(type, word) {
        return this.affix("prefix", type, word);
      }
      suffix(type, word) {
        return this.affix("suffix", type, word);
      }
      compile() {
        this.fetch = this.config.aot ? composeGeneralHandler2(this) : createDynamicHandler2(this);
        if (typeof this.server?.reload === "function")
          this.server.reload({
            ...this.server || {},
            fetch: this.fetch
          });
        return this;
      }
      /**
       * Wait until all lazy loaded modules all load is fully
       */
      get modules() {
        return Promise.all(this.promisedModules.promises);
      }
    };
  }
});

// node_modules/elysia-oauth2/dist/index.js
var require_dist = __commonJS({
  "node_modules/elysia-oauth2/dist/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc2);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.oauth2 = void 0;
    var arctic = (init_dist2(), __toCommonJS(dist_exports));
    var elysia_1 = require_cjs2();
    __exportStar((init_dist2(), __toCommonJS(dist_exports)), exports);
    function oauth22(options) {
      const providers = {};
      for (const provider of Object.keys(options)) {
        providers[provider] = new arctic[provider](...options[provider]);
      }
      return new elysia_1.default({ name: "elysia-oauth2" }).error("OAUTH2_REQUEST_ERROR", arctic.OAuth2RequestError).derive({ as: "global" }, ({ set, cookie, query }) => {
        return {
          oauth2: {
            createURL: async (provider, ...options2) => {
              const state = arctic.generateState();
              cookie.state.value = state;
              cookie.state.maxAge = 60 * 10;
              if (providers[provider].validateAuthorizationCode.length === 2) {
                const codeVerifier = arctic.generateCodeVerifier();
                cookie.codeVerifier.value = codeVerifier;
                cookie.codeVerifier.maxAge = 60 * 10;
                options2.unshift(codeVerifier);
              }
              return providers[provider].createAuthorizationURL(state, ...options2);
            },
            // TODO: reuse createURL method
            redirect: async (provider, ...options2) => {
              const state = arctic.generateState();
              cookie.state.value = state;
              cookie.state.maxAge = 60 * 10;
              if (providers[provider].validateAuthorizationCode.length === 2) {
                const codeVerifier = arctic.generateCodeVerifier();
                cookie.codeVerifier.value = codeVerifier;
                cookie.codeVerifier.maxAge = 60 * 10;
                options2.unshift(codeVerifier);
              }
              const url = await providers[provider].createAuthorizationURL(state, ...options2);
              set.redirect = url.href;
            },
            authorize: async (provider, ...options2) => {
              if (cookie.state.value !== query.state)
                throw Error("state mismatch");
              cookie.state.remove();
              if (providers[provider].validateAuthorizationCode.length === 2) {
                if (!cookie.codeVerifier.value)
                  throw new Error(`Bug with ${String(provider)} and codeVerifier. Please open issue`);
                options2.unshift(cookie.codeVerifier.value);
                cookie.codeVerifier.remove();
              }
              const tokens = await providers[provider].validateAuthorizationCode(query.code, ...options2);
              return tokens;
            },
            refresh: async (provider, ...options2) => {
              const tokens = await providers[provider].refreshAccessToken(...options2);
              return tokens;
            }
          }
        };
      });
    }
    exports.oauth2 = oauth22;
  }
});

// node_modules/fast-xml-parser/src/util.js
var require_util = __commonJS({
  "node_modules/fast-xml-parser/src/util.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
    var nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
    var nameRegexp = "[" + nameStartChar + "][" + nameChar + "]*";
    var regexName = new RegExp("^" + nameRegexp + "$");
    var getAllMatches = function(string3, regex2) {
      const matches = [];
      let match = regex2.exec(string3);
      while (match) {
        const allmatches = [];
        allmatches.startIndex = regex2.lastIndex - match[0].length;
        const len = match.length;
        for (let index3 = 0; index3 < len; index3++) {
          allmatches.push(match[index3]);
        }
        matches.push(allmatches);
        match = regex2.exec(string3);
      }
      return matches;
    };
    var isName = function(string3) {
      const match = regexName.exec(string3);
      return !(match === null || typeof match === "undefined");
    };
    exports.isExist = function(v2) {
      return typeof v2 !== "undefined";
    };
    exports.isEmptyObject = function(obj) {
      return Object.keys(obj).length === 0;
    };
    exports.merge = function(target, a2, arrayMode) {
      if (a2) {
        const keys3 = Object.keys(a2);
        const len = keys3.length;
        for (let i2 = 0; i2 < len; i2++) {
          if (arrayMode === "strict") {
            target[keys3[i2]] = [a2[keys3[i2]]];
          } else {
            target[keys3[i2]] = a2[keys3[i2]];
          }
        }
      }
    };
    exports.getValue = function(v2) {
      if (exports.isExist(v2)) {
        return v2;
      } else {
        return "";
      }
    };
    exports.isName = isName;
    exports.getAllMatches = getAllMatches;
    exports.nameRegexp = nameRegexp;
  }
});

// node_modules/fast-xml-parser/src/validator.js
var require_validator = __commonJS({
  "node_modules/fast-xml-parser/src/validator.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var util = require_util();
    var defaultOptions = {
      allowBooleanAttributes: false,
      //A tag can have attributes without any value
      unpairedTags: []
    };
    exports.validate = function(xmlData, options) {
      options = Object.assign({}, defaultOptions, options);
      const tags = [];
      let tagFound = false;
      let reachedRoot = false;
      if (xmlData[0] === "\uFEFF") {
        xmlData = xmlData.substr(1);
      }
      for (let i2 = 0; i2 < xmlData.length; i2++) {
        if (xmlData[i2] === "<" && xmlData[i2 + 1] === "?") {
          i2 += 2;
          i2 = readPI(xmlData, i2);
          if (i2.err)
            return i2;
        } else if (xmlData[i2] === "<") {
          let tagStartPos = i2;
          i2++;
          if (xmlData[i2] === "!") {
            i2 = readCommentAndCDATA(xmlData, i2);
            continue;
          } else {
            let closingTag = false;
            if (xmlData[i2] === "/") {
              closingTag = true;
              i2++;
            }
            let tagName = "";
            for (; i2 < xmlData.length && xmlData[i2] !== ">" && xmlData[i2] !== " " && xmlData[i2] !== "	" && xmlData[i2] !== "\n" && xmlData[i2] !== "\r"; i2++) {
              tagName += xmlData[i2];
            }
            tagName = tagName.trim();
            if (tagName[tagName.length - 1] === "/") {
              tagName = tagName.substring(0, tagName.length - 1);
              i2--;
            }
            if (!validateTagName(tagName)) {
              let msg;
              if (tagName.trim().length === 0) {
                msg = "Invalid space after '<'.";
              } else {
                msg = "Tag '" + tagName + "' is an invalid name.";
              }
              return getErrorObject("InvalidTag", msg, getLineNumberForPosition(xmlData, i2));
            }
            const result = readAttributeStr(xmlData, i2);
            if (result === false) {
              return getErrorObject("InvalidAttr", "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i2));
            }
            let attrStr = result.value;
            i2 = result.index;
            if (attrStr[attrStr.length - 1] === "/") {
              const attrStrStart = i2 - attrStr.length;
              attrStr = attrStr.substring(0, attrStr.length - 1);
              const isValid = validateAttributeString(attrStr, options);
              if (isValid === true) {
                tagFound = true;
              } else {
                return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
              }
            } else if (closingTag) {
              if (!result.tagClosed) {
                return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i2));
              } else if (attrStr.trim().length > 0) {
                return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
              } else if (tags.length === 0) {
                return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' has not been opened.", getLineNumberForPosition(xmlData, tagStartPos));
              } else {
                const otg = tags.pop();
                if (tagName !== otg.tagName) {
                  let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
                  return getErrorObject(
                    "InvalidTag",
                    "Expected closing tag '" + otg.tagName + "' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag '" + tagName + "'.",
                    getLineNumberForPosition(xmlData, tagStartPos)
                  );
                }
                if (tags.length == 0) {
                  reachedRoot = true;
                }
              }
            } else {
              const isValid = validateAttributeString(attrStr, options);
              if (isValid !== true) {
                return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i2 - attrStr.length + isValid.err.line));
              }
              if (reachedRoot === true) {
                return getErrorObject("InvalidXml", "Multiple possible root nodes found.", getLineNumberForPosition(xmlData, i2));
              } else if (options.unpairedTags.indexOf(tagName) !== -1) {
              } else {
                tags.push({ tagName, tagStartPos });
              }
              tagFound = true;
            }
            for (i2++; i2 < xmlData.length; i2++) {
              if (xmlData[i2] === "<") {
                if (xmlData[i2 + 1] === "!") {
                  i2++;
                  i2 = readCommentAndCDATA(xmlData, i2);
                  continue;
                } else if (xmlData[i2 + 1] === "?") {
                  i2 = readPI(xmlData, ++i2);
                  if (i2.err)
                    return i2;
                } else {
                  break;
                }
              } else if (xmlData[i2] === "&") {
                const afterAmp = validateAmpersand(xmlData, i2);
                if (afterAmp == -1)
                  return getErrorObject("InvalidChar", "char '&' is not expected.", getLineNumberForPosition(xmlData, i2));
                i2 = afterAmp;
              } else {
                if (reachedRoot === true && !isWhiteSpace(xmlData[i2])) {
                  return getErrorObject("InvalidXml", "Extra text at the end", getLineNumberForPosition(xmlData, i2));
                }
              }
            }
            if (xmlData[i2] === "<") {
              i2--;
            }
          }
        } else {
          if (isWhiteSpace(xmlData[i2])) {
            continue;
          }
          return getErrorObject("InvalidChar", "char '" + xmlData[i2] + "' is not expected.", getLineNumberForPosition(xmlData, i2));
        }
      }
      if (!tagFound) {
        return getErrorObject("InvalidXml", "Start tag expected.", 1);
      } else if (tags.length == 1) {
        return getErrorObject("InvalidTag", "Unclosed tag '" + tags[0].tagName + "'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
      } else if (tags.length > 0) {
        return getErrorObject("InvalidXml", "Invalid '" + JSON.stringify(tags.map((t3) => t3.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
      }
      return true;
    };
    function isWhiteSpace(char) {
      return char === " " || char === "	" || char === "\n" || char === "\r";
    }
    function readPI(xmlData, i2) {
      const start = i2;
      for (; i2 < xmlData.length; i2++) {
        if (xmlData[i2] == "?" || xmlData[i2] == " ") {
          const tagname = xmlData.substr(start, i2 - start);
          if (i2 > 5 && tagname === "xml") {
            return getErrorObject("InvalidXml", "XML declaration allowed only at the start of the document.", getLineNumberForPosition(xmlData, i2));
          } else if (xmlData[i2] == "?" && xmlData[i2 + 1] == ">") {
            i2++;
            break;
          } else {
            continue;
          }
        }
      }
      return i2;
    }
    function readCommentAndCDATA(xmlData, i2) {
      if (xmlData.length > i2 + 5 && xmlData[i2 + 1] === "-" && xmlData[i2 + 2] === "-") {
        for (i2 += 3; i2 < xmlData.length; i2++) {
          if (xmlData[i2] === "-" && xmlData[i2 + 1] === "-" && xmlData[i2 + 2] === ">") {
            i2 += 2;
            break;
          }
        }
      } else if (xmlData.length > i2 + 8 && xmlData[i2 + 1] === "D" && xmlData[i2 + 2] === "O" && xmlData[i2 + 3] === "C" && xmlData[i2 + 4] === "T" && xmlData[i2 + 5] === "Y" && xmlData[i2 + 6] === "P" && xmlData[i2 + 7] === "E") {
        let angleBracketsCount = 1;
        for (i2 += 8; i2 < xmlData.length; i2++) {
          if (xmlData[i2] === "<") {
            angleBracketsCount++;
          } else if (xmlData[i2] === ">") {
            angleBracketsCount--;
            if (angleBracketsCount === 0) {
              break;
            }
          }
        }
      } else if (xmlData.length > i2 + 9 && xmlData[i2 + 1] === "[" && xmlData[i2 + 2] === "C" && xmlData[i2 + 3] === "D" && xmlData[i2 + 4] === "A" && xmlData[i2 + 5] === "T" && xmlData[i2 + 6] === "A" && xmlData[i2 + 7] === "[") {
        for (i2 += 8; i2 < xmlData.length; i2++) {
          if (xmlData[i2] === "]" && xmlData[i2 + 1] === "]" && xmlData[i2 + 2] === ">") {
            i2 += 2;
            break;
          }
        }
      }
      return i2;
    }
    var doubleQuote = '"';
    var singleQuote = "'";
    function readAttributeStr(xmlData, i2) {
      let attrStr = "";
      let startChar = "";
      let tagClosed = false;
      for (; i2 < xmlData.length; i2++) {
        if (xmlData[i2] === doubleQuote || xmlData[i2] === singleQuote) {
          if (startChar === "") {
            startChar = xmlData[i2];
          } else if (startChar !== xmlData[i2]) {
          } else {
            startChar = "";
          }
        } else if (xmlData[i2] === ">") {
          if (startChar === "") {
            tagClosed = true;
            break;
          }
        }
        attrStr += xmlData[i2];
      }
      if (startChar !== "") {
        return false;
      }
      return {
        value: attrStr,
        index: i2,
        tagClosed
      };
    }
    var validAttrStrRegxp = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
    function validateAttributeString(attrStr, options) {
      const matches = util.getAllMatches(attrStr, validAttrStrRegxp);
      const attrNames = {};
      for (let i2 = 0; i2 < matches.length; i2++) {
        if (matches[i2][1].length === 0) {
          return getErrorObject("InvalidAttr", "Attribute '" + matches[i2][2] + "' has no space in starting.", getPositionFromMatch(matches[i2]));
        } else if (matches[i2][3] !== void 0 && matches[i2][4] === void 0) {
          return getErrorObject("InvalidAttr", "Attribute '" + matches[i2][2] + "' is without value.", getPositionFromMatch(matches[i2]));
        } else if (matches[i2][3] === void 0 && !options.allowBooleanAttributes) {
          return getErrorObject("InvalidAttr", "boolean attribute '" + matches[i2][2] + "' is not allowed.", getPositionFromMatch(matches[i2]));
        }
        const attrName = matches[i2][2];
        if (!validateAttrName(attrName)) {
          return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(matches[i2]));
        }
        if (!attrNames.hasOwnProperty(attrName)) {
          attrNames[attrName] = 1;
        } else {
          return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(matches[i2]));
        }
      }
      return true;
    }
    function validateNumberAmpersand(xmlData, i2) {
      let re2 = /\d/;
      if (xmlData[i2] === "x") {
        i2++;
        re2 = /[\da-fA-F]/;
      }
      for (; i2 < xmlData.length; i2++) {
        if (xmlData[i2] === ";")
          return i2;
        if (!xmlData[i2].match(re2))
          break;
      }
      return -1;
    }
    function validateAmpersand(xmlData, i2) {
      i2++;
      if (xmlData[i2] === ";")
        return -1;
      if (xmlData[i2] === "#") {
        i2++;
        return validateNumberAmpersand(xmlData, i2);
      }
      let count2 = 0;
      for (; i2 < xmlData.length; i2++, count2++) {
        if (xmlData[i2].match(/\w/) && count2 < 20)
          continue;
        if (xmlData[i2] === ";")
          break;
        return -1;
      }
      return i2;
    }
    function getErrorObject(code4, message2, lineNumber) {
      return {
        err: {
          code: code4,
          msg: message2,
          line: lineNumber.line || lineNumber,
          col: lineNumber.col
        }
      };
    }
    function validateAttrName(attrName) {
      return util.isName(attrName);
    }
    function validateTagName(tagname) {
      return util.isName(tagname);
    }
    function getLineNumberForPosition(xmlData, index3) {
      const lines = xmlData.substring(0, index3).split(/\r?\n/);
      return {
        line: lines.length,
        // column number is last line's length + 1, because column numbering starts at 1:
        col: lines[lines.length - 1].length + 1
      };
    }
    function getPositionFromMatch(match) {
      return match.startIndex + match[1].length;
    }
  }
});

// node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js
var require_OptionsBuilder = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js"(exports) {
    init_process();
    init_buffer();
    var defaultOptions = {
      preserveOrder: false,
      attributeNamePrefix: "@_",
      attributesGroupName: false,
      textNodeName: "#text",
      ignoreAttributes: true,
      removeNSPrefix: false,
      // remove NS from tag name or attribute name if true
      allowBooleanAttributes: false,
      //a tag can have attributes without any value
      //ignoreRootElement : false,
      parseTagValue: true,
      parseAttributeValue: false,
      trimValues: true,
      //Trim string values of tag and attributes
      cdataPropName: false,
      numberParseOptions: {
        hex: true,
        leadingZeros: true,
        eNotation: true
      },
      tagValueProcessor: function(tagName, val2) {
        return val2;
      },
      attributeValueProcessor: function(attrName, val2) {
        return val2;
      },
      stopNodes: [],
      //nested tags will not be parsed even for errors
      alwaysCreateTextNode: false,
      isArray: () => false,
      commentPropName: false,
      unpairedTags: [],
      processEntities: true,
      htmlEntities: false,
      ignoreDeclaration: false,
      ignorePiTags: false,
      transformTagName: false,
      transformAttributeName: false,
      updateTag: function(tagName, jPath, attrs) {
        return tagName;
      }
      // skipEmptyListItem: false
    };
    var buildOptions = function(options) {
      return Object.assign({}, defaultOptions, options);
    };
    exports.buildOptions = buildOptions;
    exports.defaultOptions = defaultOptions;
  }
});

// node_modules/fast-xml-parser/src/xmlparser/xmlNode.js
var require_xmlNode = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/xmlNode.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var XmlNode2 = class {
      constructor(tagname) {
        this.tagname = tagname;
        this.child = [];
        this[":@"] = {};
      }
      add(key2, val2) {
        if (key2 === "__proto__")
          key2 = "#__proto__";
        this.child.push({ [key2]: val2 });
      }
      addChild(node3) {
        if (node3.tagname === "__proto__")
          node3.tagname = "#__proto__";
        if (node3[":@"] && Object.keys(node3[":@"]).length > 0) {
          this.child.push({ [node3.tagname]: node3.child, [":@"]: node3[":@"] });
        } else {
          this.child.push({ [node3.tagname]: node3.child });
        }
      }
    };
    module.exports = XmlNode2;
  }
});

// node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js
var require_DocTypeReader = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js"(exports, module) {
    init_process();
    init_buffer();
    var util = require_util();
    function readDocType(xmlData, i2) {
      const entities = {};
      if (xmlData[i2 + 3] === "O" && xmlData[i2 + 4] === "C" && xmlData[i2 + 5] === "T" && xmlData[i2 + 6] === "Y" && xmlData[i2 + 7] === "P" && xmlData[i2 + 8] === "E") {
        i2 = i2 + 9;
        let angleBracketsCount = 1;
        let hasBody = false, comment2 = false;
        let exp = "";
        for (; i2 < xmlData.length; i2++) {
          if (xmlData[i2] === "<" && !comment2) {
            if (hasBody && isEntity(xmlData, i2)) {
              i2 += 7;
              [entityName, val, i2] = readEntityExp(xmlData, i2 + 1);
              if (val.indexOf("&") === -1)
                entities[validateEntityName(entityName)] = {
                  regx: RegExp(`&${entityName};`, "g"),
                  val
                };
            } else if (hasBody && isElement(xmlData, i2))
              i2 += 8;
            else if (hasBody && isAttlist(xmlData, i2))
              i2 += 8;
            else if (hasBody && isNotation(xmlData, i2))
              i2 += 9;
            else if (isComment)
              comment2 = true;
            else
              throw new Error("Invalid DOCTYPE");
            angleBracketsCount++;
            exp = "";
          } else if (xmlData[i2] === ">") {
            if (comment2) {
              if (xmlData[i2 - 1] === "-" && xmlData[i2 - 2] === "-") {
                comment2 = false;
                angleBracketsCount--;
              }
            } else {
              angleBracketsCount--;
            }
            if (angleBracketsCount === 0) {
              break;
            }
          } else if (xmlData[i2] === "[") {
            hasBody = true;
          } else {
            exp += xmlData[i2];
          }
        }
        if (angleBracketsCount !== 0) {
          throw new Error(`Unclosed DOCTYPE`);
        }
      } else {
        throw new Error(`Invalid Tag instead of DOCTYPE`);
      }
      return { entities, i: i2 };
    }
    function readEntityExp(xmlData, i2) {
      let entityName2 = "";
      for (; i2 < xmlData.length && (xmlData[i2] !== "'" && xmlData[i2] !== '"'); i2++) {
        entityName2 += xmlData[i2];
      }
      entityName2 = entityName2.trim();
      if (entityName2.indexOf(" ") !== -1)
        throw new Error("External entites are not supported");
      const startChar = xmlData[i2++];
      let val2 = "";
      for (; i2 < xmlData.length && xmlData[i2] !== startChar; i2++) {
        val2 += xmlData[i2];
      }
      return [entityName2, val2, i2];
    }
    function isComment(xmlData, i2) {
      if (xmlData[i2 + 1] === "!" && xmlData[i2 + 2] === "-" && xmlData[i2 + 3] === "-")
        return true;
      return false;
    }
    function isEntity(xmlData, i2) {
      if (xmlData[i2 + 1] === "!" && xmlData[i2 + 2] === "E" && xmlData[i2 + 3] === "N" && xmlData[i2 + 4] === "T" && xmlData[i2 + 5] === "I" && xmlData[i2 + 6] === "T" && xmlData[i2 + 7] === "Y")
        return true;
      return false;
    }
    function isElement(xmlData, i2) {
      if (xmlData[i2 + 1] === "!" && xmlData[i2 + 2] === "E" && xmlData[i2 + 3] === "L" && xmlData[i2 + 4] === "E" && xmlData[i2 + 5] === "M" && xmlData[i2 + 6] === "E" && xmlData[i2 + 7] === "N" && xmlData[i2 + 8] === "T")
        return true;
      return false;
    }
    function isAttlist(xmlData, i2) {
      if (xmlData[i2 + 1] === "!" && xmlData[i2 + 2] === "A" && xmlData[i2 + 3] === "T" && xmlData[i2 + 4] === "T" && xmlData[i2 + 5] === "L" && xmlData[i2 + 6] === "I" && xmlData[i2 + 7] === "S" && xmlData[i2 + 8] === "T")
        return true;
      return false;
    }
    function isNotation(xmlData, i2) {
      if (xmlData[i2 + 1] === "!" && xmlData[i2 + 2] === "N" && xmlData[i2 + 3] === "O" && xmlData[i2 + 4] === "T" && xmlData[i2 + 5] === "A" && xmlData[i2 + 6] === "T" && xmlData[i2 + 7] === "I" && xmlData[i2 + 8] === "O" && xmlData[i2 + 9] === "N")
        return true;
      return false;
    }
    function validateEntityName(name) {
      if (util.isName(name))
        return name;
      else
        throw new Error(`Invalid entity name ${name}`);
    }
    module.exports = readDocType;
  }
});

// node_modules/strnum/strnum.js
var require_strnum = __commonJS({
  "node_modules/strnum/strnum.js"(exports, module) {
    init_process();
    init_buffer();
    var hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
    var numRegex = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
    if (!Number.parseInt && window.parseInt) {
      Number.parseInt = window.parseInt;
    }
    if (!Number.parseFloat && window.parseFloat) {
      Number.parseFloat = window.parseFloat;
    }
    var consider = {
      hex: true,
      leadingZeros: true,
      decimalPoint: ".",
      eNotation: true
      //skipLike: /regex/
    };
    function toNumber(str, options = {}) {
      options = Object.assign({}, consider, options);
      if (!str || typeof str !== "string")
        return str;
      let trimmedStr = str.trim();
      if (options.skipLike !== void 0 && options.skipLike.test(trimmedStr))
        return str;
      else if (options.hex && hexRegex.test(trimmedStr)) {
        return Number.parseInt(trimmedStr, 16);
      } else {
        const match = numRegex.exec(trimmedStr);
        if (match) {
          const sign2 = match[1];
          const leadingZeros = match[2];
          let numTrimmedByZeros = trimZeros(match[3]);
          const eNotation = match[4] || match[6];
          if (!options.leadingZeros && leadingZeros.length > 0 && sign2 && trimmedStr[2] !== ".")
            return str;
          else if (!options.leadingZeros && leadingZeros.length > 0 && !sign2 && trimmedStr[1] !== ".")
            return str;
          else {
            const num = Number(trimmedStr);
            const numStr = "" + num;
            if (numStr.search(/[eE]/) !== -1) {
              if (options.eNotation)
                return num;
              else
                return str;
            } else if (eNotation) {
              if (options.eNotation)
                return num;
              else
                return str;
            } else if (trimmedStr.indexOf(".") !== -1) {
              if (numStr === "0" && numTrimmedByZeros === "")
                return num;
              else if (numStr === numTrimmedByZeros)
                return num;
              else if (sign2 && numStr === "-" + numTrimmedByZeros)
                return num;
              else
                return str;
            }
            if (leadingZeros) {
              if (numTrimmedByZeros === numStr)
                return num;
              else if (sign2 + numTrimmedByZeros === numStr)
                return num;
              else
                return str;
            }
            if (trimmedStr === numStr)
              return num;
            else if (trimmedStr === sign2 + numStr)
              return num;
            return str;
          }
        } else {
          return str;
        }
      }
    }
    function trimZeros(numStr) {
      if (numStr && numStr.indexOf(".") !== -1) {
        numStr = numStr.replace(/0+$/, "");
        if (numStr === ".")
          numStr = "0";
        else if (numStr[0] === ".")
          numStr = "0" + numStr;
        else if (numStr[numStr.length - 1] === ".")
          numStr = numStr.substr(0, numStr.length - 1);
        return numStr;
      }
      return numStr;
    }
    module.exports = toNumber;
  }
});

// node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js
var require_OrderedObjParser = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var util = require_util();
    var xmlNode = require_xmlNode();
    var readDocType = require_DocTypeReader();
    var toNumber = require_strnum();
    var OrderedObjParser = class {
      constructor(options) {
        this.options = options;
        this.currentNode = null;
        this.tagsNodeStack = [];
        this.docTypeEntities = {};
        this.lastEntities = {
          "apos": { regex: /&(apos|#39|#x27);/g, val: "'" },
          "gt": { regex: /&(gt|#62|#x3E);/g, val: ">" },
          "lt": { regex: /&(lt|#60|#x3C);/g, val: "<" },
          "quot": { regex: /&(quot|#34|#x22);/g, val: '"' }
        };
        this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" };
        this.htmlEntities = {
          "space": { regex: /&(nbsp|#160);/g, val: " " },
          // "lt" : { regex: /&(lt|#60);/g, val: "<" },
          // "gt" : { regex: /&(gt|#62);/g, val: ">" },
          // "amp" : { regex: /&(amp|#38);/g, val: "&" },
          // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
          // "apos" : { regex: /&(apos|#39);/g, val: "'" },
          "cent": { regex: /&(cent|#162);/g, val: "\xA2" },
          "pound": { regex: /&(pound|#163);/g, val: "\xA3" },
          "yen": { regex: /&(yen|#165);/g, val: "\xA5" },
          "euro": { regex: /&(euro|#8364);/g, val: "\u20AC" },
          "copyright": { regex: /&(copy|#169);/g, val: "\xA9" },
          "reg": { regex: /&(reg|#174);/g, val: "\xAE" },
          "inr": { regex: /&(inr|#8377);/g, val: "\u20B9" },
          "num_dec": { regex: /&#([0-9]{1,7});/g, val: (_, str) => String.fromCharCode(Number.parseInt(str, 10)) },
          "num_hex": { regex: /&#x([0-9a-fA-F]{1,6});/g, val: (_, str) => String.fromCharCode(Number.parseInt(str, 16)) }
        };
        this.addExternalEntities = addExternalEntities;
        this.parseXml = parseXml;
        this.parseTextData = parseTextData;
        this.resolveNameSpace = resolveNameSpace;
        this.buildAttributesMap = buildAttributesMap;
        this.isItStopNode = isItStopNode;
        this.replaceEntitiesValue = replaceEntitiesValue;
        this.readStopNodeData = readStopNodeData;
        this.saveTextToParentTag = saveTextToParentTag;
        this.addChild = addChild;
      }
    };
    function addExternalEntities(externalEntities) {
      const entKeys = Object.keys(externalEntities);
      for (let i2 = 0; i2 < entKeys.length; i2++) {
        const ent = entKeys[i2];
        this.lastEntities[ent] = {
          regex: new RegExp("&" + ent + ";", "g"),
          val: externalEntities[ent]
        };
      }
    }
    function parseTextData(val2, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
      if (val2 !== void 0) {
        if (this.options.trimValues && !dontTrim) {
          val2 = val2.trim();
        }
        if (val2.length > 0) {
          if (!escapeEntities)
            val2 = this.replaceEntitiesValue(val2);
          const newval = this.options.tagValueProcessor(tagName, val2, jPath, hasAttributes, isLeafNode);
          if (newval === null || newval === void 0) {
            return val2;
          } else if (typeof newval !== typeof val2 || newval !== val2) {
            return newval;
          } else if (this.options.trimValues) {
            return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
          } else {
            const trimmedVal = val2.trim();
            if (trimmedVal === val2) {
              return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
            } else {
              return val2;
            }
          }
        }
      }
    }
    function resolveNameSpace(tagname) {
      if (this.options.removeNSPrefix) {
        const tags = tagname.split(":");
        const prefix = tagname.charAt(0) === "/" ? "/" : "";
        if (tags[0] === "xmlns") {
          return "";
        }
        if (tags.length === 2) {
          tagname = prefix + tags[1];
        }
      }
      return tagname;
    }
    var attrsRegx = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
    function buildAttributesMap(attrStr, jPath, tagName) {
      if (!this.options.ignoreAttributes && typeof attrStr === "string") {
        const matches = util.getAllMatches(attrStr, attrsRegx);
        const len = matches.length;
        const attrs = {};
        for (let i2 = 0; i2 < len; i2++) {
          const attrName = this.resolveNameSpace(matches[i2][1]);
          let oldVal = matches[i2][4];
          let aName = this.options.attributeNamePrefix + attrName;
          if (attrName.length) {
            if (this.options.transformAttributeName) {
              aName = this.options.transformAttributeName(aName);
            }
            if (aName === "__proto__")
              aName = "#__proto__";
            if (oldVal !== void 0) {
              if (this.options.trimValues) {
                oldVal = oldVal.trim();
              }
              oldVal = this.replaceEntitiesValue(oldVal);
              const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
              if (newVal === null || newVal === void 0) {
                attrs[aName] = oldVal;
              } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {
                attrs[aName] = newVal;
              } else {
                attrs[aName] = parseValue(
                  oldVal,
                  this.options.parseAttributeValue,
                  this.options.numberParseOptions
                );
              }
            } else if (this.options.allowBooleanAttributes) {
              attrs[aName] = true;
            }
          }
        }
        if (!Object.keys(attrs).length) {
          return;
        }
        if (this.options.attributesGroupName) {
          const attrCollection = {};
          attrCollection[this.options.attributesGroupName] = attrs;
          return attrCollection;
        }
        return attrs;
      }
    }
    var parseXml = function(xmlData) {
      xmlData = xmlData.replace(/\r\n?/g, "\n");
      const xmlObj = new xmlNode("!xml");
      let currentNode = xmlObj;
      let textData = "";
      let jPath = "";
      for (let i2 = 0; i2 < xmlData.length; i2++) {
        const ch2 = xmlData[i2];
        if (ch2 === "<") {
          if (xmlData[i2 + 1] === "/") {
            const closeIndex = findClosingIndex(xmlData, ">", i2, "Closing Tag is not closed.");
            let tagName = xmlData.substring(i2 + 2, closeIndex).trim();
            if (this.options.removeNSPrefix) {
              const colonIndex = tagName.indexOf(":");
              if (colonIndex !== -1) {
                tagName = tagName.substr(colonIndex + 1);
              }
            }
            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }
            if (currentNode) {
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
            }
            const lastTagName = jPath.substring(jPath.lastIndexOf(".") + 1);
            if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {
              throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
            }
            let propIndex = 0;
            if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {
              propIndex = jPath.lastIndexOf(".", jPath.lastIndexOf(".") - 1);
              this.tagsNodeStack.pop();
            } else {
              propIndex = jPath.lastIndexOf(".");
            }
            jPath = jPath.substring(0, propIndex);
            currentNode = this.tagsNodeStack.pop();
            textData = "";
            i2 = closeIndex;
          } else if (xmlData[i2 + 1] === "?") {
            let tagData = readTagExp(xmlData, i2, false, "?>");
            if (!tagData)
              throw new Error("Pi Tag is not closed.");
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            if (this.options.ignoreDeclaration && tagData.tagName === "?xml" || this.options.ignorePiTags) {
            } else {
              const childNode = new xmlNode(tagData.tagName);
              childNode.add(this.options.textNodeName, "");
              if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
              }
              this.addChild(currentNode, childNode, jPath);
            }
            i2 = tagData.closeIndex + 1;
          } else if (xmlData.substr(i2 + 1, 3) === "!--") {
            const endIndex = findClosingIndex(xmlData, "-->", i2 + 4, "Comment is not closed.");
            if (this.options.commentPropName) {
              const comment2 = xmlData.substring(i2 + 4, endIndex - 2);
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
              currentNode.add(this.options.commentPropName, [{ [this.options.textNodeName]: comment2 }]);
            }
            i2 = endIndex;
          } else if (xmlData.substr(i2 + 1, 2) === "!D") {
            const result = readDocType(xmlData, i2);
            this.docTypeEntities = result.entities;
            i2 = result.i;
          } else if (xmlData.substr(i2 + 1, 2) === "![") {
            const closeIndex = findClosingIndex(xmlData, "]]>", i2, "CDATA is not closed.") - 2;
            const tagExp = xmlData.substring(i2 + 9, closeIndex);
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            let val2 = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);
            if (val2 == void 0)
              val2 = "";
            if (this.options.cdataPropName) {
              currentNode.add(this.options.cdataPropName, [{ [this.options.textNodeName]: tagExp }]);
            } else {
              currentNode.add(this.options.textNodeName, val2);
            }
            i2 = closeIndex + 2;
          } else {
            let result = readTagExp(xmlData, i2, this.options.removeNSPrefix);
            let tagName = result.tagName;
            const rawTagName = result.rawTagName;
            let tagExp = result.tagExp;
            let attrExpPresent = result.attrExpPresent;
            let closeIndex = result.closeIndex;
            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }
            if (currentNode && textData) {
              if (currentNode.tagname !== "!xml") {
                textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
              }
            }
            const lastTag = currentNode;
            if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {
              currentNode = this.tagsNodeStack.pop();
              jPath = jPath.substring(0, jPath.lastIndexOf("."));
            }
            if (tagName !== xmlObj.tagname) {
              jPath += jPath ? "." + tagName : tagName;
            }
            if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
              let tagContent = "";
              if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                if (tagName[tagName.length - 1] === "/") {
                  tagName = tagName.substr(0, tagName.length - 1);
                  jPath = jPath.substr(0, jPath.length - 1);
                  tagExp = tagName;
                } else {
                  tagExp = tagExp.substr(0, tagExp.length - 1);
                }
                i2 = result.closeIndex;
              } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {
                i2 = result.closeIndex;
              } else {
                const result2 = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);
                if (!result2)
                  throw new Error(`Unexpected end of ${rawTagName}`);
                i2 = result2.i;
                tagContent = result2.tagContent;
              }
              const childNode = new xmlNode(tagName);
              if (tagName !== tagExp && attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
              }
              if (tagContent) {
                tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
              }
              jPath = jPath.substr(0, jPath.lastIndexOf("."));
              childNode.add(this.options.textNodeName, tagContent);
              this.addChild(currentNode, childNode, jPath);
            } else {
              if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                if (tagName[tagName.length - 1] === "/") {
                  tagName = tagName.substr(0, tagName.length - 1);
                  jPath = jPath.substr(0, jPath.length - 1);
                  tagExp = tagName;
                } else {
                  tagExp = tagExp.substr(0, tagExp.length - 1);
                }
                if (this.options.transformTagName) {
                  tagName = this.options.transformTagName(tagName);
                }
                const childNode = new xmlNode(tagName);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                }
                this.addChild(currentNode, childNode, jPath);
                jPath = jPath.substr(0, jPath.lastIndexOf("."));
              } else {
                const childNode = new xmlNode(tagName);
                this.tagsNodeStack.push(currentNode);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                }
                this.addChild(currentNode, childNode, jPath);
                currentNode = childNode;
              }
              textData = "";
              i2 = closeIndex;
            }
          }
        } else {
          textData += xmlData[i2];
        }
      }
      return xmlObj.child;
    };
    function addChild(currentNode, childNode, jPath) {
      const result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"]);
      if (result === false) {
      } else if (typeof result === "string") {
        childNode.tagname = result;
        currentNode.addChild(childNode);
      } else {
        currentNode.addChild(childNode);
      }
    }
    var replaceEntitiesValue = function(val2) {
      if (this.options.processEntities) {
        for (let entityName2 in this.docTypeEntities) {
          const entity = this.docTypeEntities[entityName2];
          val2 = val2.replace(entity.regx, entity.val);
        }
        for (let entityName2 in this.lastEntities) {
          const entity = this.lastEntities[entityName2];
          val2 = val2.replace(entity.regex, entity.val);
        }
        if (this.options.htmlEntities) {
          for (let entityName2 in this.htmlEntities) {
            const entity = this.htmlEntities[entityName2];
            val2 = val2.replace(entity.regex, entity.val);
          }
        }
        val2 = val2.replace(this.ampEntity.regex, this.ampEntity.val);
      }
      return val2;
    };
    function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
      if (textData) {
        if (isLeafNode === void 0)
          isLeafNode = Object.keys(currentNode.child).length === 0;
        textData = this.parseTextData(
          textData,
          currentNode.tagname,
          jPath,
          false,
          currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false,
          isLeafNode
        );
        if (textData !== void 0 && textData !== "")
          currentNode.add(this.options.textNodeName, textData);
        textData = "";
      }
      return textData;
    }
    function isItStopNode(stopNodes, jPath, currentTagName) {
      const allNodesExp = "*." + currentTagName;
      for (const stopNodePath in stopNodes) {
        const stopNodeExp = stopNodes[stopNodePath];
        if (allNodesExp === stopNodeExp || jPath === stopNodeExp)
          return true;
      }
      return false;
    }
    function tagExpWithClosingIndex(xmlData, i2, closingChar = ">") {
      let attrBoundary;
      let tagExp = "";
      for (let index3 = i2; index3 < xmlData.length; index3++) {
        let ch2 = xmlData[index3];
        if (attrBoundary) {
          if (ch2 === attrBoundary)
            attrBoundary = "";
        } else if (ch2 === '"' || ch2 === "'") {
          attrBoundary = ch2;
        } else if (ch2 === closingChar[0]) {
          if (closingChar[1]) {
            if (xmlData[index3 + 1] === closingChar[1]) {
              return {
                data: tagExp,
                index: index3
              };
            }
          } else {
            return {
              data: tagExp,
              index: index3
            };
          }
        } else if (ch2 === "	") {
          ch2 = " ";
        }
        tagExp += ch2;
      }
    }
    function findClosingIndex(xmlData, str, i2, errMsg) {
      const closingIndex = xmlData.indexOf(str, i2);
      if (closingIndex === -1) {
        throw new Error(errMsg);
      } else {
        return closingIndex + str.length - 1;
      }
    }
    function readTagExp(xmlData, i2, removeNSPrefix, closingChar = ">") {
      const result = tagExpWithClosingIndex(xmlData, i2 + 1, closingChar);
      if (!result)
        return;
      let tagExp = result.data;
      const closeIndex = result.index;
      const separatorIndex = tagExp.search(/\s/);
      let tagName = tagExp;
      let attrExpPresent = true;
      if (separatorIndex !== -1) {
        tagName = tagExp.substring(0, separatorIndex);
        tagExp = tagExp.substring(separatorIndex + 1).trimStart();
      }
      const rawTagName = tagName;
      if (removeNSPrefix) {
        const colonIndex = tagName.indexOf(":");
        if (colonIndex !== -1) {
          tagName = tagName.substr(colonIndex + 1);
          attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
        }
      }
      return {
        tagName,
        tagExp,
        closeIndex,
        attrExpPresent,
        rawTagName
      };
    }
    function readStopNodeData(xmlData, tagName, i2) {
      const startIndex = i2;
      let openTagCount = 1;
      for (; i2 < xmlData.length; i2++) {
        if (xmlData[i2] === "<") {
          if (xmlData[i2 + 1] === "/") {
            const closeIndex = findClosingIndex(xmlData, ">", i2, `${tagName} is not closed`);
            let closeTagName = xmlData.substring(i2 + 2, closeIndex).trim();
            if (closeTagName === tagName) {
              openTagCount--;
              if (openTagCount === 0) {
                return {
                  tagContent: xmlData.substring(startIndex, i2),
                  i: closeIndex
                };
              }
            }
            i2 = closeIndex;
          } else if (xmlData[i2 + 1] === "?") {
            const closeIndex = findClosingIndex(xmlData, "?>", i2 + 1, "StopNode is not closed.");
            i2 = closeIndex;
          } else if (xmlData.substr(i2 + 1, 3) === "!--") {
            const closeIndex = findClosingIndex(xmlData, "-->", i2 + 3, "StopNode is not closed.");
            i2 = closeIndex;
          } else if (xmlData.substr(i2 + 1, 2) === "![") {
            const closeIndex = findClosingIndex(xmlData, "]]>", i2, "StopNode is not closed.") - 2;
            i2 = closeIndex;
          } else {
            const tagData = readTagExp(xmlData, i2, ">");
            if (tagData) {
              const openTagName = tagData && tagData.tagName;
              if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== "/") {
                openTagCount++;
              }
              i2 = tagData.closeIndex;
            }
          }
        }
      }
    }
    function parseValue(val2, shouldParse, options) {
      if (shouldParse && typeof val2 === "string") {
        const newval = val2.trim();
        if (newval === "true")
          return true;
        else if (newval === "false")
          return false;
        else
          return toNumber(val2, options);
      } else {
        if (util.isExist(val2)) {
          return val2;
        } else {
          return "";
        }
      }
    }
    module.exports = OrderedObjParser;
  }
});

// node_modules/fast-xml-parser/src/xmlparser/node2json.js
var require_node2json = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/node2json.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    function prettify(node3, options) {
      return compress(node3, options);
    }
    function compress(arr, options, jPath) {
      let text8;
      const compressedObj = {};
      for (let i2 = 0; i2 < arr.length; i2++) {
        const tagObj = arr[i2];
        const property = propName(tagObj);
        let newJpath = "";
        if (jPath === void 0)
          newJpath = property;
        else
          newJpath = jPath + "." + property;
        if (property === options.textNodeName) {
          if (text8 === void 0)
            text8 = tagObj[property];
          else
            text8 += "" + tagObj[property];
        } else if (property === void 0) {
          continue;
        } else if (tagObj[property]) {
          let val2 = compress(tagObj[property], options, newJpath);
          const isLeaf = isLeafTag(val2, options);
          if (tagObj[":@"]) {
            assignAttributes(val2, tagObj[":@"], newJpath, options);
          } else if (Object.keys(val2).length === 1 && val2[options.textNodeName] !== void 0 && !options.alwaysCreateTextNode) {
            val2 = val2[options.textNodeName];
          } else if (Object.keys(val2).length === 0) {
            if (options.alwaysCreateTextNode)
              val2[options.textNodeName] = "";
            else
              val2 = "";
          }
          if (compressedObj[property] !== void 0 && compressedObj.hasOwnProperty(property)) {
            if (!Array.isArray(compressedObj[property])) {
              compressedObj[property] = [compressedObj[property]];
            }
            compressedObj[property].push(val2);
          } else {
            if (options.isArray(property, newJpath, isLeaf)) {
              compressedObj[property] = [val2];
            } else {
              compressedObj[property] = val2;
            }
          }
        }
      }
      if (typeof text8 === "string") {
        if (text8.length > 0)
          compressedObj[options.textNodeName] = text8;
      } else if (text8 !== void 0)
        compressedObj[options.textNodeName] = text8;
      return compressedObj;
    }
    function propName(obj) {
      const keys3 = Object.keys(obj);
      for (let i2 = 0; i2 < keys3.length; i2++) {
        const key2 = keys3[i2];
        if (key2 !== ":@")
          return key2;
      }
    }
    function assignAttributes(obj, attrMap, jpath, options) {
      if (attrMap) {
        const keys3 = Object.keys(attrMap);
        const len = keys3.length;
        for (let i2 = 0; i2 < len; i2++) {
          const atrrName = keys3[i2];
          if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
            obj[atrrName] = [attrMap[atrrName]];
          } else {
            obj[atrrName] = attrMap[atrrName];
          }
        }
      }
    }
    function isLeafTag(obj, options) {
      const { textNodeName } = options;
      const propCount = Object.keys(obj).length;
      if (propCount === 0) {
        return true;
      }
      if (propCount === 1 && (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)) {
        return true;
      }
      return false;
    }
    exports.prettify = prettify;
  }
});

// node_modules/fast-xml-parser/src/xmlparser/XMLParser.js
var require_XMLParser = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/XMLParser.js"(exports, module) {
    init_process();
    init_buffer();
    var { buildOptions } = require_OptionsBuilder();
    var OrderedObjParser = require_OrderedObjParser();
    var { prettify } = require_node2json();
    var validator = require_validator();
    var XMLParser3 = class {
      constructor(options) {
        this.externalEntities = {};
        this.options = buildOptions(options);
      }
      /**
       * Parse XML dats to JS object 
       * @param {string|Buffer} xmlData 
       * @param {boolean|Object} validationOption 
       */
      parse(xmlData, validationOption) {
        if (typeof xmlData === "string") {
        } else if (xmlData.toString) {
          xmlData = xmlData.toString();
        } else {
          throw new Error("XML data is accepted in String or Bytes[] form.");
        }
        if (validationOption) {
          if (validationOption === true)
            validationOption = {};
          const result = validator.validate(xmlData, validationOption);
          if (result !== true) {
            throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);
          }
        }
        const orderedObjParser = new OrderedObjParser(this.options);
        orderedObjParser.addExternalEntities(this.externalEntities);
        const orderedResult = orderedObjParser.parseXml(xmlData);
        if (this.options.preserveOrder || orderedResult === void 0)
          return orderedResult;
        else
          return prettify(orderedResult, this.options);
      }
      /**
       * Add Entity which is not by default supported by this library
       * @param {string} key 
       * @param {string} value 
       */
      addEntity(key2, value) {
        if (value.indexOf("&") !== -1) {
          throw new Error("Entity value can't have '&'");
        } else if (key2.indexOf("&") !== -1 || key2.indexOf(";") !== -1) {
          throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
        } else if (value === "&") {
          throw new Error("An entity with value '&' is not permitted");
        } else {
          this.externalEntities[key2] = value;
        }
      }
    };
    module.exports = XMLParser3;
  }
});

// node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js
var require_orderedJs2Xml = __commonJS({
  "node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js"(exports, module) {
    init_process();
    init_buffer();
    var EOL = "\n";
    function toXml(jArray, options) {
      let indentation = "";
      if (options.format && options.indentBy.length > 0) {
        indentation = EOL;
      }
      return arrToStr(jArray, options, "", indentation);
    }
    function arrToStr(arr, options, jPath, indentation) {
      let xmlStr = "";
      let isPreviousElementTag = false;
      for (let i2 = 0; i2 < arr.length; i2++) {
        const tagObj = arr[i2];
        const tagName = propName(tagObj);
        if (tagName === void 0)
          continue;
        let newJPath = "";
        if (jPath.length === 0)
          newJPath = tagName;
        else
          newJPath = `${jPath}.${tagName}`;
        if (tagName === options.textNodeName) {
          let tagText = tagObj[tagName];
          if (!isStopNode(newJPath, options)) {
            tagText = options.tagValueProcessor(tagName, tagText);
            tagText = replaceEntitiesValue(tagText, options);
          }
          if (isPreviousElementTag) {
            xmlStr += indentation;
          }
          xmlStr += tagText;
          isPreviousElementTag = false;
          continue;
        } else if (tagName === options.cdataPropName) {
          if (isPreviousElementTag) {
            xmlStr += indentation;
          }
          xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
          isPreviousElementTag = false;
          continue;
        } else if (tagName === options.commentPropName) {
          xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
          isPreviousElementTag = true;
          continue;
        } else if (tagName[0] === "?") {
          const attStr2 = attr_to_str(tagObj[":@"], options);
          const tempInd = tagName === "?xml" ? "" : indentation;
          let piTextNodeName = tagObj[tagName][0][options.textNodeName];
          piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : "";
          xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr2}?>`;
          isPreviousElementTag = true;
          continue;
        }
        let newIdentation = indentation;
        if (newIdentation !== "") {
          newIdentation += options.indentBy;
        }
        const attStr = attr_to_str(tagObj[":@"], options);
        const tagStart = indentation + `<${tagName}${attStr}`;
        const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);
        if (options.unpairedTags.indexOf(tagName) !== -1) {
          if (options.suppressUnpairedNode)
            xmlStr += tagStart + ">";
          else
            xmlStr += tagStart + "/>";
        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
          xmlStr += tagStart + "/>";
        } else if (tagValue && tagValue.endsWith(">")) {
          xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
        } else {
          xmlStr += tagStart + ">";
          if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {
            xmlStr += indentation + options.indentBy + tagValue + indentation;
          } else {
            xmlStr += tagValue;
          }
          xmlStr += `</${tagName}>`;
        }
        isPreviousElementTag = true;
      }
      return xmlStr;
    }
    function propName(obj) {
      const keys3 = Object.keys(obj);
      for (let i2 = 0; i2 < keys3.length; i2++) {
        const key2 = keys3[i2];
        if (!obj.hasOwnProperty(key2))
          continue;
        if (key2 !== ":@")
          return key2;
      }
    }
    function attr_to_str(attrMap, options) {
      let attrStr = "";
      if (attrMap && !options.ignoreAttributes) {
        for (let attr in attrMap) {
          if (!attrMap.hasOwnProperty(attr))
            continue;
          let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
          attrVal = replaceEntitiesValue(attrVal, options);
          if (attrVal === true && options.suppressBooleanAttributes) {
            attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
          } else {
            attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
          }
        }
      }
      return attrStr;
    }
    function isStopNode(jPath, options) {
      jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
      let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
      for (let index3 in options.stopNodes) {
        if (options.stopNodes[index3] === jPath || options.stopNodes[index3] === "*." + tagName)
          return true;
      }
      return false;
    }
    function replaceEntitiesValue(textValue, options) {
      if (textValue && textValue.length > 0 && options.processEntities) {
        for (let i2 = 0; i2 < options.entities.length; i2++) {
          const entity = options.entities[i2];
          textValue = textValue.replace(entity.regex, entity.val);
        }
      }
      return textValue;
    }
    module.exports = toXml;
  }
});

// node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js
var require_json2xml = __commonJS({
  "node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var buildFromOrderedJs = require_orderedJs2Xml();
    var defaultOptions = {
      attributeNamePrefix: "@_",
      attributesGroupName: false,
      textNodeName: "#text",
      ignoreAttributes: true,
      cdataPropName: false,
      format: false,
      indentBy: "  ",
      suppressEmptyNode: false,
      suppressUnpairedNode: true,
      suppressBooleanAttributes: true,
      tagValueProcessor: function(key2, a2) {
        return a2;
      },
      attributeValueProcessor: function(attrName, a2) {
        return a2;
      },
      preserveOrder: false,
      commentPropName: false,
      unpairedTags: [],
      entities: [
        { regex: new RegExp("&", "g"), val: "&amp;" },
        //it must be on top
        { regex: new RegExp(">", "g"), val: "&gt;" },
        { regex: new RegExp("<", "g"), val: "&lt;" },
        { regex: new RegExp("'", "g"), val: "&apos;" },
        { regex: new RegExp('"', "g"), val: "&quot;" }
      ],
      processEntities: true,
      stopNodes: [],
      // transformTagName: false,
      // transformAttributeName: false,
      oneListGroup: false
    };
    function Builder(options) {
      this.options = Object.assign({}, defaultOptions, options);
      if (this.options.ignoreAttributes || this.options.attributesGroupName) {
        this.isAttribute = function() {
          return false;
        };
      } else {
        this.attrPrefixLen = this.options.attributeNamePrefix.length;
        this.isAttribute = isAttribute;
      }
      this.processTextOrObjNode = processTextOrObjNode;
      if (this.options.format) {
        this.indentate = indentate;
        this.tagEndChar = ">\n";
        this.newLine = "\n";
      } else {
        this.indentate = function() {
          return "";
        };
        this.tagEndChar = ">";
        this.newLine = "";
      }
    }
    Builder.prototype.build = function(jObj) {
      if (this.options.preserveOrder) {
        return buildFromOrderedJs(jObj, this.options);
      } else {
        if (Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1) {
          jObj = {
            [this.options.arrayNodeName]: jObj
          };
        }
        return this.j2x(jObj, 0).val;
      }
    };
    Builder.prototype.j2x = function(jObj, level) {
      let attrStr = "";
      let val2 = "";
      for (let key2 in jObj) {
        if (!Object.prototype.hasOwnProperty.call(jObj, key2))
          continue;
        if (typeof jObj[key2] === "undefined") {
          if (this.isAttribute(key2)) {
            val2 += "";
          }
        } else if (jObj[key2] === null) {
          if (this.isAttribute(key2)) {
            val2 += "";
          } else if (key2[0] === "?") {
            val2 += this.indentate(level) + "<" + key2 + "?" + this.tagEndChar;
          } else {
            val2 += this.indentate(level) + "<" + key2 + "/" + this.tagEndChar;
          }
        } else if (jObj[key2] instanceof Date) {
          val2 += this.buildTextValNode(jObj[key2], key2, "", level);
        } else if (typeof jObj[key2] !== "object") {
          const attr = this.isAttribute(key2);
          if (attr) {
            attrStr += this.buildAttrPairStr(attr, "" + jObj[key2]);
          } else {
            if (key2 === this.options.textNodeName) {
              let newval = this.options.tagValueProcessor(key2, "" + jObj[key2]);
              val2 += this.replaceEntitiesValue(newval);
            } else {
              val2 += this.buildTextValNode(jObj[key2], key2, "", level);
            }
          }
        } else if (Array.isArray(jObj[key2])) {
          const arrLen = jObj[key2].length;
          let listTagVal = "";
          let listTagAttr = "";
          for (let j2 = 0; j2 < arrLen; j2++) {
            const item = jObj[key2][j2];
            if (typeof item === "undefined") {
            } else if (item === null) {
              if (key2[0] === "?")
                val2 += this.indentate(level) + "<" + key2 + "?" + this.tagEndChar;
              else
                val2 += this.indentate(level) + "<" + key2 + "/" + this.tagEndChar;
            } else if (typeof item === "object") {
              if (this.options.oneListGroup) {
                const result = this.j2x(item, level + 1);
                listTagVal += result.val;
                if (this.options.attributesGroupName && item.hasOwnProperty(this.options.attributesGroupName)) {
                  listTagAttr += result.attrStr;
                }
              } else {
                listTagVal += this.processTextOrObjNode(item, key2, level);
              }
            } else {
              if (this.options.oneListGroup) {
                let textValue = this.options.tagValueProcessor(key2, item);
                textValue = this.replaceEntitiesValue(textValue);
                listTagVal += textValue;
              } else {
                listTagVal += this.buildTextValNode(item, key2, "", level);
              }
            }
          }
          if (this.options.oneListGroup) {
            listTagVal = this.buildObjectNode(listTagVal, key2, listTagAttr, level);
          }
          val2 += listTagVal;
        } else {
          if (this.options.attributesGroupName && key2 === this.options.attributesGroupName) {
            const Ks = Object.keys(jObj[key2]);
            const L2 = Ks.length;
            for (let j2 = 0; j2 < L2; j2++) {
              attrStr += this.buildAttrPairStr(Ks[j2], "" + jObj[key2][Ks[j2]]);
            }
          } else {
            val2 += this.processTextOrObjNode(jObj[key2], key2, level);
          }
        }
      }
      return { attrStr, val: val2 };
    };
    Builder.prototype.buildAttrPairStr = function(attrName, val2) {
      val2 = this.options.attributeValueProcessor(attrName, "" + val2);
      val2 = this.replaceEntitiesValue(val2);
      if (this.options.suppressBooleanAttributes && val2 === "true") {
        return " " + attrName;
      } else
        return " " + attrName + '="' + val2 + '"';
    };
    function processTextOrObjNode(object, key2, level) {
      const result = this.j2x(object, level + 1);
      if (object[this.options.textNodeName] !== void 0 && Object.keys(object).length === 1) {
        return this.buildTextValNode(object[this.options.textNodeName], key2, result.attrStr, level);
      } else {
        return this.buildObjectNode(result.val, key2, result.attrStr, level);
      }
    }
    Builder.prototype.buildObjectNode = function(val2, key2, attrStr, level) {
      if (val2 === "") {
        if (key2[0] === "?")
          return this.indentate(level) + "<" + key2 + attrStr + "?" + this.tagEndChar;
        else {
          return this.indentate(level) + "<" + key2 + attrStr + this.closeTag(key2) + this.tagEndChar;
        }
      } else {
        let tagEndExp = "</" + key2 + this.tagEndChar;
        let piClosingChar = "";
        if (key2[0] === "?") {
          piClosingChar = "?";
          tagEndExp = "";
        }
        if ((attrStr || attrStr === "") && val2.indexOf("<") === -1) {
          return this.indentate(level) + "<" + key2 + attrStr + piClosingChar + ">" + val2 + tagEndExp;
        } else if (this.options.commentPropName !== false && key2 === this.options.commentPropName && piClosingChar.length === 0) {
          return this.indentate(level) + `<!--${val2}-->` + this.newLine;
        } else {
          return this.indentate(level) + "<" + key2 + attrStr + piClosingChar + this.tagEndChar + val2 + this.indentate(level) + tagEndExp;
        }
      }
    };
    Builder.prototype.closeTag = function(key2) {
      let closeTag = "";
      if (this.options.unpairedTags.indexOf(key2) !== -1) {
        if (!this.options.suppressUnpairedNode)
          closeTag = "/";
      } else if (this.options.suppressEmptyNode) {
        closeTag = "/";
      } else {
        closeTag = `></${key2}`;
      }
      return closeTag;
    };
    Builder.prototype.buildTextValNode = function(val2, key2, attrStr, level) {
      if (this.options.cdataPropName !== false && key2 === this.options.cdataPropName) {
        return this.indentate(level) + `<![CDATA[${val2}]]>` + this.newLine;
      } else if (this.options.commentPropName !== false && key2 === this.options.commentPropName) {
        return this.indentate(level) + `<!--${val2}-->` + this.newLine;
      } else if (key2[0] === "?") {
        return this.indentate(level) + "<" + key2 + attrStr + "?" + this.tagEndChar;
      } else {
        let textValue = this.options.tagValueProcessor(key2, val2);
        textValue = this.replaceEntitiesValue(textValue);
        if (textValue === "") {
          return this.indentate(level) + "<" + key2 + attrStr + this.closeTag(key2) + this.tagEndChar;
        } else {
          return this.indentate(level) + "<" + key2 + attrStr + ">" + textValue + "</" + key2 + this.tagEndChar;
        }
      }
    };
    Builder.prototype.replaceEntitiesValue = function(textValue) {
      if (textValue && textValue.length > 0 && this.options.processEntities) {
        for (let i2 = 0; i2 < this.options.entities.length; i2++) {
          const entity = this.options.entities[i2];
          textValue = textValue.replace(entity.regex, entity.val);
        }
      }
      return textValue;
    };
    function indentate(level) {
      return this.options.indentBy.repeat(level);
    }
    function isAttribute(name) {
      if (name.startsWith(this.options.attributeNamePrefix) && name !== this.options.textNodeName) {
        return name.substr(this.attrPrefixLen);
      } else {
        return false;
      }
    }
    module.exports = Builder;
  }
});

// node_modules/fast-xml-parser/src/fxp.js
var require_fxp = __commonJS({
  "node_modules/fast-xml-parser/src/fxp.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var validator = require_validator();
    var XMLParser3 = require_XMLParser();
    var XMLBuilder = require_json2xml();
    module.exports = {
      XMLParser: XMLParser3,
      XMLValidator: validator,
      XMLBuilder
    };
  }
});

// node_modules/bowser/es5.js
var require_es5 = __commonJS({
  "node_modules/bowser/es5.js"(exports, module) {
    init_process();
    init_buffer();
    !function(e2, t3) {
      "object" == typeof exports && "object" == typeof module ? module.exports = t3() : "function" == typeof define && define.amd ? define([], t3) : "object" == typeof exports ? exports.bowser = t3() : e2.bowser = t3();
    }(exports, function() {
      return function(e2) {
        var t3 = {};
        function r2(n2) {
          if (t3[n2])
            return t3[n2].exports;
          var i2 = t3[n2] = { i: n2, l: false, exports: {} };
          return e2[n2].call(i2.exports, i2, i2.exports, r2), i2.l = true, i2.exports;
        }
        return r2.m = e2, r2.c = t3, r2.d = function(e3, t4, n2) {
          r2.o(e3, t4) || Object.defineProperty(e3, t4, { enumerable: true, get: n2 });
        }, r2.r = function(e3) {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e3, "__esModule", { value: true });
        }, r2.t = function(e3, t4) {
          if (1 & t4 && (e3 = r2(e3)), 8 & t4)
            return e3;
          if (4 & t4 && "object" == typeof e3 && e3 && e3.__esModule)
            return e3;
          var n2 = /* @__PURE__ */ Object.create(null);
          if (r2.r(n2), Object.defineProperty(n2, "default", { enumerable: true, value: e3 }), 2 & t4 && "string" != typeof e3)
            for (var i2 in e3)
              r2.d(n2, i2, function(t5) {
                return e3[t5];
              }.bind(null, i2));
          return n2;
        }, r2.n = function(e3) {
          var t4 = e3 && e3.__esModule ? function() {
            return e3.default;
          } : function() {
            return e3;
          };
          return r2.d(t4, "a", t4), t4;
        }, r2.o = function(e3, t4) {
          return Object.prototype.hasOwnProperty.call(e3, t4);
        }, r2.p = "", r2(r2.s = 90);
      }({ 17: function(e2, t3, r2) {
        "use strict";
        t3.__esModule = true, t3.default = void 0;
        var n2 = r2(18), i2 = function() {
          function e3() {
          }
          return e3.getFirstMatch = function(e4, t4) {
            var r3 = t4.match(e4);
            return r3 && r3.length > 0 && r3[1] || "";
          }, e3.getSecondMatch = function(e4, t4) {
            var r3 = t4.match(e4);
            return r3 && r3.length > 1 && r3[2] || "";
          }, e3.matchAndReturnConst = function(e4, t4, r3) {
            if (e4.test(t4))
              return r3;
          }, e3.getWindowsVersionName = function(e4) {
            switch (e4) {
              case "NT":
                return "NT";
              case "XP":
                return "XP";
              case "NT 5.0":
                return "2000";
              case "NT 5.1":
                return "XP";
              case "NT 5.2":
                return "2003";
              case "NT 6.0":
                return "Vista";
              case "NT 6.1":
                return "7";
              case "NT 6.2":
                return "8";
              case "NT 6.3":
                return "8.1";
              case "NT 10.0":
                return "10";
              default:
                return;
            }
          }, e3.getMacOSVersionName = function(e4) {
            var t4 = e4.split(".").splice(0, 2).map(function(e5) {
              return parseInt(e5, 10) || 0;
            });
            if (t4.push(0), 10 === t4[0])
              switch (t4[1]) {
                case 5:
                  return "Leopard";
                case 6:
                  return "Snow Leopard";
                case 7:
                  return "Lion";
                case 8:
                  return "Mountain Lion";
                case 9:
                  return "Mavericks";
                case 10:
                  return "Yosemite";
                case 11:
                  return "El Capitan";
                case 12:
                  return "Sierra";
                case 13:
                  return "High Sierra";
                case 14:
                  return "Mojave";
                case 15:
                  return "Catalina";
                default:
                  return;
              }
          }, e3.getAndroidVersionName = function(e4) {
            var t4 = e4.split(".").splice(0, 2).map(function(e5) {
              return parseInt(e5, 10) || 0;
            });
            if (t4.push(0), !(1 === t4[0] && t4[1] < 5))
              return 1 === t4[0] && t4[1] < 6 ? "Cupcake" : 1 === t4[0] && t4[1] >= 6 ? "Donut" : 2 === t4[0] && t4[1] < 2 ? "Eclair" : 2 === t4[0] && 2 === t4[1] ? "Froyo" : 2 === t4[0] && t4[1] > 2 ? "Gingerbread" : 3 === t4[0] ? "Honeycomb" : 4 === t4[0] && t4[1] < 1 ? "Ice Cream Sandwich" : 4 === t4[0] && t4[1] < 4 ? "Jelly Bean" : 4 === t4[0] && t4[1] >= 4 ? "KitKat" : 5 === t4[0] ? "Lollipop" : 6 === t4[0] ? "Marshmallow" : 7 === t4[0] ? "Nougat" : 8 === t4[0] ? "Oreo" : 9 === t4[0] ? "Pie" : void 0;
          }, e3.getVersionPrecision = function(e4) {
            return e4.split(".").length;
          }, e3.compareVersions = function(t4, r3, n3) {
            void 0 === n3 && (n3 = false);
            var i3 = e3.getVersionPrecision(t4), s2 = e3.getVersionPrecision(r3), a2 = Math.max(i3, s2), o2 = 0, u2 = e3.map([t4, r3], function(t5) {
              var r4 = a2 - e3.getVersionPrecision(t5), n4 = t5 + new Array(r4 + 1).join(".0");
              return e3.map(n4.split("."), function(e4) {
                return new Array(20 - e4.length).join("0") + e4;
              }).reverse();
            });
            for (n3 && (o2 = a2 - Math.min(i3, s2)), a2 -= 1; a2 >= o2; ) {
              if (u2[0][a2] > u2[1][a2])
                return 1;
              if (u2[0][a2] === u2[1][a2]) {
                if (a2 === o2)
                  return 0;
                a2 -= 1;
              } else if (u2[0][a2] < u2[1][a2])
                return -1;
            }
          }, e3.map = function(e4, t4) {
            var r3, n3 = [];
            if (Array.prototype.map)
              return Array.prototype.map.call(e4, t4);
            for (r3 = 0; r3 < e4.length; r3 += 1)
              n3.push(t4(e4[r3]));
            return n3;
          }, e3.find = function(e4, t4) {
            var r3, n3;
            if (Array.prototype.find)
              return Array.prototype.find.call(e4, t4);
            for (r3 = 0, n3 = e4.length; r3 < n3; r3 += 1) {
              var i3 = e4[r3];
              if (t4(i3, r3))
                return i3;
            }
          }, e3.assign = function(e4) {
            for (var t4, r3, n3 = e4, i3 = arguments.length, s2 = new Array(i3 > 1 ? i3 - 1 : 0), a2 = 1; a2 < i3; a2++)
              s2[a2 - 1] = arguments[a2];
            if (Object.assign)
              return Object.assign.apply(Object, [e4].concat(s2));
            var o2 = function() {
              var e5 = s2[t4];
              "object" == typeof e5 && null !== e5 && Object.keys(e5).forEach(function(t5) {
                n3[t5] = e5[t5];
              });
            };
            for (t4 = 0, r3 = s2.length; t4 < r3; t4 += 1)
              o2();
            return e4;
          }, e3.getBrowserAlias = function(e4) {
            return n2.BROWSER_ALIASES_MAP[e4];
          }, e3.getBrowserTypeByAlias = function(e4) {
            return n2.BROWSER_MAP[e4] || "";
          }, e3;
        }();
        t3.default = i2, e2.exports = t3.default;
      }, 18: function(e2, t3, r2) {
        "use strict";
        t3.__esModule = true, t3.ENGINE_MAP = t3.OS_MAP = t3.PLATFORMS_MAP = t3.BROWSER_MAP = t3.BROWSER_ALIASES_MAP = void 0;
        t3.BROWSER_ALIASES_MAP = { "Amazon Silk": "amazon_silk", "Android Browser": "android", Bada: "bada", BlackBerry: "blackberry", Chrome: "chrome", Chromium: "chromium", Electron: "electron", Epiphany: "epiphany", Firefox: "firefox", Focus: "focus", Generic: "generic", "Google Search": "google_search", Googlebot: "googlebot", "Internet Explorer": "ie", "K-Meleon": "k_meleon", Maxthon: "maxthon", "Microsoft Edge": "edge", "MZ Browser": "mz", "NAVER Whale Browser": "naver", Opera: "opera", "Opera Coast": "opera_coast", PhantomJS: "phantomjs", Puffin: "puffin", QupZilla: "qupzilla", QQ: "qq", QQLite: "qqlite", Safari: "safari", Sailfish: "sailfish", "Samsung Internet for Android": "samsung_internet", SeaMonkey: "seamonkey", Sleipnir: "sleipnir", Swing: "swing", Tizen: "tizen", "UC Browser": "uc", Vivaldi: "vivaldi", "WebOS Browser": "webos", WeChat: "wechat", "Yandex Browser": "yandex", Roku: "roku" };
        t3.BROWSER_MAP = { amazon_silk: "Amazon Silk", android: "Android Browser", bada: "Bada", blackberry: "BlackBerry", chrome: "Chrome", chromium: "Chromium", electron: "Electron", epiphany: "Epiphany", firefox: "Firefox", focus: "Focus", generic: "Generic", googlebot: "Googlebot", google_search: "Google Search", ie: "Internet Explorer", k_meleon: "K-Meleon", maxthon: "Maxthon", edge: "Microsoft Edge", mz: "MZ Browser", naver: "NAVER Whale Browser", opera: "Opera", opera_coast: "Opera Coast", phantomjs: "PhantomJS", puffin: "Puffin", qupzilla: "QupZilla", qq: "QQ Browser", qqlite: "QQ Browser Lite", safari: "Safari", sailfish: "Sailfish", samsung_internet: "Samsung Internet for Android", seamonkey: "SeaMonkey", sleipnir: "Sleipnir", swing: "Swing", tizen: "Tizen", uc: "UC Browser", vivaldi: "Vivaldi", webos: "WebOS Browser", wechat: "WeChat", yandex: "Yandex Browser" };
        t3.PLATFORMS_MAP = { tablet: "tablet", mobile: "mobile", desktop: "desktop", tv: "tv" };
        t3.OS_MAP = { WindowsPhone: "Windows Phone", Windows: "Windows", MacOS: "macOS", iOS: "iOS", Android: "Android", WebOS: "WebOS", BlackBerry: "BlackBerry", Bada: "Bada", Tizen: "Tizen", Linux: "Linux", ChromeOS: "Chrome OS", PlayStation4: "PlayStation 4", Roku: "Roku" };
        t3.ENGINE_MAP = { EdgeHTML: "EdgeHTML", Blink: "Blink", Trident: "Trident", Presto: "Presto", Gecko: "Gecko", WebKit: "WebKit" };
      }, 90: function(e2, t3, r2) {
        "use strict";
        t3.__esModule = true, t3.default = void 0;
        var n2, i2 = (n2 = r2(91)) && n2.__esModule ? n2 : { default: n2 }, s2 = r2(18);
        function a2(e3, t4) {
          for (var r3 = 0; r3 < t4.length; r3++) {
            var n3 = t4[r3];
            n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e3, n3.key, n3);
          }
        }
        var o2 = function() {
          function e3() {
          }
          var t4, r3, n3;
          return e3.getParser = function(e4, t5) {
            if (void 0 === t5 && (t5 = false), "string" != typeof e4)
              throw new Error("UserAgent should be a string");
            return new i2.default(e4, t5);
          }, e3.parse = function(e4) {
            return new i2.default(e4).getResult();
          }, t4 = e3, n3 = [{ key: "BROWSER_MAP", get: function() {
            return s2.BROWSER_MAP;
          } }, { key: "ENGINE_MAP", get: function() {
            return s2.ENGINE_MAP;
          } }, { key: "OS_MAP", get: function() {
            return s2.OS_MAP;
          } }, { key: "PLATFORMS_MAP", get: function() {
            return s2.PLATFORMS_MAP;
          } }], (r3 = null) && a2(t4.prototype, r3), n3 && a2(t4, n3), e3;
        }();
        t3.default = o2, e2.exports = t3.default;
      }, 91: function(e2, t3, r2) {
        "use strict";
        t3.__esModule = true, t3.default = void 0;
        var n2 = u2(r2(92)), i2 = u2(r2(93)), s2 = u2(r2(94)), a2 = u2(r2(95)), o2 = u2(r2(17));
        function u2(e3) {
          return e3 && e3.__esModule ? e3 : { default: e3 };
        }
        var d2 = function() {
          function e3(e4, t5) {
            if (void 0 === t5 && (t5 = false), null == e4 || "" === e4)
              throw new Error("UserAgent parameter can't be empty");
            this._ua = e4, this.parsedResult = {}, true !== t5 && this.parse();
          }
          var t4 = e3.prototype;
          return t4.getUA = function() {
            return this._ua;
          }, t4.test = function(e4) {
            return e4.test(this._ua);
          }, t4.parseBrowser = function() {
            var e4 = this;
            this.parsedResult.browser = {};
            var t5 = o2.default.find(n2.default, function(t6) {
              if ("function" == typeof t6.test)
                return t6.test(e4);
              if (t6.test instanceof Array)
                return t6.test.some(function(t7) {
                  return e4.test(t7);
                });
              throw new Error("Browser's test function is not valid");
            });
            return t5 && (this.parsedResult.browser = t5.describe(this.getUA())), this.parsedResult.browser;
          }, t4.getBrowser = function() {
            return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser();
          }, t4.getBrowserName = function(e4) {
            return e4 ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || "";
          }, t4.getBrowserVersion = function() {
            return this.getBrowser().version;
          }, t4.getOS = function() {
            return this.parsedResult.os ? this.parsedResult.os : this.parseOS();
          }, t4.parseOS = function() {
            var e4 = this;
            this.parsedResult.os = {};
            var t5 = o2.default.find(i2.default, function(t6) {
              if ("function" == typeof t6.test)
                return t6.test(e4);
              if (t6.test instanceof Array)
                return t6.test.some(function(t7) {
                  return e4.test(t7);
                });
              throw new Error("Browser's test function is not valid");
            });
            return t5 && (this.parsedResult.os = t5.describe(this.getUA())), this.parsedResult.os;
          }, t4.getOSName = function(e4) {
            var t5 = this.getOS().name;
            return e4 ? String(t5).toLowerCase() || "" : t5 || "";
          }, t4.getOSVersion = function() {
            return this.getOS().version;
          }, t4.getPlatform = function() {
            return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform();
          }, t4.getPlatformType = function(e4) {
            void 0 === e4 && (e4 = false);
            var t5 = this.getPlatform().type;
            return e4 ? String(t5).toLowerCase() || "" : t5 || "";
          }, t4.parsePlatform = function() {
            var e4 = this;
            this.parsedResult.platform = {};
            var t5 = o2.default.find(s2.default, function(t6) {
              if ("function" == typeof t6.test)
                return t6.test(e4);
              if (t6.test instanceof Array)
                return t6.test.some(function(t7) {
                  return e4.test(t7);
                });
              throw new Error("Browser's test function is not valid");
            });
            return t5 && (this.parsedResult.platform = t5.describe(this.getUA())), this.parsedResult.platform;
          }, t4.getEngine = function() {
            return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine();
          }, t4.getEngineName = function(e4) {
            return e4 ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || "";
          }, t4.parseEngine = function() {
            var e4 = this;
            this.parsedResult.engine = {};
            var t5 = o2.default.find(a2.default, function(t6) {
              if ("function" == typeof t6.test)
                return t6.test(e4);
              if (t6.test instanceof Array)
                return t6.test.some(function(t7) {
                  return e4.test(t7);
                });
              throw new Error("Browser's test function is not valid");
            });
            return t5 && (this.parsedResult.engine = t5.describe(this.getUA())), this.parsedResult.engine;
          }, t4.parse = function() {
            return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this;
          }, t4.getResult = function() {
            return o2.default.assign({}, this.parsedResult);
          }, t4.satisfies = function(e4) {
            var t5 = this, r3 = {}, n3 = 0, i3 = {}, s3 = 0;
            if (Object.keys(e4).forEach(function(t6) {
              var a4 = e4[t6];
              "string" == typeof a4 ? (i3[t6] = a4, s3 += 1) : "object" == typeof a4 && (r3[t6] = a4, n3 += 1);
            }), n3 > 0) {
              var a3 = Object.keys(r3), u3 = o2.default.find(a3, function(e5) {
                return t5.isOS(e5);
              });
              if (u3) {
                var d3 = this.satisfies(r3[u3]);
                if (void 0 !== d3)
                  return d3;
              }
              var c2 = o2.default.find(a3, function(e5) {
                return t5.isPlatform(e5);
              });
              if (c2) {
                var f2 = this.satisfies(r3[c2]);
                if (void 0 !== f2)
                  return f2;
              }
            }
            if (s3 > 0) {
              var l2 = Object.keys(i3), h2 = o2.default.find(l2, function(e5) {
                return t5.isBrowser(e5, true);
              });
              if (void 0 !== h2)
                return this.compareVersion(i3[h2]);
            }
          }, t4.isBrowser = function(e4, t5) {
            void 0 === t5 && (t5 = false);
            var r3 = this.getBrowserName().toLowerCase(), n3 = e4.toLowerCase(), i3 = o2.default.getBrowserTypeByAlias(n3);
            return t5 && i3 && (n3 = i3.toLowerCase()), n3 === r3;
          }, t4.compareVersion = function(e4) {
            var t5 = [0], r3 = e4, n3 = false, i3 = this.getBrowserVersion();
            if ("string" == typeof i3)
              return ">" === e4[0] || "<" === e4[0] ? (r3 = e4.substr(1), "=" === e4[1] ? (n3 = true, r3 = e4.substr(2)) : t5 = [], ">" === e4[0] ? t5.push(1) : t5.push(-1)) : "=" === e4[0] ? r3 = e4.substr(1) : "~" === e4[0] && (n3 = true, r3 = e4.substr(1)), t5.indexOf(o2.default.compareVersions(i3, r3, n3)) > -1;
          }, t4.isOS = function(e4) {
            return this.getOSName(true) === String(e4).toLowerCase();
          }, t4.isPlatform = function(e4) {
            return this.getPlatformType(true) === String(e4).toLowerCase();
          }, t4.isEngine = function(e4) {
            return this.getEngineName(true) === String(e4).toLowerCase();
          }, t4.is = function(e4, t5) {
            return void 0 === t5 && (t5 = false), this.isBrowser(e4, t5) || this.isOS(e4) || this.isPlatform(e4);
          }, t4.some = function(e4) {
            var t5 = this;
            return void 0 === e4 && (e4 = []), e4.some(function(e5) {
              return t5.is(e5);
            });
          }, e3;
        }();
        t3.default = d2, e2.exports = t3.default;
      }, 92: function(e2, t3, r2) {
        "use strict";
        t3.__esModule = true, t3.default = void 0;
        var n2, i2 = (n2 = r2(17)) && n2.__esModule ? n2 : { default: n2 };
        var s2 = /version\/(\d+(\.?_?\d+)+)/i, a2 = [{ test: [/googlebot/i], describe: function(e3) {
          var t4 = { name: "Googlebot" }, r3 = i2.default.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, e3) || i2.default.getFirstMatch(s2, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: [/opera/i], describe: function(e3) {
          var t4 = { name: "Opera" }, r3 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: [/opr\/|opios/i], describe: function(e3) {
          var t4 = { name: "Opera" }, r3 = i2.default.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, e3) || i2.default.getFirstMatch(s2, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: [/SamsungBrowser/i], describe: function(e3) {
          var t4 = { name: "Samsung Internet for Android" }, r3 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: [/Whale/i], describe: function(e3) {
          var t4 = { name: "NAVER Whale Browser" }, r3 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: [/MZBrowser/i], describe: function(e3) {
          var t4 = { name: "MZ Browser" }, r3 = i2.default.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, e3) || i2.default.getFirstMatch(s2, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: [/focus/i], describe: function(e3) {
          var t4 = { name: "Focus" }, r3 = i2.default.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, e3) || i2.default.getFirstMatch(s2, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: [/swing/i], describe: function(e3) {
          var t4 = { name: "Swing" }, r3 = i2.default.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, e3) || i2.default.getFirstMatch(s2, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: [/coast/i], describe: function(e3) {
          var t4 = { name: "Opera Coast" }, r3 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: [/opt\/\d+(?:.?_?\d+)+/i], describe: function(e3) {
          var t4 = { name: "Opera Touch" }, r3 = i2.default.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, e3) || i2.default.getFirstMatch(s2, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: [/yabrowser/i], describe: function(e3) {
          var t4 = { name: "Yandex Browser" }, r3 = i2.default.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, e3) || i2.default.getFirstMatch(s2, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: [/ucbrowser/i], describe: function(e3) {
          var t4 = { name: "UC Browser" }, r3 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: [/Maxthon|mxios/i], describe: function(e3) {
          var t4 = { name: "Maxthon" }, r3 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: [/epiphany/i], describe: function(e3) {
          var t4 = { name: "Epiphany" }, r3 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: [/puffin/i], describe: function(e3) {
          var t4 = { name: "Puffin" }, r3 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: [/sleipnir/i], describe: function(e3) {
          var t4 = { name: "Sleipnir" }, r3 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: [/k-meleon/i], describe: function(e3) {
          var t4 = { name: "K-Meleon" }, r3 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: [/micromessenger/i], describe: function(e3) {
          var t4 = { name: "WeChat" }, r3 = i2.default.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, e3) || i2.default.getFirstMatch(s2, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: [/qqbrowser/i], describe: function(e3) {
          var t4 = { name: /qqbrowserlite/i.test(e3) ? "QQ Browser Lite" : "QQ Browser" }, r3 = i2.default.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, e3) || i2.default.getFirstMatch(s2, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: [/msie|trident/i], describe: function(e3) {
          var t4 = { name: "Internet Explorer" }, r3 = i2.default.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: [/\sedg\//i], describe: function(e3) {
          var t4 = { name: "Microsoft Edge" }, r3 = i2.default.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: [/edg([ea]|ios)/i], describe: function(e3) {
          var t4 = { name: "Microsoft Edge" }, r3 = i2.default.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: [/vivaldi/i], describe: function(e3) {
          var t4 = { name: "Vivaldi" }, r3 = i2.default.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: [/seamonkey/i], describe: function(e3) {
          var t4 = { name: "SeaMonkey" }, r3 = i2.default.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: [/sailfish/i], describe: function(e3) {
          var t4 = { name: "Sailfish" }, r3 = i2.default.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: [/silk/i], describe: function(e3) {
          var t4 = { name: "Amazon Silk" }, r3 = i2.default.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: [/phantom/i], describe: function(e3) {
          var t4 = { name: "PhantomJS" }, r3 = i2.default.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: [/slimerjs/i], describe: function(e3) {
          var t4 = { name: "SlimerJS" }, r3 = i2.default.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: [/blackberry|\bbb\d+/i, /rim\stablet/i], describe: function(e3) {
          var t4 = { name: "BlackBerry" }, r3 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: [/(web|hpw)[o0]s/i], describe: function(e3) {
          var t4 = { name: "WebOS Browser" }, r3 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: [/bada/i], describe: function(e3) {
          var t4 = { name: "Bada" }, r3 = i2.default.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: [/tizen/i], describe: function(e3) {
          var t4 = { name: "Tizen" }, r3 = i2.default.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, e3) || i2.default.getFirstMatch(s2, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: [/qupzilla/i], describe: function(e3) {
          var t4 = { name: "QupZilla" }, r3 = i2.default.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, e3) || i2.default.getFirstMatch(s2, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: [/firefox|iceweasel|fxios/i], describe: function(e3) {
          var t4 = { name: "Firefox" }, r3 = i2.default.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: [/electron/i], describe: function(e3) {
          var t4 = { name: "Electron" }, r3 = i2.default.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: [/MiuiBrowser/i], describe: function(e3) {
          var t4 = { name: "Miui" }, r3 = i2.default.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: [/chromium/i], describe: function(e3) {
          var t4 = { name: "Chromium" }, r3 = i2.default.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, e3) || i2.default.getFirstMatch(s2, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: [/chrome|crios|crmo/i], describe: function(e3) {
          var t4 = { name: "Chrome" }, r3 = i2.default.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: [/GSA/i], describe: function(e3) {
          var t4 = { name: "Google Search" }, r3 = i2.default.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: function(e3) {
          var t4 = !e3.test(/like android/i), r3 = e3.test(/android/i);
          return t4 && r3;
        }, describe: function(e3) {
          var t4 = { name: "Android Browser" }, r3 = i2.default.getFirstMatch(s2, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: [/playstation 4/i], describe: function(e3) {
          var t4 = { name: "PlayStation 4" }, r3 = i2.default.getFirstMatch(s2, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: [/safari|applewebkit/i], describe: function(e3) {
          var t4 = { name: "Safari" }, r3 = i2.default.getFirstMatch(s2, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: [/.*/i], describe: function(e3) {
          var t4 = -1 !== e3.search("\\(") ? /^(.*)\/(.*)[ \t]\((.*)/ : /^(.*)\/(.*) /;
          return { name: i2.default.getFirstMatch(t4, e3), version: i2.default.getSecondMatch(t4, e3) };
        } }];
        t3.default = a2, e2.exports = t3.default;
      }, 93: function(e2, t3, r2) {
        "use strict";
        t3.__esModule = true, t3.default = void 0;
        var n2, i2 = (n2 = r2(17)) && n2.__esModule ? n2 : { default: n2 }, s2 = r2(18);
        var a2 = [{ test: [/Roku\/DVP/], describe: function(e3) {
          var t4 = i2.default.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, e3);
          return { name: s2.OS_MAP.Roku, version: t4 };
        } }, { test: [/windows phone/i], describe: function(e3) {
          var t4 = i2.default.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, e3);
          return { name: s2.OS_MAP.WindowsPhone, version: t4 };
        } }, { test: [/windows /i], describe: function(e3) {
          var t4 = i2.default.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, e3), r3 = i2.default.getWindowsVersionName(t4);
          return { name: s2.OS_MAP.Windows, version: t4, versionName: r3 };
        } }, { test: [/Macintosh(.*?) FxiOS(.*?)\//], describe: function(e3) {
          var t4 = { name: s2.OS_MAP.iOS }, r3 = i2.default.getSecondMatch(/(Version\/)(\d[\d.]+)/, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: [/macintosh/i], describe: function(e3) {
          var t4 = i2.default.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, e3).replace(/[_\s]/g, "."), r3 = i2.default.getMacOSVersionName(t4), n3 = { name: s2.OS_MAP.MacOS, version: t4 };
          return r3 && (n3.versionName = r3), n3;
        } }, { test: [/(ipod|iphone|ipad)/i], describe: function(e3) {
          var t4 = i2.default.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, e3).replace(/[_\s]/g, ".");
          return { name: s2.OS_MAP.iOS, version: t4 };
        } }, { test: function(e3) {
          var t4 = !e3.test(/like android/i), r3 = e3.test(/android/i);
          return t4 && r3;
        }, describe: function(e3) {
          var t4 = i2.default.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, e3), r3 = i2.default.getAndroidVersionName(t4), n3 = { name: s2.OS_MAP.Android, version: t4 };
          return r3 && (n3.versionName = r3), n3;
        } }, { test: [/(web|hpw)[o0]s/i], describe: function(e3) {
          var t4 = i2.default.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, e3), r3 = { name: s2.OS_MAP.WebOS };
          return t4 && t4.length && (r3.version = t4), r3;
        } }, { test: [/blackberry|\bbb\d+/i, /rim\stablet/i], describe: function(e3) {
          var t4 = i2.default.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, e3) || i2.default.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, e3) || i2.default.getFirstMatch(/\bbb(\d+)/i, e3);
          return { name: s2.OS_MAP.BlackBerry, version: t4 };
        } }, { test: [/bada/i], describe: function(e3) {
          var t4 = i2.default.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, e3);
          return { name: s2.OS_MAP.Bada, version: t4 };
        } }, { test: [/tizen/i], describe: function(e3) {
          var t4 = i2.default.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, e3);
          return { name: s2.OS_MAP.Tizen, version: t4 };
        } }, { test: [/linux/i], describe: function() {
          return { name: s2.OS_MAP.Linux };
        } }, { test: [/CrOS/], describe: function() {
          return { name: s2.OS_MAP.ChromeOS };
        } }, { test: [/PlayStation 4/], describe: function(e3) {
          var t4 = i2.default.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, e3);
          return { name: s2.OS_MAP.PlayStation4, version: t4 };
        } }];
        t3.default = a2, e2.exports = t3.default;
      }, 94: function(e2, t3, r2) {
        "use strict";
        t3.__esModule = true, t3.default = void 0;
        var n2, i2 = (n2 = r2(17)) && n2.__esModule ? n2 : { default: n2 }, s2 = r2(18);
        var a2 = [{ test: [/googlebot/i], describe: function() {
          return { type: "bot", vendor: "Google" };
        } }, { test: [/huawei/i], describe: function(e3) {
          var t4 = i2.default.getFirstMatch(/(can-l01)/i, e3) && "Nova", r3 = { type: s2.PLATFORMS_MAP.mobile, vendor: "Huawei" };
          return t4 && (r3.model = t4), r3;
        } }, { test: [/nexus\s*(?:7|8|9|10).*/i], describe: function() {
          return { type: s2.PLATFORMS_MAP.tablet, vendor: "Nexus" };
        } }, { test: [/ipad/i], describe: function() {
          return { type: s2.PLATFORMS_MAP.tablet, vendor: "Apple", model: "iPad" };
        } }, { test: [/Macintosh(.*?) FxiOS(.*?)\//], describe: function() {
          return { type: s2.PLATFORMS_MAP.tablet, vendor: "Apple", model: "iPad" };
        } }, { test: [/kftt build/i], describe: function() {
          return { type: s2.PLATFORMS_MAP.tablet, vendor: "Amazon", model: "Kindle Fire HD 7" };
        } }, { test: [/silk/i], describe: function() {
          return { type: s2.PLATFORMS_MAP.tablet, vendor: "Amazon" };
        } }, { test: [/tablet(?! pc)/i], describe: function() {
          return { type: s2.PLATFORMS_MAP.tablet };
        } }, { test: function(e3) {
          var t4 = e3.test(/ipod|iphone/i), r3 = e3.test(/like (ipod|iphone)/i);
          return t4 && !r3;
        }, describe: function(e3) {
          var t4 = i2.default.getFirstMatch(/(ipod|iphone)/i, e3);
          return { type: s2.PLATFORMS_MAP.mobile, vendor: "Apple", model: t4 };
        } }, { test: [/nexus\s*[0-6].*/i, /galaxy nexus/i], describe: function() {
          return { type: s2.PLATFORMS_MAP.mobile, vendor: "Nexus" };
        } }, { test: [/[^-]mobi/i], describe: function() {
          return { type: s2.PLATFORMS_MAP.mobile };
        } }, { test: function(e3) {
          return "blackberry" === e3.getBrowserName(true);
        }, describe: function() {
          return { type: s2.PLATFORMS_MAP.mobile, vendor: "BlackBerry" };
        } }, { test: function(e3) {
          return "bada" === e3.getBrowserName(true);
        }, describe: function() {
          return { type: s2.PLATFORMS_MAP.mobile };
        } }, { test: function(e3) {
          return "windows phone" === e3.getBrowserName();
        }, describe: function() {
          return { type: s2.PLATFORMS_MAP.mobile, vendor: "Microsoft" };
        } }, { test: function(e3) {
          var t4 = Number(String(e3.getOSVersion()).split(".")[0]);
          return "android" === e3.getOSName(true) && t4 >= 3;
        }, describe: function() {
          return { type: s2.PLATFORMS_MAP.tablet };
        } }, { test: function(e3) {
          return "android" === e3.getOSName(true);
        }, describe: function() {
          return { type: s2.PLATFORMS_MAP.mobile };
        } }, { test: function(e3) {
          return "macos" === e3.getOSName(true);
        }, describe: function() {
          return { type: s2.PLATFORMS_MAP.desktop, vendor: "Apple" };
        } }, { test: function(e3) {
          return "windows" === e3.getOSName(true);
        }, describe: function() {
          return { type: s2.PLATFORMS_MAP.desktop };
        } }, { test: function(e3) {
          return "linux" === e3.getOSName(true);
        }, describe: function() {
          return { type: s2.PLATFORMS_MAP.desktop };
        } }, { test: function(e3) {
          return "playstation 4" === e3.getOSName(true);
        }, describe: function() {
          return { type: s2.PLATFORMS_MAP.tv };
        } }, { test: function(e3) {
          return "roku" === e3.getOSName(true);
        }, describe: function() {
          return { type: s2.PLATFORMS_MAP.tv };
        } }];
        t3.default = a2, e2.exports = t3.default;
      }, 95: function(e2, t3, r2) {
        "use strict";
        t3.__esModule = true, t3.default = void 0;
        var n2, i2 = (n2 = r2(17)) && n2.__esModule ? n2 : { default: n2 }, s2 = r2(18);
        var a2 = [{ test: function(e3) {
          return "microsoft edge" === e3.getBrowserName(true);
        }, describe: function(e3) {
          if (/\sedg\//i.test(e3))
            return { name: s2.ENGINE_MAP.Blink };
          var t4 = i2.default.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, e3);
          return { name: s2.ENGINE_MAP.EdgeHTML, version: t4 };
        } }, { test: [/trident/i], describe: function(e3) {
          var t4 = { name: s2.ENGINE_MAP.Trident }, r3 = i2.default.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: function(e3) {
          return e3.test(/presto/i);
        }, describe: function(e3) {
          var t4 = { name: s2.ENGINE_MAP.Presto }, r3 = i2.default.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: function(e3) {
          var t4 = e3.test(/gecko/i), r3 = e3.test(/like gecko/i);
          return t4 && !r3;
        }, describe: function(e3) {
          var t4 = { name: s2.ENGINE_MAP.Gecko }, r3 = i2.default.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t4.version = r3), t4;
        } }, { test: [/(apple)?webkit\/537\.36/i], describe: function() {
          return { name: s2.ENGINE_MAP.Blink };
        } }, { test: [/(apple)?webkit/i], describe: function(e3) {
          var t4 = { name: s2.ENGINE_MAP.WebKit }, r3 = i2.default.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t4.version = r3), t4;
        } }];
        t3.default = a2, e2.exports = t3.default;
      } });
    });
  }
});

// node_modules/html-to-md/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/html-to-md/dist/index.js"(exports, module) {
    init_process();
    init_buffer();
    !function(t3, e2) {
      "object" === typeof exports && "object" === typeof module ? module.exports = e2() : "function" === typeof define && define.amd ? define([], e2) : "object" === typeof exports ? exports.html2md = e2() : t3.html2md = e2();
    }(exports, function() {
      return function(t3) {
        var e2 = {};
        function r2(n2) {
          if (e2[n2])
            return e2[n2].exports;
          var o2 = e2[n2] = { i: n2, l: false, exports: {} };
          return t3[n2].call(o2.exports, o2, o2.exports, r2), o2.l = true, o2.exports;
        }
        return r2.m = t3, r2.c = e2, r2.d = function(t4, e3, n2) {
          r2.o(t4, e3) || Object.defineProperty(t4, e3, { enumerable: true, get: n2 });
        }, r2.r = function(t4) {
          "undefined" !== typeof Symbol && Symbol.toStringTag && Object.defineProperty(t4, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t4, "__esModule", { value: true });
        }, r2.t = function(t4, e3) {
          if (1 & e3 && (t4 = r2(t4)), 8 & e3)
            return t4;
          if (4 & e3 && "object" === typeof t4 && t4 && t4.__esModule)
            return t4;
          var n2 = /* @__PURE__ */ Object.create(null);
          if (r2.r(n2), Object.defineProperty(n2, "default", { enumerable: true, value: t4 }), 2 & e3 && "string" != typeof t4)
            for (var o2 in t4)
              r2.d(n2, o2, function(e4) {
                return t4[e4];
              }.bind(null, o2));
          return n2;
        }, r2.n = function(t4) {
          var e3 = t4 && t4.__esModule ? function() {
            return t4.default;
          } : function() {
            return t4;
          };
          return r2.d(e3, "a", e3), e3;
        }, r2.o = function(t4, e3) {
          return Object.prototype.hasOwnProperty.call(t4, e3);
        }, r2.p = "", r2(r2.s = 45);
      }([function(t3, e2, r2) {
        "use strict";
        Object.defineProperty(e2, "__esModule", { value: true });
        var n2 = r2(1), o2 = r2(12), i2 = r2(6), a2 = r2(7), c2 = r2(2), u2 = function() {
          function t4(t5, e3, r3) {
            var o3 = void 0 === r3 ? {} : r3, i3 = o3.keepSpace, a3 = void 0 !== i3 && i3, c3 = o3.prevTagName, u3 = void 0 === c3 ? "" : c3, s2 = o3.nextTagName, p3 = void 0 === s2 ? "" : s2, l2 = o3.prevTagStr, f2 = void 0 === l2 ? "" : l2, h2 = o3.nextTagStr, d2 = void 0 === h2 ? "" : h2, _ = o3.parentTag, y2 = void 0 === _ ? "" : _, v2 = o3.isFirstSubTag, g2 = void 0 === v2 || v2, b2 = o3.calcLeading, O2 = void 0 !== b2 && b2, m2 = o3.leadingSpace, S2 = void 0 === m2 ? "" : m2, T2 = o3.layer, x2 = void 0 === T2 ? 1 : T2, j2 = o3.noWrap, w2 = void 0 !== j2 && j2, P2 = o3.prevHasEndSpace, M2 = void 0 !== P2 && P2, E2 = o3.prevHasStartSpace, N2 = void 0 !== E2 && E2, C2 = o3.match, L2 = void 0 === C2 ? null : C2, k2 = o3.indentSpace, A2 = void 0 === k2 ? "" : k2, H2 = o3.language, W2 = void 0 === H2 ? "" : H2, V2 = o3.count, R2 = void 0 === V2 ? 1 : V2, I2 = o3.tableColumnCount, D2 = void 0 === I2 ? 0 : I2, U2 = o3.noExtraLine, B2 = void 0 !== U2 && U2, q2 = o3.inTable, F2 = void 0 !== q2 && q2;
            if (this.tagName = e3, this.rawStr = t5, this.parentTag = y2, this.prevTagName = u3, this.nextTagName = p3, this.prevTagStr = f2, this.nextTagStr = d2, this.isFirstSubTag = g2, this.calcLeading = O2, this.leadingSpace = S2, this.layer = x2, this.noWrap = w2, this.match = L2, this.indentSpace = A2, this.language = W2, this.count = R2, this.inTable = F2, this.tableColumnCount = D2, this.noExtraLine = B2, this.prevHasEndSpace = M2, this.prevHasStartSpace = N2, this.hasStartSpace = false, this.hasEndSpace = false, this.keepSpace = a3, !this.__detectStr__(t5, this.tagName))
              return this.attrs = {}, void (this.innerHTML = "");
            var G2 = this.__fetchTagAttrAndInnerHTML__(t5), $ = G2.attr, J2 = G2.innerHTML;
            J2.startsWith(" ") && (0, n2.isSpacePassingTag)(e3) && (this.hasStartSpace = true), J2.endsWith(" ") && (0, n2.isSpacePassingTag)(e3) && (this.hasEndSpace = true), this.attrs = $, this.innerHTML = J2;
          }
          return t4.prototype.__detectStr__ = function(t5, e3) {
            if ("<" !== t5[0])
              return "Not a valid tag, current tag name: ".concat(this.tagName, ", tag content: ").concat(t5), false;
            for (var r3 = "", n3 = false, o3 = 1; o3 < t5.length && ">" !== t5[o3]; o3++)
              !n3 && /(\s|\/)/.test(t5[o3]) && (n3 = true), n3 || (r3 += t5[o3]);
            return r3 === e3;
          }, t4.prototype.__fetchTagAttrAndInnerHTML__ = function(t5) {
            for (var e3 = "", r3 = 1; r3 < t5.length && ">" !== t5[r3]; r3++)
              e3 += t5[r3];
            for (var o3 = t5.slice(r3 + 1), i3 = "", a3 = -1, c3 = o3.length - 1; c3 >= 0; c3--)
              if ((i3 = o3[c3] + i3).startsWith("</")) {
                i3.startsWith("</" + this.tagName + ">") && (a3 = c3);
                break;
              }
            -1 === a3 && (0, n2.isSelfClosing)(this.tagName) && this.tagName;
            var u3 = (0, n2.getTagAttributes)(e3);
            return this.tagName && delete u3[this.tagName], { attr: u3, innerHTML: o3.slice(0, a3) };
          }, t4.prototype.__onlyLeadingSpace__ = function(t5) {
            t5 = t5.trim();
            for (var e3 = 0; e3 < t5.length; e3++)
              if (t5[e3] !== i2.SINGLE)
                return false;
            return true;
          }, t4.prototype.__isEmpty__ = function(t5) {
            return !this.keepSpace && ("" === t5 && "td" !== this.tagName || this.calcLeading && this.__onlyLeadingSpace__(t5));
          }, t4.prototype.getValidSubTagName = function(t5) {
            return t5;
          }, t4.prototype.beforeParse = function() {
            var t5 = c2.default.get().tagListener;
            if (t5) {
              var e3 = t5(this.tagName, { parentTag: this.parentTag, prevTagName: this.prevTagName, nextTagName: this.nextTagName, isFirstSubTag: this.isFirstSubTag, attrs: this.attrs, innerHTML: this.innerHTML, language: this.language, match: this.match, isSelfClosing: false }), r3 = e3.attrs, n3 = e3.language, o3 = e3.match;
              this.attrs = r3, "string" === typeof n3 && (this.language = n3), "undefined" !== typeof o3 && (this.match = o3);
            }
            return "";
          }, t4.prototype.parseValidSubTag = function(t5, e3, r3) {
            var o3 = new ((0, n2.getTagConstructor)(e3))(t5, e3, r3);
            return [o3.exec(), o3];
          }, t4.prototype.parseOnlyString = function(t5, e3, r3) {
            var n3 = new o2.default(t5, e3, r3);
            return [n3.exec(), n3];
          }, t4.prototype.afterParsed = function(t5) {
            return t5;
          }, t4.prototype.slim = function(t5) {
            return this.keepSpace ? t5 : t5.trim();
          }, t4.prototype.beforeMergeSpace = function(t5) {
            return t5;
          }, t4.prototype.mergeSpace = function(t5, e3, r3) {
            return this.keepSpace && "pre" !== this.tagName ? t5.endsWith("\n") ? t5 : t5 + r3.replace(/\n+/g, "\n") : e3 + t5 + r3;
          }, t4.prototype.afterMergeSpace = function(t5) {
            return t5;
          }, t4.prototype.beforeReturn = function(t5) {
            return (0, n2.isSpacePassingTag)(this.prevTagName) && (0, n2.isSpacePassingTag)(this.tagName) && this.hasStartSpace && !/^\s+/.test(t5) && !/\s+$/.test(this.prevTagStr) ? " " + t5 : t5;
          }, t4.prototype.exec = function(t5, e3) {
            void 0 === t5 && (t5 = ""), void 0 === e3 && (e3 = "");
            for (var r3 = this.beforeParse(), o3 = (0, n2.generateGetNextValidTag)(this.innerHTML), i3 = o3(), c3 = i3[0], u3 = i3[1], s2 = null, p3 = false, l2 = false; "" !== u3; ) {
              var f2, h2 = o3(), d2 = h2[0], _ = h2[1], y2 = { parentTag: this.tagName, nextTagName: d2, nextTagStr: _, prevTagName: s2, prevTagStr: r3, prevHasEndSpace: l2, prevHasStartSpace: p3, leadingSpace: this.leadingSpace, layer: this.layer, keepSpace: this.keepSpace, inTable: this.inTable, calcLeading: ("li" === this.tagName || "ol" === this.tagName || "ul" === this.tagName) && this.calcLeading }, v2 = void 0, g2 = void 0;
              if (null != c3)
                v2 = (f2 = this.parseValidSubTag(u3, c3, y2))[0], g2 = f2[1];
              else
                v2 = (f2 = this.parseOnlyString(u3, c3, y2))[0], g2 = f2[1];
              l2 = (null === g2 || void 0 === g2 ? void 0 : g2.hasEndSpace) || false, p3 = (null === g2 || void 0 === g2 ? void 0 : g2.hasStartSpace) || false;
              var b2 = this.getValidSubTagName(c3);
              c3 = d2, u3 = _, null == b2 && this.__isEmpty__(v2) || (!this.keepSpace && (0, a2.default)(s2) && (0, a2.default)(b2) && (r3 = r3.replace(/\n+$/, "\n"), v2 = v2.replace(/^\n+/, "\n")), s2 = b2, this.isFirstSubTag = false, r3 += v2);
            }
            return r3 = this.afterParsed(r3), r3 = this.slim(r3), this.__isEmpty__(r3) ? "" : (r3 = this.beforeMergeSpace(r3), !this.noExtraLine && (0, a2.default)(this.tagName) && this.prevTagName && !r3.startsWith("\n") && !(0, a2.default)(this.prevTagName) && this.parentTag && (t5 = "\n\n"), r3 = this.mergeSpace(r3, t5, e3), this.noWrap && !this.keepSpace && (r3 = r3.replace(/\s+/g, " ")), r3 = this.afterMergeSpace(r3), r3 = this.beforeReturn(r3));
          }, t4;
        }();
        e2.default = u2;
      }, function(t3, e2, r2) {
        "use strict";
        Object.defineProperty(e2, "__esModule", { value: true }), e2.shouldRenderRawInside = e2.isSpacePassingTag = e2.isIndependentTag = e2.clearComment = e2.getLanguage = e2.getTableAlign = e2.getTagAttributes = e2.isSelfClosing = e2.generateGetNextValidTag = e2.getTagConstructor = e2.getRealTagName = e2.unescapeStr = e2.extraEscape = void 0;
        var n2 = r2(46);
        Object.defineProperty(e2, "extraEscape", { enumerable: true, get: function() {
          return n2.extraEscape;
        } }), Object.defineProperty(e2, "unescapeStr", { enumerable: true, get: function() {
          return n2.unescapeStr;
        } });
        var o2 = r2(47);
        e2.generateGetNextValidTag = o2.default;
        var i2 = r2(48);
        e2.getTagConstructor = i2.default;
        var a2 = r2(11);
        e2.isSelfClosing = a2.default;
        var c2 = r2(51);
        e2.getTagAttributes = c2.default;
        var u2 = r2(52);
        e2.getLanguage = u2.default;
        var s2 = r2(53);
        e2.clearComment = s2.default;
        var p3 = r2(13);
        e2.getRealTagName = p3.default;
        var l2 = r2(7);
        e2.isIndependentTag = l2.default;
        var f2 = r2(54);
        e2.isSpacePassingTag = f2.default;
        var h2 = r2(55);
        e2.getTableAlign = h2.default;
        var d2 = r2(56);
        e2.shouldRenderRawInside = d2.default;
      }, function(t3, e2, r2) {
        "use strict";
        Object.defineProperty(e2, "__esModule", { value: true });
        var n2 = function() {
          function t4(t5) {
            var e3 = void 0 === t5 ? {} : t5, r3 = e3.skipTags, n3 = void 0 === r3 ? [] : r3, o3 = e3.emptyTags, i3 = void 0 === o3 ? [] : o3, a2 = e3.ignoreTags, c2 = void 0 === a2 ? [] : a2, u2 = e3.aliasTags, s2 = void 0 === u2 ? {} : u2, p3 = e3.renderCustomTags, l2 = void 0 === p3 || p3, f2 = e3.tagListener, h2 = void 0 === f2 ? function(t6, e4) {
              return e4;
            } : f2;
            this.options = { skipTags: n3, emptyTags: i3, ignoreTags: c2, aliasTags: s2, renderCustomTags: l2, tagListener: h2 };
          }
          return t4.prototype.get = function() {
            return this.options;
          }, t4.prototype.clear = function() {
            this.options = {};
          }, t4.prototype.set = function(t5, e3) {
            var r3 = this;
            t5 && "[object Object]" === Object.prototype.toString.call(t5) && Object.keys(t5).forEach(function(n3) {
              e3 ? r3.options[n3] = t5[n3] : function(t6, e4, r4) {
                if (!(r4 in t6))
                  return void (t6[r4] = e4[r4]);
                var n4 = Array.isArray(t6[r4]), o3 = "[object Object]" === Object.prototype.toString.call(t6[r4]);
                t6[r4] = n4 ? t6[r4].concat(e4[r4]) : o3 ? Object.assign(t6[r4], e4[r4]) : e4[r4];
              }(r3.options, t5, n3);
            });
          }, t4.prototype.reset = function() {
            this.options = JSON.parse(JSON.stringify(o2)), this.options.tagListener = function(t5, e3) {
              return e3;
            };
          }, t4;
        }();
        var o2 = { ignoreTags: ["", "style", "head", "!doctype", "form", "svg", "noscript", "script", "meta"], skipTags: ["div", "html", "body", "nav", "section", "footer", "main", "aside", "article", "header"], emptyTags: [], aliasTags: { figure: "p", dl: "p", dd: "p", dt: "p", figcaption: "p" }, renderCustomTags: true }, i2 = new n2();
        i2.reset(), e2.default = i2;
      }, function(t3, e2, r2) {
        "use strict";
        var n2 = this && this.__extends || function() {
          var t4 = function(e3, r3) {
            return (t4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t5, e4) {
              t5.__proto__ = e4;
            } || function(t5, e4) {
              for (var r4 in e4)
                Object.prototype.hasOwnProperty.call(e4, r4) && (t5[r4] = e4[r4]);
            })(e3, r3);
          };
          return function(e3, r3) {
            if ("function" !== typeof r3 && null !== r3)
              throw new TypeError("Class extends value " + String(r3) + " is not a constructor or null");
            function n3() {
              this.constructor = e3;
            }
            t4(e3, r3), e3.prototype = null === r3 ? Object.create(r3) : (n3.prototype = r3.prototype, new n3());
          };
        }();
        Object.defineProperty(e2, "__esModule", { value: true });
        var o2 = function(t4) {
          function e3(e4, r3) {
            void 0 === r3 && (r3 = "h1");
            var n3 = t4.call(this, e4, r3) || this;
            return n3.match = "#", n3;
          }
          return n2(e3, t4), e3.prototype.beforeMergeSpace = function(t5) {
            return this.match + " " + t5;
          }, e3.prototype.exec = function(e4, r3) {
            return e4 || (e4 = "\n"), r3 || (r3 = "\n"), t4.prototype.exec.call(this, e4, r3);
          }, e3;
        }(r2(0).default);
        e2.default = o2;
      }, function(t3, e2, r2) {
        "use strict";
        Object.defineProperty(e2, "__esModule", { value: true });
        var n2 = r2(1), o2 = r2(2), i2 = function() {
          function t4(t5, e3, r3) {
            var n3 = void 0 === r3 ? {} : r3, o3 = n3.parentTag, i3 = void 0 === o3 ? "" : o3, a2 = n3.leadingSpace, c2 = void 0 === a2 ? "" : a2, u2 = n3.layer, s2 = void 0 === u2 ? 1 : u2, p3 = n3.isFirstSubTag, l2 = void 0 !== p3 && p3, f2 = n3.inTable, h2 = void 0 !== f2 && f2, d2 = n3.match, _ = void 0 === d2 ? null : d2, y2 = n3.prevTagName, v2 = void 0 === y2 ? "" : y2, g2 = n3.nextTagName, b2 = void 0 === g2 ? "" : g2;
            if (this.tagName = e3, this.rawStr = t5, this.parentTag = i3, this.isFirstSubTag = l2, this.prevTagName = v2, this.nextTagName = b2, this.leadingSpace = c2, this.layer = s2, this.innerHTML = "", this.match = _, this.inTable = h2, this.__detectStr__(t5, this.tagName)) {
              var O2 = this.__fetchTagAttr__(t5).attr;
              this.attrs = O2;
            } else
              this.attrs = {};
          }
          return t4.prototype.__detectStr__ = function(t5, e3) {
            if ("<" !== t5[0])
              return "Not a valid tag, current tag name: ".concat(this.tagName, ", tag content: ").concat(t5), false;
            for (var r3 = "", n3 = false, o3 = 1; o3 < t5.length && ">" !== t5[o3]; o3++)
              !n3 && /(\s|\/)/.test(t5[o3]) && (n3 = true), n3 || (r3 += t5[o3]);
            return r3 === e3;
          }, t4.prototype.__fetchTagAttr__ = function(t5) {
            for (var e3 = "", r3 = 1; r3 < t5.length && ">" !== t5[r3]; r3++)
              e3 += t5[r3];
            return { attr: (0, n2.getTagAttributes)(e3) };
          }, t4.prototype.beforeParse = function() {
            var t5 = o2.default.get().tagListener;
            if (t5) {
              var e3 = t5(this.tagName, { parentTag: this.parentTag, prevTagName: this.prevTagName, nextTagName: this.nextTagName, isFirstSubTag: this.isFirstSubTag, attrs: this.attrs, innerHTML: this.innerHTML, match: this.match, isSelfClosing: true }), r3 = e3.attrs, n3 = e3.match;
              this.attrs = r3, this.match = n3;
            }
            return "";
          }, t4.prototype.beforeMergeSpace = function(t5) {
            return t5;
          }, t4.prototype.afterMergeSpace = function(t5) {
            return t5;
          }, t4.prototype.beforeReturn = function(t5) {
            return t5;
          }, t4.prototype.exec = function(t5, e3) {
            void 0 === t5 && (t5 = ""), void 0 === e3 && (e3 = "");
            var r3 = this.beforeParse();
            return r3 = t5 + (r3 = this.beforeMergeSpace(r3)) + e3, r3 = this.afterMergeSpace(r3), r3 = this.beforeReturn(r3);
          }, t4;
        }();
        e2.default = i2;
      }, function(t3, e2, r2) {
        "use strict";
        Object.defineProperty(e2, "__esModule", { value: true });
        var n2 = function() {
          function t4() {
          }
          return t4.prototype.exec = function() {
            return "";
          }, t4;
        }();
        e2.default = n2;
      }, function(t3, e2, r2) {
        "use strict";
        Object.defineProperty(e2, "__esModule", { value: true }), e2.TRIPLE = e2.DOUBLE = e2.SINGLE = void 0;
        e2.SINGLE = "\u2608";
        e2.DOUBLE = "\u2608\u2608";
        e2.TRIPLE = "\u2608\u2608\u2608";
      }, function(t3, e2, r2) {
        "use strict";
        Object.defineProperty(e2, "__esModule", { value: true });
        var n2 = r2(13), o2 = { html: true, body: true, p: true, div: true, pre: true, section: true, blockquote: true, aside: true, li: true, ul: true, ol: true, form: true, hr: true, h1: true, h2: true, h3: true, h4: true, h5: true, h6: true, dl: true, dd: true, dt: true, br: true, table: true };
        e2.default = function(t4) {
          if (!t4)
            return false;
          var e3 = (0, n2.default)(t4);
          return !!e3 && !!o2[e3];
        };
      }, function(t3, e2, r2) {
        "use strict";
        var n2 = this && this.__extends || function() {
          var t4 = function(e3, r3) {
            return (t4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t5, e4) {
              t5.__proto__ = e4;
            } || function(t5, e4) {
              for (var r4 in e4)
                Object.prototype.hasOwnProperty.call(e4, r4) && (t5[r4] = e4[r4]);
            })(e3, r3);
          };
          return function(e3, r3) {
            if ("function" !== typeof r3 && null !== r3)
              throw new TypeError("Class extends value " + String(r3) + " is not a constructor or null");
            function n3() {
              this.constructor = e3;
            }
            t4(e3, r3), e3.prototype = null === r3 ? Object.create(r3) : (n3.prototype = r3.prototype, new n3());
          };
        }(), o2 = this && this.__assign || function() {
          return (o2 = Object.assign || function(t4) {
            for (var e3, r3 = 1, n3 = arguments.length; r3 < n3; r3++)
              for (var o3 in e3 = arguments[r3])
                Object.prototype.hasOwnProperty.call(e3, o3) && (t4[o3] = e3[o3]);
            return t4;
          }).apply(this, arguments);
        };
        Object.defineProperty(e2, "__esModule", { value: true }), e2.__EmptySelfClose__ = e2.__Empty__ = void 0;
        var i2 = r2(0), a2 = r2(4), c2 = function(t4) {
          function e3(e4, r3, n3) {
            return void 0 === r3 && (r3 = "__empty__"), t4.call(this, e4, r3, n3) || this;
          }
          return n2(e3, t4), e3.prototype.slim = function(t5) {
            return t5;
          }, e3.prototype.parseValidSubTag = function(r3, n3, i3) {
            if ("__skip__" === this.tagName)
              return t4.prototype.parseValidSubTag.call(this, r3, n3, i3);
            var a3 = new e3(r3, n3, o2({}, i3));
            return [a3.exec(), a3];
          }, e3.prototype.parseOnlyString = function(e4, r3, n3) {
            return "__skip__" === this.tagName ? t4.prototype.parseOnlyString.call(this, e4, r3, n3) : [e4, null];
          }, e3.prototype.exec = function() {
            return t4.prototype.exec.call(this, "", "");
          }, e3;
        }(i2.default);
        e2.__Empty__ = c2;
        var u2 = function(t4) {
          function e3(e4, r3) {
            void 0 === r3 && (r3 = "__emptyselfclose__");
            var n3 = t4.call(this, e4, r3) || this;
            return n3.tagName = r3, n3;
          }
          return n2(e3, t4), e3.prototype.exec = function() {
            return t4.prototype.exec.call(this, "", "");
          }, e3;
        }(a2.default);
        e2.__EmptySelfClose__ = u2;
      }, function(t3, e2, r2) {
        "use strict";
        var n2 = this && this.__extends || function() {
          var t4 = function(e3, r3) {
            return (t4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t5, e4) {
              t5.__proto__ = e4;
            } || function(t5, e4) {
              for (var r4 in e4)
                Object.prototype.hasOwnProperty.call(e4, r4) && (t5[r4] = e4[r4]);
            })(e3, r3);
          };
          return function(e3, r3) {
            if ("function" !== typeof r3 && null !== r3)
              throw new TypeError("Class extends value " + String(r3) + " is not a constructor or null");
            function n3() {
              this.constructor = e3;
            }
            t4(e3, r3), e3.prototype = null === r3 ? Object.create(r3) : (n3.prototype = r3.prototype, new n3());
          };
        }();
        Object.defineProperty(e2, "__esModule", { value: true }), e2.__SkipSelfClose__ = e2.__Skip__ = void 0;
        var o2 = r2(0), i2 = r2(4), a2 = r2(1), c2 = function(t4) {
          function e3(e4, r3, n3) {
            void 0 === r3 && (r3 = "__skip__");
            var o3 = t4.call(this, e4, r3, n3) || this;
            return o3.noNeedWrap = ["td", "th"], o3;
          }
          return n2(e3, t4), e3.prototype.exec = function() {
            var e4 = (0, a2.isIndependentTag)((0, a2.getRealTagName)(this.tagName)) && (!this.parentTag || !this.noNeedWrap.includes(this.parentTag)), r3 = e4 ? "\n" : "", n3 = e4 ? "\n" : "";
            return t4.prototype.exec.call(this, r3, n3);
          }, e3;
        }(o2.default);
        e2.__Skip__ = c2;
        var u2 = function(t4) {
          function e3(e4, r3, n3) {
            return void 0 === r3 && (r3 = "__skipselfclose__"), t4.call(this, e4, r3, n3) || this;
          }
          return n2(e3, t4), e3.prototype.exec = function() {
            return "";
          }, e3;
        }(i2.default);
        e2.__SkipSelfClose__ = u2;
      }, function(t3, e2, r2) {
        "use strict";
        var n2 = this && this.__extends || function() {
          var t4 = function(e3, r3) {
            return (t4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t5, e4) {
              t5.__proto__ = e4;
            } || function(t5, e4) {
              for (var r4 in e4)
                Object.prototype.hasOwnProperty.call(e4, r4) && (t5[r4] = e4[r4]);
            })(e3, r3);
          };
          return function(e3, r3) {
            if ("function" !== typeof r3 && null !== r3)
              throw new TypeError("Class extends value " + String(r3) + " is not a constructor or null");
            function n3() {
              this.constructor = e3;
            }
            t4(e3, r3), e3.prototype = null === r3 ? Object.create(r3) : (n3.prototype = r3.prototype, new n3());
          };
        }();
        Object.defineProperty(e2, "__esModule", { value: true }), e2.__NoMatchSelfClose__ = e2.__NoMatch__ = void 0;
        var o2 = r2(0), i2 = r2(4), a2 = function(t4) {
          function e3(e4, r3) {
            return void 0 === r3 && (r3 = "__nomatch__"), t4.call(this, e4, r3) || this;
          }
          return n2(e3, t4), e3.prototype.beforeMergeSpace = function(t5) {
            return "<".concat(this.tagName, ">").concat(t5, "</").concat(this.tagName, ">");
          }, e3.prototype.exec = function() {
            return t4.prototype.exec.call(this, "", "");
          }, e3;
        }(o2.default);
        e2.__NoMatch__ = a2;
        var c2 = function(t4) {
          function e3(e4, r3) {
            return void 0 === r3 && (r3 = "__nomatchselfclose__"), t4.call(this, e4, r3) || this;
          }
          return n2(e3, t4), e3.prototype.exec = function() {
            return "<".concat(this.tagName, " />");
          }, e3;
        }(i2.default);
        e2.__NoMatchSelfClose__ = c2;
      }, function(t3, e2, r2) {
        "use strict";
        Object.defineProperty(e2, "__esModule", { value: true });
        var n2 = { img: true, hr: true, input: true, br: true, meta: true, link: true, "!doctype": true, base: true, col: true, area: true, param: true, object: true, embed: true, keygen: true, source: true };
        e2.default = function(t4) {
          return null != t4 && !!n2[t4.toLowerCase()];
        };
      }, function(t3, e2, r2) {
        "use strict";
        Object.defineProperty(e2, "__esModule", { value: true });
        var n2 = r2(1), o2 = r2(7), i2 = function() {
          function t4(t5, e3, r3) {
            void 0 === e3 && (e3 = "__nomatch__");
            var n3 = void 0 === r3 ? {} : r3, o3 = n3.keepSpace, i3 = void 0 !== o3 && o3, a2 = n3.prevTagName, c2 = void 0 === a2 ? "" : a2, u2 = n3.nextTagName, s2 = void 0 === u2 ? "" : u2, p3 = n3.prevTagStr, l2 = void 0 === p3 ? "" : p3, f2 = n3.prevHasEndSpace, h2 = void 0 !== f2 && f2, d2 = n3.prevHasStartSpace, _ = void 0 !== d2 && d2, y2 = n3.parentTag, v2 = void 0 === y2 ? "" : y2, g2 = n3.calcLeading, b2 = void 0 !== g2 && g2, O2 = n3.layer, m2 = void 0 === O2 ? 1 : O2, S2 = n3.leadingSpace, T2 = void 0 === S2 ? "" : S2, x2 = n3.inTable, j2 = void 0 !== x2 && x2;
            this.tagName = e3, this.nextTagName = s2, this.prevTagName = c2, this.parentTag = v2, this.prevTagStr = l2, this.keepSpace = i3, this.calcLeading = b2, this.leadingSpace = T2, this.layer = m2, this.rawStr = t5, this.inTable = j2, this.prevHasEndSpace = h2, this.prevHasStartSpace = _, this.hasEndSpace = false, this.hasStartSpace = false, t5.startsWith(" ") && (this.hasStartSpace = true), t5.endsWith(" ") && (this.hasEndSpace = true);
          }
          return t4.prototype.slim = function(t5) {
            if (this.keepSpace)
              return t5;
            var e3 = t5.replace(/\s+/g, " ");
            return (0, o2.default)(this.prevTagName) && (e3 = e3.trimLeft()), (0, o2.default)(this.nextTagName) && (e3 = e3.trimRight()), e3;
          }, t4.prototype.beforeReturn = function(t5) {
            if (this.keepSpace)
              return t5;
            if (this.calcLeading)
              return this.leadingSpace + (0, n2.extraEscape)(t5);
            var e3 = (0, n2.extraEscape)(t5);
            return this.inTable && (e3 = e3.replace(/\|/g, "\\|")), this.prevTagName, this.prevHasEndSpace, this.prevTagStr, (0, n2.isSpacePassingTag)(this.prevTagName) && this.prevHasEndSpace && !/^\s+/.test(t5) && !/\s+$/.test(this.prevTagStr) ? " " + t5 : e3;
          }, t4.prototype.exec = function() {
            var t5 = this.rawStr;
            return t5 = this.slim(t5), t5 = this.beforeReturn(t5);
          }, t4;
        }();
        e2.default = i2;
      }, function(t3, e2, r2) {
        "use strict";
        Object.defineProperty(e2, "__esModule", { value: true });
        var n2 = r2(2);
        e2.default = function(t4) {
          if (!t4)
            return t4;
          var e3 = n2.default.get().aliasTags;
          return null != (null === e3 || void 0 === e3 ? void 0 : e3[t4]) ? e3[t4] : t4;
        };
      }, function(t3, e2, r2) {
        "use strict";
        var n2 = this && this.__extends || function() {
          var t4 = function(e3, r3) {
            return (t4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t5, e4) {
              t5.__proto__ = e4;
            } || function(t5, e4) {
              for (var r4 in e4)
                Object.prototype.hasOwnProperty.call(e4, r4) && (t5[r4] = e4[r4]);
            })(e3, r3);
          };
          return function(e3, r3) {
            if ("function" !== typeof r3 && null !== r3)
              throw new TypeError("Class extends value " + String(r3) + " is not a constructor or null");
            function n3() {
              this.constructor = e3;
            }
            t4(e3, r3), e3.prototype = null === r3 ? Object.create(r3) : (n3.prototype = r3.prototype, new n3());
          };
        }();
        Object.defineProperty(e2, "__esModule", { value: true });
        var o2 = function(t4) {
          function e3(e4, r3, n3) {
            void 0 === r3 && (r3 = "strong");
            var o3 = t4.call(this, e4, r3, n3) || this;
            return o3.layer = 1, o3.match = o3.match || "**", o3;
          }
          return n2(e3, t4), e3.prototype.beforeMergeSpace = function(t5) {
            return this.match + t5 + this.match;
          }, e3.prototype.exec = function(e4, r3) {
            return void 0 === e4 && (e4 = ""), void 0 === r3 && (r3 = ""), null != this.match && this.prevTagStr && !this.prevTagStr.endsWith("\\" + this.match[0]) && this.prevTagStr.endsWith(this.match[0]) && (e4 = " "), t4.prototype.exec.call(this, e4, r3);
          }, e3;
        }(r2(0).default);
        e2.default = o2;
      }, function(t3, e2, r2) {
        "use strict";
        var n2 = this && this.__extends || function() {
          var t4 = function(e3, r3) {
            return (t4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t5, e4) {
              t5.__proto__ = e4;
            } || function(t5, e4) {
              for (var r4 in e4)
                Object.prototype.hasOwnProperty.call(e4, r4) && (t5[r4] = e4[r4]);
            })(e3, r3);
          };
          return function(e3, r3) {
            if ("function" !== typeof r3 && null !== r3)
              throw new TypeError("Class extends value " + String(r3) + " is not a constructor or null");
            function n3() {
              this.constructor = e3;
            }
            t4(e3, r3), e3.prototype = null === r3 ? Object.create(r3) : (n3.prototype = r3.prototype, new n3());
          };
        }();
        Object.defineProperty(e2, "__esModule", { value: true });
        var o2 = function(t4) {
          function e3(e4, r3) {
            void 0 === r3 && (r3 = "del");
            var n3 = t4.call(this, e4, r3) || this;
            return n3.match = n3.match || "~~", n3;
          }
          return n2(e3, t4), e3.prototype.beforeMergeSpace = function(t5) {
            return this.match + t5 + this.match;
          }, e3.prototype.exec = function(e4, r3) {
            return void 0 === e4 && (e4 = ""), void 0 === r3 && (r3 = ""), t4.prototype.exec.call(this, e4, r3);
          }, e3;
        }(r2(0).default);
        e2.default = o2;
      }, function(t3, e2, r2) {
        "use strict";
        var n2 = this && this.__extends || function() {
          var t4 = function(e3, r3) {
            return (t4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t5, e4) {
              t5.__proto__ = e4;
            } || function(t5, e4) {
              for (var r4 in e4)
                Object.prototype.hasOwnProperty.call(e4, r4) && (t5[r4] = e4[r4]);
            })(e3, r3);
          };
          return function(e3, r3) {
            if ("function" !== typeof r3 && null !== r3)
              throw new TypeError("Class extends value " + String(r3) + " is not a constructor or null");
            function n3() {
              this.constructor = e3;
            }
            t4(e3, r3), e3.prototype = null === r3 ? Object.create(r3) : (n3.prototype = r3.prototype, new n3());
          };
        }();
        Object.defineProperty(e2, "__esModule", { value: true });
        var o2 = function(t4) {
          function e3(e4, r3, n3) {
            void 0 === r3 && (r3 = "em");
            var o3 = t4.call(this, e4, r3, n3) || this;
            return o3.match = o3.match || "*", o3;
          }
          return n2(e3, t4), e3.prototype.beforeMergeSpace = function(t5) {
            return this.match + t5 + this.match;
          }, e3.prototype.exec = function(e4, r3) {
            return void 0 === e4 && (e4 = ""), void 0 === r3 && (r3 = ""), "strong" === this.parentTag && this.nextTagStr && (r3 = " "), null != this.match && this.prevTagStr && !this.prevTagStr.endsWith("\\" + this.match) && this.prevTagStr.endsWith(this.match) && (e4 = " "), t4.prototype.exec.call(this, e4, r3);
          }, e3;
        }(r2(0).default);
        e2.default = o2;
      }, function(t3, e2, r2) {
        "use strict";
        var n2 = this && this.__extends || function() {
          var t4 = function(e3, r3) {
            return (t4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t5, e4) {
              t5.__proto__ = e4;
            } || function(t5, e4) {
              for (var r4 in e4)
                Object.prototype.hasOwnProperty.call(e4, r4) && (t5[r4] = e4[r4]);
            })(e3, r3);
          };
          return function(e3, r3) {
            if ("function" !== typeof r3 && null !== r3)
              throw new TypeError("Class extends value " + String(r3) + " is not a constructor or null");
            function n3() {
              this.constructor = e3;
            }
            t4(e3, r3), e3.prototype = null === r3 ? Object.create(r3) : (n3.prototype = r3.prototype, new n3());
          };
        }();
        Object.defineProperty(e2, "__esModule", { value: true });
        var o2 = function(t4) {
          function e3(e4, r3, n3) {
            void 0 === r3 && (r3 = "th");
            var o3 = t4.call(this, e4, r3, n3) || this;
            return o3.tagName = r3, o3;
          }
          return n2(e3, t4), e3.prototype.beforeMergeSpace = function(t5) {
            return t5 + "|";
          }, e3.prototype.parseValidSubTag = function(e4, r3, n3) {
            return "ul" === r3 || "ol" === r3 || "table" === r3 || "pre" === r3 ? [e4.replace(/([\n\r])/g, ""), null] : t4.prototype.parseValidSubTag.call(this, e4, r3, n3);
          }, e3.prototype.exec = function(e4, r3) {
            return void 0 === e4 && (e4 = ""), void 0 === r3 && (r3 = ""), t4.prototype.exec.call(this, e4, r3);
          }, e3;
        }(r2(0).default);
        e2.default = o2;
      }, function(t3, e2, r2) {
        "use strict";
        var n2 = this && this.__extends || function() {
          var t4 = function(e3, r3) {
            return (t4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t5, e4) {
              t5.__proto__ = e4;
            } || function(t5, e4) {
              for (var r4 in e4)
                Object.prototype.hasOwnProperty.call(e4, r4) && (t5[r4] = e4[r4]);
            })(e3, r3);
          };
          return function(e3, r3) {
            if ("function" !== typeof r3 && null !== r3)
              throw new TypeError("Class extends value " + String(r3) + " is not a constructor or null");
            function n3() {
              this.constructor = e3;
            }
            t4(e3, r3), e3.prototype = null === r3 ? Object.create(r3) : (n3.prototype = r3.prototype, new n3());
          };
        }();
        Object.defineProperty(e2, "__esModule", { value: true });
        var o2 = function(t4) {
          function e3(e4, r3, n3) {
            return void 0 === r3 && (r3 = "a"), t4.call(this, e4, r3, n3) || this;
          }
          return n2(e3, t4), e3.prototype.beforeMergeSpace = function(t5) {
            var e4 = this.attrs, r3 = e4.href, n3 = e4.title, o3 = r3 || "";
            return n3 ? "[".concat(t5, "](").concat(o3, ' "').concat(n3, '")') : "[".concat(t5, "](").concat(o3, ")");
          }, e3.prototype.parseOnlyString = function(e4, r3, n3) {
            return "tbody" === this.parentTag || "thead" === this.parentTag ? [e4, null] : t4.prototype.parseOnlyString.call(this, e4, r3, n3);
          }, e3.prototype.exec = function(e4, r3) {
            return void 0 === e4 && (e4 = ""), void 0 === r3 && (r3 = ""), t4.prototype.exec.call(this, e4, r3);
          }, e3;
        }(r2(0).default);
        e2.default = o2;
      }, function(t3, e2, r2) {
        "use strict";
        var n2 = this && this.__extends || function() {
          var t4 = function(e3, r3) {
            return (t4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t5, e4) {
              t5.__proto__ = e4;
            } || function(t5, e4) {
              for (var r4 in e4)
                Object.prototype.hasOwnProperty.call(e4, r4) && (t5[r4] = e4[r4]);
            })(e3, r3);
          };
          return function(e3, r3) {
            if ("function" !== typeof r3 && null !== r3)
              throw new TypeError("Class extends value " + String(r3) + " is not a constructor or null");
            function n3() {
              this.constructor = e3;
            }
            t4(e3, r3), e3.prototype = null === r3 ? Object.create(r3) : (n3.prototype = r3.prototype, new n3());
          };
        }();
        Object.defineProperty(e2, "__esModule", { value: true });
        var o2 = function(t4) {
          function e3(e4, r3, n3) {
            return void 0 === r3 && (r3 = "b"), t4.call(this, e4, r3, n3) || this;
          }
          return n2(e3, t4), e3.prototype.exec = function(e4, r3) {
            return t4.prototype.exec.call(this, e4, r3);
          }, e3;
        }(r2(14).default);
        e2.default = o2;
      }, function(t3, e2, r2) {
        "use strict";
        var n2 = this && this.__extends || function() {
          var t4 = function(e3, r3) {
            return (t4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t5, e4) {
              t5.__proto__ = e4;
            } || function(t5, e4) {
              for (var r4 in e4)
                Object.prototype.hasOwnProperty.call(e4, r4) && (t5[r4] = e4[r4]);
            })(e3, r3);
          };
          return function(e3, r3) {
            if ("function" !== typeof r3 && null !== r3)
              throw new TypeError("Class extends value " + String(r3) + " is not a constructor or null");
            function n3() {
              this.constructor = e3;
            }
            t4(e3, r3), e3.prototype = null === r3 ? Object.create(r3) : (n3.prototype = r3.prototype, new n3());
          };
        }(), o2 = this && this.__assign || function() {
          return (o2 = Object.assign || function(t4) {
            for (var e3, r3 = 1, n3 = arguments.length; r3 < n3; r3++)
              for (var o3 in e3 = arguments[r3])
                Object.prototype.hasOwnProperty.call(e3, o3) && (t4[o3] = e3[o3]);
            return t4;
          }).apply(this, arguments);
        };
        Object.defineProperty(e2, "__esModule", { value: true });
        var i2 = r2(7), a2 = r2(0), c2 = r2(1), u2 = function(t4) {
          function e3(e4, r3, n3) {
            void 0 === r3 && (r3 = "blockquote");
            var o3 = t4.call(this, e4, r3, n3) || this;
            return o3.match = o3.match || ">", o3.fillPerLine = o3.fillPerLine.bind(o3), o3;
          }
          return n2(e3, t4), e3.prototype.beforeMergeSpace = function(t5) {
            if ("" === t5.trim())
              return "";
            var e4 = this.match + " " + t5;
            return this.calcLeading ? this.leadingSpace + e4 : e4;
          }, e3.prototype.afterMergeSpace = function(t5) {
            for (var e4 = this, r3 = t5.split("\n"), n3 = r3.length - 1; n3 >= 0; n3--)
              n3 < r3.length - 1 && ">" === r3[n3].trim() && ">" === r3[n3 + 1].trim() && r3.splice(n3, 1);
            return (r3 = r3.map(function(t6) {
              return "" === t6 ? "" : e4.fillPerLine(t6);
            })).join("\n");
          }, e3.prototype.beforeReturn = function(t5) {
            return t5.replace("\n\n", "\n");
          }, e3.prototype.fillPerLine = function(t5) {
            var e4 = ">";
            if (this.calcLeading && (e4 = this.leadingSpace + ">"), !t5.startsWith(e4)) {
              var r3 = this.match + " " + t5;
              return this.calcLeading ? this.leadingSpace + r3 : r3;
            }
            return t5;
          }, e3.prototype.parseValidSubTag = function(t5, e4, r3) {
            var n3;
            "blockquote" === e4 ? n3 = new ((0, c2.getTagConstructor)(e4))(t5, e4, o2(o2({}, r3), { calcLeading: this.calcLeading, match: this.match + ">", noExtraLine: true })) : n3 = new ((0, c2.getTagConstructor)(e4))(t5, e4, o2(o2({}, r3), { noExtraLine: true }));
            var a3 = n3.exec(), u3 = "";
            this.calcLeading && (u3 = this.leadingSpace);
            var s2 = (0, i2.default)(r3.prevTagName) && "br" !== r3.prevTagName, p3 = (0, i2.default)(r3.nextTagName) && "br" !== r3.nextTagName, l2 = (0, i2.default)(e4) && "br" !== e4;
            return this.isFirstSubTag ? [a3.trimLeft().replace(u3, ""), n3] : l2 ? (a3 = u3 + this.match + a3, s2 || (a3 = "\n" + a3), !p3 && r3.nextTagStr && r3.nextTagStr.trim() && (a3 += this.match + "\n"), [a3, n3]) : s2 ? [u3 + this.match + "\n" + a3, n3] : [a3, n3];
          }, e3.prototype.exec = function(e4, r3) {
            return void 0 === e4 && (e4 = "\n"), void 0 === r3 && (r3 = "\n"), t4.prototype.exec.call(this, e4, r3);
          }, e3;
        }(a2.default);
        e2.default = u2;
      }, function(t3, e2, r2) {
        "use strict";
        var n2 = this && this.__extends || function() {
          var t4 = function(e3, r3) {
            return (t4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t5, e4) {
              t5.__proto__ = e4;
            } || function(t5, e4) {
              for (var r4 in e4)
                Object.prototype.hasOwnProperty.call(e4, r4) && (t5[r4] = e4[r4]);
            })(e3, r3);
          };
          return function(e3, r3) {
            if ("function" !== typeof r3 && null !== r3)
              throw new TypeError("Class extends value " + String(r3) + " is not a constructor or null");
            function n3() {
              this.constructor = e3;
            }
            t4(e3, r3), e3.prototype = null === r3 ? Object.create(r3) : (n3.prototype = r3.prototype, new n3());
          };
        }();
        Object.defineProperty(e2, "__esModule", { value: true });
        var o2 = function(t4) {
          function e3(e4, r3, n3) {
            return void 0 === r3 && (r3 = "b"), t4.call(this, e4, r3, n3) || this;
          }
          return n2(e3, t4), e3.prototype.exec = function(t5, e4) {
            return void 0 === e4 && (e4 = "\n"), this.inTable ? "" : "  " + e4;
          }, e3;
        }(r2(4).default);
        e2.default = o2;
      }, function(t3, e2, r2) {
        "use strict";
        var n2 = this && this.__extends || function() {
          var t4 = function(e3, r3) {
            return (t4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t5, e4) {
              t5.__proto__ = e4;
            } || function(t5, e4) {
              for (var r4 in e4)
                Object.prototype.hasOwnProperty.call(e4, r4) && (t5[r4] = e4[r4]);
            })(e3, r3);
          };
          return function(e3, r3) {
            if ("function" !== typeof r3 && null !== r3)
              throw new TypeError("Class extends value " + String(r3) + " is not a constructor or null");
            function n3() {
              this.constructor = e3;
            }
            t4(e3, r3), e3.prototype = null === r3 ? Object.create(r3) : (n3.prototype = r3.prototype, new n3());
          };
        }(), o2 = this && this.__assign || function() {
          return (o2 = Object.assign || function(t4) {
            for (var e3, r3 = 1, n3 = arguments.length; r3 < n3; r3++)
              for (var o3 in e3 = arguments[r3])
                Object.prototype.hasOwnProperty.call(e3, o3) && (t4[o3] = e3[o3]);
            return t4;
          }).apply(this, arguments);
        };
        Object.defineProperty(e2, "__esModule", { value: true });
        var i2 = r2(0), a2 = r2(1), c2 = function(t4) {
          function e3(e4, r3, n3) {
            void 0 === r3 && (r3 = "code");
            var o3 = t4.call(this, e4, r3, n3) || this;
            return o3.match = null == o3.match ? "`" : o3.match, o3.noWrap = "`" === o3.match, o3.layer = 1, o3;
          }
          return n2(e3, t4), e3.prototype.beforeMergeSpace = function(t5) {
            var e4, r3;
            return "" !== this.match && "`" !== this.match ? (e4 = this.match + " ", r3 = " " + this.match) : (e4 = this.match, r3 = this.match), e4 + t5 + r3;
          }, e3.prototype.parseValidSubTag = function(t5, e4, r3) {
            var n3;
            return "pre" === e4 ? [(n3 = new ((0, a2.getTagConstructor)(e4))(t5, e4, o2(o2({}, r3), { language: "", match: "" }))).exec("", "\n"), n3] : [(n3 = new ((0, a2.getTagConstructor)(e4))(t5, e4, o2(o2({}, r3), { keepSpace: this.keepSpace, noWrap: this.noWrap }))).exec("", ""), n3];
          }, e3.prototype.parseOnlyString = function(t5) {
            if ("" !== this.match && t5) {
              var e4 = 1;
              (t5.startsWith("`") || t5.endsWith("`")) && (e4 = 2, (t5.startsWith("``") || t5.endsWith("``")) && (e4 = 3)), this.match = "`".repeat(e4);
            }
            return [(0, a2.unescapeStr)(t5), null];
          }, e3.prototype.slim = function(t5) {
            return this.keepSpace ? t5 : t5.trim();
          }, e3.prototype.exec = function(e4, r3) {
            return void 0 === e4 && (e4 = ""), void 0 === r3 && (r3 = ""), t4.prototype.exec.call(this, e4, r3);
          }, e3;
        }(i2.default);
        e2.default = c2;
      }, function(t3, e2, r2) {
        "use strict";
        var n2 = this && this.__extends || function() {
          var t4 = function(e3, r3) {
            return (t4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t5, e4) {
              t5.__proto__ = e4;
            } || function(t5, e4) {
              for (var r4 in e4)
                Object.prototype.hasOwnProperty.call(e4, r4) && (t5[r4] = e4[r4]);
            })(e3, r3);
          };
          return function(e3, r3) {
            if ("function" !== typeof r3 && null !== r3)
              throw new TypeError("Class extends value " + String(r3) + " is not a constructor or null");
            function n3() {
              this.constructor = e3;
            }
            t4(e3, r3), e3.prototype = null === r3 ? Object.create(r3) : (n3.prototype = r3.prototype, new n3());
          };
        }();
        Object.defineProperty(e2, "__esModule", { value: true });
        var o2 = function(t4) {
          function e3(e4, r3) {
            void 0 === r3 && (r3 = "h1");
            var n3 = t4.call(this, e4, r3) || this;
            return n3.match = "#", n3;
          }
          return n2(e3, t4), e3.prototype.exec = function(e4, r3) {
            return void 0 === e4 && (e4 = "\n"), void 0 === r3 && (r3 = "\n"), t4.prototype.exec.call(this, e4, r3);
          }, e3;
        }(r2(3).default);
        e2.default = o2;
      }, function(t3, e2, r2) {
        "use strict";
        var n2 = this && this.__extends || function() {
          var t4 = function(e3, r3) {
            return (t4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t5, e4) {
              t5.__proto__ = e4;
            } || function(t5, e4) {
              for (var r4 in e4)
                Object.prototype.hasOwnProperty.call(e4, r4) && (t5[r4] = e4[r4]);
            })(e3, r3);
          };
          return function(e3, r3) {
            if ("function" !== typeof r3 && null !== r3)
              throw new TypeError("Class extends value " + String(r3) + " is not a constructor or null");
            function n3() {
              this.constructor = e3;
            }
            t4(e3, r3), e3.prototype = null === r3 ? Object.create(r3) : (n3.prototype = r3.prototype, new n3());
          };
        }();
        Object.defineProperty(e2, "__esModule", { value: true });
        var o2 = function(t4) {
          function e3(e4, r3) {
            void 0 === r3 && (r3 = "h2");
            var n3 = t4.call(this, e4, r3) || this;
            return n3.match = "##", n3;
          }
          return n2(e3, t4), e3.prototype.exec = function(e4, r3) {
            return void 0 === e4 && (e4 = "\n"), void 0 === r3 && (r3 = "\n"), t4.prototype.exec.call(this, e4, r3);
          }, e3;
        }(r2(3).default);
        e2.default = o2;
      }, function(t3, e2, r2) {
        "use strict";
        var n2 = this && this.__extends || function() {
          var t4 = function(e3, r3) {
            return (t4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t5, e4) {
              t5.__proto__ = e4;
            } || function(t5, e4) {
              for (var r4 in e4)
                Object.prototype.hasOwnProperty.call(e4, r4) && (t5[r4] = e4[r4]);
            })(e3, r3);
          };
          return function(e3, r3) {
            if ("function" !== typeof r3 && null !== r3)
              throw new TypeError("Class extends value " + String(r3) + " is not a constructor or null");
            function n3() {
              this.constructor = e3;
            }
            t4(e3, r3), e3.prototype = null === r3 ? Object.create(r3) : (n3.prototype = r3.prototype, new n3());
          };
        }();
        Object.defineProperty(e2, "__esModule", { value: true });
        var o2 = function(t4) {
          function e3(e4, r3) {
            void 0 === r3 && (r3 = "h3");
            var n3 = t4.call(this, e4, r3) || this;
            return n3.match = "###", n3;
          }
          return n2(e3, t4), e3.prototype.exec = function(e4, r3) {
            return void 0 === e4 && (e4 = "\n"), void 0 === r3 && (r3 = "\n"), t4.prototype.exec.call(this, e4, r3);
          }, e3;
        }(r2(3).default);
        e2.default = o2;
      }, function(t3, e2, r2) {
        "use strict";
        var n2 = this && this.__extends || function() {
          var t4 = function(e3, r3) {
            return (t4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t5, e4) {
              t5.__proto__ = e4;
            } || function(t5, e4) {
              for (var r4 in e4)
                Object.prototype.hasOwnProperty.call(e4, r4) && (t5[r4] = e4[r4]);
            })(e3, r3);
          };
          return function(e3, r3) {
            if ("function" !== typeof r3 && null !== r3)
              throw new TypeError("Class extends value " + String(r3) + " is not a constructor or null");
            function n3() {
              this.constructor = e3;
            }
            t4(e3, r3), e3.prototype = null === r3 ? Object.create(r3) : (n3.prototype = r3.prototype, new n3());
          };
        }();
        Object.defineProperty(e2, "__esModule", { value: true });
        var o2 = function(t4) {
          function e3(e4, r3) {
            void 0 === r3 && (r3 = "h4");
            var n3 = t4.call(this, e4, r3) || this;
            return n3.match = "####", n3;
          }
          return n2(e3, t4), e3.prototype.exec = function(e4, r3) {
            return void 0 === e4 && (e4 = "\n"), void 0 === r3 && (r3 = "\n"), t4.prototype.exec.call(this, e4, r3);
          }, e3;
        }(r2(3).default);
        e2.default = o2;
      }, function(t3, e2, r2) {
        "use strict";
        var n2 = this && this.__extends || function() {
          var t4 = function(e3, r3) {
            return (t4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t5, e4) {
              t5.__proto__ = e4;
            } || function(t5, e4) {
              for (var r4 in e4)
                Object.prototype.hasOwnProperty.call(e4, r4) && (t5[r4] = e4[r4]);
            })(e3, r3);
          };
          return function(e3, r3) {
            if ("function" !== typeof r3 && null !== r3)
              throw new TypeError("Class extends value " + String(r3) + " is not a constructor or null");
            function n3() {
              this.constructor = e3;
            }
            t4(e3, r3), e3.prototype = null === r3 ? Object.create(r3) : (n3.prototype = r3.prototype, new n3());
          };
        }();
        Object.defineProperty(e2, "__esModule", { value: true });
        var o2 = function(t4) {
          function e3(e4, r3) {
            void 0 === r3 && (r3 = "h5");
            var n3 = t4.call(this, e4, r3) || this;
            return n3.match = "#####", n3;
          }
          return n2(e3, t4), e3.prototype.exec = function(e4, r3) {
            return void 0 === e4 && (e4 = "\n"), void 0 === r3 && (r3 = "\n"), t4.prototype.exec.call(this, e4, r3);
          }, e3;
        }(r2(3).default);
        e2.default = o2;
      }, function(t3, e2, r2) {
        "use strict";
        var n2 = this && this.__extends || function() {
          var t4 = function(e3, r3) {
            return (t4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t5, e4) {
              t5.__proto__ = e4;
            } || function(t5, e4) {
              for (var r4 in e4)
                Object.prototype.hasOwnProperty.call(e4, r4) && (t5[r4] = e4[r4]);
            })(e3, r3);
          };
          return function(e3, r3) {
            if ("function" !== typeof r3 && null !== r3)
              throw new TypeError("Class extends value " + String(r3) + " is not a constructor or null");
            function n3() {
              this.constructor = e3;
            }
            t4(e3, r3), e3.prototype = null === r3 ? Object.create(r3) : (n3.prototype = r3.prototype, new n3());
          };
        }();
        Object.defineProperty(e2, "__esModule", { value: true });
        var o2 = function(t4) {
          function e3(e4, r3) {
            void 0 === r3 && (r3 = "h6");
            var n3 = t4.call(this, e4, r3) || this;
            return n3.match = "######", n3;
          }
          return n2(e3, t4), e3.prototype.exec = function(e4, r3) {
            return void 0 === e4 && (e4 = "\n"), void 0 === r3 && (r3 = "\n"), t4.prototype.exec.call(this, e4, r3);
          }, e3;
        }(r2(3).default);
        e2.default = o2;
      }, function(t3, e2, r2) {
        "use strict";
        var n2 = this && this.__extends || function() {
          var t4 = function(e3, r3) {
            return (t4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t5, e4) {
              t5.__proto__ = e4;
            } || function(t5, e4) {
              for (var r4 in e4)
                Object.prototype.hasOwnProperty.call(e4, r4) && (t5[r4] = e4[r4]);
            })(e3, r3);
          };
          return function(e3, r3) {
            if ("function" !== typeof r3 && null !== r3)
              throw new TypeError("Class extends value " + String(r3) + " is not a constructor or null");
            function n3() {
              this.constructor = e3;
            }
            t4(e3, r3), e3.prototype = null === r3 ? Object.create(r3) : (n3.prototype = r3.prototype, new n3());
          };
        }();
        Object.defineProperty(e2, "__esModule", { value: true });
        var o2 = function(t4) {
          function e3(e4, r3, n3) {
            void 0 === r3 && (r3 = "hr");
            var o3 = t4.call(this, e4, r3, n3) || this;
            return o3.match = "---", o3;
          }
          return n2(e3, t4), e3.prototype.beforeMergeSpace = function() {
            return this.leadingSpace + this.match;
          }, e3.prototype.beforeReturn = function(t5) {
            return t5.replace(/^(?:\n\s*)/, "\n\n").replace(/(?:\n\s*)$/, "\n\n"), t5;
          }, e3.prototype.exec = function(e4, r3) {
            return void 0 === e4 && (e4 = "\n"), void 0 === r3 && (r3 = "\n"), t4.prototype.exec.call(this, e4, r3);
          }, e3;
        }(r2(4).default);
        e2.default = o2;
      }, function(t3, e2, r2) {
        "use strict";
        var n2 = this && this.__extends || function() {
          var t4 = function(e3, r3) {
            return (t4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t5, e4) {
              t5.__proto__ = e4;
            } || function(t5, e4) {
              for (var r4 in e4)
                Object.prototype.hasOwnProperty.call(e4, r4) && (t5[r4] = e4[r4]);
            })(e3, r3);
          };
          return function(e3, r3) {
            if ("function" !== typeof r3 && null !== r3)
              throw new TypeError("Class extends value " + String(r3) + " is not a constructor or null");
            function n3() {
              this.constructor = e3;
            }
            t4(e3, r3), e3.prototype = null === r3 ? Object.create(r3) : (n3.prototype = r3.prototype, new n3());
          };
        }();
        Object.defineProperty(e2, "__esModule", { value: true });
        var o2 = function(t4) {
          function e3(e4, r3, n3) {
            return void 0 === r3 && (r3 = "i"), t4.call(this, e4, r3, n3) || this;
          }
          return n2(e3, t4), e3.prototype.exec = function(e4, r3) {
            return t4.prototype.exec.call(this, e4, r3);
          }, e3;
        }(r2(16).default);
        e2.default = o2;
      }, function(t3, e2, r2) {
        "use strict";
        var n2 = this && this.__extends || function() {
          var t4 = function(e3, r3) {
            return (t4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t5, e4) {
              t5.__proto__ = e4;
            } || function(t5, e4) {
              for (var r4 in e4)
                Object.prototype.hasOwnProperty.call(e4, r4) && (t5[r4] = e4[r4]);
            })(e3, r3);
          };
          return function(e3, r3) {
            if ("function" !== typeof r3 && null !== r3)
              throw new TypeError("Class extends value " + String(r3) + " is not a constructor or null");
            function n3() {
              this.constructor = e3;
            }
            t4(e3, r3), e3.prototype = null === r3 ? Object.create(r3) : (n3.prototype = r3.prototype, new n3());
          };
        }();
        Object.defineProperty(e2, "__esModule", { value: true });
        var o2 = function(t4) {
          function e3(e4, r3, n3) {
            return void 0 === r3 && (r3 = "img"), t4.call(this, e4, r3, n3) || this;
          }
          return n2(e3, t4), e3.prototype.beforeMergeSpace = function() {
            var t5 = this.attrs, e4 = t5.src, r3 = t5.alt;
            return r3 || (r3 = ""), e4 || (e4 = ""), "![".concat(r3, "](").concat(e4, ")");
          }, e3.prototype.exec = function(e4, r3) {
            return void 0 === e4 && (e4 = ""), void 0 === r3 && (r3 = ""), t4.prototype.exec.call(this, e4, r3);
          }, e3;
        }(r2(4).default);
        e2.default = o2;
      }, function(t3, e2, r2) {
        "use strict";
        var n2 = this && this.__extends || function() {
          var t4 = function(e3, r3) {
            return (t4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t5, e4) {
              t5.__proto__ = e4;
            } || function(t5, e4) {
              for (var r4 in e4)
                Object.prototype.hasOwnProperty.call(e4, r4) && (t5[r4] = e4[r4]);
            })(e3, r3);
          };
          return function(e3, r3) {
            if ("function" !== typeof r3 && null !== r3)
              throw new TypeError("Class extends value " + String(r3) + " is not a constructor or null");
            function n3() {
              this.constructor = e3;
            }
            t4(e3, r3), e3.prototype = null === r3 ? Object.create(r3) : (n3.prototype = r3.prototype, new n3());
          };
        }();
        Object.defineProperty(e2, "__esModule", { value: true });
        var o2 = function(t4) {
          function e3(e4, r3, n3) {
            return void 0 === r3 && (r3 = "input"), t4.call(this, e4, r3, n3) || this;
          }
          return n2(e3, t4), e3.prototype.beforeMergeSpace = function() {
            var t5 = this.attrs, e4 = t5.type, r3 = t5.checked;
            return "li" === this.parentTag && "checkbox" === e4 ? null != r3 ? "[x] " : "[ ] " : "";
          }, e3.prototype.exec = function(e4, r3) {
            return void 0 === e4 && (e4 = ""), void 0 === r3 && (r3 = ""), t4.prototype.exec.call(this, e4, r3);
          }, e3;
        }(r2(4).default);
        e2.default = o2;
      }, function(t3, e2, r2) {
        "use strict";
        var n2 = this && this.__extends || function() {
          var t4 = function(e3, r3) {
            return (t4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t5, e4) {
              t5.__proto__ = e4;
            } || function(t5, e4) {
              for (var r4 in e4)
                Object.prototype.hasOwnProperty.call(e4, r4) && (t5[r4] = e4[r4]);
            })(e3, r3);
          };
          return function(e3, r3) {
            if ("function" !== typeof r3 && null !== r3)
              throw new TypeError("Class extends value " + String(r3) + " is not a constructor or null");
            function n3() {
              this.constructor = e3;
            }
            t4(e3, r3), e3.prototype = null === r3 ? Object.create(r3) : (n3.prototype = r3.prototype, new n3());
          };
        }(), o2 = this && this.__assign || function() {
          return (o2 = Object.assign || function(t4) {
            for (var e3, r3 = 1, n3 = arguments.length; r3 < n3; r3++)
              for (var o3 in e3 = arguments[r3])
                Object.prototype.hasOwnProperty.call(e3, o3) && (t4[o3] = e3[o3]);
            return t4;
          }).apply(this, arguments);
        };
        Object.defineProperty(e2, "__esModule", { value: true });
        var i2 = r2(0), a2 = r2(1), c2 = r2(7), u2 = r2(6), s2 = function(t4) {
          function e3(e4, r3, n3) {
            void 0 === r3 && (r3 = "li");
            var o3 = t4.call(this, e4, r3, n3) || this;
            return o3.match = o3.match || "*", o3.extraGap = "", o3;
          }
          return n2(e3, t4), e3.prototype.beforeMergeSpace = function(t5) {
            return this.extraGap + this.leadingSpace + this.match + " " + t5;
          }, e3.prototype.__calcNextLeading__ = function() {
            var t5, e4, r3;
            return 1 === (null === (t5 = this.match) || void 0 === t5 ? void 0 : t5.length) ? u2.DOUBLE : 2 === (null === (e4 = this.match) || void 0 === e4 ? void 0 : e4.length) ? u2.TRIPLE : 3 === (null === (r3 = this.match) || void 0 === r3 ? void 0 : r3.length) ? u2.DOUBLE : u2.TRIPLE + u2.DOUBLE;
          }, e3.prototype.parseValidSubTag = function(t5, e4, r3) {
            var n3 = (0, a2.getTagConstructor)(e4), i3 = this.__calcNextLeading__(), c3 = new n3(t5, e4, o2(o2({}, r3), { calcLeading: true, leadingSpace: this.leadingSpace + i3, layer: this.layer + 1 })), u3 = c3.exec();
            return "p" === e4 && (this.extraGap = "\n"), this.isFirstSubTag ? [u3.trimLeft().replace(this.leadingSpace + i3, ""), c3] : [u3, c3];
          }, e3.prototype.parseOnlyString = function(e4, r3, n3) {
            var i3 = false;
            (0, c2.default)(n3.prevTagName) && (i3 = true);
            var a3 = this.__calcNextLeading__(), u3 = t4.prototype.parseOnlyString.call(this, e4, r3, o2(o2({}, n3), { calcLeading: i3, leadingSpace: this.leadingSpace + a3, layer: this.layer + 1 })), s3 = u3[0], p3 = u3[1];
            return this.isFirstSubTag ? [s3.replace(this.leadingSpace + a3, ""), p3] : [s3, p3];
          }, e3.prototype.beforeReturn = function(e4) {
            return t4.prototype.beforeReturn.call(this, e4);
          }, e3.prototype.exec = function(e4, r3) {
            return void 0 === e4 && (e4 = "\n"), void 0 === r3 && (r3 = "\n"), t4.prototype.exec.call(this, e4, r3);
          }, e3;
        }(i2.default);
        e2.default = s2;
      }, function(t3, e2, r2) {
        "use strict";
        var n2 = this && this.__extends || function() {
          var t4 = function(e3, r3) {
            return (t4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t5, e4) {
              t5.__proto__ = e4;
            } || function(t5, e4) {
              for (var r4 in e4)
                Object.prototype.hasOwnProperty.call(e4, r4) && (t5[r4] = e4[r4]);
            })(e3, r3);
          };
          return function(e3, r3) {
            if ("function" !== typeof r3 && null !== r3)
              throw new TypeError("Class extends value " + String(r3) + " is not a constructor or null");
            function n3() {
              this.constructor = e3;
            }
            t4(e3, r3), e3.prototype = null === r3 ? Object.create(r3) : (n3.prototype = r3.prototype, new n3());
          };
        }(), o2 = this && this.__assign || function() {
          return (o2 = Object.assign || function(t4) {
            for (var e3, r3 = 1, n3 = arguments.length; r3 < n3; r3++)
              for (var o3 in e3 = arguments[r3])
                Object.prototype.hasOwnProperty.call(e3, o3) && (t4[o3] = e3[o3]);
            return t4;
          }).apply(this, arguments);
        };
        Object.defineProperty(e2, "__esModule", { value: true });
        var i2 = r2(0), a2 = r2(5), c2 = r2(1), u2 = r2(2), s2 = function(t4) {
          function e3(e4, r3, n3) {
            void 0 === r3 && (r3 = "ol");
            var o3, i3 = this;
            i3 = t4.call(this, e4, r3, n3) || this;
            var a3 = parseInt(null === (o3 = null === i3 || void 0 === i3 ? void 0 : i3.attrs) || void 0 === o3 ? void 0 : o3.start, 10);
            return i3.count = isNaN(a3) ? 1 : a3, i3;
          }
          return n2(e3, t4), e3.prototype.__isValidSubTag__ = function(t5) {
            if (!t5)
              return false;
            var e4 = u2.default.get().aliasTags, r3 = (0, c2.getTagConstructor)(t5);
            return "li" === t5 || "li" == (null === e4 || void 0 === e4 ? void 0 : e4[t5]) || r3 === a2.default;
          }, e3.prototype.getValidSubTagName = function(t5) {
            return t5 && this.__isValidSubTag__(t5) ? t5 : null;
          }, e3.prototype.parseValidSubTag = function(t5, e4, r3) {
            var n3 = (0, c2.getTagConstructor)(e4);
            if (this.__isValidSubTag__(e4)) {
              var i3 = this.count + ".", a3 = new n3(t5, e4, o2(o2({}, r3), { calcLeading: true, leadingSpace: this.leadingSpace, layer: this.layer, match: i3 }));
              return this.count++, [a3.exec("", "\n"), a3];
            }
            return ["", null];
          }, e3.prototype.parseOnlyString = function() {
            return ["", null];
          }, e3.prototype.exec = function(e4, r3) {
            return void 0 === e4 && (e4 = "\n"), void 0 === r3 && (r3 = "\n"), t4.prototype.exec.call(this, e4, r3);
          }, e3;
        }(i2.default);
        e2.default = s2;
      }, function(t3, e2, r2) {
        "use strict";
        var n2 = this && this.__extends || function() {
          var t4 = function(e3, r3) {
            return (t4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t5, e4) {
              t5.__proto__ = e4;
            } || function(t5, e4) {
              for (var r4 in e4)
                Object.prototype.hasOwnProperty.call(e4, r4) && (t5[r4] = e4[r4]);
            })(e3, r3);
          };
          return function(e3, r3) {
            if ("function" !== typeof r3 && null !== r3)
              throw new TypeError("Class extends value " + String(r3) + " is not a constructor or null");
            function n3() {
              this.constructor = e3;
            }
            t4(e3, r3), e3.prototype = null === r3 ? Object.create(r3) : (n3.prototype = r3.prototype, new n3());
          };
        }();
        Object.defineProperty(e2, "__esModule", { value: true });
        var o2 = function(t4) {
          function e3(e4, r3, n3) {
            return void 0 === r3 && (r3 = "p"), t4.call(this, e4, r3, n3) || this;
          }
          return n2(e3, t4), e3.prototype.beforeMergeSpace = function(t5) {
            return this.calcLeading ? this.leadingSpace + t5 : t5;
          }, e3.prototype.exec = function(e4, r3) {
            return void 0 === e4 && (e4 = "\n"), void 0 === r3 && (r3 = "\n"), this.prevTagName || !this.prevTagStr || this.prevTagStr.endsWith("\n") || (e4 = "\n\n"), this.nextTagName || !this.nextTagStr || this.nextTagStr.startsWith("\n") || (r3 = "\n\n"), t4.prototype.exec.call(this, e4, r3);
          }, e3;
        }(r2(0).default);
        e2.default = o2;
      }, function(t3, e2, r2) {
        "use strict";
        var n2 = this && this.__extends || function() {
          var t4 = function(e3, r3) {
            return (t4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t5, e4) {
              t5.__proto__ = e4;
            } || function(t5, e4) {
              for (var r4 in e4)
                Object.prototype.hasOwnProperty.call(e4, r4) && (t5[r4] = e4[r4]);
            })(e3, r3);
          };
          return function(e3, r3) {
            if ("function" !== typeof r3 && null !== r3)
              throw new TypeError("Class extends value " + String(r3) + " is not a constructor or null");
            function n3() {
              this.constructor = e3;
            }
            t4(e3, r3), e3.prototype = null === r3 ? Object.create(r3) : (n3.prototype = r3.prototype, new n3());
          };
        }(), o2 = this && this.__assign || function() {
          return (o2 = Object.assign || function(t4) {
            for (var e3, r3 = 1, n3 = arguments.length; r3 < n3; r3++)
              for (var o3 in e3 = arguments[r3])
                Object.prototype.hasOwnProperty.call(e3, o3) && (t4[o3] = e3[o3]);
            return t4;
          }).apply(this, arguments);
        };
        Object.defineProperty(e2, "__esModule", { value: true });
        var i2 = r2(0), a2 = r2(8), c2 = r2(1), u2 = r2(6), s2 = function(t4) {
          function e3(e4, r3, n3) {
            void 0 === r3 && (r3 = "pre");
            var o3 = t4.call(this, e4, r3, n3) || this;
            return o3.indentSpace = u2.DOUBLE + u2.DOUBLE, o3.isIndent = o3.innerHTML.includes("```"), o3.match = o3.isIndent ? "" : "```", o3.language = o3.language || (0, c2.getLanguage)(e4), o3.keepSpace = true, o3;
          }
          return n2(e3, t4), e3.prototype.beforeMergeSpace = function(t5) {
            var e4 = this.isIndent || "code" === this.parentTag ? "" : this.match + this.language + "\n", r3 = "";
            return t5.endsWith("\n") || (r3 = "\n"), e4 + t5 + (this.isIndent || "code" === this.parentTag ? "" : r3 + this.match);
          }, e3.prototype.fillPerLine = function(t5) {
            var e4 = "";
            return this.calcLeading && (e4 = this.leadingSpace), this.isIndent ? e4 + this.indentSpace + t5 : e4 + t5;
          }, e3.prototype.afterMergeSpace = function(t5) {
            var e4 = this, r3 = t5.split("\n");
            return (r3 = r3.map(function(t6) {
              return "" === t6 ? "" : e4.fillPerLine(t6);
            })).join("\n");
          }, e3.prototype.parseValidSubTag = function(t5, e4, r3) {
            if ("code" === e4) {
              var n3 = new ((0, c2.getTagConstructor)(e4))(t5, e4, o2(o2({}, r3), { match: "", language: this.language, keepSpace: true }));
              return [n3.exec("", ""), n3];
            }
            var i3 = void 0;
            return [(i3 = (0, c2.isSelfClosing)(e4) ? new a2.__EmptySelfClose__(t5, e4) : new a2.__Empty__(t5, e4, o2(o2({}, r3), { keepSpace: true }))).exec(), i3];
          }, e3.prototype.parseOnlyString = function(t5) {
            return [t5, null];
          }, e3.prototype.slim = function(t5) {
            return t5;
          }, e3.prototype.exec = function(e4, r3) {
            return void 0 === e4 && (e4 = "\n"), void 0 === r3 && (r3 = "\n"), t4.prototype.exec.call(this, e4, r3);
          }, e3;
        }(i2.default);
        e2.default = s2;
      }, function(t3, e2, r2) {
        "use strict";
        var n2 = this && this.__extends || function() {
          var t4 = function(e3, r3) {
            return (t4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t5, e4) {
              t5.__proto__ = e4;
            } || function(t5, e4) {
              for (var r4 in e4)
                Object.prototype.hasOwnProperty.call(e4, r4) && (t5[r4] = e4[r4]);
            })(e3, r3);
          };
          return function(e3, r3) {
            if ("function" !== typeof r3 && null !== r3)
              throw new TypeError("Class extends value " + String(r3) + " is not a constructor or null");
            function n3() {
              this.constructor = e3;
            }
            t4(e3, r3), e3.prototype = null === r3 ? Object.create(r3) : (n3.prototype = r3.prototype, new n3());
          };
        }();
        Object.defineProperty(e2, "__esModule", { value: true });
        var o2 = function(t4) {
          function e3(e4, r3) {
            return void 0 === r3 && (r3 = "s"), t4.call(this, e4, r3) || this;
          }
          return n2(e3, t4), e3.prototype.exec = function(e4, r3) {
            return t4.prototype.exec.call(this, e4, r3);
          }, e3;
        }(r2(15).default);
        e2.default = o2;
      }, function(t3, e2, r2) {
        "use strict";
        var n2 = this && this.__extends || function() {
          var t4 = function(e3, r3) {
            return (t4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t5, e4) {
              t5.__proto__ = e4;
            } || function(t5, e4) {
              for (var r4 in e4)
                Object.prototype.hasOwnProperty.call(e4, r4) && (t5[r4] = e4[r4]);
            })(e3, r3);
          };
          return function(e3, r3) {
            if ("function" !== typeof r3 && null !== r3)
              throw new TypeError("Class extends value " + String(r3) + " is not a constructor or null");
            function n3() {
              this.constructor = e3;
            }
            t4(e3, r3), e3.prototype = null === r3 ? Object.create(r3) : (n3.prototype = r3.prototype, new n3());
          };
        }();
        Object.defineProperty(e2, "__esModule", { value: true });
        var o2 = function(t4) {
          function e3(e4, r3, n3) {
            return void 0 === r3 && (r3 = "span"), t4.call(this, e4, r3, n3) || this;
          }
          return n2(e3, t4), e3.prototype.exec = function(e4, r3) {
            return void 0 === e4 && (e4 = ""), void 0 === r3 && (r3 = ""), t4.prototype.exec.call(this, e4, r3);
          }, e3;
        }(r2(0).default);
        e2.default = o2;
      }, function(t3, e2, r2) {
        "use strict";
        var n2 = this && this.__extends || function() {
          var t4 = function(e3, r3) {
            return (t4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t5, e4) {
              t5.__proto__ = e4;
            } || function(t5, e4) {
              for (var r4 in e4)
                Object.prototype.hasOwnProperty.call(e4, r4) && (t5[r4] = e4[r4]);
            })(e3, r3);
          };
          return function(e3, r3) {
            if ("function" !== typeof r3 && null !== r3)
              throw new TypeError("Class extends value " + String(r3) + " is not a constructor or null");
            function n3() {
              this.constructor = e3;
            }
            t4(e3, r3), e3.prototype = null === r3 ? Object.create(r3) : (n3.prototype = r3.prototype, new n3());
          };
        }(), o2 = this && this.__assign || function() {
          return (o2 = Object.assign || function(t4) {
            for (var e3, r3 = 1, n3 = arguments.length; r3 < n3; r3++)
              for (var o3 in e3 = arguments[r3])
                Object.prototype.hasOwnProperty.call(e3, o3) && (t4[o3] = e3[o3]);
            return t4;
          }).apply(this, arguments);
        };
        Object.defineProperty(e2, "__esModule", { value: true });
        var i2 = r2(0), a2 = r2(1);
        var c2 = function(t4) {
          function e3(e4, r3, n3) {
            void 0 === r3 && (r3 = "table");
            var o3 = t4.call(this, e4, r3, n3) || this;
            return o3.exist_thead = false, o3.exist_tbody = false, o3.empty_tbody = true, o3.tableColumnCount = function(t5) {
              for (var e5 = "", r4 = 0; r4 < t5.length && !e5.endsWith("</tr>"); r4++)
                e5 += t5[r4];
              return Math.max(e5.split("</td>").length - 1, e5.split("</th>").length - 1);
            }(o3.innerHTML), o3;
          }
          return n2(e3, t4), e3.prototype.parseValidSubTag = function(t5, e4, r3) {
            "thead" === e4 && (this.exist_thead = true), "tbody" === e4 && (this.exist_tbody = true, this.empty_tbody = false), "tr" === e4 && (this.empty_tbody = false);
            var n3 = new ((0, a2.getTagConstructor)(e4))(t5, e4, o2(o2({}, r3), { tableColumnCount: this.tableColumnCount, inTable: true }));
            return [n3.exec("", "\n"), n3];
          }, e3.prototype.parseOnlyString = function() {
            return ["", null];
          }, e3.prototype.beforeReturn = function(t5) {
            if (!this.exist_thead && !this.exist_tbody && this.empty_tbody)
              return "";
            if (0 === this.tableColumnCount)
              return "";
            if (!this.exist_tbody) {
              for (var e4 = (0, a2.getTableAlign)(this.innerHTML, this.tableColumnCount), r3 = this.leadingSpace + "|", n3 = 0; n3 < e4.length; n3++)
                r3 += e4[n3];
              t5 = this.empty_tbody ? t5 + r3 + "\n" : r3 + "" + t5;
            }
            return this.exist_thead || (t5 = "\n" + this.leadingSpace + "|".repeat(this.tableColumnCount + 1) + (t5.startsWith("\n") ? "" : "\n") + t5), t5;
          }, e3.prototype.exec = function(e4, r3) {
            return void 0 === e4 && (e4 = "\n"), void 0 === r3 && (r3 = "\n"), t4.prototype.exec.call(this, e4, r3);
          }, e3;
        }(i2.default);
        e2.default = c2;
      }, function(t3, e2, r2) {
        "use strict";
        var n2 = this && this.__extends || function() {
          var t4 = function(e3, r3) {
            return (t4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t5, e4) {
              t5.__proto__ = e4;
            } || function(t5, e4) {
              for (var r4 in e4)
                Object.prototype.hasOwnProperty.call(e4, r4) && (t5[r4] = e4[r4]);
            })(e3, r3);
          };
          return function(e3, r3) {
            if ("function" !== typeof r3 && null !== r3)
              throw new TypeError("Class extends value " + String(r3) + " is not a constructor or null");
            function n3() {
              this.constructor = e3;
            }
            t4(e3, r3), e3.prototype = null === r3 ? Object.create(r3) : (n3.prototype = r3.prototype, new n3());
          };
        }();
        Object.defineProperty(e2, "__esModule", { value: true });
        var o2 = r2(0), i2 = r2(1), a2 = function(t4) {
          function e3(e4, r3, n3) {
            return void 0 === r3 && (r3 = "tbody"), t4.call(this, e4, r3, n3) || this;
          }
          return n2(e3, t4), e3.prototype.beforeMergeSpace = function(t5) {
            for (var e4 = (0, i2.getTableAlign)(this.innerHTML, this.tableColumnCount), r3 = this.leadingSpace + "|", n3 = 0; n3 < e4.length; n3++)
              r3 += e4[n3];
            return r3 + "\n" + t5;
          }, e3.prototype.parseOnlyString = function() {
            return ["", null];
          }, e3.prototype.exec = function(e4, r3) {
            return void 0 === e4 && (e4 = ""), void 0 === r3 && (r3 = ""), t4.prototype.exec.call(this, e4, r3);
          }, e3;
        }(o2.default);
        e2.default = a2;
      }, function(t3, e2, r2) {
        "use strict";
        var n2 = this && this.__extends || function() {
          var t4 = function(e3, r3) {
            return (t4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t5, e4) {
              t5.__proto__ = e4;
            } || function(t5, e4) {
              for (var r4 in e4)
                Object.prototype.hasOwnProperty.call(e4, r4) && (t5[r4] = e4[r4]);
            })(e3, r3);
          };
          return function(e3, r3) {
            if ("function" !== typeof r3 && null !== r3)
              throw new TypeError("Class extends value " + String(r3) + " is not a constructor or null");
            function n3() {
              this.constructor = e3;
            }
            t4(e3, r3), e3.prototype = null === r3 ? Object.create(r3) : (n3.prototype = r3.prototype, new n3());
          };
        }();
        Object.defineProperty(e2, "__esModule", { value: true });
        var o2 = function(t4) {
          function e3(e4, r3, n3) {
            return void 0 === r3 && (r3 = "td"), t4.call(this, e4, r3, n3) || this;
          }
          return n2(e3, t4), e3.prototype.parseValidSubTag = function(e4, r3, n3) {
            return "ul" === r3 || "ol" === r3 || "table" === r3 || "pre" === r3 ? [e4.replace(/([\n\r])/g, ""), null] : t4.prototype.parseValidSubTag.call(this, e4, r3, n3);
          }, e3.prototype.exec = function(e4, r3) {
            return void 0 === e4 && (e4 = ""), void 0 === r3 && (r3 = ""), t4.prototype.exec.call(this, e4, r3);
          }, e3;
        }(r2(17).default);
        e2.default = o2;
      }, function(t3, e2, r2) {
        "use strict";
        var n2 = this && this.__extends || function() {
          var t4 = function(e3, r3) {
            return (t4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t5, e4) {
              t5.__proto__ = e4;
            } || function(t5, e4) {
              for (var r4 in e4)
                Object.prototype.hasOwnProperty.call(e4, r4) && (t5[r4] = e4[r4]);
            })(e3, r3);
          };
          return function(e3, r3) {
            if ("function" !== typeof r3 && null !== r3)
              throw new TypeError("Class extends value " + String(r3) + " is not a constructor or null");
            function n3() {
              this.constructor = e3;
            }
            t4(e3, r3), e3.prototype = null === r3 ? Object.create(r3) : (n3.prototype = r3.prototype, new n3());
          };
        }();
        Object.defineProperty(e2, "__esModule", { value: true });
        var o2 = function(t4) {
          function e3(e4, r3, n3) {
            return void 0 === r3 && (r3 = "thead"), t4.call(this, e4, r3, n3) || this;
          }
          return n2(e3, t4), e3.prototype.exec = function(e4, r3) {
            return void 0 === e4 && (e4 = ""), void 0 === r3 && (r3 = ""), t4.prototype.exec.call(this, e4, r3);
          }, e3;
        }(r2(0).default);
        e2.default = o2;
      }, function(t3, e2, r2) {
        "use strict";
        var n2 = this && this.__extends || function() {
          var t4 = function(e3, r3) {
            return (t4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t5, e4) {
              t5.__proto__ = e4;
            } || function(t5, e4) {
              for (var r4 in e4)
                Object.prototype.hasOwnProperty.call(e4, r4) && (t5[r4] = e4[r4]);
            })(e3, r3);
          };
          return function(e3, r3) {
            if ("function" !== typeof r3 && null !== r3)
              throw new TypeError("Class extends value " + String(r3) + " is not a constructor or null");
            function n3() {
              this.constructor = e3;
            }
            t4(e3, r3), e3.prototype = null === r3 ? Object.create(r3) : (n3.prototype = r3.prototype, new n3());
          };
        }();
        Object.defineProperty(e2, "__esModule", { value: true });
        var o2 = r2(0), i2 = r2(5), a2 = r2(1), c2 = r2(2), u2 = function(t4) {
          function e3(e4, r3, n3) {
            return void 0 === r3 && (r3 = "tr"), t4.call(this, e4, r3, n3) || this;
          }
          return n2(e3, t4), e3.prototype.beforeMergeSpace = function(t5) {
            return this.leadingSpace + "|" + t5;
          }, e3.prototype.parseValidSubTag = function(t5, e4, r3) {
            var n3 = c2.default.get().aliasTags, o3 = (0, a2.getTagConstructor)(e4);
            if ("td" !== e4 && "th" !== e4 && "td" !== (null === n3 || void 0 === n3 ? void 0 : n3[e4]) && "th" !== (null === n3 || void 0 === n3 ? void 0 : n3[e4]) && o3 !== i2.default)
              return "Should not have tags except <td> or <th> inside <tr>, current tag is ".concat(e4, " have been ignore."), ["", null];
            var u3 = new o3(t5, e4, r3);
            return [u3.exec("", ""), u3];
          }, e3.prototype.parseOnlyString = function() {
            return ["", null];
          }, e3.prototype.exec = function(e4, r3) {
            return void 0 === e4 && (e4 = ""), void 0 === r3 && (r3 = "\n"), t4.prototype.exec.call(this, e4, r3);
          }, e3;
        }(o2.default);
        e2.default = u2;
      }, function(t3, e2, r2) {
        "use strict";
        var n2 = this && this.__extends || function() {
          var t4 = function(e3, r3) {
            return (t4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t5, e4) {
              t5.__proto__ = e4;
            } || function(t5, e4) {
              for (var r4 in e4)
                Object.prototype.hasOwnProperty.call(e4, r4) && (t5[r4] = e4[r4]);
            })(e3, r3);
          };
          return function(e3, r3) {
            if ("function" !== typeof r3 && null !== r3)
              throw new TypeError("Class extends value " + String(r3) + " is not a constructor or null");
            function n3() {
              this.constructor = e3;
            }
            t4(e3, r3), e3.prototype = null === r3 ? Object.create(r3) : (n3.prototype = r3.prototype, new n3());
          };
        }(), o2 = this && this.__assign || function() {
          return (o2 = Object.assign || function(t4) {
            for (var e3, r3 = 1, n3 = arguments.length; r3 < n3; r3++)
              for (var o3 in e3 = arguments[r3])
                Object.prototype.hasOwnProperty.call(e3, o3) && (t4[o3] = e3[o3]);
            return t4;
          }).apply(this, arguments);
        };
        Object.defineProperty(e2, "__esModule", { value: true });
        var i2 = r2(0), a2 = r2(5), c2 = r2(1), u2 = r2(2).default.get().aliasTags, s2 = function(t4) {
          function e3(e4, r3, n3) {
            return void 0 === r3 && (r3 = "ul"), t4.call(this, e4, r3, n3) || this;
          }
          return n2(e3, t4), e3.prototype.__isValidSubTag__ = function(t5) {
            if (!t5)
              return false;
            var e4 = (0, c2.getTagConstructor)(t5);
            return "li" === t5 || "li" == (null === u2 || void 0 === u2 ? void 0 : u2[t5]) || e4 === a2.default;
          }, e3.prototype.getValidSubTagName = function(t5) {
            return t5 && this.__isValidSubTag__(t5) ? t5 : null;
          }, e3.prototype.parseValidSubTag = function(t5, e4, r3) {
            var n3 = (0, c2.getTagConstructor)(e4);
            if (this.__isValidSubTag__(e4)) {
              var i3 = new n3(t5, e4, o2(o2({}, r3), { calcLeading: true, leadingSpace: this.leadingSpace, layer: this.layer, match: "*" }));
              return [i3.exec("", "\n"), i3];
            }
            return ["", null];
          }, e3.prototype.parseOnlyString = function() {
            return ["", null];
          }, e3.prototype.exec = function(e4, r3) {
            return void 0 === e4 && (e4 = "\n"), void 0 === r3 && (r3 = "\n"), t4.prototype.exec.call(this, e4, r3);
          }, e3;
        }(i2.default);
        e2.default = s2;
      }, function(t3, e2, r2) {
        "use strict";
        Object.defineProperty(e2, "__esModule", { value: true });
        var n2 = r2(1), o2 = r2(2), i2 = r2(6);
        e2.default = function(t4, e3, r3) {
          void 0 === r3 && (r3 = false), o2.default.reset(), o2.default.set(e3, r3), t4 = (t4 = (t4 = (0, n2.clearComment)(t4)).trim()).replace(/(\r\n)/g, "").replace(/&nbsp;/g, " "), t4 = "<".concat(i2.DOUBLE, "skip").concat(i2.DOUBLE, ">").concat(t4, "</").concat(i2.DOUBLE, "skip").concat(i2.DOUBLE, ">");
          var a2 = "", c2 = "".concat(i2.DOUBLE, "skip").concat(i2.DOUBLE), u2 = t4;
          return a2 += new ((0, n2.getTagConstructor)(c2))(u2, c2, { parentTag: null, prevTagName: null, prevTagStr: a2 }).exec(), function(t5) {
            return t5 = (t5 = (t5 = t5.replace(/^\s+/, "")).replace(/\s+$/, "")).replace(/\u2608/g, " ");
          }((0, n2.unescapeStr)(a2));
        };
      }, function(t3, e2, r2) {
        "use strict";
        Object.defineProperty(e2, "__esModule", { value: true }), e2.unescapeStr = e2.extraEscape = void 0;
        var n2 = {}, o2 = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;", "`": "&#x60;", "\u201C": "&ldquo;", "\u201D": "&rdquo;" };
        for (var i2 in o2)
          n2[o2[i2]] = i2;
        var a2 = /&(?:amp|lt|gt|quot|#39|#x60|ldquo|rdquo);/g, c2 = RegExp(a2.source), u2 = [[/\\/g, "\\\\"], [/\*/g, "\\*"], [/^-/g, "\\-"], [/^\+ /g, "\\+ "], [/^(=+)/g, "\\$1"], [/^(#{1,6}) /g, "\\$1 "], [/`/g, "\\`"], [/^~~~/g, "\\~~~"], [/\[/g, "\\["], [/\]/g, "\\]"], [/^>/g, "\\>"], [/_/g, "\\_"], [/^(\d+)\. /g, "$1\\. "]];
        e2.unescapeStr = function(t4) {
          return t4 = t4 && c2.test(t4) ? t4.replace(a2, function(t5) {
            return n2[t5];
          }) : t4;
        }, e2.extraEscape = function(t4) {
          return u2.reduce(function(t5, e3) {
            return t5.replace(e3[0], e3[1]);
          }, t4);
        };
      }, function(t3, e2, r2) {
        "use strict";
        Object.defineProperty(e2, "__esModule", { value: true });
        var n2 = r2(11);
        function o2(t4, e3) {
          for (var r3 = ""; e3 < t4.length && /[a-zA-Z0-9!\-_]/.test(t4[e3]); )
            r3 += t4[e3++];
          return r3.toLowerCase();
        }
        e2.default = function(t4) {
          var e3 = 0;
          return function() {
            var r3 = "", i2 = null, a2 = 0, c2 = null, u2 = false;
            if (e3 >= t4.length)
              return [i2, r3];
            for (var s2 = e3; s2 < t4.length; s2++) {
              if ("<" === t4[s2] && "/" !== t4[s2 + 1]) {
                if ("" !== r3 && null == i2 && !u2)
                  return e3 = s2, [i2, r3];
                var p3 = o2(t4, s2 + 1);
                null == i2 && (i2 = p3), i2 === p3 && a2++, (0, n2.default)(i2) && (0 === --a2 && (u2 = true), a2 < 0 && "Tag ".concat(i2, " is abnormal"));
              } else if ("<" === t4[s2] && "/" === t4[s2 + 1]) {
                if (null == i2) {
                  "Tag is not integrity, current tagStr is ".concat(t4.slice(e3));
                  for (var l2 = s2; l2 < t4.length && ">" !== t4[l2]; )
                    l2++;
                  s2 = l2;
                  continue;
                }
                i2 === (c2 = o2(t4, s2 + 2)) && a2--, a2 <= 0 && (u2 = true);
              }
              if (r3 += t4[s2], ">" === t4[s2] && u2)
                return e3 = s2 + 1, [i2, r3];
              s2 === t4.length - 1 && i2 !== c2 && (null != c2 && null != i2 && (r3 = r3.replace("<".concat(i2, ">"), "").replace("</".concat(c2, ">"), "")), i2 = null);
            }
            return e3 = t4.length, [i2, r3];
          };
        };
      }, function(t3, e2, r2) {
        "use strict";
        Object.defineProperty(e2, "__esModule", { value: true });
        var n2 = r2(2), o2 = r2(6), i2 = r2(11), a2 = r2(49);
        e2.default = function t4(e3) {
          var c2, u2 = n2.default.get(), s2 = u2.skipTags, p3 = u2.emptyTags, l2 = u2.ignoreTags, f2 = u2.aliasTags, h2 = u2.renderCustomTags, d2 = (0, i2.default)(e3);
          if ((null === s2 || void 0 === s2 ? void 0 : s2.includes(e3)) || e3 === "".concat(o2.DOUBLE, "skip").concat(o2.DOUBLE)) {
            var _ = r2(9);
            return d2 ? _.__SkipSelfClose__ : _.__Skip__;
          }
          if (null === p3 || void 0 === p3 ? void 0 : p3.includes(e3)) {
            var y2 = r2(8);
            return d2 ? y2.__EmptySelfClose__ : y2.__Empty__;
          }
          if (null === l2 || void 0 === l2 ? void 0 : l2.includes(e3))
            return r2(5).default;
          if (null != (null === f2 || void 0 === f2 ? void 0 : f2[e3]))
            return t4(f2[e3]);
          var v2 = e3.toLowerCase();
          if (true !== h2 && !(0, a2.default)(v2)) {
            if (false === h2 || "SKIP" === h2)
              return _ = r2(9), d2 ? _.__SkipSelfClose__ : _.__Skip__;
            if ("EMPTY" === h2)
              return y2 = r2(8), d2 ? y2.__EmptySelfClose__ : y2.__Empty__;
            if ("IGNORE" === h2)
              return r2(5).default;
          }
          try {
            c2 = r2(50)("./".concat(e3)).default;
          } catch (g2) {
            c2 = d2 ? r2(10).__NoMatchSelfClose__ : r2(10).__NoMatch__;
          }
          return c2;
        };
      }, function(t3, e2, r2) {
        "use strict";
        Object.defineProperty(e2, "__esModule", { value: true });
        var n2 = ["!doctype", "a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio", "b", "base", "basefont", "bdi", "bdo", "bgsound", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "circle", "cite", "clipPath", "code", "col", "colgroup", "command", "content", "data", "datalist", "dd", "defs", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "ellipse", "em", "embed", "fieldset", "figcaption", "figure", "font", "footer", "foreignObject", "form", "frame", "frameset", "g", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "image", "img", "input", "ins", "isindex", "kbd", "keygen", "label", "legend", "li", "line", "linearGradient", "link", "listing", "main", "map", "mark", "marquee", "mask", "math", "menu", "menuitem", "meta", "meter", "multicol", "nav", "nextid", "nobr", "noembed", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "path", "pattern", "picture", "plaintext", "polygon", "polyline", "pre", "progress", "q", "radialGradient", "rb", "rbc", "rect", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "stop", "strike", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "text", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "tspan", "tt", "u", "ul", "var", "video", "wbr", "xmp"];
        e2.default = function(t4) {
          return "string" === typeof t4 && n2.includes(t4.toLowerCase());
        };
      }, function(t3, e2, r2) {
        var n2 = { "./__Heading__": 3, "./__Heading__.ts": 3, "./__empty__": 8, "./__empty__.ts": 8, "./__ignore__": 5, "./__ignore__.ts": 5, "./__nomatch__": 10, "./__nomatch__.ts": 10, "./__rawString__": 12, "./__rawString__.ts": 12, "./__skip__": 9, "./__skip__.ts": 9, "./a": 18, "./a.ts": 18, "./b": 19, "./b.ts": 19, "./blockquote": 20, "./blockquote.ts": 20, "./br": 21, "./br.ts": 21, "./code": 22, "./code.ts": 22, "./del": 15, "./del.ts": 15, "./em": 16, "./em.ts": 16, "./h1": 23, "./h1.ts": 23, "./h2": 24, "./h2.ts": 24, "./h3": 25, "./h3.ts": 25, "./h4": 26, "./h4.ts": 26, "./h5": 27, "./h5.ts": 27, "./h6": 28, "./h6.ts": 28, "./hr": 29, "./hr.ts": 29, "./i": 30, "./i.ts": 30, "./img": 31, "./img.ts": 31, "./input": 32, "./input.ts": 32, "./li": 33, "./li.ts": 33, "./ol": 34, "./ol.ts": 34, "./p": 35, "./p.ts": 35, "./pre": 36, "./pre.ts": 36, "./s": 37, "./s.ts": 37, "./span": 38, "./span.ts": 38, "./strong": 14, "./strong.ts": 14, "./table": 39, "./table.ts": 39, "./tbody": 40, "./tbody.ts": 40, "./td": 41, "./td.ts": 41, "./th": 17, "./th.ts": 17, "./thead": 42, "./thead.ts": 42, "./tr": 43, "./tr.ts": 43, "./ul": 44, "./ul.ts": 44 };
        function o2(t4) {
          var e3 = i2(t4);
          return r2(e3);
        }
        function i2(t4) {
          if (!r2.o(n2, t4)) {
            var e3 = new Error("Cannot find module '" + t4 + "'");
            throw e3.code = "MODULE_NOT_FOUND", e3;
          }
          return n2[t4];
        }
        o2.keys = function() {
          return Object.keys(n2);
        }, o2.resolve = i2, t3.exports = o2, o2.id = 50;
      }, function(t3, e2, r2) {
        "use strict";
        Object.defineProperty(e2, "__esModule", { value: true }), e2.default = function(t4) {
          for (var e3 = {}, r3 = false, n2 = "", o2 = "", i2 = null, a2 = 0; a2 <= t4.length; a2++) {
            if (a2 === t4.length || /\s/.test(t4[a2])) {
              if (a2 === t4.length || !r3) {
                var c2 = n2.trim();
                "/" === c2[c2.length - 1] && (c2 = c2.slice(0, c2.length - 1)), c2 && (e3[c2] = o2.trim()), n2 = "", o2 = "";
              }
            } else {
              if (/['"]/.test(t4[a2]) && (!i2 || t4[a2] === i2)) {
                (r3 = !r3) && (i2 = t4[a2]);
                continue;
              }
              if ("=" === t4[a2] && !r3)
                continue;
            }
            if (a2 === t4.length)
              break;
            r3 ? o2 += t4[a2] : n2 += t4[a2];
          }
          return e3;
        };
      }, function(t3, e2, r2) {
        "use strict";
        Object.defineProperty(e2, "__esModule", { value: true });
        var n2 = "javascript";
        e2.default = function(t4) {
          var e3 = t4.match(/<.*?class=".*?language-([^\s"]*)?.*".*>/);
          return e3 ? e3[1] || "" : t4.match(/<span.*?hljs-(comment|keyword|number|string|literal|built_in|function|title|bullet).*?<\/span>/) ? n2 : "";
        };
      }, function(t3, e2, r2) {
        "use strict";
        Object.defineProperty(e2, "__esModule", { value: true }), e2.default = function(t4) {
          return t4.replace(/<!--(?:[\s\S]*?)-->/g, "");
        };
      }, function(t3, e2, r2) {
        "use strict";
        Object.defineProperty(e2, "__esModule", { value: true });
        var n2 = r2(13), o2 = { b: true, a: true, del: true, em: true, i: true, s: true, span: true, strong: true };
        e2.default = function(t4) {
          if (null === t4)
            return true;
          if (!t4)
            return false;
          var e3 = (0, n2.default)(t4);
          return !!e3 && !!o2[e3];
        };
      }, function(t3, e2, r2) {
        "use strict";
        Object.defineProperty(e2, "__esModule", { value: true }), e2.default = function(t4, e3) {
          var r3 = { _default_: "---|", center: ":---:|", left: ":---|", right: "---:|", start: ":---|", end: "---:|" }, n2 = Array(e3).fill(r3._default_), o2 = t4.match(/<(td|th)(.*?)>/g);
          return o2 ? n2 = (n2 = o2.slice(0, e3)).map(function(t5) {
            var e4 = t5.match(/align\s*=\s*['"]\s*(center|left|right|start|end)/), n3 = t5.match(/text-align\s*:\s*(center|left|right|start|end)/);
            return e4 || n3 ? e4 && !n3 ? r3[e4[1]] || r3._default_ : n3 ? r3[n3[1]] || r3._default_ : void 0 : r3._default_;
          }) : n2;
        };
      }, function(t3, e2, r2) {
        "use strict";
        Object.defineProperty(e2, "__esModule", { value: true }), e2.default = ["th", "td"];
      }]).default;
    });
  }
});

// node-modules-polyfills:events
function EventHandlers() {
}
function EventEmitter() {
  EventEmitter.init.call(this);
}
function $getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}
function emitNone(handler, isFn, self2) {
  if (isFn)
    handler.call(self2);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i2 = 0; i2 < len; ++i2)
      listeners2[i2].call(self2);
  }
}
function emitOne(handler, isFn, self2, arg1) {
  if (isFn)
    handler.call(self2, arg1);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i2 = 0; i2 < len; ++i2)
      listeners2[i2].call(self2, arg1);
  }
}
function emitTwo(handler, isFn, self2, arg1, arg2) {
  if (isFn)
    handler.call(self2, arg1, arg2);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i2 = 0; i2 < len; ++i2)
      listeners2[i2].call(self2, arg1, arg2);
  }
}
function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self2, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i2 = 0; i2 < len; ++i2)
      listeners2[i2].call(self2, arg1, arg2, arg3);
  }
}
function emitMany(handler, isFn, self2, args) {
  if (isFn)
    handler.apply(self2, args);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i2 = 0; i2 < len; ++i2)
      listeners2[i2].apply(self2, args);
  }
}
function _addListener(target, type, listener, prepend) {
  var m2;
  var events;
  var existing;
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  events = target._events;
  if (!events) {
    events = target._events = new EventHandlers();
    target._eventsCount = 0;
  } else {
    if (events.newListener) {
      target.emit(
        "newListener",
        type,
        listener.listener ? listener.listener : listener
      );
      events = target._events;
    }
    existing = events[type];
  }
  if (!existing) {
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events[type] = prepend ? [listener, existing] : [existing, listener];
    } else {
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }
    if (!existing.warned) {
      m2 = $getMaxListeners(target);
      if (m2 && m2 > 0 && existing.length > m2) {
        existing.warned = true;
        var w2 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type + " listeners added. Use emitter.setMaxListeners() to increase limit");
        w2.name = "MaxListenersExceededWarning";
        w2.emitter = target;
        w2.type = type;
        w2.count = existing.length;
        emitWarning(w2);
      }
    }
  }
  return target;
}
function emitWarning(e2) {
  typeof console.warn === "function" ? console.warn(e2) : console.log(e2);
}
function _onceWrap(target, type, listener) {
  var fired = false;
  function g2() {
    target.removeListener(type, g2);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  g2.listener = listener;
  return g2;
}
function listenerCount(type) {
  var events = this._events;
  if (events) {
    var evlistener = events[type];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }
  return 0;
}
function spliceOne(list4, index3) {
  for (var i2 = index3, k2 = i2 + 1, n2 = list4.length; k2 < n2; i2 += 1, k2 += 1)
    list4[i2] = list4[k2];
  list4.pop();
}
function arrayClone(arr, i2) {
  var copy3 = new Array(i2);
  while (i2--)
    copy3[i2] = arr[i2];
  return copy3;
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i2 = 0; i2 < ret.length; ++i2) {
    ret[i2] = arr[i2].listener || arr[i2];
  }
  return ret;
}
var domain, events_default;
var init_events = __esm({
  "node-modules-polyfills:events"() {
    "use strict";
    init_process();
    init_buffer();
    EventHandlers.prototype = /* @__PURE__ */ Object.create(null);
    events_default = EventEmitter;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.usingDomains = false;
    EventEmitter.prototype.domain = void 0;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._maxListeners = void 0;
    EventEmitter.defaultMaxListeners = 10;
    EventEmitter.init = function() {
      this.domain = null;
      if (EventEmitter.usingDomains) {
        if (domain.active && !(this instanceof domain.Domain)) {
          this.domain = domain.active;
        }
      }
      if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
        this._events = new EventHandlers();
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n2) {
      if (typeof n2 !== "number" || n2 < 0 || isNaN(n2))
        throw new TypeError('"n" argument must be a positive number');
      this._maxListeners = n2;
      return this;
    };
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return $getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit2(type) {
      var er, handler, len, args, i2, events, domain3;
      var needDomainExit = false;
      var doError = type === "error";
      events = this._events;
      if (events)
        doError = doError && events.error == null;
      else if (!doError)
        return false;
      domain3 = this.domain;
      if (doError) {
        er = arguments[1];
        if (domain3) {
          if (!er)
            er = new Error('Uncaught, unspecified "error" event');
          er.domainEmitter = this;
          er.domain = domain3;
          er.domainThrown = false;
          domain3.emit("error", er);
        } else if (er instanceof Error) {
          throw er;
        } else {
          var err = new Error('Uncaught, unspecified "error" event. (' + er + ")");
          err.context = er;
          throw err;
        }
        return false;
      }
      handler = events[type];
      if (!handler)
        return false;
      var isFn = typeof handler === "function";
      len = arguments.length;
      switch (len) {
        case 1:
          emitNone(handler, isFn, this);
          break;
        case 2:
          emitOne(handler, isFn, this, arguments[1]);
          break;
        case 3:
          emitTwo(handler, isFn, this, arguments[1], arguments[2]);
          break;
        case 4:
          emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
          break;
        default:
          args = new Array(len - 1);
          for (i2 = 1; i2 < len; i2++)
            args[i2 - 1] = arguments[i2];
          emitMany(handler, isFn, this, args);
      }
      if (needDomainExit)
        domain3.exit();
      return true;
    };
    EventEmitter.prototype.addListener = function addListener2(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    EventEmitter.prototype.once = function once2(type, listener) {
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener2(type, listener) {
      var list4, events, position4, i2, originalListener;
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      events = this._events;
      if (!events)
        return this;
      list4 = events[type];
      if (!list4)
        return this;
      if (list4 === listener || list4.listener && list4.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = new EventHandlers();
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list4.listener || listener);
        }
      } else if (typeof list4 !== "function") {
        position4 = -1;
        for (i2 = list4.length; i2-- > 0; ) {
          if (list4[i2] === listener || list4[i2].listener && list4[i2].listener === listener) {
            originalListener = list4[i2].listener;
            position4 = i2;
            break;
          }
        }
        if (position4 < 0)
          return this;
        if (list4.length === 1) {
          list4[0] = void 0;
          if (--this._eventsCount === 0) {
            this._events = new EventHandlers();
            return this;
          } else {
            delete events[type];
          }
        } else {
          spliceOne(list4, position4);
        }
        if (events.removeListener)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners2(type) {
      var listeners2, events;
      events = this._events;
      if (!events)
        return this;
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = new EventHandlers();
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys3 = Object.keys(events);
        for (var i2 = 0, key2; i2 < keys3.length; ++i2) {
          key2 = keys3[i2];
          if (key2 === "removeListener")
            continue;
          this.removeAllListeners(key2);
        }
        this.removeAllListeners("removeListener");
        this._events = new EventHandlers();
        this._eventsCount = 0;
        return this;
      }
      listeners2 = events[type];
      if (typeof listeners2 === "function") {
        this.removeListener(type, listeners2);
      } else if (listeners2) {
        do {
          this.removeListener(type, listeners2[listeners2.length - 1]);
        } while (listeners2[0]);
      }
      return this;
    };
    EventEmitter.prototype.listeners = function listeners(type) {
      var evlistener;
      var ret;
      var events = this._events;
      if (!events)
        ret = [];
      else {
        evlistener = events[type];
        if (!evlistener)
          ret = [];
        else if (typeof evlistener === "function")
          ret = [evlistener.listener || evlistener];
        else
          ret = unwrapListeners(evlistener);
      }
      return ret;
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
    };
  }
});

// node-modules-polyfills:process
function defaultSetTimout2() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout2() {
  throw new Error("clearTimeout has not been defined");
}
function runTimeout2(fun) {
  if (cachedSetTimeout2 === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout2 === defaultSetTimout2 || !cachedSetTimeout2) && setTimeout) {
    cachedSetTimeout2 = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout2(fun, 0);
  } catch (e2) {
    try {
      return cachedSetTimeout2.call(null, fun, 0);
    } catch (e3) {
      return cachedSetTimeout2.call(this, fun, 0);
    }
  }
}
function runClearTimeout2(marker) {
  if (cachedClearTimeout2 === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout2 === defaultClearTimeout2 || !cachedClearTimeout2) && clearTimeout) {
    cachedClearTimeout2 = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout2(marker);
  } catch (e2) {
    try {
      return cachedClearTimeout2.call(null, marker);
    } catch (e3) {
      return cachedClearTimeout2.call(this, marker);
    }
  }
}
function cleanUpNextTick2() {
  if (!draining2 || !currentQueue2) {
    return;
  }
  draining2 = false;
  if (currentQueue2.length) {
    queue2 = currentQueue2.concat(queue2);
  } else {
    queueIndex2 = -1;
  }
  if (queue2.length) {
    drainQueue2();
  }
}
function drainQueue2() {
  if (draining2) {
    return;
  }
  var timeout = runTimeout2(cleanUpNextTick2);
  draining2 = true;
  var len = queue2.length;
  while (len) {
    currentQueue2 = queue2;
    queue2 = [];
    while (++queueIndex2 < len) {
      if (currentQueue2) {
        currentQueue2[queueIndex2].run();
      }
    }
    queueIndex2 = -1;
    len = queue2.length;
  }
  currentQueue2 = null;
  draining2 = false;
  runClearTimeout2(timeout);
}
function nextTick2(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      args[i2 - 1] = arguments[i2];
    }
  }
  queue2.push(new Item2(fun, args));
  if (queue2.length === 1 && !draining2) {
    runTimeout2(drainQueue2);
  }
}
function Item2(fun, array) {
  this.fun = fun;
  this.array = array;
}
function noop2() {
}
function binding2(name) {
  throw new Error("process.binding is not supported");
}
function cwd2() {
  return "/";
}
function chdir2(dir) {
  throw new Error("process.chdir is not supported");
}
function umask2() {
  return 0;
}
function hrtime2(previousTimestamp) {
  var clocktime = performanceNow2.call(performance3) * 1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds, nanoseconds];
}
function uptime2() {
  var currentTime = /* @__PURE__ */ new Date();
  var dif = currentTime - startTime2;
  return dif / 1e3;
}
var cachedSetTimeout2, cachedClearTimeout2, queue2, draining2, currentQueue2, queueIndex2, title2, platform2, browser2, env3, argv2, version4, versions2, release2, config2, on2, addListener3, once3, off2, removeListener3, removeAllListeners3, emit3, performance3, performanceNow2, startTime2, browser$1, process_default;
var init_process2 = __esm({
  "node-modules-polyfills:process"() {
    init_process();
    init_buffer();
    cachedSetTimeout2 = defaultSetTimout2;
    cachedClearTimeout2 = defaultClearTimeout2;
    if (typeof globalThis.setTimeout === "function") {
      cachedSetTimeout2 = setTimeout;
    }
    if (typeof globalThis.clearTimeout === "function") {
      cachedClearTimeout2 = clearTimeout;
    }
    queue2 = [];
    draining2 = false;
    queueIndex2 = -1;
    Item2.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    title2 = "browser";
    platform2 = "browser";
    browser2 = true;
    env3 = {};
    argv2 = [];
    version4 = "";
    versions2 = {};
    release2 = {};
    config2 = {};
    on2 = noop2;
    addListener3 = noop2;
    once3 = noop2;
    off2 = noop2;
    removeListener3 = noop2;
    removeAllListeners3 = noop2;
    emit3 = noop2;
    performance3 = globalThis.performance || {};
    performanceNow2 = performance3.now || performance3.mozNow || performance3.msNow || performance3.oNow || performance3.webkitNow || function() {
      return (/* @__PURE__ */ new Date()).getTime();
    };
    startTime2 = /* @__PURE__ */ new Date();
    browser$1 = {
      nextTick: nextTick2,
      title: title2,
      browser: browser2,
      env: env3,
      argv: argv2,
      version: version4,
      versions: versions2,
      on: on2,
      addListener: addListener3,
      once: once3,
      off: off2,
      removeListener: removeListener3,
      removeAllListeners: removeAllListeners3,
      emit: emit3,
      binding: binding2,
      cwd: cwd2,
      chdir: chdir2,
      umask: umask2,
      hrtime: hrtime2,
      platform: platform2,
      release: release2,
      config: config2,
      uptime: uptime2
    };
    process_default = browser$1;
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js
var inherits, inherits_default;
var init_inherits = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js"() {
    init_process();
    init_buffer();
    if (typeof Object.create === "function") {
      inherits = function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      };
    } else {
      inherits = function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      };
    }
    inherits_default = inherits;
  }
});

// node-modules-polyfills:util
function format(f2) {
  if (!isString(f2)) {
    var objects = [];
    for (var i2 = 0; i2 < arguments.length; i2++) {
      objects.push(inspect(arguments[i2]));
    }
    return objects.join(" ");
  }
  var i2 = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f2).replace(formatRegExp, function(x3) {
    if (x3 === "%%")
      return "%";
    if (i2 >= len)
      return x3;
    switch (x3) {
      case "%s":
        return String(args[i2++]);
      case "%d":
        return Number(args[i2++]);
      case "%j":
        try {
          return JSON.stringify(args[i2++]);
        } catch (_) {
          return "[Circular]";
        }
      default:
        return x3;
    }
  });
  for (var x2 = args[i2]; i2 < len; x2 = args[++i2]) {
    if (isNull2(x2) || !isObject3(x2)) {
      str += " " + x2;
    } else {
      str += " " + inspect(x2);
    }
  }
  return str;
}
function deprecate(fn, msg) {
  if (isUndefined(globalThis.process)) {
    return function() {
      return deprecate(fn, msg).apply(this, arguments);
    };
  }
  if (process_default.noDeprecation === true) {
    return fn;
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process_default.throwDeprecation) {
        throw new Error(msg);
      } else if (process_default.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
}
function debuglog(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process_default.env.NODE_DEBUG || "";
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
      var pid = 0;
      debugs[set] = function() {
        var msg = format.apply(null, arguments);
        console.error("%s %d: %s", set, pid, msg);
      };
    } else {
      debugs[set] = function() {
      };
    }
  }
  return debugs[set];
}
function inspect(obj, opts) {
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  if (arguments.length >= 3)
    ctx.depth = arguments[2];
  if (arguments.length >= 4)
    ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    ctx.showHidden = opts;
  } else if (opts) {
    _extend(ctx, opts);
  }
  if (isUndefined(ctx.showHidden))
    ctx.showHidden = false;
  if (isUndefined(ctx.depth))
    ctx.depth = 2;
  if (isUndefined(ctx.colors))
    ctx.colors = false;
  if (isUndefined(ctx.customInspect))
    ctx.customInspect = true;
  if (ctx.colors)
    ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];
  if (style) {
    return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
  } else {
    return str;
  }
}
function stylizeNoColor(str, styleType) {
  return str;
}
function arrayToHash(array) {
  var hash = {};
  array.forEach(function(val2, idx) {
    hash[val2] = true;
  });
  return hash;
}
function formatValue(ctx, value, recurseTimes) {
  if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
  value.inspect !== inspect && // Also filter out any prototype objects using the circular check.
  !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }
  var keys3 = Object.keys(value);
  var visibleKeys = arrayToHash(keys3);
  if (ctx.showHidden) {
    keys3 = Object.getOwnPropertyNames(value);
  }
  if (isError(value) && (keys3.indexOf("message") >= 0 || keys3.indexOf("description") >= 0)) {
    return formatError(value);
  }
  if (keys3.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ": " + value.name : "";
      return ctx.stylize("[Function" + name + "]", "special");
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), "date");
    }
    if (isError(value)) {
      return formatError(value);
    }
  }
  var base2 = "", array = false, braces = ["{", "}"];
  if (isArray(value)) {
    array = true;
    braces = ["[", "]"];
  }
  if (isFunction(value)) {
    var n2 = value.name ? ": " + value.name : "";
    base2 = " [Function" + n2 + "]";
  }
  if (isRegExp(value)) {
    base2 = " " + RegExp.prototype.toString.call(value);
  }
  if (isDate(value)) {
    base2 = " " + Date.prototype.toUTCString.call(value);
  }
  if (isError(value)) {
    base2 = " " + formatError(value);
  }
  if (keys3.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base2 + braces[1];
  }
  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    } else {
      return ctx.stylize("[Object]", "special");
    }
  }
  ctx.seen.push(value);
  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys3);
  } else {
    output = keys3.map(function(key2) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key2, array);
    });
  }
  ctx.seen.pop();
  return reduceToSingleString(output, base2, braces);
}
function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize("undefined", "undefined");
  if (isString(value)) {
    var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return ctx.stylize(simple, "string");
  }
  if (isNumber(value))
    return ctx.stylize("" + value, "number");
  if (isBoolean(value))
    return ctx.stylize("" + value, "boolean");
  if (isNull2(value))
    return ctx.stylize("null", "null");
}
function formatError(value) {
  return "[" + Error.prototype.toString.call(value) + "]";
}
function formatArray(ctx, value, recurseTimes, visibleKeys, keys3) {
  var output = [];
  for (var i2 = 0, l2 = value.length; i2 < l2; ++i2) {
    if (hasOwnProperty(value, String(i2))) {
      output.push(formatProperty(
        ctx,
        value,
        recurseTimes,
        visibleKeys,
        String(i2),
        true
      ));
    } else {
      output.push("");
    }
  }
  keys3.forEach(function(key2) {
    if (!key2.match(/^\d+$/)) {
      output.push(formatProperty(
        ctx,
        value,
        recurseTimes,
        visibleKeys,
        key2,
        true
      ));
    }
  });
  return output;
}
function formatProperty(ctx, value, recurseTimes, visibleKeys, key2, array) {
  var name, str, desc2;
  desc2 = Object.getOwnPropertyDescriptor(value, key2) || { value: value[key2] };
  if (desc2.get) {
    if (desc2.set) {
      str = ctx.stylize("[Getter/Setter]", "special");
    } else {
      str = ctx.stylize("[Getter]", "special");
    }
  } else {
    if (desc2.set) {
      str = ctx.stylize("[Setter]", "special");
    }
  }
  if (!hasOwnProperty(visibleKeys, key2)) {
    name = "[" + key2 + "]";
  }
  if (!str) {
    if (ctx.seen.indexOf(desc2.value) < 0) {
      if (isNull2(recurseTimes)) {
        str = formatValue(ctx, desc2.value, null);
      } else {
        str = formatValue(ctx, desc2.value, recurseTimes - 1);
      }
      if (str.indexOf("\n") > -1) {
        if (array) {
          str = str.split("\n").map(function(line) {
            return "  " + line;
          }).join("\n").substr(2);
        } else {
          str = "\n" + str.split("\n").map(function(line) {
            return "   " + line;
          }).join("\n");
        }
      }
    } else {
      str = ctx.stylize("[Circular]", "special");
    }
  }
  if (isUndefined(name)) {
    if (array && key2.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify("" + key2);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, "name");
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, "string");
    }
  }
  return name + ": " + str;
}
function reduceToSingleString(output, base2, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf("\n") >= 0)
      numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  if (length > 60) {
    return braces[0] + (base2 === "" ? "" : base2 + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
  }
  return braces[0] + base2 + " " + output.join(", ") + " " + braces[1];
}
function isArray(ar2) {
  return Array.isArray(ar2);
}
function isBoolean(arg) {
  return typeof arg === "boolean";
}
function isNull2(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return arg == null;
}
function isNumber(arg) {
  return typeof arg === "number";
}
function isString(arg) {
  return typeof arg === "string";
}
function isUndefined(arg) {
  return arg === void 0;
}
function isRegExp(re2) {
  return isObject3(re2) && objectToString(re2) === "[object RegExp]";
}
function isObject3(arg) {
  return typeof arg === "object" && arg !== null;
}
function isDate(d2) {
  return isObject3(d2) && objectToString(d2) === "[object Date]";
}
function isError(e2) {
  return isObject3(e2) && (objectToString(e2) === "[object Error]" || e2 instanceof Error);
}
function isFunction(arg) {
  return typeof arg === "function";
}
function objectToString(o2) {
  return Object.prototype.toString.call(o2);
}
function _extend(origin, add) {
  if (!add || !isObject3(add))
    return origin;
  var keys3 = Object.keys(add);
  var i2 = keys3.length;
  while (i2--) {
    origin[keys3[i2]] = add[keys3[i2]];
  }
  return origin;
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var formatRegExp, debugs, debugEnviron;
var init_util = __esm({
  "node-modules-polyfills:util"() {
    init_process();
    init_buffer();
    init_process2();
    init_inherits();
    formatRegExp = /%[sdj%]/g;
    debugs = {};
    inspect.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    };
    inspect.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      // "name": intentionally not styling
      "regexp": "red"
    };
  }
});

// node-modules-polyfills:buffer
function init2() {
  inited2 = true;
  var code4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i2 = 0, len = code4.length; i2 < len; ++i2) {
    lookup2[i2] = code4[i2];
    revLookup2[code4.charCodeAt(i2)] = i2;
  }
  revLookup2["-".charCodeAt(0)] = 62;
  revLookup2["_".charCodeAt(0)] = 63;
}
function toByteArray(b64) {
  if (!inited2) {
    init2();
  }
  var i2, j2, l2, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
  arr = new Arr2(len * 3 / 4 - placeHolders);
  l2 = placeHolders > 0 ? len - 4 : len;
  var L2 = 0;
  for (i2 = 0, j2 = 0; i2 < l2; i2 += 4, j2 += 3) {
    tmp = revLookup2[b64.charCodeAt(i2)] << 18 | revLookup2[b64.charCodeAt(i2 + 1)] << 12 | revLookup2[b64.charCodeAt(i2 + 2)] << 6 | revLookup2[b64.charCodeAt(i2 + 3)];
    arr[L2++] = tmp >> 16 & 255;
    arr[L2++] = tmp >> 8 & 255;
    arr[L2++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup2[b64.charCodeAt(i2)] << 2 | revLookup2[b64.charCodeAt(i2 + 1)] >> 4;
    arr[L2++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup2[b64.charCodeAt(i2)] << 10 | revLookup2[b64.charCodeAt(i2 + 1)] << 4 | revLookup2[b64.charCodeAt(i2 + 2)] >> 2;
    arr[L2++] = tmp >> 8 & 255;
    arr[L2++] = tmp & 255;
  }
  return arr;
}
function tripletToBase642(num) {
  return lookup2[num >> 18 & 63] + lookup2[num >> 12 & 63] + lookup2[num >> 6 & 63] + lookup2[num & 63];
}
function encodeChunk2(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i2 = start; i2 < end; i2 += 3) {
    tmp = (uint8[i2] << 16) + (uint8[i2 + 1] << 8) + uint8[i2 + 2];
    output.push(tripletToBase642(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  if (!inited2) {
    init2();
  }
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var output = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i2 = 0, len2 = len - extraBytes; i2 < len2; i2 += maxChunkLength) {
    parts.push(encodeChunk2(uint8, i2, i2 + maxChunkLength > len2 ? len2 : i2 + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup2[tmp >> 2];
    output += lookup2[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup2[tmp >> 10];
    output += lookup2[tmp >> 4 & 63];
    output += lookup2[tmp << 2 & 63];
    output += "=";
  }
  parts.push(output);
  return parts.join("");
}
function read(buffer, offset, isLE, mLen, nBytes) {
  var e2, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i2 = isLE ? nBytes - 1 : 0;
  var d2 = isLE ? -1 : 1;
  var s2 = buffer[offset + i2];
  i2 += d2;
  e2 = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e2 = e2 * 256 + buffer[offset + i2], i2 += d2, nBits -= 8) {
  }
  m2 = e2 & (1 << -nBits) - 1;
  e2 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer[offset + i2], i2 += d2, nBits -= 8) {
  }
  if (e2 === 0) {
    e2 = 1 - eBias;
  } else if (e2 === eMax) {
    return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e2 = e2 - eBias;
  }
  return (s2 ? -1 : 1) * m2 * Math.pow(2, e2 - mLen);
}
function write2(buffer, value, offset, isLE, mLen, nBytes) {
  var e2, m2, c2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i2 = isLE ? 0 : nBytes - 1;
  var d2 = isLE ? 1 : -1;
  var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m2 = isNaN(value) ? 1 : 0;
    e2 = eMax;
  } else {
    e2 = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c2 = Math.pow(2, -e2)) < 1) {
      e2--;
      c2 *= 2;
    }
    if (e2 + eBias >= 1) {
      value += rt / c2;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c2 >= 2) {
      e2++;
      c2 /= 2;
    }
    if (e2 + eBias >= eMax) {
      m2 = 0;
      e2 = eMax;
    } else if (e2 + eBias >= 1) {
      m2 = (value * c2 - 1) * Math.pow(2, mLen);
      e2 = e2 + eBias;
    } else {
      m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e2 = 0;
    }
  }
  for (; mLen >= 8; buffer[offset + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {
  }
  e2 = e2 << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i2] = e2 & 255, i2 += d2, e2 /= 256, eLen -= 8) {
  }
  buffer[offset + i2 - d2] |= s2 * 128;
}
function kMaxLength2() {
  return Buffer3.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer2(that, length) {
  if (kMaxLength2() < length) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer3.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length);
    that.__proto__ = Buffer3.prototype;
  } else {
    if (that === null) {
      that = new Buffer3(length);
    }
    that.length = length;
  }
  return that;
}
function Buffer3(arg, encodingOrOffset, length) {
  if (!Buffer3.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer3)) {
    return new Buffer3(arg, encodingOrOffset, length);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    }
    return allocUnsafe2(this, arg);
  }
  return from2(this, arg, encodingOrOffset, length);
}
function from2(that, value, encodingOrOffset, length) {
  if (typeof value === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
    return fromArrayBuffer2(that, value, encodingOrOffset, length);
  }
  if (typeof value === "string") {
    return fromString2(that, value, encodingOrOffset);
  }
  return fromObject2(that, value);
}
function assertSize2(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc2(that, size, fill3, encoding) {
  assertSize2(size);
  if (size <= 0) {
    return createBuffer2(that, size);
  }
  if (fill3 !== void 0) {
    return typeof encoding === "string" ? createBuffer2(that, size).fill(fill3, encoding) : createBuffer2(that, size).fill(fill3);
  }
  return createBuffer2(that, size);
}
function allocUnsafe2(that, size) {
  assertSize2(size);
  that = createBuffer2(that, size < 0 ? 0 : checked2(size) | 0);
  if (!Buffer3.TYPED_ARRAY_SUPPORT) {
    for (var i2 = 0; i2 < size; ++i2) {
      that[i2] = 0;
    }
  }
  return that;
}
function fromString2(that, string3, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer3.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length = byteLength2(string3, encoding) | 0;
  that = createBuffer2(that, length);
  var actual = that.write(string3, encoding);
  if (actual !== length) {
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike2(that, array) {
  var length = array.length < 0 ? 0 : checked2(array.length) | 0;
  that = createBuffer2(that, length);
  for (var i2 = 0; i2 < length; i2 += 1) {
    that[i2] = array[i2] & 255;
  }
  return that;
}
function fromArrayBuffer2(that, array, byteOffset, length) {
  array.byteLength;
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length === void 0) {
    array = new Uint8Array(array);
  } else if (length === void 0) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }
  if (Buffer3.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer3.prototype;
  } else {
    that = fromArrayLike2(that, array);
  }
  return that;
}
function fromObject2(that, obj) {
  if (internalIsBuffer2(obj)) {
    var len = checked2(obj.length) | 0;
    that = createBuffer2(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan2(obj.length)) {
        return createBuffer2(that, 0);
      }
      return fromArrayLike2(that, obj);
    }
    if (obj.type === "Buffer" && isArray2(obj.data)) {
      return fromArrayLike2(that, obj.data);
    }
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked2(length) {
  if (length >= kMaxLength2()) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength2().toString(16) + " bytes");
  }
  return length | 0;
}
function internalIsBuffer2(b2) {
  return !!(b2 != null && b2._isBuffer);
}
function byteLength2(string3, encoding) {
  if (internalIsBuffer2(string3)) {
    return string3.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string3) || string3 instanceof ArrayBuffer)) {
    return string3.byteLength;
  }
  if (typeof string3 !== "string") {
    string3 = "" + string3;
  }
  var len = string3.length;
  if (len === 0)
    return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes2(string3).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes2(string3).length;
      default:
        if (loweredCase)
          return utf8ToBytes2(string3).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
function slowToString2(encoding, start, end) {
  var loweredCase = false;
  if (start === void 0 || start < 0) {
    start = 0;
  }
  if (start > this.length) {
    return "";
  }
  if (end === void 0 || end > this.length) {
    end = this.length;
  }
  if (end <= 0) {
    return "";
  }
  end >>>= 0;
  start >>>= 0;
  if (end <= start) {
    return "";
  }
  if (!encoding)
    encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice2(this, start, end);
      case "utf8":
      case "utf-8":
        return utf8Slice2(this, start, end);
      case "ascii":
        return asciiSlice2(this, start, end);
      case "latin1":
      case "binary":
        return latin1Slice2(this, start, end);
      case "base64":
        return base64Slice2(this, start, end);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice2(this, start, end);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
function swap2(b2, n2, m2) {
  var i2 = b2[n2];
  b2[n2] = b2[m2];
  b2[m2] = i2;
}
function bidirectionalIndexOf2(buffer, val2, byteOffset, encoding, dir) {
  if (buffer.length === 0)
    return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length - 1;
  }
  if (byteOffset < 0)
    byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir)
      return -1;
    else
      byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir)
      byteOffset = 0;
    else
      return -1;
  }
  if (typeof val2 === "string") {
    val2 = Buffer3.from(val2, encoding);
  }
  if (internalIsBuffer2(val2)) {
    if (val2.length === 0) {
      return -1;
    }
    return arrayIndexOf2(buffer, val2, byteOffset, encoding, dir);
  } else if (typeof val2 === "number") {
    val2 = val2 & 255;
    if (Buffer3.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val2, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val2, byteOffset);
      }
    }
    return arrayIndexOf2(buffer, [val2], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf2(arr, val2, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val2.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val2.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read2(buf, i3) {
    if (indexSize === 1) {
      return buf[i3];
    } else {
      return buf.readUInt16BE(i3 * indexSize);
    }
  }
  var i2;
  if (dir) {
    var foundIndex = -1;
    for (i2 = byteOffset; i2 < arrLength; i2++) {
      if (read2(arr, i2) === read2(val2, foundIndex === -1 ? 0 : i2 - foundIndex)) {
        if (foundIndex === -1)
          foundIndex = i2;
        if (i2 - foundIndex + 1 === valLength)
          return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1)
          i2 -= i2 - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength)
      byteOffset = arrLength - valLength;
    for (i2 = byteOffset; i2 >= 0; i2--) {
      var found = true;
      for (var j2 = 0; j2 < valLength; j2++) {
        if (read2(arr, i2 + j2) !== read2(val2, j2)) {
          found = false;
          break;
        }
      }
      if (found)
        return i2;
    }
  }
  return -1;
}
function hexWrite2(buf, string3, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }
  var strLen = string3.length;
  if (strLen % 2 !== 0)
    throw new TypeError("Invalid hex string");
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i2 = 0; i2 < length; ++i2) {
    var parsed = parseInt(string3.substr(i2 * 2, 2), 16);
    if (isNaN(parsed))
      return i2;
    buf[offset + i2] = parsed;
  }
  return i2;
}
function utf8Write2(buf, string3, offset, length) {
  return blitBuffer2(utf8ToBytes2(string3, buf.length - offset), buf, offset, length);
}
function asciiWrite2(buf, string3, offset, length) {
  return blitBuffer2(asciiToBytes2(string3), buf, offset, length);
}
function latin1Write2(buf, string3, offset, length) {
  return asciiWrite2(buf, string3, offset, length);
}
function base64Write2(buf, string3, offset, length) {
  return blitBuffer2(base64ToBytes2(string3), buf, offset, length);
}
function ucs2Write2(buf, string3, offset, length) {
  return blitBuffer2(utf16leToBytes2(string3, buf.length - offset), buf, offset, length);
}
function base64Slice2(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray(buf);
  } else {
    return fromByteArray(buf.slice(start, end));
  }
}
function utf8Slice2(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i2 = start;
  while (i2 < end) {
    var firstByte = buf[i2];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i2 + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i2 + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i2 + 1];
          thirdByte = buf[i2 + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i2 + 1];
          thirdByte = buf[i2 + 2];
          fourthByte = buf[i2 + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i2 += bytesPerSequence;
  }
  return decodeCodePointsArray2(res);
}
function decodeCodePointsArray2(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH2) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i2 = 0;
  while (i2 < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH2)
    );
  }
  return res;
}
function asciiSlice2(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i2 = start; i2 < end; ++i2) {
    ret += String.fromCharCode(buf[i2] & 127);
  }
  return ret;
}
function latin1Slice2(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i2 = start; i2 < end; ++i2) {
    ret += String.fromCharCode(buf[i2]);
  }
  return ret;
}
function hexSlice2(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0)
    start = 0;
  if (!end || end < 0 || end > len)
    end = len;
  var out = "";
  for (var i2 = start; i2 < end; ++i2) {
    out += toHex3(buf[i2]);
  }
  return out;
}
function utf16leSlice2(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = "";
  for (var i2 = 0; i2 < bytes.length; i2 += 2) {
    res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
  }
  return res;
}
function checkOffset2(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0)
    throw new RangeError("offset is not uint");
  if (offset + ext > length)
    throw new RangeError("Trying to access beyond buffer length");
}
function checkInt2(buf, value, offset, ext, max, min) {
  if (!internalIsBuffer2(buf))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min)
    throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
}
function objectWriteUInt162(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 65535 + value + 1;
  for (var i2 = 0, j2 = Math.min(buf.length - offset, 2); i2 < j2; ++i2) {
    buf[offset + i2] = (value & 255 << 8 * (littleEndian ? i2 : 1 - i2)) >>> (littleEndian ? i2 : 1 - i2) * 8;
  }
}
function objectWriteUInt322(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 4294967295 + value + 1;
  for (var i2 = 0, j2 = Math.min(buf.length - offset, 4); i2 < j2; ++i2) {
    buf[offset + i2] = value >>> (littleEndian ? i2 : 3 - i2) * 8 & 255;
  }
}
function checkIEEE7542(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
  if (offset < 0)
    throw new RangeError("Index out of range");
}
function writeFloat2(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE7542(buf, value, offset, 4);
  }
  write2(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}
function writeDouble2(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE7542(buf, value, offset, 8);
  }
  write2(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}
function base64clean2(str) {
  str = stringtrim2(str).replace(INVALID_BASE64_RE2, "");
  if (str.length < 2)
    return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function stringtrim2(str) {
  if (str.trim)
    return str.trim();
  return str.replace(/^\s+|\s+$/g, "");
}
function toHex3(n2) {
  if (n2 < 16)
    return "0" + n2.toString(16);
  return n2.toString(16);
}
function utf8ToBytes2(string3, units) {
  units = units || Infinity;
  var codePoint;
  var length = string3.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i2 = 0; i2 < length; ++i2) {
    codePoint = string3.charCodeAt(i2);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        } else if (i2 + 1 === length) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes.push(
        codePoint >> 6 | 192,
        codePoint & 63 | 128
      );
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes.push(
        codePoint >> 12 | 224,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes.push(
        codePoint >> 18 | 240,
        codePoint >> 12 & 63 | 128,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function asciiToBytes2(str) {
  var byteArray = [];
  for (var i2 = 0; i2 < str.length; ++i2) {
    byteArray.push(str.charCodeAt(i2) & 255);
  }
  return byteArray;
}
function utf16leToBytes2(str, units) {
  var c2, hi, lo;
  var byteArray = [];
  for (var i2 = 0; i2 < str.length; ++i2) {
    if ((units -= 2) < 0)
      break;
    c2 = str.charCodeAt(i2);
    hi = c2 >> 8;
    lo = c2 % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes2(str) {
  return toByteArray(base64clean2(str));
}
function blitBuffer2(src, dst, offset, length) {
  for (var i2 = 0; i2 < length; ++i2) {
    if (i2 + offset >= dst.length || i2 >= src.length)
      break;
    dst[i2 + offset] = src[i2];
  }
  return i2;
}
function isnan2(val2) {
  return val2 !== val2;
}
function isBuffer2(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer2(obj) || isSlowBuffer2(obj));
}
function isFastBuffer2(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer2(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer2(obj.slice(0, 0));
}
var lookup2, revLookup2, Arr2, inited2, toString2, isArray2, INSPECT_MAX_BYTES, _kMaxLength, MAX_ARGUMENTS_LENGTH2, INVALID_BASE64_RE2;
var init_buffer3 = __esm({
  "node-modules-polyfills:buffer"() {
    init_process();
    init_buffer();
    lookup2 = [];
    revLookup2 = [];
    Arr2 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    inited2 = false;
    toString2 = {}.toString;
    isArray2 = Array.isArray || function(arr) {
      return toString2.call(arr) == "[object Array]";
    };
    INSPECT_MAX_BYTES = 50;
    Buffer3.TYPED_ARRAY_SUPPORT = globalThis.TYPED_ARRAY_SUPPORT !== void 0 ? globalThis.TYPED_ARRAY_SUPPORT : true;
    _kMaxLength = kMaxLength2();
    Buffer3.poolSize = 8192;
    Buffer3._augment = function(arr) {
      arr.__proto__ = Buffer3.prototype;
      return arr;
    };
    Buffer3.from = function(value, encodingOrOffset, length) {
      return from2(null, value, encodingOrOffset, length);
    };
    if (Buffer3.TYPED_ARRAY_SUPPORT) {
      Buffer3.prototype.__proto__ = Uint8Array.prototype;
      Buffer3.__proto__ = Uint8Array;
    }
    Buffer3.alloc = function(size, fill3, encoding) {
      return alloc2(null, size, fill3, encoding);
    };
    Buffer3.allocUnsafe = function(size) {
      return allocUnsafe2(null, size);
    };
    Buffer3.allocUnsafeSlow = function(size) {
      return allocUnsafe2(null, size);
    };
    Buffer3.isBuffer = isBuffer2;
    Buffer3.compare = function compare3(a2, b2) {
      if (!internalIsBuffer2(a2) || !internalIsBuffer2(b2)) {
        throw new TypeError("Arguments must be Buffers");
      }
      if (a2 === b2)
        return 0;
      var x2 = a2.length;
      var y2 = b2.length;
      for (var i2 = 0, len = Math.min(x2, y2); i2 < len; ++i2) {
        if (a2[i2] !== b2[i2]) {
          x2 = a2[i2];
          y2 = b2[i2];
          break;
        }
      }
      if (x2 < y2)
        return -1;
      if (y2 < x2)
        return 1;
      return 0;
    };
    Buffer3.isEncoding = function isEncoding2(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer3.concat = function concat3(list4, length) {
      if (!isArray2(list4)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list4.length === 0) {
        return Buffer3.alloc(0);
      }
      var i2;
      if (length === void 0) {
        length = 0;
        for (i2 = 0; i2 < list4.length; ++i2) {
          length += list4[i2].length;
        }
      }
      var buffer = Buffer3.allocUnsafe(length);
      var pos = 0;
      for (i2 = 0; i2 < list4.length; ++i2) {
        var buf = list4[i2];
        if (!internalIsBuffer2(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        buf.copy(buffer, pos);
        pos += buf.length;
      }
      return buffer;
    };
    Buffer3.byteLength = byteLength2;
    Buffer3.prototype._isBuffer = true;
    Buffer3.prototype.swap16 = function swap162() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i2 = 0; i2 < len; i2 += 2) {
        swap2(this, i2, i2 + 1);
      }
      return this;
    };
    Buffer3.prototype.swap32 = function swap322() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i2 = 0; i2 < len; i2 += 4) {
        swap2(this, i2, i2 + 3);
        swap2(this, i2 + 1, i2 + 2);
      }
      return this;
    };
    Buffer3.prototype.swap64 = function swap642() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i2 = 0; i2 < len; i2 += 8) {
        swap2(this, i2, i2 + 7);
        swap2(this, i2 + 1, i2 + 6);
        swap2(this, i2 + 2, i2 + 5);
        swap2(this, i2 + 3, i2 + 4);
      }
      return this;
    };
    Buffer3.prototype.toString = function toString3() {
      var length = this.length | 0;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice2(this, 0, length);
      return slowToString2.apply(this, arguments);
    };
    Buffer3.prototype.equals = function equals2(b2) {
      if (!internalIsBuffer2(b2))
        throw new TypeError("Argument must be a Buffer");
      if (this === b2)
        return true;
      return Buffer3.compare(this, b2) === 0;
    };
    Buffer3.prototype.inspect = function inspect2() {
      var str = "";
      var max = INSPECT_MAX_BYTES;
      if (this.length > 0) {
        str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
        if (this.length > max)
          str += " ... ";
      }
      return "<Buffer " + str + ">";
    };
    Buffer3.prototype.compare = function compare4(target, start, end, thisStart, thisEnd) {
      if (!internalIsBuffer2(target)) {
        throw new TypeError("Argument must be a Buffer");
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x2 = thisEnd - thisStart;
      var y2 = end - start;
      var len = Math.min(x2, y2);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i2 = 0; i2 < len; ++i2) {
        if (thisCopy[i2] !== targetCopy[i2]) {
          x2 = thisCopy[i2];
          y2 = targetCopy[i2];
          break;
        }
      }
      if (x2 < y2)
        return -1;
      if (y2 < x2)
        return 1;
      return 0;
    };
    Buffer3.prototype.includes = function includes2(val2, byteOffset, encoding) {
      return this.indexOf(val2, byteOffset, encoding) !== -1;
    };
    Buffer3.prototype.indexOf = function indexOf2(val2, byteOffset, encoding) {
      return bidirectionalIndexOf2(this, val2, byteOffset, encoding, true);
    };
    Buffer3.prototype.lastIndexOf = function lastIndexOf2(val2, byteOffset, encoding) {
      return bidirectionalIndexOf2(this, val2, byteOffset, encoding, false);
    };
    Buffer3.prototype.write = function write3(string3, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset | 0;
        if (isFinite(length)) {
          length = length | 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string3.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite2(this, string3, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write2(this, string3, offset, length);
          case "ascii":
            return asciiWrite2(this, string3, offset, length);
          case "latin1":
          case "binary":
            return latin1Write2(this, string3, offset, length);
          case "base64":
            return base64Write2(this, string3, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write2(this, string3, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer3.prototype.toJSON = function toJSON2() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    MAX_ARGUMENTS_LENGTH2 = 4096;
    Buffer3.prototype.slice = function slice2(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf;
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer3.prototype;
      } else {
        var sliceLen = end - start;
        newBuf = new Buffer3(sliceLen, void 0);
        for (var i2 = 0; i2 < sliceLen; ++i2) {
          newBuf[i2] = this[i2 + start];
        }
      }
      return newBuf;
    };
    Buffer3.prototype.readUIntLE = function readUIntLE2(offset, byteLength3, noAssert) {
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert)
        checkOffset2(offset, byteLength3, this.length);
      var val2 = this[offset];
      var mul = 1;
      var i2 = 0;
      while (++i2 < byteLength3 && (mul *= 256)) {
        val2 += this[offset + i2] * mul;
      }
      return val2;
    };
    Buffer3.prototype.readUIntBE = function readUIntBE2(offset, byteLength3, noAssert) {
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert) {
        checkOffset2(offset, byteLength3, this.length);
      }
      var val2 = this[offset + --byteLength3];
      var mul = 1;
      while (byteLength3 > 0 && (mul *= 256)) {
        val2 += this[offset + --byteLength3] * mul;
      }
      return val2;
    };
    Buffer3.prototype.readUInt8 = function readUInt82(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 1, this.length);
      return this[offset];
    };
    Buffer3.prototype.readUInt16LE = function readUInt16LE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer3.prototype.readUInt16BE = function readUInt16BE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer3.prototype.readUInt32LE = function readUInt32LE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer3.prototype.readUInt32BE = function readUInt32BE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer3.prototype.readIntLE = function readIntLE2(offset, byteLength3, noAssert) {
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert)
        checkOffset2(offset, byteLength3, this.length);
      var val2 = this[offset];
      var mul = 1;
      var i2 = 0;
      while (++i2 < byteLength3 && (mul *= 256)) {
        val2 += this[offset + i2] * mul;
      }
      mul *= 128;
      if (val2 >= mul)
        val2 -= Math.pow(2, 8 * byteLength3);
      return val2;
    };
    Buffer3.prototype.readIntBE = function readIntBE2(offset, byteLength3, noAssert) {
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert)
        checkOffset2(offset, byteLength3, this.length);
      var i2 = byteLength3;
      var mul = 1;
      var val2 = this[offset + --i2];
      while (i2 > 0 && (mul *= 256)) {
        val2 += this[offset + --i2] * mul;
      }
      mul *= 128;
      if (val2 >= mul)
        val2 -= Math.pow(2, 8 * byteLength3);
      return val2;
    };
    Buffer3.prototype.readInt8 = function readInt82(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer3.prototype.readInt16LE = function readInt16LE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 2, this.length);
      var val2 = this[offset] | this[offset + 1] << 8;
      return val2 & 32768 ? val2 | 4294901760 : val2;
    };
    Buffer3.prototype.readInt16BE = function readInt16BE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 2, this.length);
      var val2 = this[offset + 1] | this[offset] << 8;
      return val2 & 32768 ? val2 | 4294901760 : val2;
    };
    Buffer3.prototype.readInt32LE = function readInt32LE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer3.prototype.readInt32BE = function readInt32BE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer3.prototype.readFloatLE = function readFloatLE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 4, this.length);
      return read(this, offset, true, 23, 4);
    };
    Buffer3.prototype.readFloatBE = function readFloatBE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 4, this.length);
      return read(this, offset, false, 23, 4);
    };
    Buffer3.prototype.readDoubleLE = function readDoubleLE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 8, this.length);
      return read(this, offset, true, 52, 8);
    };
    Buffer3.prototype.readDoubleBE = function readDoubleBE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 8, this.length);
      return read(this, offset, false, 52, 8);
    };
    Buffer3.prototype.writeUIntLE = function writeUIntLE2(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt2(this, value, offset, byteLength3, maxBytes, 0);
      }
      var mul = 1;
      var i2 = 0;
      this[offset] = value & 255;
      while (++i2 < byteLength3 && (mul *= 256)) {
        this[offset + i2] = value / mul & 255;
      }
      return offset + byteLength3;
    };
    Buffer3.prototype.writeUIntBE = function writeUIntBE2(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt2(this, value, offset, byteLength3, maxBytes, 0);
      }
      var i2 = byteLength3 - 1;
      var mul = 1;
      this[offset + i2] = value & 255;
      while (--i2 >= 0 && (mul *= 256)) {
        this[offset + i2] = value / mul & 255;
      }
      return offset + byteLength3;
    };
    Buffer3.prototype.writeUInt8 = function writeUInt82(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 1, 255, 0);
      if (!Buffer3.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeUInt16LE = function writeUInt16LE2(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 2, 65535, 0);
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt162(this, value, offset, true);
      }
      return offset + 2;
    };
    Buffer3.prototype.writeUInt16BE = function writeUInt16BE2(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 2, 65535, 0);
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
      } else {
        objectWriteUInt162(this, value, offset, false);
      }
      return offset + 2;
    };
    Buffer3.prototype.writeUInt32LE = function writeUInt32LE2(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 4, 4294967295, 0);
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
      } else {
        objectWriteUInt322(this, value, offset, true);
      }
      return offset + 4;
    };
    Buffer3.prototype.writeUInt32BE = function writeUInt32BE2(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 4, 4294967295, 0);
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
      } else {
        objectWriteUInt322(this, value, offset, false);
      }
      return offset + 4;
    };
    Buffer3.prototype.writeIntLE = function writeIntLE2(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt2(this, value, offset, byteLength3, limit - 1, -limit);
      }
      var i2 = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i2 < byteLength3 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
          sub = 1;
        }
        this[offset + i2] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength3;
    };
    Buffer3.prototype.writeIntBE = function writeIntBE2(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt2(this, value, offset, byteLength3, limit - 1, -limit);
      }
      var i2 = byteLength3 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i2] = value & 255;
      while (--i2 >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
          sub = 1;
        }
        this[offset + i2] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength3;
    };
    Buffer3.prototype.writeInt8 = function writeInt82(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 1, 127, -128);
      if (!Buffer3.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeInt16LE = function writeInt16LE2(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 2, 32767, -32768);
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt162(this, value, offset, true);
      }
      return offset + 2;
    };
    Buffer3.prototype.writeInt16BE = function writeInt16BE2(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 2, 32767, -32768);
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
      } else {
        objectWriteUInt162(this, value, offset, false);
      }
      return offset + 2;
    };
    Buffer3.prototype.writeInt32LE = function writeInt32LE2(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 4, 2147483647, -2147483648);
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
      } else {
        objectWriteUInt322(this, value, offset, true);
      }
      return offset + 4;
    };
    Buffer3.prototype.writeInt32BE = function writeInt32BE2(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
      } else {
        objectWriteUInt322(this, value, offset, false);
      }
      return offset + 4;
    };
    Buffer3.prototype.writeFloatLE = function writeFloatLE2(value, offset, noAssert) {
      return writeFloat2(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeFloatBE = function writeFloatBE2(value, offset, noAssert) {
      return writeFloat2(this, value, offset, false, noAssert);
    };
    Buffer3.prototype.writeDoubleLE = function writeDoubleLE2(value, offset, noAssert) {
      return writeDouble2(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeDoubleBE = function writeDoubleBE2(value, offset, noAssert) {
      return writeDouble2(this, value, offset, false, noAssert);
    };
    Buffer3.prototype.copy = function copy2(target, targetStart, start, end) {
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("sourceStart out of bounds");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      var i2;
      if (this === target && start < targetStart && targetStart < end) {
        for (i2 = len - 1; i2 >= 0; --i2) {
          target[i2 + targetStart] = this[i2 + start];
        }
      } else if (len < 1e3 || !Buffer3.TYPED_ARRAY_SUPPORT) {
        for (i2 = 0; i2 < len; ++i2) {
          target[i2 + targetStart] = this[i2 + start];
        }
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, start + len),
          targetStart
        );
      }
      return len;
    };
    Buffer3.prototype.fill = function fill2(val2, start, end, encoding) {
      if (typeof val2 === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (val2.length === 1) {
          var code4 = val2.charCodeAt(0);
          if (code4 < 256) {
            val2 = code4;
          }
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
      } else if (typeof val2 === "number") {
        val2 = val2 & 255;
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val2)
        val2 = 0;
      var i2;
      if (typeof val2 === "number") {
        for (i2 = start; i2 < end; ++i2) {
          this[i2] = val2;
        }
      } else {
        var bytes = internalIsBuffer2(val2) ? val2 : utf8ToBytes2(new Buffer3(val2, encoding).toString());
        var len = bytes.length;
        for (i2 = 0; i2 < end - start; ++i2) {
          this[i2 + start] = bytes[i2 % len];
        }
      }
      return this;
    };
    INVALID_BASE64_RE2 = /[^+\/0-9A-Za-z-_]/g;
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/buffer-list.js
function BufferList() {
  this.head = null;
  this.tail = null;
  this.length = 0;
}
var buffer_list_default;
var init_buffer_list = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/buffer-list.js"() {
    init_process();
    init_buffer();
    init_buffer3();
    buffer_list_default = BufferList;
    BufferList.prototype.push = function(v2) {
      var entry = { data: v2, next: null };
      if (this.length > 0)
        this.tail.next = entry;
      else
        this.head = entry;
      this.tail = entry;
      ++this.length;
    };
    BufferList.prototype.unshift = function(v2) {
      var entry = { data: v2, next: this.head };
      if (this.length === 0)
        this.tail = entry;
      this.head = entry;
      ++this.length;
    };
    BufferList.prototype.shift = function() {
      if (this.length === 0)
        return;
      var ret = this.head.data;
      if (this.length === 1)
        this.head = this.tail = null;
      else
        this.head = this.head.next;
      --this.length;
      return ret;
    };
    BufferList.prototype.clear = function() {
      this.head = this.tail = null;
      this.length = 0;
    };
    BufferList.prototype.join = function(s2) {
      if (this.length === 0)
        return "";
      var p3 = this.head;
      var ret = "" + p3.data;
      while (p3 = p3.next) {
        ret += s2 + p3.data;
      }
      return ret;
    };
    BufferList.prototype.concat = function(n2) {
      if (this.length === 0)
        return Buffer3.alloc(0);
      if (this.length === 1)
        return this.head.data;
      var ret = Buffer3.allocUnsafe(n2 >>> 0);
      var p3 = this.head;
      var i2 = 0;
      while (p3) {
        p3.data.copy(ret, i2);
        i2 += p3.data.length;
        p3 = p3.next;
      }
      return ret;
    };
  }
});

// node-modules-polyfills:string_decoder
var string_decoder_exports = {};
__export(string_decoder_exports, {
  StringDecoder: () => StringDecoder
});
function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error("Unknown encoding: " + encoding);
  }
}
function StringDecoder(encoding) {
  this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
  assertEncoding(encoding);
  switch (this.encoding) {
    case "utf8":
      this.surrogateSize = 3;
      break;
    case "ucs2":
    case "utf16le":
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case "base64":
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }
  this.charBuffer = new Buffer3(6);
  this.charReceived = 0;
  this.charLength = 0;
}
function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}
function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}
function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}
var isBufferEncoding;
var init_string_decoder = __esm({
  "node-modules-polyfills:string_decoder"() {
    init_process();
    init_buffer();
    init_buffer3();
    isBufferEncoding = Buffer3.isEncoding || function(encoding) {
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    StringDecoder.prototype.write = function(buffer) {
      var charStr = "";
      while (this.charLength) {
        var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
        buffer.copy(this.charBuffer, this.charReceived, 0, available);
        this.charReceived += available;
        if (this.charReceived < this.charLength) {
          return "";
        }
        buffer = buffer.slice(available, buffer.length);
        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
        var charCode = charStr.charCodeAt(charStr.length - 1);
        if (charCode >= 55296 && charCode <= 56319) {
          this.charLength += this.surrogateSize;
          charStr = "";
          continue;
        }
        this.charReceived = this.charLength = 0;
        if (buffer.length === 0) {
          return charStr;
        }
        break;
      }
      this.detectIncompleteChar(buffer);
      var end = buffer.length;
      if (this.charLength) {
        buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
        end -= this.charReceived;
      }
      charStr += buffer.toString(this.encoding, 0, end);
      var end = charStr.length - 1;
      var charCode = charStr.charCodeAt(end);
      if (charCode >= 55296 && charCode <= 56319) {
        var size = this.surrogateSize;
        this.charLength += size;
        this.charReceived += size;
        this.charBuffer.copy(this.charBuffer, size, 0, size);
        buffer.copy(this.charBuffer, 0, 0, size);
        return charStr.substring(0, end);
      }
      return charStr;
    };
    StringDecoder.prototype.detectIncompleteChar = function(buffer) {
      var i2 = buffer.length >= 3 ? 3 : buffer.length;
      for (; i2 > 0; i2--) {
        var c2 = buffer[buffer.length - i2];
        if (i2 == 1 && c2 >> 5 == 6) {
          this.charLength = 2;
          break;
        }
        if (i2 <= 2 && c2 >> 4 == 14) {
          this.charLength = 3;
          break;
        }
        if (i2 <= 3 && c2 >> 3 == 30) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = i2;
    };
    StringDecoder.prototype.end = function(buffer) {
      var res = "";
      if (buffer && buffer.length)
        res = this.write(buffer);
      if (this.charReceived) {
        var cr2 = this.charReceived;
        var buf = this.charBuffer;
        var enc = this.encoding;
        res += buf.slice(0, cr2).toString(enc);
      }
      return res;
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/readable.js
function prependListener2(emitter, event, fn) {
  if (typeof emitter.prependListener === "function") {
    return emitter.prependListener(event, fn);
  } else {
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
}
function listenerCount2(emitter, type) {
  return emitter.listeners(type).length;
}
function ReadableState(options, stream) {
  options = options || {};
  this.objectMode = !!options.objectMode;
  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.readableObjectMode;
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.buffer = new buffer_list_default();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;
  this.sync = true;
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.ranOut = false;
  this.awaitDrain = 0;
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable(options) {
  if (!(this instanceof Readable))
    return new Readable(options);
  this._readableState = new ReadableState(options, this);
  this.readable = true;
  if (options && typeof options.read === "function")
    this._read = options.read;
  events_default.call(this);
}
function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit("error", er);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e2 = new Error("stream.push() after EOF");
      stream.emit("error", e2);
    } else if (state.endEmitted && addToFront) {
      var _e2 = new Error("stream.unshift() after end event");
      stream.emit("error", _e2);
    } else {
      var skipAdd;
      if (state.decoder && !addToFront && !encoding) {
        chunk = state.decoder.write(chunk);
        skipAdd = !state.objectMode && chunk.length === 0;
      }
      if (!addToFront)
        state.reading = false;
      if (!skipAdd) {
        if (state.flowing && state.length === 0 && !state.sync) {
          stream.emit("data", chunk);
          stream.read(0);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront)
            state.buffer.unshift(chunk);
          else
            state.buffer.push(chunk);
          if (state.needReadable)
            emitReadable(stream);
        }
      }
      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }
  return needMoreData(state);
}
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}
function computeNewHighWaterMark(n2) {
  if (n2 >= MAX_HWM) {
    n2 = MAX_HWM;
  } else {
    n2--;
    n2 |= n2 >>> 1;
    n2 |= n2 >>> 2;
    n2 |= n2 >>> 4;
    n2 |= n2 >>> 8;
    n2 |= n2 >>> 16;
    n2++;
  }
  return n2;
}
function howMuchToRead(n2, state) {
  if (n2 <= 0 || state.length === 0 && state.ended)
    return 0;
  if (state.objectMode)
    return 1;
  if (n2 !== n2) {
    if (state.flowing && state.length)
      return state.buffer.head.data.length;
    else
      return state.length;
  }
  if (n2 > state.highWaterMark)
    state.highWaterMark = computeNewHighWaterMark(n2);
  if (n2 <= state.length)
    return n2;
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}
function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer2.isBuffer(chunk) && typeof chunk !== "string" && chunk !== null && chunk !== void 0 && !state.objectMode) {
    er = new TypeError("Invalid non-string/buffer chunk");
  }
  return er;
}
function onEofChunk(stream, state) {
  if (state.ended)
    return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;
  emitReadable(stream);
}
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug("emitReadable", state.flowing);
    state.emittedReadable = true;
    if (state.sync)
      nextTick2(emitReadable_, stream);
    else
      emitReadable_(stream);
  }
}
function emitReadable_(stream) {
  debug("emit readable");
  stream.emit("readable");
  flow(stream);
}
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    nextTick2(maybeReadMore_, stream, state);
  }
}
function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug("maybeReadMore read 0");
    stream.read(0);
    if (len === state.length)
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}
function pipeOnDrain(src) {
  return function() {
    var state = src._readableState;
    debug("pipeOnDrain", state.awaitDrain);
    if (state.awaitDrain)
      state.awaitDrain--;
    if (state.awaitDrain === 0 && src.listeners("data").length) {
      state.flowing = true;
      flow(src);
    }
  };
}
function nReadingNextTick(self2) {
  debug("readable nexttick read 0");
  self2.read(0);
}
function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    nextTick2(resume_, stream, state);
  }
}
function resume_(stream, state) {
  if (!state.reading) {
    debug("resume read 0");
    stream.read(0);
  }
  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit("resume");
  flow(stream);
  if (state.flowing && !state.reading)
    stream.read(0);
}
function flow(stream) {
  var state = stream._readableState;
  debug("flow", state.flowing);
  while (state.flowing && stream.read() !== null) {
  }
}
function fromList(n2, state) {
  if (state.length === 0)
    return null;
  var ret;
  if (state.objectMode)
    ret = state.buffer.shift();
  else if (!n2 || n2 >= state.length) {
    if (state.decoder)
      ret = state.buffer.join("");
    else if (state.buffer.length === 1)
      ret = state.buffer.head.data;
    else
      ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    ret = fromListPartial(n2, state.buffer, state.decoder);
  }
  return ret;
}
function fromListPartial(n2, list4, hasStrings) {
  var ret;
  if (n2 < list4.head.data.length) {
    ret = list4.head.data.slice(0, n2);
    list4.head.data = list4.head.data.slice(n2);
  } else if (n2 === list4.head.data.length) {
    ret = list4.shift();
  } else {
    ret = hasStrings ? copyFromBufferString(n2, list4) : copyFromBuffer(n2, list4);
  }
  return ret;
}
function copyFromBufferString(n2, list4) {
  var p3 = list4.head;
  var c2 = 1;
  var ret = p3.data;
  n2 -= ret.length;
  while (p3 = p3.next) {
    var str = p3.data;
    var nb = n2 > str.length ? str.length : n2;
    if (nb === str.length)
      ret += str;
    else
      ret += str.slice(0, n2);
    n2 -= nb;
    if (n2 === 0) {
      if (nb === str.length) {
        ++c2;
        if (p3.next)
          list4.head = p3.next;
        else
          list4.head = list4.tail = null;
      } else {
        list4.head = p3;
        p3.data = str.slice(nb);
      }
      break;
    }
    ++c2;
  }
  list4.length -= c2;
  return ret;
}
function copyFromBuffer(n2, list4) {
  var ret = Buffer2.allocUnsafe(n2);
  var p3 = list4.head;
  var c2 = 1;
  p3.data.copy(ret);
  n2 -= p3.data.length;
  while (p3 = p3.next) {
    var buf = p3.data;
    var nb = n2 > buf.length ? buf.length : n2;
    buf.copy(ret, ret.length - n2, 0, nb);
    n2 -= nb;
    if (n2 === 0) {
      if (nb === buf.length) {
        ++c2;
        if (p3.next)
          list4.head = p3.next;
        else
          list4.head = list4.tail = null;
      } else {
        list4.head = p3;
        p3.data = buf.slice(nb);
      }
      break;
    }
    ++c2;
  }
  list4.length -= c2;
  return ret;
}
function endReadable(stream) {
  var state = stream._readableState;
  if (state.length > 0)
    throw new Error('"endReadable()" called on non-empty stream');
  if (!state.endEmitted) {
    state.ended = true;
    nextTick2(endReadableNT, state, stream);
  }
}
function endReadableNT(state, stream) {
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit("end");
  }
}
function forEach(xs, f2) {
  for (var i2 = 0, l2 = xs.length; i2 < l2; i2++) {
    f2(xs[i2], i2);
  }
}
function indexOf3(xs, x2) {
  for (var i2 = 0, l2 = xs.length; i2 < l2; i2++) {
    if (xs[i2] === x2)
      return i2;
  }
  return -1;
}
var debug, MAX_HWM;
var init_readable = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/readable.js"() {
    "use strict";
    init_process();
    init_buffer();
    init_events();
    init_util();
    init_buffer_list();
    init_string_decoder();
    init_duplex();
    init_process2();
    Readable.ReadableState = ReadableState;
    debug = debuglog("stream");
    inherits_default(Readable, events_default);
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      if (!state.objectMode && typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
      }
      return readableAddChunk(this, state, chunk, encoding, false);
    };
    Readable.prototype.unshift = function(chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, "", true);
    };
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    MAX_HWM = 8388608;
    Readable.prototype.read = function(n2) {
      debug("read", n2);
      n2 = parseInt(n2, 10);
      var state = this._readableState;
      var nOrig = n2;
      if (n2 !== 0)
        state.emittedReadable = false;
      if (n2 === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n2 = howMuchToRead(n2, state);
      if (n2 === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n2 < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n2 = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n2 > 0)
        ret = fromList(n2, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = true;
        n2 = 0;
      } else {
        state.length -= n2;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n2 && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    Readable.prototype._read = function(n2) {
      this.emit("error", new Error("not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = !pipeOpts || pipeOpts.end !== false;
      var endFn = doEnd ? onend2 : cleanup;
      if (state.endEmitted)
        nextTick2(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable) {
        debug("onunpipe");
        if (readable === src) {
          cleanup();
        }
      }
      function onend2() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend2);
        src.removeListener("end", cleanup);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (false === ret && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf3(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", src._readableState.awaitDrain);
            src._readableState.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (listenerCount2(dest, "error") === 0)
          dest.emit("error", er);
      }
      prependListener2(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var _i = 0; _i < len; _i++) {
          dests[_i].emit("unpipe", this);
        }
        return this;
      }
      var i2 = indexOf3(state.pipes, dest);
      if (i2 === -1)
        return this;
      state.pipes.splice(i2, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = events_default.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            nextTick2(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this, state);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    Readable.prototype.wrap = function(stream) {
      var state = this._readableState;
      var paused = false;
      var self2 = this;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            self2.push(chunk);
        }
        self2.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = self2.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i2 in stream) {
        if (this[i2] === void 0 && typeof stream[i2] === "function") {
          this[i2] = function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i2);
        }
      }
      var events = ["error", "close", "destroy", "pause", "resume"];
      forEach(events, function(ev) {
        stream.on(ev, self2.emit.bind(self2, ev));
      });
      self2._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return self2;
    };
    Readable._fromList = fromList;
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/writable.js
function nop() {
}
function WriteReq(chunk, encoding, cb2) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb2;
  this.next = null;
}
function WritableState(options, stream) {
  Object.defineProperty(this, "buffer", {
    get: deprecate(function() {
      return this.getBuffer();
    }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.")
  });
  options = options || {};
  this.objectMode = !!options.objectMode;
  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.writableObjectMode;
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.needDrain = false;
  this.ending = false;
  this.ended = false;
  this.finished = false;
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.length = 0;
  this.writing = false;
  this.corked = 0;
  this.sync = true;
  this.bufferProcessing = false;
  this.onwrite = function(er) {
    onwrite(stream, er);
  };
  this.writecb = null;
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;
  this.pendingcb = 0;
  this.prefinished = false;
  this.errorEmitted = false;
  this.bufferedRequestCount = 0;
  this.corkedRequestsFree = new CorkedRequest(this);
}
function Writable(options) {
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);
  this._writableState = new WritableState(options, this);
  this.writable = true;
  if (options) {
    if (typeof options.write === "function")
      this._write = options.write;
    if (typeof options.writev === "function")
      this._writev = options.writev;
  }
  EventEmitter.call(this);
}
function writeAfterEnd(stream, cb2) {
  var er = new Error("write after end");
  stream.emit("error", er);
  nextTick2(cb2, er);
}
function validChunk(stream, state, chunk, cb2) {
  var valid2 = true;
  var er = false;
  if (chunk === null) {
    er = new TypeError("May not write null values to stream");
  } else if (!Buffer3.isBuffer(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
    er = new TypeError("Invalid non-string/buffer chunk");
  }
  if (er) {
    stream.emit("error", er);
    nextTick2(cb2, er);
    valid2 = false;
  }
  return valid2;
}
function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
    chunk = Buffer3.from(chunk, encoding);
  }
  return chunk;
}
function writeOrBuffer(stream, state, chunk, encoding, cb2) {
  chunk = decodeChunk(state, chunk, encoding);
  if (Buffer3.isBuffer(chunk))
    encoding = "buffer";
  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark;
  if (!ret)
    state.needDrain = true;
  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb2);
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb2);
  }
  return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb2) {
  state.writelen = len;
  state.writecb = cb2;
  state.writing = true;
  state.sync = true;
  if (writev)
    stream._writev(chunk, state.onwrite);
  else
    stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}
function onwriteError(stream, state, sync, er, cb2) {
  --state.pendingcb;
  if (sync)
    nextTick2(cb2, er);
  else
    cb2(er);
  stream._writableState.errorEmitted = true;
  stream.emit("error", er);
}
function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}
function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb2 = state.writecb;
  onwriteStateUpdate(state);
  if (er)
    onwriteError(stream, state, sync, er, cb2);
  else {
    var finished = needFinish(state);
    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }
    if (sync) {
      nextTick2(afterWrite, stream, state, finished, cb2);
    } else {
      afterWrite(stream, state, finished, cb2);
    }
  }
}
function afterWrite(stream, state, finished, cb2) {
  if (!finished)
    onwriteDrain(stream, state);
  state.pendingcb--;
  cb2();
  finishMaybe(stream, state);
}
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit("drain");
  }
}
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;
  if (stream._writev && entry && entry.next) {
    var l2 = state.bufferedRequestCount;
    var buffer = new Array(l2);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count2 = 0;
    while (entry) {
      buffer[count2] = entry;
      entry = entry.next;
      count2 += 1;
    }
    doWrite(stream, state, true, state.length, buffer, "", holder.finish);
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb2 = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb2);
      entry = entry.next;
      if (state.writing) {
        break;
      }
    }
    if (entry === null)
      state.lastBufferedRequest = null;
  }
  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}
function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit("prefinish");
  }
}
function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit("finish");
    } else {
      prefinish(stream, state);
    }
  }
  return need;
}
function endWritable(stream, state, cb2) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb2) {
    if (state.finished)
      nextTick2(cb2);
    else
      stream.once("finish", cb2);
  }
  state.ended = true;
  stream.writable = false;
}
function CorkedRequest(state) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function(err) {
    var entry = _this.entry;
    _this.entry = null;
    while (entry) {
      var cb2 = entry.callback;
      state.pendingcb--;
      cb2(err);
      entry = entry.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = _this;
    } else {
      state.corkedRequestsFree = _this;
    }
  };
}
var init_writable = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/writable.js"() {
    init_process();
    init_buffer();
    init_util();
    init_buffer3();
    init_events();
    init_duplex();
    init_process2();
    Writable.WritableState = WritableState;
    inherits_default(Writable, EventEmitter);
    WritableState.prototype.getBuffer = function writableStateGetBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    Writable.prototype.write = function(chunk, encoding, cb2) {
      var state = this._writableState;
      var ret = false;
      if (typeof encoding === "function") {
        cb2 = encoding;
        encoding = null;
      }
      if (Buffer3.isBuffer(chunk))
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb2 !== "function")
        cb2 = nop;
      if (state.ended)
        writeAfterEnd(this, cb2);
      else if (validChunk(this, state, chunk, cb2)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, chunk, encoding, cb2);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Writable.prototype._write = function(chunk, encoding, cb2) {
      cb2(new Error("not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb2) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb2 = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb2 = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending && !state.finished)
        endWritable(this, state, cb2);
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/duplex.js
function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  if (options && options.readable === false)
    this.readable = false;
  if (options && options.writable === false)
    this.writable = false;
  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;
  this.once("end", onend);
}
function onend() {
  if (this.allowHalfOpen || this._writableState.ended)
    return;
  nextTick2(onEndNT, this);
}
function onEndNT(self2) {
  self2.end();
}
var keys, method, v2;
var init_duplex = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/duplex.js"() {
    init_process();
    init_buffer();
    init_util();
    init_process2();
    init_readable();
    init_writable();
    inherits_default(Duplex, Readable);
    keys = Object.keys(Writable.prototype);
    for (v2 = 0; v2 < keys.length; v2++) {
      method = keys[v2];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/transform.js
function TransformState(stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };
  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}
function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;
  var cb2 = ts.writecb;
  if (!cb2)
    return stream.emit("error", new Error("no writecb in Transform class"));
  ts.writechunk = null;
  ts.writecb = null;
  if (data !== null && data !== void 0)
    stream.push(data);
  cb2(er);
  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}
function Transform2(options) {
  if (!(this instanceof Transform2))
    return new Transform2(options);
  Duplex.call(this, options);
  this._transformState = new TransformState(this);
  var stream = this;
  this._readableState.needReadable = true;
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === "function")
      this._transform = options.transform;
    if (typeof options.flush === "function")
      this._flush = options.flush;
  }
  this.once("prefinish", function() {
    if (typeof this._flush === "function")
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}
function done(stream, er) {
  if (er)
    return stream.emit("error", er);
  var ws = stream._writableState;
  var ts = stream._transformState;
  if (ws.length)
    throw new Error("Calling transform done when ws.length != 0");
  if (ts.transforming)
    throw new Error("Calling transform done when still transforming");
  return stream.push(null);
}
var init_transform = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/transform.js"() {
    init_process();
    init_buffer();
    init_duplex();
    init_util();
    inherits_default(Transform2, Duplex);
    Transform2.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform2.prototype._transform = function(chunk, encoding, cb2) {
      throw new Error("Not implemented");
    };
    Transform2.prototype._write = function(chunk, encoding, cb2) {
      var ts = this._transformState;
      ts.writecb = cb2;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform2.prototype._read = function(n2) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/passthrough.js
function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);
  Transform2.call(this, options);
}
var init_passthrough = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/passthrough.js"() {
    init_process();
    init_buffer();
    init_transform();
    init_util();
    inherits_default(PassThrough, Transform2);
    PassThrough.prototype._transform = function(chunk, encoding, cb2) {
      cb2(null, chunk);
    };
  }
});

// node-modules-polyfills:stream
var stream_exports = {};
__export(stream_exports, {
  Duplex: () => Duplex,
  PassThrough: () => PassThrough,
  Readable: () => Readable,
  Stream: () => Stream,
  Transform: () => Transform2,
  Writable: () => Writable,
  default: () => stream_default
});
function Stream() {
  events_default.call(this);
}
var stream_default;
var init_stream = __esm({
  "node-modules-polyfills:stream"() {
    init_process();
    init_buffer();
    init_events();
    init_util();
    init_duplex();
    init_readable();
    init_writable();
    init_transform();
    init_passthrough();
    inherits_default(Stream, events_default);
    Stream.Readable = Readable;
    Stream.Writable = Writable;
    Stream.Duplex = Duplex;
    Stream.Transform = Transform2;
    Stream.PassThrough = PassThrough;
    Stream.Stream = Stream;
    stream_default = Stream;
    Stream.prototype.pipe = function(dest, options) {
      var source = this;
      function ondata(chunk) {
        if (dest.writable) {
          if (false === dest.write(chunk) && source.pause) {
            source.pause();
          }
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend2);
        source.on("close", onclose);
      }
      var didOnEnd = false;
      function onend2() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        if (typeof dest.destroy === "function")
          dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (events_default.listenerCount(this, "error") === 0) {
          throw er;
        }
      }
      source.on("error", onerror);
      dest.on("error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend2);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
  }
});

// node-modules-polyfills-commonjs:stream
var require_stream = __commonJS({
  "node-modules-polyfills-commonjs:stream"(exports, module) {
    init_process();
    init_buffer();
    var polyfill = (init_stream(), __toCommonJS(stream_exports));
    if (polyfill && polyfill.default) {
      module.exports = polyfill.default;
      for (let k2 in polyfill) {
        module.exports[k2] = polyfill[k2];
      }
    } else if (polyfill) {
      module.exports = polyfill;
    }
  }
});

// node-modules-polyfills-commonjs:string_decoder
var require_string_decoder = __commonJS({
  "node-modules-polyfills-commonjs:string_decoder"(exports, module) {
    init_process();
    init_buffer();
    var polyfill = (init_string_decoder(), __toCommonJS(string_decoder_exports));
    if (polyfill && polyfill.default) {
      module.exports = polyfill.default;
      for (let k2 in polyfill) {
        module.exports[k2] = polyfill[k2];
      }
    } else if (polyfill) {
      module.exports = polyfill;
    }
  }
});

// node_modules/sax/lib/sax.js
var require_sax = __commonJS({
  "node_modules/sax/lib/sax.js"(exports) {
    init_process();
    init_buffer();
    (function(sax) {
      sax.parser = function(strict, opt) {
        return new SAXParser(strict, opt);
      };
      sax.SAXParser = SAXParser;
      sax.SAXStream = SAXStream;
      sax.createStream = createStream;
      sax.MAX_BUFFER_LENGTH = 64 * 1024;
      var buffers = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      sax.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser)) {
          return new SAXParser(strict, opt);
        }
        var parser = this;
        clearBuffers(parser);
        parser.q = parser.c = "";
        parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
        parser.opt = opt || {};
        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
        parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
        parser.tags = [];
        parser.closed = parser.closedRoot = parser.sawRoot = false;
        parser.tag = parser.error = null;
        parser.strict = !!strict;
        parser.noscript = !!(strict || parser.opt.noscript);
        parser.state = S2.BEGIN;
        parser.strictEntities = parser.opt.strictEntities;
        parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
        parser.attribList = [];
        if (parser.opt.xmlns) {
          parser.ns = Object.create(rootNS);
        }
        if (parser.opt.unquotedAttributeValues === void 0) {
          parser.opt.unquotedAttributeValues = !strict;
        }
        parser.trackPosition = parser.opt.position !== false;
        if (parser.trackPosition) {
          parser.position = parser.line = parser.column = 0;
        }
        emit4(parser, "onready");
      }
      if (!Object.create) {
        Object.create = function(o2) {
          function F2() {
          }
          F2.prototype = o2;
          var newf = new F2();
          return newf;
        };
      }
      if (!Object.keys) {
        Object.keys = function(o2) {
          var a2 = [];
          for (var i2 in o2)
            if (o2.hasOwnProperty(i2))
              a2.push(i2);
          return a2;
        };
      }
      function checkBufferLength(parser) {
        var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
        var maxActual = 0;
        for (var i2 = 0, l2 = buffers.length; i2 < l2; i2++) {
          var len = parser[buffers[i2]].length;
          if (len > maxAllowed) {
            switch (buffers[i2]) {
              case "textNode":
                closeText(parser);
                break;
              case "cdata":
                emitNode(parser, "oncdata", parser.cdata);
                parser.cdata = "";
                break;
              case "script":
                emitNode(parser, "onscript", parser.script);
                parser.script = "";
                break;
              default:
                error3(parser, "Max buffer length exceeded: " + buffers[i2]);
            }
          }
          maxActual = Math.max(maxActual, len);
        }
        var m2 = sax.MAX_BUFFER_LENGTH - maxActual;
        parser.bufferCheckPosition = m2 + parser.position;
      }
      function clearBuffers(parser) {
        for (var i2 = 0, l2 = buffers.length; i2 < l2; i2++) {
          parser[buffers[i2]] = "";
        }
      }
      function flushBuffers(parser) {
        closeText(parser);
        if (parser.cdata !== "") {
          emitNode(parser, "oncdata", parser.cdata);
          parser.cdata = "";
        }
        if (parser.script !== "") {
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
      }
      SAXParser.prototype = {
        end: function() {
          end(this);
        },
        write: write4,
        resume: function() {
          this.error = null;
          return this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          flushBuffers(this);
        }
      };
      var Stream2;
      try {
        Stream2 = require_stream().Stream;
      } catch (ex) {
        Stream2 = function() {
        };
      }
      if (!Stream2)
        Stream2 = function() {
        };
      var streamWraps = sax.EVENTS.filter(function(ev) {
        return ev !== "error" && ev !== "end";
      });
      function createStream(strict, opt) {
        return new SAXStream(strict, opt);
      }
      function SAXStream(strict, opt) {
        if (!(this instanceof SAXStream)) {
          return new SAXStream(strict, opt);
        }
        Stream2.apply(this);
        this._parser = new SAXParser(strict, opt);
        this.writable = true;
        this.readable = true;
        var me = this;
        this._parser.onend = function() {
          me.emit("end");
        };
        this._parser.onerror = function(er) {
          me.emit("error", er);
          me._parser.error = null;
        };
        this._decoder = null;
        streamWraps.forEach(function(ev) {
          Object.defineProperty(me, "on" + ev, {
            get: function() {
              return me._parser["on" + ev];
            },
            set: function(h2) {
              if (!h2) {
                me.removeAllListeners(ev);
                me._parser["on" + ev] = h2;
                return h2;
              }
              me.on(ev, h2);
            },
            enumerable: true,
            configurable: false
          });
        });
      }
      SAXStream.prototype = Object.create(Stream2.prototype, {
        constructor: {
          value: SAXStream
        }
      });
      SAXStream.prototype.write = function(data) {
        if (typeof Buffer2 === "function" && typeof Buffer2.isBuffer === "function" && Buffer2.isBuffer(data)) {
          if (!this._decoder) {
            var SD = require_string_decoder().StringDecoder;
            this._decoder = new SD("utf8");
          }
          data = this._decoder.write(data);
        }
        this._parser.write(data.toString());
        this.emit("data", data);
        return true;
      };
      SAXStream.prototype.end = function(chunk) {
        if (chunk && chunk.length) {
          this.write(chunk);
        }
        this._parser.end();
        return true;
      };
      SAXStream.prototype.on = function(ev, handler) {
        var me = this;
        if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
          me._parser["on" + ev] = function() {
            var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
            args.splice(0, 0, ev);
            me.emit.apply(me, args);
          };
        }
        return Stream2.prototype.on.call(me, ev, handler);
      };
      var CDATA = "[CDATA[";
      var DOCTYPE = "DOCTYPE";
      var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
      var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
      var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
      var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function isWhitespace(c2) {
        return c2 === " " || c2 === "\n" || c2 === "\r" || c2 === "	";
      }
      function isQuote(c2) {
        return c2 === '"' || c2 === "'";
      }
      function isAttribEnd(c2) {
        return c2 === ">" || isWhitespace(c2);
      }
      function isMatch(regex2, c2) {
        return regex2.test(c2);
      }
      function notMatch(regex2, c2) {
        return !isMatch(regex2, c2);
      }
      var S2 = 0;
      sax.STATE = {
        BEGIN: S2++,
        // leading byte order mark or whitespace
        BEGIN_WHITESPACE: S2++,
        // leading whitespace
        TEXT: S2++,
        // general stuff
        TEXT_ENTITY: S2++,
        // &amp and such.
        OPEN_WAKA: S2++,
        // <
        SGML_DECL: S2++,
        // <!BLARG
        SGML_DECL_QUOTED: S2++,
        // <!BLARG foo "bar
        DOCTYPE: S2++,
        // <!DOCTYPE
        DOCTYPE_QUOTED: S2++,
        // <!DOCTYPE "//blah
        DOCTYPE_DTD: S2++,
        // <!DOCTYPE "//blah" [ ...
        DOCTYPE_DTD_QUOTED: S2++,
        // <!DOCTYPE "//blah" [ "foo
        COMMENT_STARTING: S2++,
        // <!-
        COMMENT: S2++,
        // <!--
        COMMENT_ENDING: S2++,
        // <!-- blah -
        COMMENT_ENDED: S2++,
        // <!-- blah --
        CDATA: S2++,
        // <![CDATA[ something
        CDATA_ENDING: S2++,
        // ]
        CDATA_ENDING_2: S2++,
        // ]]
        PROC_INST: S2++,
        // <?hi
        PROC_INST_BODY: S2++,
        // <?hi there
        PROC_INST_ENDING: S2++,
        // <?hi "there" ?
        OPEN_TAG: S2++,
        // <strong
        OPEN_TAG_SLASH: S2++,
        // <strong /
        ATTRIB: S2++,
        // <a
        ATTRIB_NAME: S2++,
        // <a foo
        ATTRIB_NAME_SAW_WHITE: S2++,
        // <a foo _
        ATTRIB_VALUE: S2++,
        // <a foo=
        ATTRIB_VALUE_QUOTED: S2++,
        // <a foo="bar
        ATTRIB_VALUE_CLOSED: S2++,
        // <a foo="bar"
        ATTRIB_VALUE_UNQUOTED: S2++,
        // <a foo=bar
        ATTRIB_VALUE_ENTITY_Q: S2++,
        // <foo bar="&quot;"
        ATTRIB_VALUE_ENTITY_U: S2++,
        // <foo bar=&quot
        CLOSE_TAG: S2++,
        // </a
        CLOSE_TAG_SAW_WHITE: S2++,
        // </a   >
        SCRIPT: S2++,
        // <script> ...
        SCRIPT_ENDING: S2++
        // <script> ... <
      };
      sax.XML_ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'"
      };
      sax.ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'",
        "AElig": 198,
        "Aacute": 193,
        "Acirc": 194,
        "Agrave": 192,
        "Aring": 197,
        "Atilde": 195,
        "Auml": 196,
        "Ccedil": 199,
        "ETH": 208,
        "Eacute": 201,
        "Ecirc": 202,
        "Egrave": 200,
        "Euml": 203,
        "Iacute": 205,
        "Icirc": 206,
        "Igrave": 204,
        "Iuml": 207,
        "Ntilde": 209,
        "Oacute": 211,
        "Ocirc": 212,
        "Ograve": 210,
        "Oslash": 216,
        "Otilde": 213,
        "Ouml": 214,
        "THORN": 222,
        "Uacute": 218,
        "Ucirc": 219,
        "Ugrave": 217,
        "Uuml": 220,
        "Yacute": 221,
        "aacute": 225,
        "acirc": 226,
        "aelig": 230,
        "agrave": 224,
        "aring": 229,
        "atilde": 227,
        "auml": 228,
        "ccedil": 231,
        "eacute": 233,
        "ecirc": 234,
        "egrave": 232,
        "eth": 240,
        "euml": 235,
        "iacute": 237,
        "icirc": 238,
        "igrave": 236,
        "iuml": 239,
        "ntilde": 241,
        "oacute": 243,
        "ocirc": 244,
        "ograve": 242,
        "oslash": 248,
        "otilde": 245,
        "ouml": 246,
        "szlig": 223,
        "thorn": 254,
        "uacute": 250,
        "ucirc": 251,
        "ugrave": 249,
        "uuml": 252,
        "yacute": 253,
        "yuml": 255,
        "copy": 169,
        "reg": 174,
        "nbsp": 160,
        "iexcl": 161,
        "cent": 162,
        "pound": 163,
        "curren": 164,
        "yen": 165,
        "brvbar": 166,
        "sect": 167,
        "uml": 168,
        "ordf": 170,
        "laquo": 171,
        "not": 172,
        "shy": 173,
        "macr": 175,
        "deg": 176,
        "plusmn": 177,
        "sup1": 185,
        "sup2": 178,
        "sup3": 179,
        "acute": 180,
        "micro": 181,
        "para": 182,
        "middot": 183,
        "cedil": 184,
        "ordm": 186,
        "raquo": 187,
        "frac14": 188,
        "frac12": 189,
        "frac34": 190,
        "iquest": 191,
        "times": 215,
        "divide": 247,
        "OElig": 338,
        "oelig": 339,
        "Scaron": 352,
        "scaron": 353,
        "Yuml": 376,
        "fnof": 402,
        "circ": 710,
        "tilde": 732,
        "Alpha": 913,
        "Beta": 914,
        "Gamma": 915,
        "Delta": 916,
        "Epsilon": 917,
        "Zeta": 918,
        "Eta": 919,
        "Theta": 920,
        "Iota": 921,
        "Kappa": 922,
        "Lambda": 923,
        "Mu": 924,
        "Nu": 925,
        "Xi": 926,
        "Omicron": 927,
        "Pi": 928,
        "Rho": 929,
        "Sigma": 931,
        "Tau": 932,
        "Upsilon": 933,
        "Phi": 934,
        "Chi": 935,
        "Psi": 936,
        "Omega": 937,
        "alpha": 945,
        "beta": 946,
        "gamma": 947,
        "delta": 948,
        "epsilon": 949,
        "zeta": 950,
        "eta": 951,
        "theta": 952,
        "iota": 953,
        "kappa": 954,
        "lambda": 955,
        "mu": 956,
        "nu": 957,
        "xi": 958,
        "omicron": 959,
        "pi": 960,
        "rho": 961,
        "sigmaf": 962,
        "sigma": 963,
        "tau": 964,
        "upsilon": 965,
        "phi": 966,
        "chi": 967,
        "psi": 968,
        "omega": 969,
        "thetasym": 977,
        "upsih": 978,
        "piv": 982,
        "ensp": 8194,
        "emsp": 8195,
        "thinsp": 8201,
        "zwnj": 8204,
        "zwj": 8205,
        "lrm": 8206,
        "rlm": 8207,
        "ndash": 8211,
        "mdash": 8212,
        "lsquo": 8216,
        "rsquo": 8217,
        "sbquo": 8218,
        "ldquo": 8220,
        "rdquo": 8221,
        "bdquo": 8222,
        "dagger": 8224,
        "Dagger": 8225,
        "bull": 8226,
        "hellip": 8230,
        "permil": 8240,
        "prime": 8242,
        "Prime": 8243,
        "lsaquo": 8249,
        "rsaquo": 8250,
        "oline": 8254,
        "frasl": 8260,
        "euro": 8364,
        "image": 8465,
        "weierp": 8472,
        "real": 8476,
        "trade": 8482,
        "alefsym": 8501,
        "larr": 8592,
        "uarr": 8593,
        "rarr": 8594,
        "darr": 8595,
        "harr": 8596,
        "crarr": 8629,
        "lArr": 8656,
        "uArr": 8657,
        "rArr": 8658,
        "dArr": 8659,
        "hArr": 8660,
        "forall": 8704,
        "part": 8706,
        "exist": 8707,
        "empty": 8709,
        "nabla": 8711,
        "isin": 8712,
        "notin": 8713,
        "ni": 8715,
        "prod": 8719,
        "sum": 8721,
        "minus": 8722,
        "lowast": 8727,
        "radic": 8730,
        "prop": 8733,
        "infin": 8734,
        "ang": 8736,
        "and": 8743,
        "or": 8744,
        "cap": 8745,
        "cup": 8746,
        "int": 8747,
        "there4": 8756,
        "sim": 8764,
        "cong": 8773,
        "asymp": 8776,
        "ne": 8800,
        "equiv": 8801,
        "le": 8804,
        "ge": 8805,
        "sub": 8834,
        "sup": 8835,
        "nsub": 8836,
        "sube": 8838,
        "supe": 8839,
        "oplus": 8853,
        "otimes": 8855,
        "perp": 8869,
        "sdot": 8901,
        "lceil": 8968,
        "rceil": 8969,
        "lfloor": 8970,
        "rfloor": 8971,
        "lang": 9001,
        "rang": 9002,
        "loz": 9674,
        "spades": 9824,
        "clubs": 9827,
        "hearts": 9829,
        "diams": 9830
      };
      Object.keys(sax.ENTITIES).forEach(function(key2) {
        var e2 = sax.ENTITIES[key2];
        var s3 = typeof e2 === "number" ? String.fromCharCode(e2) : e2;
        sax.ENTITIES[key2] = s3;
      });
      for (var s2 in sax.STATE) {
        sax.STATE[sax.STATE[s2]] = s2;
      }
      S2 = sax.STATE;
      function emit4(parser, event, data) {
        parser[event] && parser[event](data);
      }
      function emitNode(parser, nodeType, data) {
        if (parser.textNode)
          closeText(parser);
        emit4(parser, nodeType, data);
      }
      function closeText(parser) {
        parser.textNode = textopts(parser.opt, parser.textNode);
        if (parser.textNode)
          emit4(parser, "ontext", parser.textNode);
        parser.textNode = "";
      }
      function textopts(opt, text8) {
        if (opt.trim)
          text8 = text8.trim();
        if (opt.normalize)
          text8 = text8.replace(/\s+/g, " ");
        return text8;
      }
      function error3(parser, er) {
        closeText(parser);
        if (parser.trackPosition) {
          er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
        }
        er = new Error(er);
        parser.error = er;
        emit4(parser, "onerror", er);
        return parser;
      }
      function end(parser) {
        if (parser.sawRoot && !parser.closedRoot)
          strictFail(parser, "Unclosed root tag");
        if (parser.state !== S2.BEGIN && parser.state !== S2.BEGIN_WHITESPACE && parser.state !== S2.TEXT) {
          error3(parser, "Unexpected end");
        }
        closeText(parser);
        parser.c = "";
        parser.closed = true;
        emit4(parser, "onend");
        SAXParser.call(parser, parser.strict, parser.opt);
        return parser;
      }
      function strictFail(parser, message2) {
        if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
          throw new Error("bad call to strictFail");
        }
        if (parser.strict) {
          error3(parser, message2);
        }
      }
      function newTag(parser) {
        if (!parser.strict)
          parser.tagName = parser.tagName[parser.looseCase]();
        var parent = parser.tags[parser.tags.length - 1] || parser;
        var tag2 = parser.tag = { name: parser.tagName, attributes: {} };
        if (parser.opt.xmlns) {
          tag2.ns = parent.ns;
        }
        parser.attribList.length = 0;
        emitNode(parser, "onopentagstart", tag2);
      }
      function qname(name, attribute) {
        var i2 = name.indexOf(":");
        var qualName = i2 < 0 ? ["", name] : name.split(":");
        var prefix = qualName[0];
        var local = qualName[1];
        if (attribute && name === "xmlns") {
          prefix = "xmlns";
          local = "";
        }
        return { prefix, local };
      }
      function attrib(parser) {
        if (!parser.strict) {
          parser.attribName = parser.attribName[parser.looseCase]();
        }
        if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
          parser.attribName = parser.attribValue = "";
          return;
        }
        if (parser.opt.xmlns) {
          var qn = qname(parser.attribName, true);
          var prefix = qn.prefix;
          var local = qn.local;
          if (prefix === "xmlns") {
            if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
              strictFail(
                parser,
                "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
              strictFail(
                parser,
                "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else {
              var tag2 = parser.tag;
              var parent = parser.tags[parser.tags.length - 1] || parser;
              if (tag2.ns === parent.ns) {
                tag2.ns = Object.create(parent.ns);
              }
              tag2.ns[local] = parser.attribValue;
            }
          }
          parser.attribList.push([parser.attribName, parser.attribValue]);
        } else {
          parser.tag.attributes[parser.attribName] = parser.attribValue;
          emitNode(parser, "onattribute", {
            name: parser.attribName,
            value: parser.attribValue
          });
        }
        parser.attribName = parser.attribValue = "";
      }
      function openTag(parser, selfClosing) {
        if (parser.opt.xmlns) {
          var tag2 = parser.tag;
          var qn = qname(parser.tagName);
          tag2.prefix = qn.prefix;
          tag2.local = qn.local;
          tag2.uri = tag2.ns[qn.prefix] || "";
          if (tag2.prefix && !tag2.uri) {
            strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
            tag2.uri = qn.prefix;
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (tag2.ns && parent.ns !== tag2.ns) {
            Object.keys(tag2.ns).forEach(function(p3) {
              emitNode(parser, "onopennamespace", {
                prefix: p3,
                uri: tag2.ns[p3]
              });
            });
          }
          for (var i2 = 0, l2 = parser.attribList.length; i2 < l2; i2++) {
            var nv = parser.attribList[i2];
            var name = nv[0];
            var value = nv[1];
            var qualName = qname(name, true);
            var prefix = qualName.prefix;
            var local = qualName.local;
            var uri2 = prefix === "" ? "" : tag2.ns[prefix] || "";
            var a2 = {
              name,
              value,
              prefix,
              local,
              uri: uri2
            };
            if (prefix && prefix !== "xmlns" && !uri2) {
              strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
              a2.uri = prefix;
            }
            parser.tag.attributes[name] = a2;
            emitNode(parser, "onattribute", a2);
          }
          parser.attribList.length = 0;
        }
        parser.tag.isSelfClosing = !!selfClosing;
        parser.sawRoot = true;
        parser.tags.push(parser.tag);
        emitNode(parser, "onopentag", parser.tag);
        if (!selfClosing) {
          if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
            parser.state = S2.SCRIPT;
          } else {
            parser.state = S2.TEXT;
          }
          parser.tag = null;
          parser.tagName = "";
        }
        parser.attribName = parser.attribValue = "";
        parser.attribList.length = 0;
      }
      function closeTag(parser) {
        if (!parser.tagName) {
          strictFail(parser, "Weird empty close tag.");
          parser.textNode += "</>";
          parser.state = S2.TEXT;
          return;
        }
        if (parser.script) {
          if (parser.tagName !== "script") {
            parser.script += "</" + parser.tagName + ">";
            parser.tagName = "";
            parser.state = S2.SCRIPT;
            return;
          }
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
        var t3 = parser.tags.length;
        var tagName = parser.tagName;
        if (!parser.strict) {
          tagName = tagName[parser.looseCase]();
        }
        var closeTo = tagName;
        while (t3--) {
          var close = parser.tags[t3];
          if (close.name !== closeTo) {
            strictFail(parser, "Unexpected close tag");
          } else {
            break;
          }
        }
        if (t3 < 0) {
          strictFail(parser, "Unmatched closing tag: " + parser.tagName);
          parser.textNode += "</" + parser.tagName + ">";
          parser.state = S2.TEXT;
          return;
        }
        parser.tagName = tagName;
        var s3 = parser.tags.length;
        while (s3-- > t3) {
          var tag2 = parser.tag = parser.tags.pop();
          parser.tagName = parser.tag.name;
          emitNode(parser, "onclosetag", parser.tagName);
          var x2 = {};
          for (var i2 in tag2.ns) {
            x2[i2] = tag2.ns[i2];
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (parser.opt.xmlns && tag2.ns !== parent.ns) {
            Object.keys(tag2.ns).forEach(function(p3) {
              var n2 = tag2.ns[p3];
              emitNode(parser, "onclosenamespace", { prefix: p3, uri: n2 });
            });
          }
        }
        if (t3 === 0)
          parser.closedRoot = true;
        parser.tagName = parser.attribValue = parser.attribName = "";
        parser.attribList.length = 0;
        parser.state = S2.TEXT;
      }
      function parseEntity(parser) {
        var entity = parser.entity;
        var entityLC = entity.toLowerCase();
        var num;
        var numStr = "";
        if (parser.ENTITIES[entity]) {
          return parser.ENTITIES[entity];
        }
        if (parser.ENTITIES[entityLC]) {
          return parser.ENTITIES[entityLC];
        }
        entity = entityLC;
        if (entity.charAt(0) === "#") {
          if (entity.charAt(1) === "x") {
            entity = entity.slice(2);
            num = parseInt(entity, 16);
            numStr = num.toString(16);
          } else {
            entity = entity.slice(1);
            num = parseInt(entity, 10);
            numStr = num.toString(10);
          }
        }
        entity = entity.replace(/^0+/, "");
        if (isNaN(num) || numStr.toLowerCase() !== entity) {
          strictFail(parser, "Invalid character entity");
          return "&" + parser.entity + ";";
        }
        return String.fromCodePoint(num);
      }
      function beginWhiteSpace(parser, c2) {
        if (c2 === "<") {
          parser.state = S2.OPEN_WAKA;
          parser.startTagPosition = parser.position;
        } else if (!isWhitespace(c2)) {
          strictFail(parser, "Non-whitespace before first tag.");
          parser.textNode = c2;
          parser.state = S2.TEXT;
        }
      }
      function charAt(chunk, i2) {
        var result = "";
        if (i2 < chunk.length) {
          result = chunk.charAt(i2);
        }
        return result;
      }
      function write4(chunk) {
        var parser = this;
        if (this.error) {
          throw this.error;
        }
        if (parser.closed) {
          return error3(
            parser,
            "Cannot write after close. Assign an onready handler."
          );
        }
        if (chunk === null) {
          return end(parser);
        }
        if (typeof chunk === "object") {
          chunk = chunk.toString();
        }
        var i2 = 0;
        var c2 = "";
        while (true) {
          c2 = charAt(chunk, i2++);
          parser.c = c2;
          if (!c2) {
            break;
          }
          if (parser.trackPosition) {
            parser.position++;
            if (c2 === "\n") {
              parser.line++;
              parser.column = 0;
            } else {
              parser.column++;
            }
          }
          switch (parser.state) {
            case S2.BEGIN:
              parser.state = S2.BEGIN_WHITESPACE;
              if (c2 === "\uFEFF") {
                continue;
              }
              beginWhiteSpace(parser, c2);
              continue;
            case S2.BEGIN_WHITESPACE:
              beginWhiteSpace(parser, c2);
              continue;
            case S2.TEXT:
              if (parser.sawRoot && !parser.closedRoot) {
                var starti = i2 - 1;
                while (c2 && c2 !== "<" && c2 !== "&") {
                  c2 = charAt(chunk, i2++);
                  if (c2 && parser.trackPosition) {
                    parser.position++;
                    if (c2 === "\n") {
                      parser.line++;
                      parser.column = 0;
                    } else {
                      parser.column++;
                    }
                  }
                }
                parser.textNode += chunk.substring(starti, i2 - 1);
              }
              if (c2 === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                parser.state = S2.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else {
                if (!isWhitespace(c2) && (!parser.sawRoot || parser.closedRoot)) {
                  strictFail(parser, "Text data outside of root node.");
                }
                if (c2 === "&") {
                  parser.state = S2.TEXT_ENTITY;
                } else {
                  parser.textNode += c2;
                }
              }
              continue;
            case S2.SCRIPT:
              if (c2 === "<") {
                parser.state = S2.SCRIPT_ENDING;
              } else {
                parser.script += c2;
              }
              continue;
            case S2.SCRIPT_ENDING:
              if (c2 === "/") {
                parser.state = S2.CLOSE_TAG;
              } else {
                parser.script += "<" + c2;
                parser.state = S2.SCRIPT;
              }
              continue;
            case S2.OPEN_WAKA:
              if (c2 === "!") {
                parser.state = S2.SGML_DECL;
                parser.sgmlDecl = "";
              } else if (isWhitespace(c2)) {
              } else if (isMatch(nameStart, c2)) {
                parser.state = S2.OPEN_TAG;
                parser.tagName = c2;
              } else if (c2 === "/") {
                parser.state = S2.CLOSE_TAG;
                parser.tagName = "";
              } else if (c2 === "?") {
                parser.state = S2.PROC_INST;
                parser.procInstName = parser.procInstBody = "";
              } else {
                strictFail(parser, "Unencoded <");
                if (parser.startTagPosition + 1 < parser.position) {
                  var pad = parser.position - parser.startTagPosition;
                  c2 = new Array(pad).join(" ") + c2;
                }
                parser.textNode += "<" + c2;
                parser.state = S2.TEXT;
              }
              continue;
            case S2.SGML_DECL:
              if (parser.sgmlDecl + c2 === "--") {
                parser.state = S2.COMMENT;
                parser.comment = "";
                parser.sgmlDecl = "";
                continue;
              }
              if (parser.doctype && parser.doctype !== true && parser.sgmlDecl) {
                parser.state = S2.DOCTYPE_DTD;
                parser.doctype += "<!" + parser.sgmlDecl + c2;
                parser.sgmlDecl = "";
              } else if ((parser.sgmlDecl + c2).toUpperCase() === CDATA) {
                emitNode(parser, "onopencdata");
                parser.state = S2.CDATA;
                parser.sgmlDecl = "";
                parser.cdata = "";
              } else if ((parser.sgmlDecl + c2).toUpperCase() === DOCTYPE) {
                parser.state = S2.DOCTYPE;
                if (parser.doctype || parser.sawRoot) {
                  strictFail(
                    parser,
                    "Inappropriately located doctype declaration"
                  );
                }
                parser.doctype = "";
                parser.sgmlDecl = "";
              } else if (c2 === ">") {
                emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                parser.sgmlDecl = "";
                parser.state = S2.TEXT;
              } else if (isQuote(c2)) {
                parser.state = S2.SGML_DECL_QUOTED;
                parser.sgmlDecl += c2;
              } else {
                parser.sgmlDecl += c2;
              }
              continue;
            case S2.SGML_DECL_QUOTED:
              if (c2 === parser.q) {
                parser.state = S2.SGML_DECL;
                parser.q = "";
              }
              parser.sgmlDecl += c2;
              continue;
            case S2.DOCTYPE:
              if (c2 === ">") {
                parser.state = S2.TEXT;
                emitNode(parser, "ondoctype", parser.doctype);
                parser.doctype = true;
              } else {
                parser.doctype += c2;
                if (c2 === "[") {
                  parser.state = S2.DOCTYPE_DTD;
                } else if (isQuote(c2)) {
                  parser.state = S2.DOCTYPE_QUOTED;
                  parser.q = c2;
                }
              }
              continue;
            case S2.DOCTYPE_QUOTED:
              parser.doctype += c2;
              if (c2 === parser.q) {
                parser.q = "";
                parser.state = S2.DOCTYPE;
              }
              continue;
            case S2.DOCTYPE_DTD:
              if (c2 === "]") {
                parser.doctype += c2;
                parser.state = S2.DOCTYPE;
              } else if (c2 === "<") {
                parser.state = S2.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else if (isQuote(c2)) {
                parser.doctype += c2;
                parser.state = S2.DOCTYPE_DTD_QUOTED;
                parser.q = c2;
              } else {
                parser.doctype += c2;
              }
              continue;
            case S2.DOCTYPE_DTD_QUOTED:
              parser.doctype += c2;
              if (c2 === parser.q) {
                parser.state = S2.DOCTYPE_DTD;
                parser.q = "";
              }
              continue;
            case S2.COMMENT:
              if (c2 === "-") {
                parser.state = S2.COMMENT_ENDING;
              } else {
                parser.comment += c2;
              }
              continue;
            case S2.COMMENT_ENDING:
              if (c2 === "-") {
                parser.state = S2.COMMENT_ENDED;
                parser.comment = textopts(parser.opt, parser.comment);
                if (parser.comment) {
                  emitNode(parser, "oncomment", parser.comment);
                }
                parser.comment = "";
              } else {
                parser.comment += "-" + c2;
                parser.state = S2.COMMENT;
              }
              continue;
            case S2.COMMENT_ENDED:
              if (c2 !== ">") {
                strictFail(parser, "Malformed comment");
                parser.comment += "--" + c2;
                parser.state = S2.COMMENT;
              } else if (parser.doctype && parser.doctype !== true) {
                parser.state = S2.DOCTYPE_DTD;
              } else {
                parser.state = S2.TEXT;
              }
              continue;
            case S2.CDATA:
              if (c2 === "]") {
                parser.state = S2.CDATA_ENDING;
              } else {
                parser.cdata += c2;
              }
              continue;
            case S2.CDATA_ENDING:
              if (c2 === "]") {
                parser.state = S2.CDATA_ENDING_2;
              } else {
                parser.cdata += "]" + c2;
                parser.state = S2.CDATA;
              }
              continue;
            case S2.CDATA_ENDING_2:
              if (c2 === ">") {
                if (parser.cdata) {
                  emitNode(parser, "oncdata", parser.cdata);
                }
                emitNode(parser, "onclosecdata");
                parser.cdata = "";
                parser.state = S2.TEXT;
              } else if (c2 === "]") {
                parser.cdata += "]";
              } else {
                parser.cdata += "]]" + c2;
                parser.state = S2.CDATA;
              }
              continue;
            case S2.PROC_INST:
              if (c2 === "?") {
                parser.state = S2.PROC_INST_ENDING;
              } else if (isWhitespace(c2)) {
                parser.state = S2.PROC_INST_BODY;
              } else {
                parser.procInstName += c2;
              }
              continue;
            case S2.PROC_INST_BODY:
              if (!parser.procInstBody && isWhitespace(c2)) {
                continue;
              } else if (c2 === "?") {
                parser.state = S2.PROC_INST_ENDING;
              } else {
                parser.procInstBody += c2;
              }
              continue;
            case S2.PROC_INST_ENDING:
              if (c2 === ">") {
                emitNode(parser, "onprocessinginstruction", {
                  name: parser.procInstName,
                  body: parser.procInstBody
                });
                parser.procInstName = parser.procInstBody = "";
                parser.state = S2.TEXT;
              } else {
                parser.procInstBody += "?" + c2;
                parser.state = S2.PROC_INST_BODY;
              }
              continue;
            case S2.OPEN_TAG:
              if (isMatch(nameBody, c2)) {
                parser.tagName += c2;
              } else {
                newTag(parser);
                if (c2 === ">") {
                  openTag(parser);
                } else if (c2 === "/") {
                  parser.state = S2.OPEN_TAG_SLASH;
                } else {
                  if (!isWhitespace(c2)) {
                    strictFail(parser, "Invalid character in tag name");
                  }
                  parser.state = S2.ATTRIB;
                }
              }
              continue;
            case S2.OPEN_TAG_SLASH:
              if (c2 === ">") {
                openTag(parser, true);
                closeTag(parser);
              } else {
                strictFail(parser, "Forward-slash in opening tag not followed by >");
                parser.state = S2.ATTRIB;
              }
              continue;
            case S2.ATTRIB:
              if (isWhitespace(c2)) {
                continue;
              } else if (c2 === ">") {
                openTag(parser);
              } else if (c2 === "/") {
                parser.state = S2.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c2)) {
                parser.attribName = c2;
                parser.attribValue = "";
                parser.state = S2.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S2.ATTRIB_NAME:
              if (c2 === "=") {
                parser.state = S2.ATTRIB_VALUE;
              } else if (c2 === ">") {
                strictFail(parser, "Attribute without value");
                parser.attribValue = parser.attribName;
                attrib(parser);
                openTag(parser);
              } else if (isWhitespace(c2)) {
                parser.state = S2.ATTRIB_NAME_SAW_WHITE;
              } else if (isMatch(nameBody, c2)) {
                parser.attribName += c2;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S2.ATTRIB_NAME_SAW_WHITE:
              if (c2 === "=") {
                parser.state = S2.ATTRIB_VALUE;
              } else if (isWhitespace(c2)) {
                continue;
              } else {
                strictFail(parser, "Attribute without value");
                parser.tag.attributes[parser.attribName] = "";
                parser.attribValue = "";
                emitNode(parser, "onattribute", {
                  name: parser.attribName,
                  value: ""
                });
                parser.attribName = "";
                if (c2 === ">") {
                  openTag(parser);
                } else if (isMatch(nameStart, c2)) {
                  parser.attribName = c2;
                  parser.state = S2.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                  parser.state = S2.ATTRIB;
                }
              }
              continue;
            case S2.ATTRIB_VALUE:
              if (isWhitespace(c2)) {
                continue;
              } else if (isQuote(c2)) {
                parser.q = c2;
                parser.state = S2.ATTRIB_VALUE_QUOTED;
              } else {
                if (!parser.opt.unquotedAttributeValues) {
                  error3(parser, "Unquoted attribute value");
                }
                parser.state = S2.ATTRIB_VALUE_UNQUOTED;
                parser.attribValue = c2;
              }
              continue;
            case S2.ATTRIB_VALUE_QUOTED:
              if (c2 !== parser.q) {
                if (c2 === "&") {
                  parser.state = S2.ATTRIB_VALUE_ENTITY_Q;
                } else {
                  parser.attribValue += c2;
                }
                continue;
              }
              attrib(parser);
              parser.q = "";
              parser.state = S2.ATTRIB_VALUE_CLOSED;
              continue;
            case S2.ATTRIB_VALUE_CLOSED:
              if (isWhitespace(c2)) {
                parser.state = S2.ATTRIB;
              } else if (c2 === ">") {
                openTag(parser);
              } else if (c2 === "/") {
                parser.state = S2.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c2)) {
                strictFail(parser, "No whitespace between attributes");
                parser.attribName = c2;
                parser.attribValue = "";
                parser.state = S2.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S2.ATTRIB_VALUE_UNQUOTED:
              if (!isAttribEnd(c2)) {
                if (c2 === "&") {
                  parser.state = S2.ATTRIB_VALUE_ENTITY_U;
                } else {
                  parser.attribValue += c2;
                }
                continue;
              }
              attrib(parser);
              if (c2 === ">") {
                openTag(parser);
              } else {
                parser.state = S2.ATTRIB;
              }
              continue;
            case S2.CLOSE_TAG:
              if (!parser.tagName) {
                if (isWhitespace(c2)) {
                  continue;
                } else if (notMatch(nameStart, c2)) {
                  if (parser.script) {
                    parser.script += "</" + c2;
                    parser.state = S2.SCRIPT;
                  } else {
                    strictFail(parser, "Invalid tagname in closing tag.");
                  }
                } else {
                  parser.tagName = c2;
                }
              } else if (c2 === ">") {
                closeTag(parser);
              } else if (isMatch(nameBody, c2)) {
                parser.tagName += c2;
              } else if (parser.script) {
                parser.script += "</" + parser.tagName;
                parser.tagName = "";
                parser.state = S2.SCRIPT;
              } else {
                if (!isWhitespace(c2)) {
                  strictFail(parser, "Invalid tagname in closing tag");
                }
                parser.state = S2.CLOSE_TAG_SAW_WHITE;
              }
              continue;
            case S2.CLOSE_TAG_SAW_WHITE:
              if (isWhitespace(c2)) {
                continue;
              }
              if (c2 === ">") {
                closeTag(parser);
              } else {
                strictFail(parser, "Invalid characters in closing tag");
              }
              continue;
            case S2.TEXT_ENTITY:
            case S2.ATTRIB_VALUE_ENTITY_Q:
            case S2.ATTRIB_VALUE_ENTITY_U:
              var returnState;
              var buffer;
              switch (parser.state) {
                case S2.TEXT_ENTITY:
                  returnState = S2.TEXT;
                  buffer = "textNode";
                  break;
                case S2.ATTRIB_VALUE_ENTITY_Q:
                  returnState = S2.ATTRIB_VALUE_QUOTED;
                  buffer = "attribValue";
                  break;
                case S2.ATTRIB_VALUE_ENTITY_U:
                  returnState = S2.ATTRIB_VALUE_UNQUOTED;
                  buffer = "attribValue";
                  break;
              }
              if (c2 === ";") {
                var parsedEntity = parseEntity(parser);
                if (parser.opt.unparsedEntities && !Object.values(sax.XML_ENTITIES).includes(parsedEntity)) {
                  parser.entity = "";
                  parser.state = returnState;
                  parser.write(parsedEntity);
                } else {
                  parser[buffer] += parsedEntity;
                  parser.entity = "";
                  parser.state = returnState;
                }
              } else if (isMatch(parser.entity.length ? entityBody : entityStart, c2)) {
                parser.entity += c2;
              } else {
                strictFail(parser, "Invalid character in entity name");
                parser[buffer] += "&" + parser.entity + c2;
                parser.entity = "";
                parser.state = returnState;
              }
              continue;
            default: {
              throw new Error(parser, "Unknown state: " + parser.state);
            }
          }
        }
        if (parser.position >= parser.bufferCheckPosition) {
          checkBufferLength(parser);
        }
        return parser;
      }
      if (!String.fromCodePoint) {
        (function() {
          var stringFromCharCode2 = String.fromCharCode;
          var floor2 = Math.floor;
          var fromCodePoint = function() {
            var MAX_SIZE = 16384;
            var codeUnits = [];
            var highSurrogate;
            var lowSurrogate;
            var index3 = -1;
            var length = arguments.length;
            if (!length) {
              return "";
            }
            var result = "";
            while (++index3 < length) {
              var codePoint = Number(arguments[index3]);
              if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
              codePoint < 0 || // not a valid Unicode code point
              codePoint > 1114111 || // not a valid Unicode code point
              floor2(codePoint) !== codePoint) {
                throw RangeError("Invalid code point: " + codePoint);
              }
              if (codePoint <= 65535) {
                codeUnits.push(codePoint);
              } else {
                codePoint -= 65536;
                highSurrogate = (codePoint >> 10) + 55296;
                lowSurrogate = codePoint % 1024 + 56320;
                codeUnits.push(highSurrogate, lowSurrogate);
              }
              if (index3 + 1 === length || codeUnits.length > MAX_SIZE) {
                result += stringFromCharCode2.apply(null, codeUnits);
                codeUnits.length = 0;
              }
            }
            return result;
          };
          if (Object.defineProperty) {
            Object.defineProperty(String, "fromCodePoint", {
              value: fromCodePoint,
              configurable: true,
              writable: true
            });
          } else {
            String.fromCodePoint = fromCodePoint;
          }
        })();
      }
    })(typeof exports === "undefined" ? exports.sax = {} : exports);
  }
});

// node_modules/xml-js/lib/array-helper.js
var require_array_helper = __commonJS({
  "node_modules/xml-js/lib/array-helper.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = {
      isArray: function(value) {
        if (Array.isArray) {
          return Array.isArray(value);
        }
        return Object.prototype.toString.call(value) === "[object Array]";
      }
    };
  }
});

// node_modules/xml-js/lib/options-helper.js
var require_options_helper = __commonJS({
  "node_modules/xml-js/lib/options-helper.js"(exports, module) {
    init_process();
    init_buffer();
    var isArray4 = require_array_helper().isArray;
    module.exports = {
      copyOptions: function(options) {
        var key2, copy3 = {};
        for (key2 in options) {
          if (options.hasOwnProperty(key2)) {
            copy3[key2] = options[key2];
          }
        }
        return copy3;
      },
      ensureFlagExists: function(item, options) {
        if (!(item in options) || typeof options[item] !== "boolean") {
          options[item] = false;
        }
      },
      ensureSpacesExists: function(options) {
        if (!("spaces" in options) || typeof options.spaces !== "number" && typeof options.spaces !== "string") {
          options.spaces = 0;
        }
      },
      ensureAlwaysArrayExists: function(options) {
        if (!("alwaysArray" in options) || typeof options.alwaysArray !== "boolean" && !isArray4(options.alwaysArray)) {
          options.alwaysArray = false;
        }
      },
      ensureKeyExists: function(key2, options) {
        if (!(key2 + "Key" in options) || typeof options[key2 + "Key"] !== "string") {
          options[key2 + "Key"] = options.compact ? "_" + key2 : key2;
        }
      },
      checkFnExists: function(key2, options) {
        return key2 + "Fn" in options;
      }
    };
  }
});

// node_modules/xml-js/lib/xml2js.js
var require_xml2js = __commonJS({
  "node_modules/xml-js/lib/xml2js.js"(exports, module) {
    init_process();
    init_buffer();
    var sax = require_sax();
    var expat = { on: function() {
    }, parse: function() {
    } };
    var helper = require_options_helper();
    var isArray4 = require_array_helper().isArray;
    var options;
    var pureJsParser = true;
    var currentElement;
    function validateOptions(userOptions) {
      options = helper.copyOptions(userOptions);
      helper.ensureFlagExists("ignoreDeclaration", options);
      helper.ensureFlagExists("ignoreInstruction", options);
      helper.ensureFlagExists("ignoreAttributes", options);
      helper.ensureFlagExists("ignoreText", options);
      helper.ensureFlagExists("ignoreComment", options);
      helper.ensureFlagExists("ignoreCdata", options);
      helper.ensureFlagExists("ignoreDoctype", options);
      helper.ensureFlagExists("compact", options);
      helper.ensureFlagExists("alwaysChildren", options);
      helper.ensureFlagExists("addParent", options);
      helper.ensureFlagExists("trim", options);
      helper.ensureFlagExists("nativeType", options);
      helper.ensureFlagExists("nativeTypeAttributes", options);
      helper.ensureFlagExists("sanitize", options);
      helper.ensureFlagExists("instructionHasAttributes", options);
      helper.ensureFlagExists("captureSpacesBetweenElements", options);
      helper.ensureAlwaysArrayExists(options);
      helper.ensureKeyExists("declaration", options);
      helper.ensureKeyExists("instruction", options);
      helper.ensureKeyExists("attributes", options);
      helper.ensureKeyExists("text", options);
      helper.ensureKeyExists("comment", options);
      helper.ensureKeyExists("cdata", options);
      helper.ensureKeyExists("doctype", options);
      helper.ensureKeyExists("type", options);
      helper.ensureKeyExists("name", options);
      helper.ensureKeyExists("elements", options);
      helper.ensureKeyExists("parent", options);
      helper.checkFnExists("doctype", options);
      helper.checkFnExists("instruction", options);
      helper.checkFnExists("cdata", options);
      helper.checkFnExists("comment", options);
      helper.checkFnExists("text", options);
      helper.checkFnExists("instructionName", options);
      helper.checkFnExists("elementName", options);
      helper.checkFnExists("attributeName", options);
      helper.checkFnExists("attributeValue", options);
      helper.checkFnExists("attributes", options);
      return options;
    }
    function nativeType(value) {
      var nValue = Number(value);
      if (!isNaN(nValue)) {
        return nValue;
      }
      var bValue = value.toLowerCase();
      if (bValue === "true") {
        return true;
      } else if (bValue === "false") {
        return false;
      }
      return value;
    }
    function addField(type, value) {
      var key2;
      if (options.compact) {
        if (!currentElement[options[type + "Key"]] && (isArray4(options.alwaysArray) ? options.alwaysArray.indexOf(options[type + "Key"]) !== -1 : options.alwaysArray)) {
          currentElement[options[type + "Key"]] = [];
        }
        if (currentElement[options[type + "Key"]] && !isArray4(currentElement[options[type + "Key"]])) {
          currentElement[options[type + "Key"]] = [currentElement[options[type + "Key"]]];
        }
        if (type + "Fn" in options && typeof value === "string") {
          value = options[type + "Fn"](value, currentElement);
        }
        if (type === "instruction" && ("instructionFn" in options || "instructionNameFn" in options)) {
          for (key2 in value) {
            if (value.hasOwnProperty(key2)) {
              if ("instructionFn" in options) {
                value[key2] = options.instructionFn(value[key2], key2, currentElement);
              } else {
                var temp = value[key2];
                delete value[key2];
                value[options.instructionNameFn(key2, temp, currentElement)] = temp;
              }
            }
          }
        }
        if (isArray4(currentElement[options[type + "Key"]])) {
          currentElement[options[type + "Key"]].push(value);
        } else {
          currentElement[options[type + "Key"]] = value;
        }
      } else {
        if (!currentElement[options.elementsKey]) {
          currentElement[options.elementsKey] = [];
        }
        var element2 = {};
        element2[options.typeKey] = type;
        if (type === "instruction") {
          for (key2 in value) {
            if (value.hasOwnProperty(key2)) {
              break;
            }
          }
          element2[options.nameKey] = "instructionNameFn" in options ? options.instructionNameFn(key2, value, currentElement) : key2;
          if (options.instructionHasAttributes) {
            element2[options.attributesKey] = value[key2][options.attributesKey];
            if ("instructionFn" in options) {
              element2[options.attributesKey] = options.instructionFn(element2[options.attributesKey], key2, currentElement);
            }
          } else {
            if ("instructionFn" in options) {
              value[key2] = options.instructionFn(value[key2], key2, currentElement);
            }
            element2[options.instructionKey] = value[key2];
          }
        } else {
          if (type + "Fn" in options) {
            value = options[type + "Fn"](value, currentElement);
          }
          element2[options[type + "Key"]] = value;
        }
        if (options.addParent) {
          element2[options.parentKey] = currentElement;
        }
        currentElement[options.elementsKey].push(element2);
      }
    }
    function manipulateAttributes(attributes) {
      if ("attributesFn" in options && attributes) {
        attributes = options.attributesFn(attributes, currentElement);
      }
      if ((options.trim || "attributeValueFn" in options || "attributeNameFn" in options || options.nativeTypeAttributes) && attributes) {
        var key2;
        for (key2 in attributes) {
          if (attributes.hasOwnProperty(key2)) {
            if (options.trim)
              attributes[key2] = attributes[key2].trim();
            if (options.nativeTypeAttributes) {
              attributes[key2] = nativeType(attributes[key2]);
            }
            if ("attributeValueFn" in options)
              attributes[key2] = options.attributeValueFn(attributes[key2], key2, currentElement);
            if ("attributeNameFn" in options) {
              var temp = attributes[key2];
              delete attributes[key2];
              attributes[options.attributeNameFn(key2, attributes[key2], currentElement)] = temp;
            }
          }
        }
      }
      return attributes;
    }
    function onInstruction(instruction) {
      var attributes = {};
      if (instruction.body && (instruction.name.toLowerCase() === "xml" || options.instructionHasAttributes)) {
        var attrsRegExp = /([\w:-]+)\s*=\s*(?:"([^"]*)"|'([^']*)'|(\w+))\s*/g;
        var match;
        while ((match = attrsRegExp.exec(instruction.body)) !== null) {
          attributes[match[1]] = match[2] || match[3] || match[4];
        }
        attributes = manipulateAttributes(attributes);
      }
      if (instruction.name.toLowerCase() === "xml") {
        if (options.ignoreDeclaration) {
          return;
        }
        currentElement[options.declarationKey] = {};
        if (Object.keys(attributes).length) {
          currentElement[options.declarationKey][options.attributesKey] = attributes;
        }
        if (options.addParent) {
          currentElement[options.declarationKey][options.parentKey] = currentElement;
        }
      } else {
        if (options.ignoreInstruction) {
          return;
        }
        if (options.trim) {
          instruction.body = instruction.body.trim();
        }
        var value = {};
        if (options.instructionHasAttributes && Object.keys(attributes).length) {
          value[instruction.name] = {};
          value[instruction.name][options.attributesKey] = attributes;
        } else {
          value[instruction.name] = instruction.body;
        }
        addField("instruction", value);
      }
    }
    function onStartElement(name, attributes) {
      var element2;
      if (typeof name === "object") {
        attributes = name.attributes;
        name = name.name;
      }
      attributes = manipulateAttributes(attributes);
      if ("elementNameFn" in options) {
        name = options.elementNameFn(name, currentElement);
      }
      if (options.compact) {
        element2 = {};
        if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {
          element2[options.attributesKey] = {};
          var key2;
          for (key2 in attributes) {
            if (attributes.hasOwnProperty(key2)) {
              element2[options.attributesKey][key2] = attributes[key2];
            }
          }
        }
        if (!(name in currentElement) && (isArray4(options.alwaysArray) ? options.alwaysArray.indexOf(name) !== -1 : options.alwaysArray)) {
          currentElement[name] = [];
        }
        if (currentElement[name] && !isArray4(currentElement[name])) {
          currentElement[name] = [currentElement[name]];
        }
        if (isArray4(currentElement[name])) {
          currentElement[name].push(element2);
        } else {
          currentElement[name] = element2;
        }
      } else {
        if (!currentElement[options.elementsKey]) {
          currentElement[options.elementsKey] = [];
        }
        element2 = {};
        element2[options.typeKey] = "element";
        element2[options.nameKey] = name;
        if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {
          element2[options.attributesKey] = attributes;
        }
        if (options.alwaysChildren) {
          element2[options.elementsKey] = [];
        }
        currentElement[options.elementsKey].push(element2);
      }
      element2[options.parentKey] = currentElement;
      currentElement = element2;
    }
    function onText(text8) {
      if (options.ignoreText) {
        return;
      }
      if (!text8.trim() && !options.captureSpacesBetweenElements) {
        return;
      }
      if (options.trim) {
        text8 = text8.trim();
      }
      if (options.nativeType) {
        text8 = nativeType(text8);
      }
      if (options.sanitize) {
        text8 = text8.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
      }
      addField("text", text8);
    }
    function onComment(comment2) {
      if (options.ignoreComment) {
        return;
      }
      if (options.trim) {
        comment2 = comment2.trim();
      }
      addField("comment", comment2);
    }
    function onEndElement(name) {
      var parentElement = currentElement[options.parentKey];
      if (!options.addParent) {
        delete currentElement[options.parentKey];
      }
      currentElement = parentElement;
    }
    function onCdata(cdata) {
      if (options.ignoreCdata) {
        return;
      }
      if (options.trim) {
        cdata = cdata.trim();
      }
      addField("cdata", cdata);
    }
    function onDoctype(doctype2) {
      if (options.ignoreDoctype) {
        return;
      }
      doctype2 = doctype2.replace(/^ /, "");
      if (options.trim) {
        doctype2 = doctype2.trim();
      }
      addField("doctype", doctype2);
    }
    function onError(error3) {
      error3.note = error3;
    }
    module.exports = function(xml2, userOptions) {
      var parser = pureJsParser ? sax.parser(true, {}) : parser = new expat.Parser("UTF-8");
      var result = {};
      currentElement = result;
      options = validateOptions(userOptions);
      if (pureJsParser) {
        parser.opt = { strictEntities: true };
        parser.onopentag = onStartElement;
        parser.ontext = onText;
        parser.oncomment = onComment;
        parser.onclosetag = onEndElement;
        parser.onerror = onError;
        parser.oncdata = onCdata;
        parser.ondoctype = onDoctype;
        parser.onprocessinginstruction = onInstruction;
      } else {
        parser.on("startElement", onStartElement);
        parser.on("text", onText);
        parser.on("comment", onComment);
        parser.on("endElement", onEndElement);
        parser.on("error", onError);
      }
      if (pureJsParser) {
        parser.write(xml2).close();
      } else {
        if (!parser.parse(xml2)) {
          throw new Error("XML parsing error: " + parser.getError());
        }
      }
      if (result[options.elementsKey]) {
        var temp = result[options.elementsKey];
        delete result[options.elementsKey];
        result[options.elementsKey] = temp;
        delete result.text;
      }
      return result;
    };
  }
});

// node_modules/xml-js/lib/xml2json.js
var require_xml2json = __commonJS({
  "node_modules/xml-js/lib/xml2json.js"(exports, module) {
    init_process();
    init_buffer();
    var helper = require_options_helper();
    var xml2js = require_xml2js();
    function validateOptions(userOptions) {
      var options = helper.copyOptions(userOptions);
      helper.ensureSpacesExists(options);
      return options;
    }
    module.exports = function(xml2, userOptions) {
      var options, js, json, parentKey;
      options = validateOptions(userOptions);
      js = xml2js(xml2, options);
      parentKey = "compact" in options && options.compact ? "_parent" : "parent";
      if ("addParent" in options && options.addParent) {
        json = JSON.stringify(js, function(k2, v2) {
          return k2 === parentKey ? "_" : v2;
        }, options.spaces);
      } else {
        json = JSON.stringify(js, null, options.spaces);
      }
      return json.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    };
  }
});

// node_modules/xml-js/lib/js2xml.js
var require_js2xml = __commonJS({
  "node_modules/xml-js/lib/js2xml.js"(exports, module) {
    init_process();
    init_buffer();
    var helper = require_options_helper();
    var isArray4 = require_array_helper().isArray;
    var currentElement;
    var currentElementName;
    function validateOptions(userOptions) {
      var options = helper.copyOptions(userOptions);
      helper.ensureFlagExists("ignoreDeclaration", options);
      helper.ensureFlagExists("ignoreInstruction", options);
      helper.ensureFlagExists("ignoreAttributes", options);
      helper.ensureFlagExists("ignoreText", options);
      helper.ensureFlagExists("ignoreComment", options);
      helper.ensureFlagExists("ignoreCdata", options);
      helper.ensureFlagExists("ignoreDoctype", options);
      helper.ensureFlagExists("compact", options);
      helper.ensureFlagExists("indentText", options);
      helper.ensureFlagExists("indentCdata", options);
      helper.ensureFlagExists("indentAttributes", options);
      helper.ensureFlagExists("indentInstruction", options);
      helper.ensureFlagExists("fullTagEmptyElement", options);
      helper.ensureFlagExists("noQuotesForNativeAttributes", options);
      helper.ensureSpacesExists(options);
      if (typeof options.spaces === "number") {
        options.spaces = Array(options.spaces + 1).join(" ");
      }
      helper.ensureKeyExists("declaration", options);
      helper.ensureKeyExists("instruction", options);
      helper.ensureKeyExists("attributes", options);
      helper.ensureKeyExists("text", options);
      helper.ensureKeyExists("comment", options);
      helper.ensureKeyExists("cdata", options);
      helper.ensureKeyExists("doctype", options);
      helper.ensureKeyExists("type", options);
      helper.ensureKeyExists("name", options);
      helper.ensureKeyExists("elements", options);
      helper.checkFnExists("doctype", options);
      helper.checkFnExists("instruction", options);
      helper.checkFnExists("cdata", options);
      helper.checkFnExists("comment", options);
      helper.checkFnExists("text", options);
      helper.checkFnExists("instructionName", options);
      helper.checkFnExists("elementName", options);
      helper.checkFnExists("attributeName", options);
      helper.checkFnExists("attributeValue", options);
      helper.checkFnExists("attributes", options);
      helper.checkFnExists("fullTagEmptyElement", options);
      return options;
    }
    function writeIndentation(options, depth, firstLine) {
      return (!firstLine && options.spaces ? "\n" : "") + Array(depth + 1).join(options.spaces);
    }
    function writeAttributes(attributes, options, depth) {
      if (options.ignoreAttributes) {
        return "";
      }
      if ("attributesFn" in options) {
        attributes = options.attributesFn(attributes, currentElementName, currentElement);
      }
      var key2, attr, attrName, quote, result = [];
      for (key2 in attributes) {
        if (attributes.hasOwnProperty(key2) && attributes[key2] !== null && attributes[key2] !== void 0) {
          quote = options.noQuotesForNativeAttributes && typeof attributes[key2] !== "string" ? "" : '"';
          attr = "" + attributes[key2];
          attr = attr.replace(/"/g, "&quot;");
          attrName = "attributeNameFn" in options ? options.attributeNameFn(key2, attr, currentElementName, currentElement) : key2;
          result.push(options.spaces && options.indentAttributes ? writeIndentation(options, depth + 1, false) : " ");
          result.push(attrName + "=" + quote + ("attributeValueFn" in options ? options.attributeValueFn(attr, key2, currentElementName, currentElement) : attr) + quote);
        }
      }
      if (attributes && Object.keys(attributes).length && options.spaces && options.indentAttributes) {
        result.push(writeIndentation(options, depth, false));
      }
      return result.join("");
    }
    function writeDeclaration(declaration, options, depth) {
      currentElement = declaration;
      currentElementName = "xml";
      return options.ignoreDeclaration ? "" : "<?xml" + writeAttributes(declaration[options.attributesKey], options, depth) + "?>";
    }
    function writeInstruction(instruction, options, depth) {
      if (options.ignoreInstruction) {
        return "";
      }
      var key2;
      for (key2 in instruction) {
        if (instruction.hasOwnProperty(key2)) {
          break;
        }
      }
      var instructionName = "instructionNameFn" in options ? options.instructionNameFn(key2, instruction[key2], currentElementName, currentElement) : key2;
      if (typeof instruction[key2] === "object") {
        currentElement = instruction;
        currentElementName = instructionName;
        return "<?" + instructionName + writeAttributes(instruction[key2][options.attributesKey], options, depth) + "?>";
      } else {
        var instructionValue = instruction[key2] ? instruction[key2] : "";
        if ("instructionFn" in options)
          instructionValue = options.instructionFn(instructionValue, key2, currentElementName, currentElement);
        return "<?" + instructionName + (instructionValue ? " " + instructionValue : "") + "?>";
      }
    }
    function writeComment(comment2, options) {
      return options.ignoreComment ? "" : "<!--" + ("commentFn" in options ? options.commentFn(comment2, currentElementName, currentElement) : comment2) + "-->";
    }
    function writeCdata(cdata, options) {
      return options.ignoreCdata ? "" : "<![CDATA[" + ("cdataFn" in options ? options.cdataFn(cdata, currentElementName, currentElement) : cdata.replace("]]>", "]]]]><![CDATA[>")) + "]]>";
    }
    function writeDoctype(doctype2, options) {
      return options.ignoreDoctype ? "" : "<!DOCTYPE " + ("doctypeFn" in options ? options.doctypeFn(doctype2, currentElementName, currentElement) : doctype2) + ">";
    }
    function writeText(text8, options) {
      if (options.ignoreText)
        return "";
      text8 = "" + text8;
      text8 = text8.replace(/&amp;/g, "&");
      text8 = text8.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
      return "textFn" in options ? options.textFn(text8, currentElementName, currentElement) : text8;
    }
    function hasContent(element2, options) {
      var i2;
      if (element2.elements && element2.elements.length) {
        for (i2 = 0; i2 < element2.elements.length; ++i2) {
          switch (element2.elements[i2][options.typeKey]) {
            case "text":
              if (options.indentText) {
                return true;
              }
              break;
            case "cdata":
              if (options.indentCdata) {
                return true;
              }
              break;
            case "instruction":
              if (options.indentInstruction) {
                return true;
              }
              break;
            case "doctype":
            case "comment":
            case "element":
              return true;
            default:
              return true;
          }
        }
      }
      return false;
    }
    function writeElement(element2, options, depth) {
      currentElement = element2;
      currentElementName = element2.name;
      var xml2 = [], elementName = "elementNameFn" in options ? options.elementNameFn(element2.name, element2) : element2.name;
      xml2.push("<" + elementName);
      if (element2[options.attributesKey]) {
        xml2.push(writeAttributes(element2[options.attributesKey], options, depth));
      }
      var withClosingTag = element2[options.elementsKey] && element2[options.elementsKey].length || element2[options.attributesKey] && element2[options.attributesKey]["xml:space"] === "preserve";
      if (!withClosingTag) {
        if ("fullTagEmptyElementFn" in options) {
          withClosingTag = options.fullTagEmptyElementFn(element2.name, element2);
        } else {
          withClosingTag = options.fullTagEmptyElement;
        }
      }
      if (withClosingTag) {
        xml2.push(">");
        if (element2[options.elementsKey] && element2[options.elementsKey].length) {
          xml2.push(writeElements(element2[options.elementsKey], options, depth + 1));
          currentElement = element2;
          currentElementName = element2.name;
        }
        xml2.push(options.spaces && hasContent(element2, options) ? "\n" + Array(depth + 1).join(options.spaces) : "");
        xml2.push("</" + elementName + ">");
      } else {
        xml2.push("/>");
      }
      return xml2.join("");
    }
    function writeElements(elements, options, depth, firstLine) {
      return elements.reduce(function(xml2, element2) {
        var indent2 = writeIndentation(options, depth, firstLine && !xml2);
        switch (element2.type) {
          case "element":
            return xml2 + indent2 + writeElement(element2, options, depth);
          case "comment":
            return xml2 + indent2 + writeComment(element2[options.commentKey], options);
          case "doctype":
            return xml2 + indent2 + writeDoctype(element2[options.doctypeKey], options);
          case "cdata":
            return xml2 + (options.indentCdata ? indent2 : "") + writeCdata(element2[options.cdataKey], options);
          case "text":
            return xml2 + (options.indentText ? indent2 : "") + writeText(element2[options.textKey], options);
          case "instruction":
            var instruction = {};
            instruction[element2[options.nameKey]] = element2[options.attributesKey] ? element2 : element2[options.instructionKey];
            return xml2 + (options.indentInstruction ? indent2 : "") + writeInstruction(instruction, options, depth);
        }
      }, "");
    }
    function hasContentCompact(element2, options, anyContent) {
      var key2;
      for (key2 in element2) {
        if (element2.hasOwnProperty(key2)) {
          switch (key2) {
            case options.parentKey:
            case options.attributesKey:
              break;
            case options.textKey:
              if (options.indentText || anyContent) {
                return true;
              }
              break;
            case options.cdataKey:
              if (options.indentCdata || anyContent) {
                return true;
              }
              break;
            case options.instructionKey:
              if (options.indentInstruction || anyContent) {
                return true;
              }
              break;
            case options.doctypeKey:
            case options.commentKey:
              return true;
            default:
              return true;
          }
        }
      }
      return false;
    }
    function writeElementCompact(element2, name, options, depth, indent2) {
      currentElement = element2;
      currentElementName = name;
      var elementName = "elementNameFn" in options ? options.elementNameFn(name, element2) : name;
      if (typeof element2 === "undefined" || element2 === null || element2 === "") {
        return "fullTagEmptyElementFn" in options && options.fullTagEmptyElementFn(name, element2) || options.fullTagEmptyElement ? "<" + elementName + "></" + elementName + ">" : "<" + elementName + "/>";
      }
      var xml2 = [];
      if (name) {
        xml2.push("<" + elementName);
        if (typeof element2 !== "object") {
          xml2.push(">" + writeText(element2, options) + "</" + elementName + ">");
          return xml2.join("");
        }
        if (element2[options.attributesKey]) {
          xml2.push(writeAttributes(element2[options.attributesKey], options, depth));
        }
        var withClosingTag = hasContentCompact(element2, options, true) || element2[options.attributesKey] && element2[options.attributesKey]["xml:space"] === "preserve";
        if (!withClosingTag) {
          if ("fullTagEmptyElementFn" in options) {
            withClosingTag = options.fullTagEmptyElementFn(name, element2);
          } else {
            withClosingTag = options.fullTagEmptyElement;
          }
        }
        if (withClosingTag) {
          xml2.push(">");
        } else {
          xml2.push("/>");
          return xml2.join("");
        }
      }
      xml2.push(writeElementsCompact(element2, options, depth + 1, false));
      currentElement = element2;
      currentElementName = name;
      if (name) {
        xml2.push((indent2 ? writeIndentation(options, depth, false) : "") + "</" + elementName + ">");
      }
      return xml2.join("");
    }
    function writeElementsCompact(element2, options, depth, firstLine) {
      var i2, key2, nodes, xml2 = [];
      for (key2 in element2) {
        if (element2.hasOwnProperty(key2)) {
          nodes = isArray4(element2[key2]) ? element2[key2] : [element2[key2]];
          for (i2 = 0; i2 < nodes.length; ++i2) {
            switch (key2) {
              case options.declarationKey:
                xml2.push(writeDeclaration(nodes[i2], options, depth));
                break;
              case options.instructionKey:
                xml2.push((options.indentInstruction ? writeIndentation(options, depth, firstLine) : "") + writeInstruction(nodes[i2], options, depth));
                break;
              case options.attributesKey:
              case options.parentKey:
                break;
              case options.textKey:
                xml2.push((options.indentText ? writeIndentation(options, depth, firstLine) : "") + writeText(nodes[i2], options));
                break;
              case options.cdataKey:
                xml2.push((options.indentCdata ? writeIndentation(options, depth, firstLine) : "") + writeCdata(nodes[i2], options));
                break;
              case options.doctypeKey:
                xml2.push(writeIndentation(options, depth, firstLine) + writeDoctype(nodes[i2], options));
                break;
              case options.commentKey:
                xml2.push(writeIndentation(options, depth, firstLine) + writeComment(nodes[i2], options));
                break;
              default:
                xml2.push(writeIndentation(options, depth, firstLine) + writeElementCompact(nodes[i2], key2, options, depth, hasContentCompact(nodes[i2], options)));
            }
            firstLine = firstLine && !xml2.length;
          }
        }
      }
      return xml2.join("");
    }
    module.exports = function(js, options) {
      options = validateOptions(options);
      var xml2 = [];
      currentElement = js;
      currentElementName = "_root_";
      if (options.compact) {
        xml2.push(writeElementsCompact(js, options, 0, true));
      } else {
        if (js[options.declarationKey]) {
          xml2.push(writeDeclaration(js[options.declarationKey], options, 0));
        }
        if (js[options.elementsKey] && js[options.elementsKey].length) {
          xml2.push(writeElements(js[options.elementsKey], options, 0, !xml2.length));
        }
      }
      return xml2.join("");
    };
  }
});

// node_modules/xml-js/lib/json2xml.js
var require_json2xml2 = __commonJS({
  "node_modules/xml-js/lib/json2xml.js"(exports, module) {
    init_process();
    init_buffer();
    var js2xml = require_js2xml();
    module.exports = function(json, options) {
      if (json instanceof Buffer2) {
        json = json.toString();
      }
      var js = null;
      if (typeof json === "string") {
        try {
          js = JSON.parse(json);
        } catch (e2) {
          throw new Error("The JSON structure is invalid");
        }
      } else {
        js = json;
      }
      return js2xml(js, options);
    };
  }
});

// node_modules/xml-js/lib/index.js
var require_lib = __commonJS({
  "node_modules/xml-js/lib/index.js"(exports, module) {
    init_process();
    init_buffer();
    var xml2js = require_xml2js();
    var xml2json = require_xml2json();
    var js2xml = require_js2xml();
    var json2xml = require_json2xml2();
    module.exports = {
      xml2js,
      xml2json,
      js2xml,
      json2xml
    };
  }
});

// node_modules/feed/lib/config/index.js
var require_config = __commonJS({
  "node_modules/feed/lib/config/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generator = void 0;
    exports.generator = "https://github.com/jpmonette/feed";
  }
});

// node_modules/feed/lib/utils.js
var require_utils = __commonJS({
  "node_modules/feed/lib/utils.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sanitize = void 0;
    function sanitize(url) {
      if (typeof url === "undefined") {
        return;
      }
      return url.replace(/&/g, "&amp;");
    }
    exports.sanitize = sanitize;
  }
});

// node_modules/feed/lib/atom1.js
var require_atom1 = __commonJS({
  "node_modules/feed/lib/atom1.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var convert2 = require_lib();
    var config_1 = require_config();
    var utils_1 = require_utils();
    exports.default = function(ins) {
      var options = ins.options;
      var base2 = {
        _declaration: { _attributes: { version: "1.0", encoding: "utf-8" } },
        feed: {
          _attributes: { xmlns: "http://www.w3.org/2005/Atom" },
          id: options.id,
          title: options.title,
          updated: options.updated ? options.updated.toISOString() : (/* @__PURE__ */ new Date()).toISOString(),
          generator: utils_1.sanitize(options.generator || config_1.generator)
        }
      };
      if (options.author) {
        base2.feed.author = formatAuthor(options.author);
      }
      base2.feed.link = [];
      if (options.link) {
        base2.feed.link.push({ _attributes: { rel: "alternate", href: utils_1.sanitize(options.link) } });
      }
      var atomLink = utils_1.sanitize(options.feed || options.feedLinks && options.feedLinks.atom);
      if (atomLink) {
        base2.feed.link.push({ _attributes: { rel: "self", href: utils_1.sanitize(atomLink) } });
      }
      if (options.hub) {
        base2.feed.link.push({ _attributes: { rel: "hub", href: utils_1.sanitize(options.hub) } });
      }
      if (options.description) {
        base2.feed.subtitle = options.description;
      }
      if (options.image) {
        base2.feed.logo = options.image;
      }
      if (options.favicon) {
        base2.feed.icon = options.favicon;
      }
      if (options.copyright) {
        base2.feed.rights = options.copyright;
      }
      base2.feed.category = [];
      ins.categories.map(function(category) {
        base2.feed.category.push({ _attributes: { term: category } });
      });
      base2.feed.contributor = [];
      ins.contributors.map(function(contributor) {
        base2.feed.contributor.push(formatAuthor(contributor));
      });
      base2.feed.entry = [];
      ins.items.map(function(item) {
        var entry = {
          title: { _attributes: { type: "html" }, _cdata: item.title },
          id: utils_1.sanitize(item.id || item.link),
          link: [{ _attributes: { href: utils_1.sanitize(item.link) } }],
          updated: item.date.toISOString()
        };
        if (item.description) {
          entry.summary = {
            _attributes: { type: "html" },
            _cdata: item.description
          };
        }
        if (item.content) {
          entry.content = {
            _attributes: { type: "html" },
            _cdata: item.content
          };
        }
        if (Array.isArray(item.author)) {
          entry.author = [];
          item.author.map(function(author) {
            entry.author.push(formatAuthor(author));
          });
        }
        if (Array.isArray(item.category)) {
          entry.category = [];
          item.category.map(function(category) {
            entry.category.push(formatCategory(category));
          });
        }
        if (item.contributor && Array.isArray(item.contributor)) {
          entry.contributor = [];
          item.contributor.map(function(contributor) {
            entry.contributor.push(formatAuthor(contributor));
          });
        }
        if (item.published) {
          entry.published = item.published.toISOString();
        }
        if (item.copyright) {
          entry.rights = item.copyright;
        }
        base2.feed.entry.push(entry);
      });
      return convert2.js2xml(base2, { compact: true, ignoreComment: true, spaces: 4 });
    };
    var formatAuthor = function(author) {
      var name = author.name, email = author.email, link3 = author.link;
      var out = { name };
      if (email) {
        out.email = email;
      }
      if (link3) {
        out.uri = utils_1.sanitize(link3);
      }
      return out;
    };
    var formatCategory = function(category) {
      var name = category.name, scheme = category.scheme, term = category.term;
      return {
        _attributes: {
          label: name,
          scheme,
          term
        }
      };
    };
  }
});

// node_modules/feed/lib/json.js
var require_json2 = __commonJS({
  "node_modules/feed/lib/json.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = function(ins) {
      var options = ins.options, items = ins.items, extensions = ins.extensions;
      var feed = {
        version: "https://jsonfeed.org/version/1",
        title: options.title
      };
      if (options.link) {
        feed.home_page_url = options.link;
      }
      if (options.feedLinks && options.feedLinks.json) {
        feed.feed_url = options.feedLinks.json;
      }
      if (options.description) {
        feed.description = options.description;
      }
      if (options.image) {
        feed.icon = options.image;
      }
      if (options.author) {
        feed.author = {};
        if (options.author.name) {
          feed.author.name = options.author.name;
        }
        if (options.author.link) {
          feed.author.url = options.author.link;
        }
      }
      extensions.map(function(e2) {
        feed[e2.name] = e2.objects;
      });
      feed.items = items.map(function(item) {
        var feedItem = {
          id: item.id,
          content_html: item.content
        };
        if (item.link) {
          feedItem.url = item.link;
        }
        if (item.title) {
          feedItem.title = item.title;
        }
        if (item.description) {
          feedItem.summary = item.description;
        }
        if (item.image) {
          feedItem.image = item.image;
        }
        if (item.date) {
          feedItem.date_modified = item.date.toISOString();
        }
        if (item.published) {
          feedItem.date_published = item.published.toISOString();
        }
        if (item.author) {
          var author = item.author;
          if (author instanceof Array) {
            author = author[0];
          }
          feedItem.author = {};
          if (author.name) {
            feedItem.author.name = author.name;
          }
          if (author.link) {
            feedItem.author.url = author.link;
          }
        }
        if (Array.isArray(item.category)) {
          feedItem.tags = [];
          item.category.map(function(category) {
            if (category.name) {
              feedItem.tags.push(category.name);
            }
          });
        }
        if (item.extensions) {
          item.extensions.map(function(e2) {
            feedItem[e2.name] = e2.objects;
          });
        }
        return feedItem;
      });
      return JSON.stringify(feed, null, 4);
    };
  }
});

// node_modules/feed/lib/rss2.js
var require_rss2 = __commonJS({
  "node_modules/feed/lib/rss2.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __assign2 = exports && exports.__assign || function() {
      __assign2 = Object.assign || function(t3) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p3 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p3))
              t3[p3] = s2[p3];
        }
        return t3;
      };
      return __assign2.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var convert2 = require_lib();
    var config_1 = require_config();
    var utils_1 = require_utils();
    exports.default = function(ins) {
      var options = ins.options;
      var isAtom = false;
      var isContent = false;
      var base2 = {
        _declaration: { _attributes: { version: "1.0", encoding: "utf-8" } },
        rss: {
          _attributes: { version: "2.0" },
          channel: {
            title: { _text: options.title },
            link: { _text: utils_1.sanitize(options.link) },
            description: { _text: options.description },
            lastBuildDate: { _text: options.updated ? options.updated.toUTCString() : (/* @__PURE__ */ new Date()).toUTCString() },
            docs: { _text: options.docs ? options.docs : "https://validator.w3.org/feed/docs/rss2.html" },
            generator: { _text: options.generator || config_1.generator }
          }
        }
      };
      if (options.language) {
        base2.rss.channel.language = { _text: options.language };
      }
      if (options.ttl) {
        base2.rss.channel.ttl = { _text: options.ttl };
      }
      if (options.image) {
        base2.rss.channel.image = {
          title: { _text: options.title },
          url: { _text: options.image },
          link: { _text: utils_1.sanitize(options.link) }
        };
      }
      if (options.copyright) {
        base2.rss.channel.copyright = { _text: options.copyright };
      }
      ins.categories.map(function(category) {
        if (!base2.rss.channel.category) {
          base2.rss.channel.category = [];
        }
        base2.rss.channel.category.push({ _text: category });
      });
      var atomLink = options.feed || options.feedLinks && options.feedLinks.rss;
      if (atomLink) {
        isAtom = true;
        base2.rss.channel["atom:link"] = [
          {
            _attributes: {
              href: utils_1.sanitize(atomLink),
              rel: "self",
              type: "application/rss+xml"
            }
          }
        ];
      }
      if (options.hub) {
        isAtom = true;
        if (!base2.rss.channel["atom:link"]) {
          base2.rss.channel["atom:link"] = [];
        }
        base2.rss.channel["atom:link"] = {
          _attributes: {
            href: utils_1.sanitize(options.hub),
            rel: "hub"
          }
        };
      }
      base2.rss.channel.item = [];
      ins.items.map(function(entry) {
        var item = {};
        if (entry.title) {
          item.title = { _cdata: entry.title };
        }
        if (entry.link) {
          item.link = { _text: utils_1.sanitize(entry.link) };
        }
        if (entry.guid) {
          item.guid = { _text: entry.guid };
        } else if (entry.id) {
          item.guid = { _text: entry.id };
        } else if (entry.link) {
          item.guid = { _text: utils_1.sanitize(entry.link) };
        }
        if (entry.date) {
          item.pubDate = { _text: entry.date.toUTCString() };
        }
        if (entry.published) {
          item.pubDate = { _text: entry.published.toUTCString() };
        }
        if (entry.description) {
          item.description = { _cdata: entry.description };
        }
        if (entry.content) {
          isContent = true;
          item["content:encoded"] = { _cdata: entry.content };
        }
        if (Array.isArray(entry.author)) {
          item.author = [];
          entry.author.map(function(author) {
            if (author.email && author.name) {
              item.author.push({ _text: author.email + " (" + author.name + ")" });
            }
          });
        }
        if (Array.isArray(entry.category)) {
          item.category = [];
          entry.category.map(function(category) {
            item.category.push(formatCategory(category));
          });
        }
        if (entry.enclosure) {
          item.enclosure = formatEnclosure(entry.enclosure);
        }
        if (entry.image) {
          item.enclosure = formatEnclosure(entry.image, "image");
        }
        if (entry.audio) {
          item.enclosure = formatEnclosure(entry.audio, "audio");
        }
        if (entry.video) {
          item.enclosure = formatEnclosure(entry.video, "video");
        }
        base2.rss.channel.item.push(item);
      });
      if (isContent) {
        base2.rss._attributes["xmlns:dc"] = "http://purl.org/dc/elements/1.1/";
        base2.rss._attributes["xmlns:content"] = "http://purl.org/rss/1.0/modules/content/";
      }
      if (isAtom) {
        base2.rss._attributes["xmlns:atom"] = "http://www.w3.org/2005/Atom";
      }
      return convert2.js2xml(base2, { compact: true, ignoreComment: true, spaces: 4 });
    };
    var formatEnclosure = function(enclosure, mimeCategory) {
      if (mimeCategory === void 0) {
        mimeCategory = "image";
      }
      if (typeof enclosure === "string") {
        var type_1 = new URL(enclosure).pathname.split(".").slice(-1)[0];
        return { _attributes: { url: enclosure, length: 0, type: mimeCategory + "/" + type_1 } };
      }
      var type = new URL(enclosure.url).pathname.split(".").slice(-1)[0];
      return { _attributes: __assign2({ length: 0, type: mimeCategory + "/" + type }, enclosure) };
    };
    var formatCategory = function(category) {
      var name = category.name, domain3 = category.domain;
      return {
        _text: name,
        _attributes: {
          domain: domain3
        }
      };
    };
  }
});

// node_modules/feed/lib/feed.js
var require_feed = __commonJS({
  "node_modules/feed/lib/feed.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Feed = void 0;
    var atom1_1 = require_atom1();
    var json_1 = require_json2();
    var rss2_1 = require_rss2();
    var Feed2 = function() {
      function Feed3(options) {
        var _this = this;
        this.items = [];
        this.categories = [];
        this.contributors = [];
        this.extensions = [];
        this.addItem = function(item) {
          return _this.items.push(item);
        };
        this.addCategory = function(category) {
          return _this.categories.push(category);
        };
        this.addContributor = function(contributor) {
          return _this.contributors.push(contributor);
        };
        this.addExtension = function(extension2) {
          return _this.extensions.push(extension2);
        };
        this.atom1 = function() {
          return atom1_1.default(_this);
        };
        this.rss2 = function() {
          return rss2_1.default(_this);
        };
        this.json1 = function() {
          return json_1.default(_this);
        };
        this.options = options;
      }
      return Feed3;
    }();
    exports.Feed = Feed2;
  }
});

// node_modules/extend/index.js
var require_extend = __commonJS({
  "node_modules/extend/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var hasOwn = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var defineProperty = Object.defineProperty;
    var gOPD = Object.getOwnPropertyDescriptor;
    var isArray4 = function isArray5(arr) {
      if (typeof Array.isArray === "function") {
        return Array.isArray(arr);
      }
      return toStr.call(arr) === "[object Array]";
    };
    var isPlainObject2 = function isPlainObject3(obj) {
      if (!obj || toStr.call(obj) !== "[object Object]") {
        return false;
      }
      var hasOwnConstructor = hasOwn.call(obj, "constructor");
      var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
      if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
        return false;
      }
      var key2;
      for (key2 in obj) {
      }
      return typeof key2 === "undefined" || hasOwn.call(obj, key2);
    };
    var setProperty = function setProperty2(target, options) {
      if (defineProperty && options.name === "__proto__") {
        defineProperty(target, options.name, {
          enumerable: true,
          configurable: true,
          value: options.newValue,
          writable: true
        });
      } else {
        target[options.name] = options.newValue;
      }
    };
    var getProperty = function getProperty2(obj, name) {
      if (name === "__proto__") {
        if (!hasOwn.call(obj, name)) {
          return void 0;
        } else if (gOPD) {
          return gOPD(obj, name).value;
        }
      }
      return obj[name];
    };
    module.exports = function extend2() {
      var options, name, src, copy3, copyIsArray, clone;
      var target = arguments[0];
      var i2 = 1;
      var length = arguments.length;
      var deep = false;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};
        i2 = 2;
      }
      if (target == null || typeof target !== "object" && typeof target !== "function") {
        target = {};
      }
      for (; i2 < length; ++i2) {
        options = arguments[i2];
        if (options != null) {
          for (name in options) {
            src = getProperty(target, name);
            copy3 = getProperty(options, name);
            if (target !== copy3) {
              if (deep && copy3 && (isPlainObject2(copy3) || (copyIsArray = isArray4(copy3)))) {
                if (copyIsArray) {
                  copyIsArray = false;
                  clone = src && isArray4(src) ? src : [];
                } else {
                  clone = src && isPlainObject2(src) ? src : {};
                }
                setProperty(target, { name, newValue: extend2(deep, clone, copy3) });
              } else if (typeof copy3 !== "undefined") {
                setProperty(target, { name, newValue: copy3 });
              }
            }
          }
        }
      }
      return target;
    };
  }
});

// server/src/_worker.ts
init_process();
init_buffer();

// node_modules/drizzle-orm/d1/driver.js
init_process();
init_buffer();

// node_modules/drizzle-orm/entity.js
init_process();
init_buffer();
var entityKind = Symbol.for("drizzle:entityKind");
var hasOwnEntityKind = Symbol.for("drizzle:hasOwnEntityKind");
function is(value, type) {
  if (!value || typeof value !== "object") {
    return false;
  }
  if (value instanceof type) {
    return true;
  }
  if (!Object.prototype.hasOwnProperty.call(type, entityKind)) {
    throw new Error(
      `Class "${type.name ?? "<unknown>"}" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`
    );
  }
  let cls = value.constructor;
  if (cls) {
    while (cls) {
      if (entityKind in cls && cls[entityKind] === type[entityKind]) {
        return true;
      }
      cls = Object.getPrototypeOf(cls);
    }
  }
  return false;
}

// node_modules/drizzle-orm/logger.js
init_process();
init_buffer();
var _a;
var ConsoleLogWriter = class {
  write(message2) {
    console.log(message2);
  }
};
_a = entityKind;
__publicField(ConsoleLogWriter, _a, "ConsoleLogWriter");
var _a2;
var DefaultLogger = class {
  writer;
  constructor(config3) {
    this.writer = config3?.writer ?? new ConsoleLogWriter();
  }
  logQuery(query, params) {
    const stringifiedParams = params.map((p3) => {
      try {
        return JSON.stringify(p3);
      } catch {
        return String(p3);
      }
    });
    const paramsStr = stringifiedParams.length ? ` -- params: [${stringifiedParams.join(", ")}]` : "";
    this.writer.write(`Query: ${query}${paramsStr}`);
  }
};
_a2 = entityKind;
__publicField(DefaultLogger, _a2, "DefaultLogger");
var _a3;
var NoopLogger = class {
  logQuery() {
  }
};
_a3 = entityKind;
__publicField(NoopLogger, _a3, "NoopLogger");

// node_modules/drizzle-orm/relations.js
init_process();
init_buffer();

// node_modules/drizzle-orm/table.js
init_process();
init_buffer();
var TableName = Symbol.for("drizzle:Name");
var Schema = Symbol.for("drizzle:Schema");
var Columns = Symbol.for("drizzle:Columns");
var OriginalName = Symbol.for("drizzle:OriginalName");
var BaseName = Symbol.for("drizzle:BaseName");
var IsAlias = Symbol.for("drizzle:IsAlias");
var ExtraConfigBuilder = Symbol.for("drizzle:ExtraConfigBuilder");
var IsDrizzleTable = Symbol.for("drizzle:IsDrizzleTable");
var _a4;
var Table = class {
  /**
   * @internal
   * Can be changed if the table is aliased.
   */
  [(_a4 = entityKind, TableName)];
  /**
   * @internal
   * Used to store the original name of the table, before any aliasing.
   */
  [OriginalName];
  /** @internal */
  [Schema];
  /** @internal */
  [Columns];
  /**
   *  @internal
   * Used to store the table name before the transformation via the `tableCreator` functions.
   */
  [BaseName];
  /** @internal */
  [IsAlias] = false;
  /** @internal */
  [ExtraConfigBuilder] = void 0;
  [IsDrizzleTable] = true;
  constructor(name, schema, baseName) {
    this[TableName] = this[OriginalName] = name;
    this[Schema] = schema;
    this[BaseName] = baseName;
  }
};
__publicField(Table, _a4, "Table");
/** @internal */
__publicField(Table, "Symbol", {
  Name: TableName,
  Schema,
  OriginalName,
  Columns,
  BaseName,
  IsAlias,
  ExtraConfigBuilder
});
function isTable(table2) {
  return typeof table2 === "object" && table2 !== null && IsDrizzleTable in table2;
}
function getTableName(table2) {
  return table2[TableName];
}

// node_modules/drizzle-orm/column.js
init_process();
init_buffer();
var _a5;
var Column = class {
  constructor(table2, config3) {
    this.table = table2;
    this.config = config3;
    this.name = config3.name;
    this.notNull = config3.notNull;
    this.default = config3.default;
    this.defaultFn = config3.defaultFn;
    this.onUpdateFn = config3.onUpdateFn;
    this.hasDefault = config3.hasDefault;
    this.primary = config3.primaryKey;
    this.isUnique = config3.isUnique;
    this.uniqueName = config3.uniqueName;
    this.uniqueType = config3.uniqueType;
    this.dataType = config3.dataType;
    this.columnType = config3.columnType;
  }
  name;
  primary;
  notNull;
  default;
  defaultFn;
  onUpdateFn;
  hasDefault;
  isUnique;
  uniqueName;
  uniqueType;
  dataType;
  columnType;
  enumValues = void 0;
  config;
  mapFromDriverValue(value) {
    return value;
  }
  mapToDriverValue(value) {
    return value;
  }
};
_a5 = entityKind;
__publicField(Column, _a5, "Column");

// node_modules/drizzle-orm/pg-core/primary-keys.js
init_process();
init_buffer();

// node_modules/drizzle-orm/pg-core/table.js
init_process();
init_buffer();
var InlineForeignKeys = Symbol.for("drizzle:PgInlineForeignKeys");
var _a6;
var PgTable = class extends Table {
  /**@internal */
  [(_a6 = entityKind, InlineForeignKeys)] = [];
  /** @internal */
  [Table.Symbol.ExtraConfigBuilder] = void 0;
};
__publicField(PgTable, _a6, "PgTable");
/** @internal */
__publicField(PgTable, "Symbol", Object.assign({}, Table.Symbol, {
  InlineForeignKeys
}));

// node_modules/drizzle-orm/pg-core/primary-keys.js
var _a7;
var PrimaryKeyBuilder = class {
  /** @internal */
  columns;
  /** @internal */
  name;
  constructor(columns, name) {
    this.columns = columns;
    this.name = name;
  }
  /** @internal */
  build(table2) {
    return new PrimaryKey(table2, this.columns, this.name);
  }
};
_a7 = entityKind;
__publicField(PrimaryKeyBuilder, _a7, "PgPrimaryKeyBuilder");
var _a8;
var PrimaryKey = class {
  constructor(table2, columns, name) {
    this.table = table2;
    this.columns = columns;
    this.name = name;
  }
  columns;
  name;
  getName() {
    return this.name ?? `${this.table[PgTable.Symbol.Name]}_${this.columns.map((column) => column.name).join("_")}_pk`;
  }
};
_a8 = entityKind;
__publicField(PrimaryKey, _a8, "PgPrimaryKey");

// node_modules/drizzle-orm/sql/expressions/conditions.js
init_process();
init_buffer();

// node_modules/drizzle-orm/sql/sql.js
init_process();
init_buffer();

// node_modules/drizzle-orm/pg-core/columns/enum.js
init_process();
init_buffer();

// node_modules/drizzle-orm/pg-core/columns/common.js
init_process();
init_buffer();

// node_modules/drizzle-orm/column-builder.js
init_process();
init_buffer();
var _a9;
var ColumnBuilder = class {
  config;
  constructor(name, dataType, columnType) {
    this.config = {
      name,
      notNull: false,
      default: void 0,
      hasDefault: false,
      primaryKey: false,
      isUnique: false,
      uniqueName: void 0,
      uniqueType: void 0,
      dataType,
      columnType
    };
  }
  /**
   * Changes the data type of the column. Commonly used with `json` columns. Also, useful for branded types.
   *
   * @example
   * ```ts
   * const users = pgTable('users', {
   * 	id: integer('id').$type<UserId>().primaryKey(),
   * 	details: json('details').$type<UserDetails>().notNull(),
   * });
   * ```
   */
  $type() {
    return this;
  }
  /**
   * Adds a `not null` clause to the column definition.
   *
   * Affects the `select` model of the table - columns *without* `not null` will be nullable on select.
   */
  notNull() {
    this.config.notNull = true;
    return this;
  }
  /**
   * Adds a `default <value>` clause to the column definition.
   *
   * Affects the `insert` model of the table - columns *with* `default` are optional on insert.
   *
   * If you need to set a dynamic default value, use {@link $defaultFn} instead.
   */
  default(value) {
    this.config.default = value;
    this.config.hasDefault = true;
    return this;
  }
  /**
   * Adds a dynamic default value to the column.
   * The function will be called when the row is inserted, and the returned value will be used as the column value.
   *
   * **Note:** This value does not affect the `drizzle-kit` behavior, it is only used at runtime in `drizzle-orm`.
   */
  $defaultFn(fn) {
    this.config.defaultFn = fn;
    this.config.hasDefault = true;
    return this;
  }
  /**
   * Alias for {@link $defaultFn}.
   */
  $default = this.$defaultFn;
  /**
   * Adds a dynamic update value to the column.
   * The function will be called when the row is updated, and the returned value will be used as the column value if none is provided.
   * If no `default` (or `$defaultFn`) value is provided, the function will be called when the row is inserted as well, and the returned value will be used as the column value.
   *
   * **Note:** This value does not affect the `drizzle-kit` behavior, it is only used at runtime in `drizzle-orm`.
   */
  $onUpdateFn(fn) {
    this.config.onUpdateFn = fn;
    this.config.hasDefault = true;
    return this;
  }
  /**
   * Alias for {@link $onUpdateFn}.
   */
  $onUpdate = this.$onUpdateFn;
  /**
   * Adds a `primary key` clause to the column definition. This implicitly makes the column `not null`.
   *
   * In SQLite, `integer primary key` implicitly makes the column auto-incrementing.
   */
  primaryKey() {
    this.config.primaryKey = true;
    this.config.notNull = true;
    return this;
  }
};
_a9 = entityKind;
__publicField(ColumnBuilder, _a9, "ColumnBuilder");

// node_modules/drizzle-orm/pg-core/foreign-keys.js
init_process();
init_buffer();
var _a10;
var ForeignKeyBuilder = class {
  /** @internal */
  reference;
  /** @internal */
  _onUpdate = "no action";
  /** @internal */
  _onDelete = "no action";
  constructor(config3, actions) {
    this.reference = () => {
      const { name, columns, foreignColumns } = config3();
      return { name, columns, foreignTable: foreignColumns[0].table, foreignColumns };
    };
    if (actions) {
      this._onUpdate = actions.onUpdate;
      this._onDelete = actions.onDelete;
    }
  }
  onUpdate(action) {
    this._onUpdate = action === void 0 ? "no action" : action;
    return this;
  }
  onDelete(action) {
    this._onDelete = action === void 0 ? "no action" : action;
    return this;
  }
  /** @internal */
  build(table2) {
    return new ForeignKey(table2, this);
  }
};
_a10 = entityKind;
__publicField(ForeignKeyBuilder, _a10, "PgForeignKeyBuilder");
var _a11;
var ForeignKey = class {
  constructor(table2, builder) {
    this.table = table2;
    this.reference = builder.reference;
    this.onUpdate = builder._onUpdate;
    this.onDelete = builder._onDelete;
  }
  reference;
  onUpdate;
  onDelete;
  getName() {
    const { name, columns, foreignColumns } = this.reference();
    const columnNames = columns.map((column) => column.name);
    const foreignColumnNames = foreignColumns.map((column) => column.name);
    const chunks = [
      this.table[PgTable.Symbol.Name],
      ...columnNames,
      foreignColumns[0].table[PgTable.Symbol.Name],
      ...foreignColumnNames
    ];
    return name ?? `${chunks.join("_")}_fk`;
  }
};
_a11 = entityKind;
__publicField(ForeignKey, _a11, "PgForeignKey");

// node_modules/drizzle-orm/tracing-utils.js
init_process();
init_buffer();
function iife(fn, ...args) {
  return fn(...args);
}

// node_modules/drizzle-orm/pg-core/unique-constraint.js
init_process();
init_buffer();
function uniqueKeyName(table2, columns) {
  return `${table2[PgTable.Symbol.Name]}_${columns.join("_")}_unique`;
}
var _a12;
var UniqueConstraintBuilder = class {
  constructor(columns, name) {
    this.name = name;
    this.columns = columns;
  }
  /** @internal */
  columns;
  /** @internal */
  nullsNotDistinctConfig = false;
  nullsNotDistinct() {
    this.nullsNotDistinctConfig = true;
    return this;
  }
  /** @internal */
  build(table2) {
    return new UniqueConstraint(table2, this.columns, this.nullsNotDistinctConfig, this.name);
  }
};
_a12 = entityKind;
__publicField(UniqueConstraintBuilder, _a12, "PgUniqueConstraintBuilder");
var _a13;
var UniqueOnConstraintBuilder = class {
  /** @internal */
  name;
  constructor(name) {
    this.name = name;
  }
  on(...columns) {
    return new UniqueConstraintBuilder(columns, this.name);
  }
};
_a13 = entityKind;
__publicField(UniqueOnConstraintBuilder, _a13, "PgUniqueOnConstraintBuilder");
var _a14;
var UniqueConstraint = class {
  constructor(table2, columns, nullsNotDistinct, name) {
    this.table = table2;
    this.columns = columns;
    this.name = name ?? uniqueKeyName(this.table, this.columns.map((column) => column.name));
    this.nullsNotDistinct = nullsNotDistinct;
  }
  columns;
  name;
  nullsNotDistinct = false;
  getName() {
    return this.name;
  }
};
_a14 = entityKind;
__publicField(UniqueConstraint, _a14, "PgUniqueConstraint");

// node_modules/drizzle-orm/pg-core/utils/array.js
init_process();
init_buffer();
function parsePgArrayValue(arrayString, startFrom, inQuotes) {
  for (let i2 = startFrom; i2 < arrayString.length; i2++) {
    const char = arrayString[i2];
    if (char === "\\") {
      i2++;
      continue;
    }
    if (char === '"') {
      return [arrayString.slice(startFrom, i2).replace(/\\/g, ""), i2 + 1];
    }
    if (inQuotes) {
      continue;
    }
    if (char === "," || char === "}") {
      return [arrayString.slice(startFrom, i2).replace(/\\/g, ""), i2];
    }
  }
  return [arrayString.slice(startFrom).replace(/\\/g, ""), arrayString.length];
}
function parsePgNestedArray(arrayString, startFrom = 0) {
  const result = [];
  let i2 = startFrom;
  let lastCharIsComma = false;
  while (i2 < arrayString.length) {
    const char = arrayString[i2];
    if (char === ",") {
      if (lastCharIsComma || i2 === startFrom) {
        result.push("");
      }
      lastCharIsComma = true;
      i2++;
      continue;
    }
    lastCharIsComma = false;
    if (char === "\\") {
      i2 += 2;
      continue;
    }
    if (char === '"') {
      const [value2, startFrom2] = parsePgArrayValue(arrayString, i2 + 1, true);
      result.push(value2);
      i2 = startFrom2;
      continue;
    }
    if (char === "}") {
      return [result, i2 + 1];
    }
    if (char === "{") {
      const [value2, startFrom2] = parsePgNestedArray(arrayString, i2 + 1);
      result.push(value2);
      i2 = startFrom2;
      continue;
    }
    const [value, newStartFrom] = parsePgArrayValue(arrayString, i2, false);
    result.push(value);
    i2 = newStartFrom;
  }
  return [result, i2];
}
function parsePgArray(arrayString) {
  const [result] = parsePgNestedArray(arrayString, 1);
  return result;
}
function makePgArray(array) {
  return `{${array.map((item) => {
    if (Array.isArray(item)) {
      return makePgArray(item);
    }
    if (typeof item === "string") {
      return `"${item.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"`;
    }
    return `${item}`;
  }).join(",")}}`;
}

// node_modules/drizzle-orm/pg-core/columns/common.js
var _a15;
var PgColumnBuilder = class extends ColumnBuilder {
  foreignKeyConfigs = [];
  array(size) {
    return new PgArrayBuilder(this.config.name, this, size);
  }
  references(ref, actions = {}) {
    this.foreignKeyConfigs.push({ ref, actions });
    return this;
  }
  unique(name, config3) {
    this.config.isUnique = true;
    this.config.uniqueName = name;
    this.config.uniqueType = config3?.nulls;
    return this;
  }
  /** @internal */
  buildForeignKeys(column, table2) {
    return this.foreignKeyConfigs.map(({ ref, actions }) => {
      return iife(
        (ref2, actions2) => {
          const builder = new ForeignKeyBuilder(() => {
            const foreignColumn = ref2();
            return { columns: [column], foreignColumns: [foreignColumn] };
          });
          if (actions2.onUpdate) {
            builder.onUpdate(actions2.onUpdate);
          }
          if (actions2.onDelete) {
            builder.onDelete(actions2.onDelete);
          }
          return builder.build(table2);
        },
        ref,
        actions
      );
    });
  }
};
_a15 = entityKind;
__publicField(PgColumnBuilder, _a15, "PgColumnBuilder");
var _a16;
var PgColumn = class extends Column {
  constructor(table2, config3) {
    if (!config3.uniqueName) {
      config3.uniqueName = uniqueKeyName(table2, [config3.name]);
    }
    super(table2, config3);
    this.table = table2;
  }
};
_a16 = entityKind;
__publicField(PgColumn, _a16, "PgColumn");
var _a17;
var PgArrayBuilder = class extends PgColumnBuilder {
  constructor(name, baseBuilder, size) {
    super(name, "array", "PgArray");
    this.config.baseBuilder = baseBuilder;
    this.config.size = size;
  }
  /** @internal */
  build(table2) {
    const baseColumn = this.config.baseBuilder.build(table2);
    return new PgArray(
      table2,
      this.config,
      baseColumn
    );
  }
};
_a17 = entityKind;
__publicField(PgArrayBuilder, _a17, "PgArrayBuilder");
var _a18;
var _PgArray = class extends PgColumn {
  constructor(table2, config3, baseColumn, range) {
    super(table2, config3);
    this.baseColumn = baseColumn;
    this.range = range;
    this.size = config3.size;
  }
  size;
  getSQLType() {
    return `${this.baseColumn.getSQLType()}[${typeof this.size === "number" ? this.size : ""}]`;
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      value = parsePgArray(value);
    }
    return value.map((v2) => this.baseColumn.mapFromDriverValue(v2));
  }
  mapToDriverValue(value, isNestedArray = false) {
    const a2 = value.map(
      (v2) => v2 === null ? null : is(this.baseColumn, _PgArray) ? this.baseColumn.mapToDriverValue(v2, true) : this.baseColumn.mapToDriverValue(v2)
    );
    if (isNestedArray)
      return a2;
    return makePgArray(a2);
  }
};
var PgArray = _PgArray;
_a18 = entityKind;
__publicField(PgArray, _a18, "PgArray");

// node_modules/drizzle-orm/pg-core/columns/enum.js
var isPgEnumSym = Symbol.for("drizzle:isPgEnum");
function isPgEnum(obj) {
  return !!obj && typeof obj === "function" && isPgEnumSym in obj && obj[isPgEnumSym] === true;
}
var _a19;
var PgEnumColumnBuilder = class extends PgColumnBuilder {
  constructor(name, enumInstance) {
    super(name, "string", "PgEnumColumn");
    this.config.enum = enumInstance;
  }
  /** @internal */
  build(table2) {
    return new PgEnumColumn(
      table2,
      this.config
    );
  }
};
_a19 = entityKind;
__publicField(PgEnumColumnBuilder, _a19, "PgEnumColumnBuilder");
var _a20;
var PgEnumColumn = class extends PgColumn {
  enum = this.config.enum;
  enumValues = this.config.enum.enumValues;
  constructor(table2, config3) {
    super(table2, config3);
    this.enum = config3.enum;
  }
  getSQLType() {
    return this.enum.enumName;
  }
};
_a20 = entityKind;
__publicField(PgEnumColumn, _a20, "PgEnumColumn");

// node_modules/drizzle-orm/subquery.js
init_process();
init_buffer();
var _a21;
var Subquery = class {
  constructor(sql2, selection, alias, isWith = false) {
    this._ = {
      brand: "Subquery",
      sql: sql2,
      selectedFields: selection,
      alias,
      isWith
    };
  }
  // getSQL(): SQL<unknown> {
  // 	return new SQL([this]);
  // }
};
_a21 = entityKind;
__publicField(Subquery, _a21, "Subquery");
var _a22;
var WithSubquery = class extends Subquery {
};
_a22 = entityKind;
__publicField(WithSubquery, _a22, "WithSubquery");

// node_modules/drizzle-orm/tracing.js
init_process();
init_buffer();

// node_modules/drizzle-orm/version.js
init_process();
init_buffer();
var version2 = "0.30.10";

// node_modules/drizzle-orm/tracing.js
var otel;
var rawTracer;
var tracer = {
  startActiveSpan(name, fn) {
    if (!otel) {
      return fn();
    }
    if (!rawTracer) {
      rawTracer = otel.trace.getTracer("drizzle-orm", version2);
    }
    return iife(
      (otel2, rawTracer2) => rawTracer2.startActiveSpan(
        name,
        (span) => {
          try {
            return fn(span);
          } catch (e2) {
            span.setStatus({
              code: otel2.SpanStatusCode.ERROR,
              message: e2 instanceof Error ? e2.message : "Unknown error"
              // eslint-disable-line no-instanceof/no-instanceof
            });
            throw e2;
          } finally {
            span.end();
          }
        }
      ),
      otel,
      rawTracer
    );
  }
};

// node_modules/drizzle-orm/view-common.js
init_process();
init_buffer();
var ViewBaseConfig = Symbol.for("drizzle:ViewBaseConfig");

// node_modules/drizzle-orm/sql/sql.js
var _a23;
var FakePrimitiveParam = class {
};
_a23 = entityKind;
__publicField(FakePrimitiveParam, _a23, "FakePrimitiveParam");
function isSQLWrapper(value) {
  return value !== null && value !== void 0 && typeof value.getSQL === "function";
}
function mergeQueries(queries) {
  const result = { sql: "", params: [] };
  for (const query of queries) {
    result.sql += query.sql;
    result.params.push(...query.params);
    if (query.typings?.length) {
      if (!result.typings) {
        result.typings = [];
      }
      result.typings.push(...query.typings);
    }
  }
  return result;
}
var _a24;
var StringChunk = class {
  value;
  constructor(value) {
    this.value = Array.isArray(value) ? value : [value];
  }
  getSQL() {
    return new SQL([this]);
  }
};
_a24 = entityKind;
__publicField(StringChunk, _a24, "StringChunk");
var _a25;
var _SQL = class {
  constructor(queryChunks) {
    this.queryChunks = queryChunks;
  }
  /** @internal */
  decoder = noopDecoder;
  shouldInlineParams = false;
  append(query) {
    this.queryChunks.push(...query.queryChunks);
    return this;
  }
  toQuery(config3) {
    return tracer.startActiveSpan("drizzle.buildSQL", (span) => {
      const query = this.buildQueryFromSourceParams(this.queryChunks, config3);
      span?.setAttributes({
        "drizzle.query.text": query.sql,
        "drizzle.query.params": JSON.stringify(query.params)
      });
      return query;
    });
  }
  buildQueryFromSourceParams(chunks, _config) {
    const config3 = Object.assign({}, _config, {
      inlineParams: _config.inlineParams || this.shouldInlineParams,
      paramStartIndex: _config.paramStartIndex || { value: 0 }
    });
    const {
      escapeName,
      escapeParam,
      prepareTyping,
      inlineParams,
      paramStartIndex
    } = config3;
    return mergeQueries(chunks.map((chunk) => {
      if (is(chunk, StringChunk)) {
        return { sql: chunk.value.join(""), params: [] };
      }
      if (is(chunk, Name)) {
        return { sql: escapeName(chunk.value), params: [] };
      }
      if (chunk === void 0) {
        return { sql: "", params: [] };
      }
      if (Array.isArray(chunk)) {
        const result = [new StringChunk("(")];
        for (const [i2, p3] of chunk.entries()) {
          result.push(p3);
          if (i2 < chunk.length - 1) {
            result.push(new StringChunk(", "));
          }
        }
        result.push(new StringChunk(")"));
        return this.buildQueryFromSourceParams(result, config3);
      }
      if (is(chunk, _SQL)) {
        return this.buildQueryFromSourceParams(chunk.queryChunks, {
          ...config3,
          inlineParams: inlineParams || chunk.shouldInlineParams
        });
      }
      if (is(chunk, Table)) {
        const schemaName = chunk[Table.Symbol.Schema];
        const tableName = chunk[Table.Symbol.Name];
        return {
          sql: schemaName === void 0 ? escapeName(tableName) : escapeName(schemaName) + "." + escapeName(tableName),
          params: []
        };
      }
      if (is(chunk, Column)) {
        return { sql: escapeName(chunk.table[Table.Symbol.Name]) + "." + escapeName(chunk.name), params: [] };
      }
      if (is(chunk, View)) {
        const schemaName = chunk[ViewBaseConfig].schema;
        const viewName = chunk[ViewBaseConfig].name;
        return {
          sql: schemaName === void 0 ? escapeName(viewName) : escapeName(schemaName) + "." + escapeName(viewName),
          params: []
        };
      }
      if (is(chunk, Param)) {
        const mappedValue = chunk.value === null ? null : chunk.encoder.mapToDriverValue(chunk.value);
        if (is(mappedValue, _SQL)) {
          return this.buildQueryFromSourceParams([mappedValue], config3);
        }
        if (inlineParams) {
          return { sql: this.mapInlineParam(mappedValue, config3), params: [] };
        }
        let typings;
        if (prepareTyping !== void 0) {
          typings = [prepareTyping(chunk.encoder)];
        }
        return { sql: escapeParam(paramStartIndex.value++, mappedValue), params: [mappedValue], typings };
      }
      if (is(chunk, Placeholder)) {
        return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk] };
      }
      if (is(chunk, _SQL.Aliased) && chunk.fieldAlias !== void 0) {
        return { sql: escapeName(chunk.fieldAlias), params: [] };
      }
      if (is(chunk, Subquery)) {
        if (chunk._.isWith) {
          return { sql: escapeName(chunk._.alias), params: [] };
        }
        return this.buildQueryFromSourceParams([
          new StringChunk("("),
          chunk._.sql,
          new StringChunk(") "),
          new Name(chunk._.alias)
        ], config3);
      }
      if (isPgEnum(chunk)) {
        if (chunk.schema) {
          return { sql: escapeName(chunk.schema) + "." + escapeName(chunk.enumName), params: [] };
        }
        return { sql: escapeName(chunk.enumName), params: [] };
      }
      if (isSQLWrapper(chunk)) {
        return this.buildQueryFromSourceParams([
          new StringChunk("("),
          chunk.getSQL(),
          new StringChunk(")")
        ], config3);
      }
      if (inlineParams) {
        return { sql: this.mapInlineParam(chunk, config3), params: [] };
      }
      return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk] };
    }));
  }
  mapInlineParam(chunk, { escapeString }) {
    if (chunk === null) {
      return "null";
    }
    if (typeof chunk === "number" || typeof chunk === "boolean") {
      return chunk.toString();
    }
    if (typeof chunk === "string") {
      return escapeString(chunk);
    }
    if (typeof chunk === "object") {
      const mappedValueAsString = chunk.toString();
      if (mappedValueAsString === "[object Object]") {
        return escapeString(JSON.stringify(chunk));
      }
      return escapeString(mappedValueAsString);
    }
    throw new Error("Unexpected param value: " + chunk);
  }
  getSQL() {
    return this;
  }
  as(alias) {
    if (alias === void 0) {
      return this;
    }
    return new _SQL.Aliased(this, alias);
  }
  mapWith(decoder2) {
    this.decoder = typeof decoder2 === "function" ? { mapFromDriverValue: decoder2 } : decoder2;
    return this;
  }
  inlineParams() {
    this.shouldInlineParams = true;
    return this;
  }
  /**
   * This method is used to conditionally include a part of the query.
   *
   * @param condition - Condition to check
   * @returns itself if the condition is `true`, otherwise `undefined`
   */
  if(condition) {
    return condition ? this : void 0;
  }
};
var SQL = _SQL;
_a25 = entityKind;
__publicField(SQL, _a25, "SQL");
var _a26;
var Name = class {
  constructor(value) {
    this.value = value;
  }
  brand;
  getSQL() {
    return new SQL([this]);
  }
};
_a26 = entityKind;
__publicField(Name, _a26, "Name");
function isDriverValueEncoder(value) {
  return typeof value === "object" && value !== null && "mapToDriverValue" in value && typeof value.mapToDriverValue === "function";
}
var noopDecoder = {
  mapFromDriverValue: (value) => value
};
var noopEncoder = {
  mapToDriverValue: (value) => value
};
var noopMapper = {
  ...noopDecoder,
  ...noopEncoder
};
var _a27;
var Param = class {
  /**
   * @param value - Parameter value
   * @param encoder - Encoder to convert the value to a driver parameter
   */
  constructor(value, encoder3 = noopEncoder) {
    this.value = value;
    this.encoder = encoder3;
  }
  brand;
  getSQL() {
    return new SQL([this]);
  }
};
_a27 = entityKind;
__publicField(Param, _a27, "Param");
function sql(strings, ...params) {
  const queryChunks = [];
  if (params.length > 0 || strings.length > 0 && strings[0] !== "") {
    queryChunks.push(new StringChunk(strings[0]));
  }
  for (const [paramIndex, param2] of params.entries()) {
    queryChunks.push(param2, new StringChunk(strings[paramIndex + 1]));
  }
  return new SQL(queryChunks);
}
((sql2) => {
  function empty3() {
    return new SQL([]);
  }
  sql2.empty = empty3;
  function fromList2(list4) {
    return new SQL(list4);
  }
  sql2.fromList = fromList2;
  function raw2(str) {
    return new SQL([new StringChunk(str)]);
  }
  sql2.raw = raw2;
  function join3(chunks, separator) {
    const result = [];
    for (const [i2, chunk] of chunks.entries()) {
      if (i2 > 0 && separator !== void 0) {
        result.push(separator);
      }
      result.push(chunk);
    }
    return new SQL(result);
  }
  sql2.join = join3;
  function identifier(value) {
    return new Name(value);
  }
  sql2.identifier = identifier;
  function placeholder2(name2) {
    return new Placeholder(name2);
  }
  sql2.placeholder = placeholder2;
  function param2(value, encoder3) {
    return new Param(value, encoder3);
  }
  sql2.param = param2;
})(sql || (sql = {}));
((SQL2) => {
  class Aliased {
    constructor(sql2, fieldAlias) {
      this.sql = sql2;
      this.fieldAlias = fieldAlias;
    }
    static [entityKind] = "SQL.Aliased";
    /** @internal */
    isSelectionField = false;
    getSQL() {
      return this.sql;
    }
    /** @internal */
    clone() {
      return new Aliased(this.sql, this.fieldAlias);
    }
  }
  SQL2.Aliased = Aliased;
})(SQL || (SQL = {}));
var _a28;
var Placeholder = class {
  constructor(name2) {
    this.name = name2;
  }
  getSQL() {
    return new SQL([this]);
  }
};
_a28 = entityKind;
__publicField(Placeholder, _a28, "Placeholder");
function fillPlaceholders(params, values) {
  return params.map((p3) => {
    if (is(p3, Placeholder)) {
      if (!(p3.name in values)) {
        throw new Error(`No value for placeholder "${p3.name}" was provided`);
      }
      return values[p3.name];
    }
    return p3;
  });
}
var _a29;
var View = class {
  /** @internal */
  [(_a29 = entityKind, ViewBaseConfig)];
  constructor({ name: name2, schema, selectedFields, query }) {
    this[ViewBaseConfig] = {
      name: name2,
      originalName: name2,
      schema,
      selectedFields,
      query,
      isExisting: !query,
      isAlias: false
    };
  }
  getSQL() {
    return new SQL([this]);
  }
};
__publicField(View, _a29, "View");
Column.prototype.getSQL = function() {
  return new SQL([this]);
};
Table.prototype.getSQL = function() {
  return new SQL([this]);
};
Subquery.prototype.getSQL = function() {
  return new SQL([this]);
};

// node_modules/drizzle-orm/sql/expressions/conditions.js
function bindIfParam(value, column) {
  if (isDriverValueEncoder(column) && !isSQLWrapper(value) && !is(value, Param) && !is(value, Placeholder) && !is(value, Column) && !is(value, Table) && !is(value, View)) {
    return new Param(value, column);
  }
  return value;
}
var eq = (left, right) => {
  return sql`${left} = ${bindIfParam(right, left)}`;
};
var ne = (left, right) => {
  return sql`${left} <> ${bindIfParam(right, left)}`;
};
function and(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter(
    (c2) => c2 !== void 0
  );
  if (conditions.length === 0) {
    return void 0;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" and ")),
    new StringChunk(")")
  ]);
}
function or(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter(
    (c2) => c2 !== void 0
  );
  if (conditions.length === 0) {
    return void 0;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" or ")),
    new StringChunk(")")
  ]);
}
function not(condition) {
  return sql`not ${condition}`;
}
var gt = (left, right) => {
  return sql`${left} > ${bindIfParam(right, left)}`;
};
var gte = (left, right) => {
  return sql`${left} >= ${bindIfParam(right, left)}`;
};
var lt = (left, right) => {
  return sql`${left} < ${bindIfParam(right, left)}`;
};
var lte = (left, right) => {
  return sql`${left} <= ${bindIfParam(right, left)}`;
};
function inArray(column, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      throw new Error("inArray requires at least one value");
    }
    return sql`${column} in ${values.map((v2) => bindIfParam(v2, column))}`;
  }
  return sql`${column} in ${bindIfParam(values, column)}`;
}
function notInArray(column, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      throw new Error("notInArray requires at least one value");
    }
    return sql`${column} not in ${values.map((v2) => bindIfParam(v2, column))}`;
  }
  return sql`${column} not in ${bindIfParam(values, column)}`;
}
function isNull(value) {
  return sql`${value} is null`;
}
function isNotNull(value) {
  return sql`${value} is not null`;
}
function exists(subquery) {
  return sql`exists ${subquery}`;
}
function notExists(subquery) {
  return sql`not exists ${subquery}`;
}
function between(column, min, max) {
  return sql`${column} between ${bindIfParam(min, column)} and ${bindIfParam(
    max,
    column
  )}`;
}
function notBetween(column, min, max) {
  return sql`${column} not between ${bindIfParam(
    min,
    column
  )} and ${bindIfParam(max, column)}`;
}
function like(column, value) {
  return sql`${column} like ${value}`;
}
function notLike(column, value) {
  return sql`${column} not like ${value}`;
}
function ilike(column, value) {
  return sql`${column} ilike ${value}`;
}
function notIlike(column, value) {
  return sql`${column} not ilike ${value}`;
}

// node_modules/drizzle-orm/sql/expressions/select.js
init_process();
init_buffer();
function asc(column) {
  return sql`${column} asc`;
}
function desc(column) {
  return sql`${column} desc`;
}

// node_modules/drizzle-orm/relations.js
var _a30;
var Relation = class {
  constructor(sourceTable, referencedTable, relationName) {
    this.sourceTable = sourceTable;
    this.referencedTable = referencedTable;
    this.relationName = relationName;
    this.referencedTableName = referencedTable[Table.Symbol.Name];
  }
  referencedTableName;
  fieldName;
};
_a30 = entityKind;
__publicField(Relation, _a30, "Relation");
var _a31;
var Relations = class {
  constructor(table2, config3) {
    this.table = table2;
    this.config = config3;
  }
};
_a31 = entityKind;
__publicField(Relations, _a31, "Relations");
var _a32;
var _One = class extends Relation {
  constructor(sourceTable, referencedTable, config3, isNullable) {
    super(sourceTable, referencedTable, config3?.relationName);
    this.config = config3;
    this.isNullable = isNullable;
  }
  withFieldName(fieldName) {
    const relation = new _One(
      this.sourceTable,
      this.referencedTable,
      this.config,
      this.isNullable
    );
    relation.fieldName = fieldName;
    return relation;
  }
};
var One = _One;
_a32 = entityKind;
__publicField(One, _a32, "One");
var _a33;
var _Many = class extends Relation {
  constructor(sourceTable, referencedTable, config3) {
    super(sourceTable, referencedTable, config3?.relationName);
    this.config = config3;
  }
  withFieldName(fieldName) {
    const relation = new _Many(
      this.sourceTable,
      this.referencedTable,
      this.config
    );
    relation.fieldName = fieldName;
    return relation;
  }
};
var Many = _Many;
_a33 = entityKind;
__publicField(Many, _a33, "Many");
function getOperators() {
  return {
    and,
    between,
    eq,
    exists,
    gt,
    gte,
    ilike,
    inArray,
    isNull,
    isNotNull,
    like,
    lt,
    lte,
    ne,
    not,
    notBetween,
    notExists,
    notLike,
    notIlike,
    notInArray,
    or,
    sql
  };
}
function getOrderByOperators() {
  return {
    sql,
    asc,
    desc
  };
}
function extractTablesRelationalConfig(schema, configHelpers) {
  if (Object.keys(schema).length === 1 && "default" in schema && !is(schema["default"], Table)) {
    schema = schema["default"];
  }
  const tableNamesMap = {};
  const relationsBuffer = {};
  const tablesConfig = {};
  for (const [key2, value] of Object.entries(schema)) {
    if (isTable(value)) {
      const dbName = value[Table.Symbol.Name];
      const bufferedRelations = relationsBuffer[dbName];
      tableNamesMap[dbName] = key2;
      tablesConfig[key2] = {
        tsName: key2,
        dbName: value[Table.Symbol.Name],
        schema: value[Table.Symbol.Schema],
        columns: value[Table.Symbol.Columns],
        relations: bufferedRelations?.relations ?? {},
        primaryKey: bufferedRelations?.primaryKey ?? []
      };
      for (const column of Object.values(
        value[Table.Symbol.Columns]
      )) {
        if (column.primary) {
          tablesConfig[key2].primaryKey.push(column);
        }
      }
      const extraConfig = value[Table.Symbol.ExtraConfigBuilder]?.(value);
      if (extraConfig) {
        for (const configEntry of Object.values(extraConfig)) {
          if (is(configEntry, PrimaryKeyBuilder)) {
            tablesConfig[key2].primaryKey.push(...configEntry.columns);
          }
        }
      }
    } else if (is(value, Relations)) {
      const dbName = value.table[Table.Symbol.Name];
      const tableName = tableNamesMap[dbName];
      const relations2 = value.config(
        configHelpers(value.table)
      );
      let primaryKey;
      for (const [relationName, relation] of Object.entries(relations2)) {
        if (tableName) {
          const tableConfig = tablesConfig[tableName];
          tableConfig.relations[relationName] = relation;
          if (primaryKey) {
            tableConfig.primaryKey.push(...primaryKey);
          }
        } else {
          if (!(dbName in relationsBuffer)) {
            relationsBuffer[dbName] = {
              relations: {},
              primaryKey
            };
          }
          relationsBuffer[dbName].relations[relationName] = relation;
        }
      }
    }
  }
  return { tables: tablesConfig, tableNamesMap };
}
function relations(table2, relations2) {
  return new Relations(
    table2,
    (helpers) => Object.fromEntries(
      Object.entries(relations2(helpers)).map(([key2, value]) => [
        key2,
        value.withFieldName(key2)
      ])
    )
  );
}
function createOne(sourceTable) {
  return function one4(table2, config3) {
    return new One(
      sourceTable,
      table2,
      config3,
      config3?.fields.reduce((res, f2) => res && f2.notNull, true) ?? false
    );
  };
}
function createMany(sourceTable) {
  return function many(referencedTable, config3) {
    return new Many(sourceTable, referencedTable, config3);
  };
}
function normalizeRelation(schema, tableNamesMap, relation) {
  if (is(relation, One) && relation.config) {
    return {
      fields: relation.config.fields,
      references: relation.config.references
    };
  }
  const referencedTableTsName = tableNamesMap[relation.referencedTable[Table.Symbol.Name]];
  if (!referencedTableTsName) {
    throw new Error(
      `Table "${relation.referencedTable[Table.Symbol.Name]}" not found in schema`
    );
  }
  const referencedTableConfig = schema[referencedTableTsName];
  if (!referencedTableConfig) {
    throw new Error(`Table "${referencedTableTsName}" not found in schema`);
  }
  const sourceTable = relation.sourceTable;
  const sourceTableTsName = tableNamesMap[sourceTable[Table.Symbol.Name]];
  if (!sourceTableTsName) {
    throw new Error(
      `Table "${sourceTable[Table.Symbol.Name]}" not found in schema`
    );
  }
  const reverseRelations = [];
  for (const referencedTableRelation of Object.values(
    referencedTableConfig.relations
  )) {
    if (relation.relationName && relation !== referencedTableRelation && referencedTableRelation.relationName === relation.relationName || !relation.relationName && referencedTableRelation.referencedTable === relation.sourceTable) {
      reverseRelations.push(referencedTableRelation);
    }
  }
  if (reverseRelations.length > 1) {
    throw relation.relationName ? new Error(
      `There are multiple relations with name "${relation.relationName}" in table "${referencedTableTsName}"`
    ) : new Error(
      `There are multiple relations between "${referencedTableTsName}" and "${relation.sourceTable[Table.Symbol.Name]}". Please specify relation name`
    );
  }
  if (reverseRelations[0] && is(reverseRelations[0], One) && reverseRelations[0].config) {
    return {
      fields: reverseRelations[0].config.references,
      references: reverseRelations[0].config.fields
    };
  }
  throw new Error(
    `There is not enough information to infer relation "${sourceTableTsName}.${relation.fieldName}"`
  );
}
function createTableRelationsHelpers(sourceTable) {
  return {
    one: createOne(sourceTable),
    many: createMany(sourceTable)
  };
}
function mapRelationalRow(tablesConfig, tableConfig, row, buildQueryResultSelection, mapColumnValue = (value) => value) {
  const result = {};
  for (const [
    selectionItemIndex,
    selectionItem
  ] of buildQueryResultSelection.entries()) {
    if (selectionItem.isJson) {
      const relation = tableConfig.relations[selectionItem.tsKey];
      const rawSubRows = row[selectionItemIndex];
      const subRows = typeof rawSubRows === "string" ? JSON.parse(rawSubRows) : rawSubRows;
      result[selectionItem.tsKey] = is(relation, One) ? subRows && mapRelationalRow(
        tablesConfig,
        tablesConfig[selectionItem.relationTableTsKey],
        subRows,
        selectionItem.selection,
        mapColumnValue
      ) : subRows.map(
        (subRow) => mapRelationalRow(
          tablesConfig,
          tablesConfig[selectionItem.relationTableTsKey],
          subRow,
          selectionItem.selection,
          mapColumnValue
        )
      );
    } else {
      const value = mapColumnValue(row[selectionItemIndex]);
      const field = selectionItem.field;
      let decoder2;
      if (is(field, Column)) {
        decoder2 = field;
      } else if (is(field, SQL)) {
        decoder2 = field.decoder;
      } else {
        decoder2 = field.sql.decoder;
      }
      result[selectionItem.tsKey] = value === null ? null : decoder2.mapFromDriverValue(value);
    }
  }
  return result;
}

// node_modules/drizzle-orm/sqlite-core/db.js
init_process();
init_buffer();

// node_modules/drizzle-orm/selection-proxy.js
init_process();
init_buffer();

// node_modules/drizzle-orm/alias.js
init_process();
init_buffer();
var _a34;
var ColumnAliasProxyHandler = class {
  constructor(table2) {
    this.table = table2;
  }
  get(columnObj, prop) {
    if (prop === "table") {
      return this.table;
    }
    return columnObj[prop];
  }
};
_a34 = entityKind;
__publicField(ColumnAliasProxyHandler, _a34, "ColumnAliasProxyHandler");
var _a35;
var TableAliasProxyHandler = class {
  constructor(alias, replaceOriginalName) {
    this.alias = alias;
    this.replaceOriginalName = replaceOriginalName;
  }
  get(target, prop) {
    if (prop === Table.Symbol.IsAlias) {
      return true;
    }
    if (prop === Table.Symbol.Name) {
      return this.alias;
    }
    if (this.replaceOriginalName && prop === Table.Symbol.OriginalName) {
      return this.alias;
    }
    if (prop === ViewBaseConfig) {
      return {
        ...target[ViewBaseConfig],
        name: this.alias,
        isAlias: true
      };
    }
    if (prop === Table.Symbol.Columns) {
      const columns = target[Table.Symbol.Columns];
      if (!columns) {
        return columns;
      }
      const proxiedColumns = {};
      Object.keys(columns).map((key2) => {
        proxiedColumns[key2] = new Proxy(
          columns[key2],
          new ColumnAliasProxyHandler(new Proxy(target, this))
        );
      });
      return proxiedColumns;
    }
    const value = target[prop];
    if (is(value, Column)) {
      return new Proxy(value, new ColumnAliasProxyHandler(new Proxy(target, this)));
    }
    return value;
  }
};
_a35 = entityKind;
__publicField(TableAliasProxyHandler, _a35, "TableAliasProxyHandler");
var _a36;
var RelationTableAliasProxyHandler = class {
  constructor(alias) {
    this.alias = alias;
  }
  get(target, prop) {
    if (prop === "sourceTable") {
      return aliasedTable(target.sourceTable, this.alias);
    }
    return target[prop];
  }
};
_a36 = entityKind;
__publicField(RelationTableAliasProxyHandler, _a36, "RelationTableAliasProxyHandler");
function aliasedTable(table2, tableAlias) {
  return new Proxy(table2, new TableAliasProxyHandler(tableAlias, false));
}
function aliasedTableColumn(column, tableAlias) {
  return new Proxy(
    column,
    new ColumnAliasProxyHandler(new Proxy(column.table, new TableAliasProxyHandler(tableAlias, false)))
  );
}
function mapColumnsInAliasedSQLToAlias(query, alias) {
  return new SQL.Aliased(mapColumnsInSQLToAlias(query.sql, alias), query.fieldAlias);
}
function mapColumnsInSQLToAlias(query, alias) {
  return sql.join(query.queryChunks.map((c2) => {
    if (is(c2, Column)) {
      return aliasedTableColumn(c2, alias);
    }
    if (is(c2, SQL)) {
      return mapColumnsInSQLToAlias(c2, alias);
    }
    if (is(c2, SQL.Aliased)) {
      return mapColumnsInAliasedSQLToAlias(c2, alias);
    }
    return c2;
  }));
}

// node_modules/drizzle-orm/selection-proxy.js
var _a37;
var _SelectionProxyHandler = class {
  config;
  constructor(config3) {
    this.config = { ...config3 };
  }
  get(subquery, prop) {
    if (prop === "_") {
      return {
        ...subquery["_"],
        selectedFields: new Proxy(
          subquery._.selectedFields,
          this
        )
      };
    }
    if (prop === ViewBaseConfig) {
      return {
        ...subquery[ViewBaseConfig],
        selectedFields: new Proxy(
          subquery[ViewBaseConfig].selectedFields,
          this
        )
      };
    }
    if (typeof prop === "symbol") {
      return subquery[prop];
    }
    const columns = is(subquery, Subquery) ? subquery._.selectedFields : is(subquery, View) ? subquery[ViewBaseConfig].selectedFields : subquery;
    const value = columns[prop];
    if (is(value, SQL.Aliased)) {
      if (this.config.sqlAliasedBehavior === "sql" && !value.isSelectionField) {
        return value.sql;
      }
      const newValue = value.clone();
      newValue.isSelectionField = true;
      return newValue;
    }
    if (is(value, SQL)) {
      if (this.config.sqlBehavior === "sql") {
        return value;
      }
      throw new Error(
        `You tried to reference "${prop}" field from a subquery, which is a raw SQL field, but it doesn't have an alias declared. Please add an alias to the field using ".as('alias')" method.`
      );
    }
    if (is(value, Column)) {
      if (this.config.alias) {
        return new Proxy(
          value,
          new ColumnAliasProxyHandler(
            new Proxy(
              value.table,
              new TableAliasProxyHandler(this.config.alias, this.config.replaceOriginalName ?? false)
            )
          )
        );
      }
      return value;
    }
    if (typeof value !== "object" || value === null) {
      return value;
    }
    return new Proxy(value, new _SelectionProxyHandler(this.config));
  }
};
var SelectionProxyHandler = _SelectionProxyHandler;
_a37 = entityKind;
__publicField(SelectionProxyHandler, _a37, "SelectionProxyHandler");

// node_modules/drizzle-orm/sqlite-core/query-builders/delete.js
init_process();
init_buffer();

// node_modules/drizzle-orm/query-promise.js
init_process();
init_buffer();
var _a38;
var QueryPromise = class {
  [(_a38 = entityKind, Symbol.toStringTag)] = "QueryPromise";
  catch(onRejected) {
    return this.then(void 0, onRejected);
  }
  finally(onFinally) {
    return this.then(
      (value) => {
        onFinally?.();
        return value;
      },
      (reason) => {
        onFinally?.();
        throw reason;
      }
    );
  }
  then(onFulfilled, onRejected) {
    return this.execute().then(onFulfilled, onRejected);
  }
};
__publicField(QueryPromise, _a38, "QueryPromise");

// node_modules/drizzle-orm/sqlite-core/table.js
init_process();
init_buffer();
var InlineForeignKeys2 = Symbol.for("drizzle:SQLiteInlineForeignKeys");
var _a39;
var SQLiteTable = class extends Table {
  /** @internal */
  [(_a39 = entityKind, Table.Symbol.Columns)];
  /** @internal */
  [InlineForeignKeys2] = [];
  /** @internal */
  [Table.Symbol.ExtraConfigBuilder] = void 0;
};
__publicField(SQLiteTable, _a39, "SQLiteTable");
/** @internal */
__publicField(SQLiteTable, "Symbol", Object.assign({}, Table.Symbol, {
  InlineForeignKeys: InlineForeignKeys2
}));
function sqliteTableBase(name, columns, extraConfig, schema, baseName = name) {
  const rawTable = new SQLiteTable(name, schema, baseName);
  const builtColumns = Object.fromEntries(
    Object.entries(columns).map(([name2, colBuilderBase]) => {
      const colBuilder = colBuilderBase;
      const column = colBuilder.build(rawTable);
      rawTable[InlineForeignKeys2].push(...colBuilder.buildForeignKeys(column, rawTable));
      return [name2, column];
    })
  );
  const table2 = Object.assign(rawTable, builtColumns);
  table2[Table.Symbol.Columns] = builtColumns;
  if (extraConfig) {
    table2[SQLiteTable.Symbol.ExtraConfigBuilder] = extraConfig;
  }
  return table2;
}
var sqliteTable = (name, columns, extraConfig) => {
  return sqliteTableBase(name, columns, extraConfig);
};

// node_modules/drizzle-orm/utils.js
init_process();
init_buffer();
function mapResultRow(columns, row, joinsNotNullableMap) {
  const nullifyMap = {};
  const result = columns.reduce(
    (result2, { path: path2, field }, columnIndex) => {
      let decoder2;
      if (is(field, Column)) {
        decoder2 = field;
      } else if (is(field, SQL)) {
        decoder2 = field.decoder;
      } else {
        decoder2 = field.sql.decoder;
      }
      let node3 = result2;
      for (const [pathChunkIndex, pathChunk] of path2.entries()) {
        if (pathChunkIndex < path2.length - 1) {
          if (!(pathChunk in node3)) {
            node3[pathChunk] = {};
          }
          node3 = node3[pathChunk];
        } else {
          const rawValue = row[columnIndex];
          const value = node3[pathChunk] = rawValue === null ? null : decoder2.mapFromDriverValue(rawValue);
          if (joinsNotNullableMap && is(field, Column) && path2.length === 2) {
            const objectName = path2[0];
            if (!(objectName in nullifyMap)) {
              nullifyMap[objectName] = value === null ? getTableName(field.table) : false;
            } else if (typeof nullifyMap[objectName] === "string" && nullifyMap[objectName] !== getTableName(field.table)) {
              nullifyMap[objectName] = false;
            }
          }
        }
      }
      return result2;
    },
    {}
  );
  if (joinsNotNullableMap && Object.keys(nullifyMap).length > 0) {
    for (const [objectName, tableName] of Object.entries(nullifyMap)) {
      if (typeof tableName === "string" && !joinsNotNullableMap[tableName]) {
        result[objectName] = null;
      }
    }
  }
  return result;
}
function orderSelectedFields(fields, pathPrefix) {
  return Object.entries(fields).reduce((result, [name, field]) => {
    if (typeof name !== "string") {
      return result;
    }
    const newPath = pathPrefix ? [...pathPrefix, name] : [name];
    if (is(field, Column) || is(field, SQL) || is(field, SQL.Aliased)) {
      result.push({ path: newPath, field });
    } else if (is(field, Table)) {
      result.push(...orderSelectedFields(field[Table.Symbol.Columns], newPath));
    } else {
      result.push(...orderSelectedFields(field, newPath));
    }
    return result;
  }, []);
}
function haveSameKeys(left, right) {
  const leftKeys = Object.keys(left);
  const rightKeys = Object.keys(right);
  if (leftKeys.length !== rightKeys.length) {
    return false;
  }
  for (const [index3, key2] of leftKeys.entries()) {
    if (key2 !== rightKeys[index3]) {
      return false;
    }
  }
  return true;
}
function mapUpdateSet(table2, values) {
  const entries = Object.entries(values).filter(([, value]) => value !== void 0).map(([key2, value]) => {
    if (is(value, SQL)) {
      return [key2, value];
    } else {
      return [key2, new Param(value, table2[Table.Symbol.Columns][key2])];
    }
  });
  if (entries.length === 0) {
    throw new Error("No values to set");
  }
  return Object.fromEntries(entries);
}
function applyMixins(baseClass, extendedClasses) {
  for (const extendedClass of extendedClasses) {
    for (const name of Object.getOwnPropertyNames(extendedClass.prototype)) {
      if (name === "constructor")
        continue;
      Object.defineProperty(
        baseClass.prototype,
        name,
        Object.getOwnPropertyDescriptor(extendedClass.prototype, name) || /* @__PURE__ */ Object.create(null)
      );
    }
  }
}
function getTableColumns(table2) {
  return table2[Table.Symbol.Columns];
}
function getTableLikeName(table2) {
  return is(table2, Subquery) ? table2._.alias : is(table2, View) ? table2[ViewBaseConfig].name : is(table2, SQL) ? void 0 : table2[Table.Symbol.IsAlias] ? table2[Table.Symbol.Name] : table2[Table.Symbol.BaseName];
}

// node_modules/drizzle-orm/sqlite-core/query-builders/delete.js
var _a40;
var SQLiteDeleteBase = class extends QueryPromise {
  constructor(table2, session, dialect, withList) {
    super();
    this.table = table2;
    this.session = session;
    this.dialect = dialect;
    this.config = { table: table2, withList };
  }
  /** @internal */
  config;
  /**
   * Adds a `where` clause to the query.
   *
   * Calling this method will delete only those rows that fulfill a specified condition.
   *
   * See docs: {@link https://orm.drizzle.team/docs/delete}
   *
   * @param where the `where` clause.
   *
   * @example
   * You can use conditional operators and `sql function` to filter the rows to be deleted.
   *
   * ```ts
   * // Delete all cars with green color
   * db.delete(cars).where(eq(cars.color, 'green'));
   * // or
   * db.delete(cars).where(sql`${cars.color} = 'green'`)
   * ```
   *
   * You can logically combine conditional operators with `and()` and `or()` operators:
   *
   * ```ts
   * // Delete all BMW cars with a green color
   * db.delete(cars).where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));
   *
   * // Delete all cars with the green or blue color
   * db.delete(cars).where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));
   * ```
   */
  where(where) {
    this.config.where = where;
    return this;
  }
  returning(fields = this.table[SQLiteTable.Symbol.Columns]) {
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  /** @internal */
  getSQL() {
    return this.dialect.buildDeleteQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  /** @internal */
  _prepare(isOneTimeQuery = true) {
    return this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](
      this.dialect.sqlToQuery(this.getSQL()),
      this.config.returning,
      this.config.returning ? "all" : "run",
      true
    );
  }
  prepare() {
    return this._prepare(false);
  }
  run = (placeholderValues) => {
    return this._prepare().run(placeholderValues);
  };
  all = (placeholderValues) => {
    return this._prepare().all(placeholderValues);
  };
  get = (placeholderValues) => {
    return this._prepare().get(placeholderValues);
  };
  values = (placeholderValues) => {
    return this._prepare().values(placeholderValues);
  };
  async execute(placeholderValues) {
    return this._prepare().execute(placeholderValues);
  }
  $dynamic() {
    return this;
  }
};
_a40 = entityKind;
__publicField(SQLiteDeleteBase, _a40, "SQLiteDelete");

// node_modules/drizzle-orm/sqlite-core/query-builders/insert.js
init_process();
init_buffer();
var _a41;
var SQLiteInsertBuilder = class {
  constructor(table2, session, dialect, withList) {
    this.table = table2;
    this.session = session;
    this.dialect = dialect;
    this.withList = withList;
  }
  values(values) {
    values = Array.isArray(values) ? values : [values];
    if (values.length === 0) {
      throw new Error("values() must be called with at least one value");
    }
    const mappedValues = values.map((entry) => {
      const result = {};
      const cols = this.table[Table.Symbol.Columns];
      for (const colKey of Object.keys(entry)) {
        const colValue = entry[colKey];
        result[colKey] = is(colValue, SQL) ? colValue : new Param(colValue, cols[colKey]);
      }
      return result;
    });
    return new SQLiteInsertBase(this.table, mappedValues, this.session, this.dialect, this.withList);
  }
};
_a41 = entityKind;
__publicField(SQLiteInsertBuilder, _a41, "SQLiteInsertBuilder");
var _a42;
var SQLiteInsertBase = class extends QueryPromise {
  constructor(table2, values, session, dialect, withList) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { table: table2, values, withList };
  }
  /** @internal */
  config;
  returning(fields = this.config.table[SQLiteTable.Symbol.Columns]) {
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  /**
   * Adds an `on conflict do nothing` clause to the query.
   *
   * Calling this method simply avoids inserting a row as its alternative action.
   *
   * See docs: {@link https://orm.drizzle.team/docs/insert#on-conflict-do-nothing}
   *
   * @param config The `target` and `where` clauses.
   *
   * @example
   * ```ts
   * // Insert one row and cancel the insert if there's a conflict
   * await db.insert(cars)
   *   .values({ id: 1, brand: 'BMW' })
   *   .onConflictDoNothing();
   *
   * // Explicitly specify conflict target
   * await db.insert(cars)
   *   .values({ id: 1, brand: 'BMW' })
   *   .onConflictDoNothing({ target: cars.id });
   * ```
   */
  onConflictDoNothing(config3 = {}) {
    if (config3.target === void 0) {
      this.config.onConflict = sql`do nothing`;
    } else {
      const targetSql = Array.isArray(config3.target) ? sql`${config3.target}` : sql`${[config3.target]}`;
      const whereSql = config3.where ? sql` where ${config3.where}` : sql``;
      this.config.onConflict = sql`${targetSql} do nothing${whereSql}`;
    }
    return this;
  }
  /**
   * Adds an `on conflict do update` clause to the query.
   *
   * Calling this method will update the existing row that conflicts with the row proposed for insertion as its alternative action.
   *
   * See docs: {@link https://orm.drizzle.team/docs/insert#upserts-and-conflicts}
   *
   * @param config The `target`, `set` and `where` clauses.
   *
   * @example
   * ```ts
   * // Update the row if there's a conflict
   * await db.insert(cars)
   *   .values({ id: 1, brand: 'BMW' })
   *   .onConflictDoUpdate({
   *     target: cars.id,
   *     set: { brand: 'Porsche' }
   *   });
   *
   * // Upsert with 'where' clause
   * await db.insert(cars)
   *   .values({ id: 1, brand: 'BMW' })
   *   .onConflictDoUpdate({
   *     target: cars.id,
   *     set: { brand: 'newBMW' },
   *     where: sql`${cars.createdAt} > '2023-01-01'::date`,
   *   });
   * ```
   */
  onConflictDoUpdate(config3) {
    if (config3.where && (config3.targetWhere || config3.setWhere)) {
      throw new Error(
        'You cannot use both "where" and "targetWhere"/"setWhere" at the same time - "where" is deprecated, use "targetWhere" or "setWhere" instead.'
      );
    }
    const whereSql = config3.where ? sql` where ${config3.where}` : void 0;
    const targetWhereSql = config3.targetWhere ? sql` where ${config3.targetWhere}` : void 0;
    const setWhereSql = config3.setWhere ? sql` where ${config3.setWhere}` : void 0;
    const targetSql = Array.isArray(config3.target) ? sql`${config3.target}` : sql`${[config3.target]}`;
    const setSql = this.dialect.buildUpdateSet(this.config.table, mapUpdateSet(this.config.table, config3.set));
    this.config.onConflict = sql`${targetSql}${targetWhereSql} do update set ${setSql}${whereSql}${setWhereSql}`;
    return this;
  }
  /** @internal */
  getSQL() {
    return this.dialect.buildInsertQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  /** @internal */
  _prepare(isOneTimeQuery = true) {
    return this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](
      this.dialect.sqlToQuery(this.getSQL()),
      this.config.returning,
      this.config.returning ? "all" : "run",
      true
    );
  }
  prepare() {
    return this._prepare(false);
  }
  run = (placeholderValues) => {
    return this._prepare().run(placeholderValues);
  };
  all = (placeholderValues) => {
    return this._prepare().all(placeholderValues);
  };
  get = (placeholderValues) => {
    return this._prepare().get(placeholderValues);
  };
  values = (placeholderValues) => {
    return this._prepare().values(placeholderValues);
  };
  async execute() {
    return this.config.returning ? this.all() : this.run();
  }
  $dynamic() {
    return this;
  }
};
_a42 = entityKind;
__publicField(SQLiteInsertBase, _a42, "SQLiteInsert");

// node_modules/drizzle-orm/sqlite-core/query-builders/query-builder.js
init_process();
init_buffer();

// node_modules/drizzle-orm/sqlite-core/dialect.js
init_process();
init_buffer();

// node_modules/drizzle-orm/errors.js
init_process();
init_buffer();
var _a43;
var DrizzleError = class extends Error {
  constructor({ message: message2, cause }) {
    super(message2);
    this.name = "DrizzleError";
    this.cause = cause;
  }
};
_a43 = entityKind;
__publicField(DrizzleError, _a43, "DrizzleError");
var _a44;
var TransactionRollbackError = class extends DrizzleError {
  constructor() {
    super({ message: "Rollback" });
  }
};
_a44 = entityKind;
__publicField(TransactionRollbackError, _a44, "TransactionRollbackError");

// node_modules/drizzle-orm/sql/functions/aggregate.js
init_process();
init_buffer();
function count(expression) {
  return sql`count(${expression || sql.raw("*")})`.mapWith(Number);
}

// node_modules/drizzle-orm/sqlite-core/columns/common.js
init_process();
init_buffer();

// node_modules/drizzle-orm/sqlite-core/foreign-keys.js
init_process();
init_buffer();
var _a45;
var ForeignKeyBuilder2 = class {
  /** @internal */
  reference;
  /** @internal */
  _onUpdate;
  /** @internal */
  _onDelete;
  constructor(config3, actions) {
    this.reference = () => {
      const { name, columns, foreignColumns } = config3();
      return { name, columns, foreignTable: foreignColumns[0].table, foreignColumns };
    };
    if (actions) {
      this._onUpdate = actions.onUpdate;
      this._onDelete = actions.onDelete;
    }
  }
  onUpdate(action) {
    this._onUpdate = action;
    return this;
  }
  onDelete(action) {
    this._onDelete = action;
    return this;
  }
  /** @internal */
  build(table2) {
    return new ForeignKey2(table2, this);
  }
};
_a45 = entityKind;
__publicField(ForeignKeyBuilder2, _a45, "SQLiteForeignKeyBuilder");
var _a46;
var ForeignKey2 = class {
  constructor(table2, builder) {
    this.table = table2;
    this.reference = builder.reference;
    this.onUpdate = builder._onUpdate;
    this.onDelete = builder._onDelete;
  }
  reference;
  onUpdate;
  onDelete;
  getName() {
    const { name, columns, foreignColumns } = this.reference();
    const columnNames = columns.map((column) => column.name);
    const foreignColumnNames = foreignColumns.map((column) => column.name);
    const chunks = [
      this.table[SQLiteTable.Symbol.Name],
      ...columnNames,
      foreignColumns[0].table[SQLiteTable.Symbol.Name],
      ...foreignColumnNames
    ];
    return name ?? `${chunks.join("_")}_fk`;
  }
};
_a46 = entityKind;
__publicField(ForeignKey2, _a46, "SQLiteForeignKey");

// node_modules/drizzle-orm/sqlite-core/unique-constraint.js
init_process();
init_buffer();
function uniqueKeyName2(table2, columns) {
  return `${table2[SQLiteTable.Symbol.Name]}_${columns.join("_")}_unique`;
}
var _a47;
var UniqueConstraintBuilder2 = class {
  constructor(columns, name) {
    this.name = name;
    this.columns = columns;
  }
  /** @internal */
  columns;
  /** @internal */
  build(table2) {
    return new UniqueConstraint2(table2, this.columns, this.name);
  }
};
_a47 = entityKind;
__publicField(UniqueConstraintBuilder2, _a47, "SQLiteUniqueConstraintBuilder");
var _a48;
var UniqueOnConstraintBuilder2 = class {
  /** @internal */
  name;
  constructor(name) {
    this.name = name;
  }
  on(...columns) {
    return new UniqueConstraintBuilder2(columns, this.name);
  }
};
_a48 = entityKind;
__publicField(UniqueOnConstraintBuilder2, _a48, "SQLiteUniqueOnConstraintBuilder");
var _a49;
var UniqueConstraint2 = class {
  constructor(table2, columns, name) {
    this.table = table2;
    this.columns = columns;
    this.name = name ?? uniqueKeyName2(this.table, this.columns.map((column) => column.name));
  }
  columns;
  name;
  getName() {
    return this.name;
  }
};
_a49 = entityKind;
__publicField(UniqueConstraint2, _a49, "SQLiteUniqueConstraint");

// node_modules/drizzle-orm/sqlite-core/columns/common.js
var _a50;
var SQLiteColumnBuilder = class extends ColumnBuilder {
  foreignKeyConfigs = [];
  references(ref, actions = {}) {
    this.foreignKeyConfigs.push({ ref, actions });
    return this;
  }
  unique(name) {
    this.config.isUnique = true;
    this.config.uniqueName = name;
    return this;
  }
  /** @internal */
  buildForeignKeys(column, table2) {
    return this.foreignKeyConfigs.map(({ ref, actions }) => {
      return ((ref2, actions2) => {
        const builder = new ForeignKeyBuilder2(() => {
          const foreignColumn = ref2();
          return { columns: [column], foreignColumns: [foreignColumn] };
        });
        if (actions2.onUpdate) {
          builder.onUpdate(actions2.onUpdate);
        }
        if (actions2.onDelete) {
          builder.onDelete(actions2.onDelete);
        }
        return builder.build(table2);
      })(ref, actions);
    });
  }
};
_a50 = entityKind;
__publicField(SQLiteColumnBuilder, _a50, "SQLiteColumnBuilder");
var _a51;
var SQLiteColumn = class extends Column {
  constructor(table2, config3) {
    if (!config3.uniqueName) {
      config3.uniqueName = uniqueKeyName2(table2, [config3.name]);
    }
    super(table2, config3);
    this.table = table2;
  }
};
_a51 = entityKind;
__publicField(SQLiteColumn, _a51, "SQLiteColumn");

// node_modules/drizzle-orm/sqlite-core/columns/integer.js
init_process();
init_buffer();
var _a52;
var SQLiteBaseIntegerBuilder = class extends SQLiteColumnBuilder {
  constructor(name, dataType, columnType) {
    super(name, dataType, columnType);
    this.config.autoIncrement = false;
  }
  primaryKey(config3) {
    if (config3?.autoIncrement) {
      this.config.autoIncrement = true;
    }
    this.config.hasDefault = true;
    return super.primaryKey();
  }
};
_a52 = entityKind;
__publicField(SQLiteBaseIntegerBuilder, _a52, "SQLiteBaseIntegerBuilder");
var _a53;
var SQLiteBaseInteger = class extends SQLiteColumn {
  autoIncrement = this.config.autoIncrement;
  getSQLType() {
    return "integer";
  }
};
_a53 = entityKind;
__publicField(SQLiteBaseInteger, _a53, "SQLiteBaseInteger");
var _a54;
var SQLiteIntegerBuilder = class extends SQLiteBaseIntegerBuilder {
  constructor(name) {
    super(name, "number", "SQLiteInteger");
  }
  build(table2) {
    return new SQLiteInteger(
      table2,
      this.config
    );
  }
};
_a54 = entityKind;
__publicField(SQLiteIntegerBuilder, _a54, "SQLiteIntegerBuilder");
var _a55;
var SQLiteInteger = class extends SQLiteBaseInteger {
};
_a55 = entityKind;
__publicField(SQLiteInteger, _a55, "SQLiteInteger");
var _a56;
var SQLiteTimestampBuilder = class extends SQLiteBaseIntegerBuilder {
  constructor(name, mode) {
    super(name, "date", "SQLiteTimestamp");
    this.config.mode = mode;
  }
  /**
   * @deprecated Use `default()` with your own expression instead.
   *
   * Adds `DEFAULT (cast((julianday('now') - 2440587.5)*86400000 as integer))` to the column, which is the current epoch timestamp in milliseconds.
   */
  defaultNow() {
    return this.default(sql`(cast((julianday('now') - 2440587.5)*86400000 as integer))`);
  }
  build(table2) {
    return new SQLiteTimestamp(
      table2,
      this.config
    );
  }
};
_a56 = entityKind;
__publicField(SQLiteTimestampBuilder, _a56, "SQLiteTimestampBuilder");
var _a57;
var SQLiteTimestamp = class extends SQLiteBaseInteger {
  mode = this.config.mode;
  mapFromDriverValue(value) {
    if (this.config.mode === "timestamp") {
      return new Date(value * 1e3);
    }
    return new Date(value);
  }
  mapToDriverValue(value) {
    const unix = value.getTime();
    if (this.config.mode === "timestamp") {
      return Math.floor(unix / 1e3);
    }
    return unix;
  }
};
_a57 = entityKind;
__publicField(SQLiteTimestamp, _a57, "SQLiteTimestamp");
var _a58;
var SQLiteBooleanBuilder = class extends SQLiteBaseIntegerBuilder {
  constructor(name, mode) {
    super(name, "boolean", "SQLiteBoolean");
    this.config.mode = mode;
  }
  build(table2) {
    return new SQLiteBoolean(
      table2,
      this.config
    );
  }
};
_a58 = entityKind;
__publicField(SQLiteBooleanBuilder, _a58, "SQLiteBooleanBuilder");
var _a59;
var SQLiteBoolean = class extends SQLiteBaseInteger {
  mode = this.config.mode;
  mapFromDriverValue(value) {
    return Number(value) === 1;
  }
  mapToDriverValue(value) {
    return value ? 1 : 0;
  }
};
_a59 = entityKind;
__publicField(SQLiteBoolean, _a59, "SQLiteBoolean");
function integer(name, config3) {
  if (config3?.mode === "timestamp" || config3?.mode === "timestamp_ms") {
    return new SQLiteTimestampBuilder(name, config3.mode);
  }
  if (config3?.mode === "boolean") {
    return new SQLiteBooleanBuilder(name, config3.mode);
  }
  return new SQLiteIntegerBuilder(name);
}

// node_modules/drizzle-orm/sqlite-core/columns/text.js
init_process();
init_buffer();
var _a60;
var SQLiteTextBuilder = class extends SQLiteColumnBuilder {
  constructor(name, config3) {
    super(name, "string", "SQLiteText");
    this.config.enumValues = config3.enum;
    this.config.length = config3.length;
  }
  /** @internal */
  build(table2) {
    return new SQLiteText(table2, this.config);
  }
};
_a60 = entityKind;
__publicField(SQLiteTextBuilder, _a60, "SQLiteTextBuilder");
var _a61;
var SQLiteText = class extends SQLiteColumn {
  enumValues = this.config.enumValues;
  length = this.config.length;
  constructor(table2, config3) {
    super(table2, config3);
  }
  getSQLType() {
    return `text${this.config.length ? `(${this.config.length})` : ""}`;
  }
};
_a61 = entityKind;
__publicField(SQLiteText, _a61, "SQLiteText");
var _a62;
var SQLiteTextJsonBuilder = class extends SQLiteColumnBuilder {
  constructor(name) {
    super(name, "json", "SQLiteTextJson");
  }
  /** @internal */
  build(table2) {
    return new SQLiteTextJson(
      table2,
      this.config
    );
  }
};
_a62 = entityKind;
__publicField(SQLiteTextJsonBuilder, _a62, "SQLiteTextJsonBuilder");
var _a63;
var SQLiteTextJson = class extends SQLiteColumn {
  getSQLType() {
    return "text";
  }
  mapFromDriverValue(value) {
    return JSON.parse(value);
  }
  mapToDriverValue(value) {
    return JSON.stringify(value);
  }
};
_a63 = entityKind;
__publicField(SQLiteTextJson, _a63, "SQLiteTextJson");
function text(name, config3 = {}) {
  return config3.mode === "json" ? new SQLiteTextJsonBuilder(name) : new SQLiteTextBuilder(name, config3);
}

// node_modules/drizzle-orm/sqlite-core/view-base.js
init_process();
init_buffer();
var _a64;
var SQLiteViewBase = class extends View {
};
_a64 = entityKind;
__publicField(SQLiteViewBase, _a64, "SQLiteViewBase");

// node_modules/drizzle-orm/sqlite-core/dialect.js
var _a65;
var SQLiteDialect = class {
  escapeName(name) {
    return `"${name}"`;
  }
  escapeParam(_num) {
    return "?";
  }
  escapeString(str) {
    return `'${str.replace(/'/g, "''")}'`;
  }
  buildWithCTE(queries) {
    if (!queries?.length)
      return void 0;
    const withSqlChunks = [sql`with `];
    for (const [i2, w2] of queries.entries()) {
      withSqlChunks.push(sql`${sql.identifier(w2._.alias)} as (${w2._.sql})`);
      if (i2 < queries.length - 1) {
        withSqlChunks.push(sql`, `);
      }
    }
    withSqlChunks.push(sql` `);
    return sql.join(withSqlChunks);
  }
  buildDeleteQuery({ table: table2, where, returning, withList }) {
    const withSql = this.buildWithCTE(withList);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
    const whereSql = where ? sql` where ${where}` : void 0;
    return sql`${withSql}delete from ${table2}${whereSql}${returningSql}`;
  }
  buildUpdateSet(table2, set) {
    const tableColumns = table2[Table.Symbol.Columns];
    const columnNames = Object.keys(tableColumns).filter(
      (colName) => set[colName] !== void 0 || tableColumns[colName]?.onUpdateFn !== void 0
    );
    const setSize = columnNames.length;
    return sql.join(columnNames.flatMap((colName, i2) => {
      const col = tableColumns[colName];
      const value = set[colName] ?? sql.param(col.onUpdateFn(), col);
      const res = sql`${sql.identifier(col.name)} = ${value}`;
      if (i2 < setSize - 1) {
        return [res, sql.raw(", ")];
      }
      return [res];
    }));
  }
  buildUpdateQuery({ table: table2, set, where, returning, withList }) {
    const withSql = this.buildWithCTE(withList);
    const setSql = this.buildUpdateSet(table2, set);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
    const whereSql = where ? sql` where ${where}` : void 0;
    return sql`${withSql}update ${table2} set ${setSql}${whereSql}${returningSql}`;
  }
  /**
   * Builds selection SQL with provided fields/expressions
   *
   * Examples:
   *
   * `select <selection> from`
   *
   * `insert ... returning <selection>`
   *
   * If `isSingleTable` is true, then columns won't be prefixed with table name
   */
  buildSelection(fields, { isSingleTable = false } = {}) {
    const columnsLen = fields.length;
    const chunks = fields.flatMap(({ field }, i2) => {
      const chunk = [];
      if (is(field, SQL.Aliased) && field.isSelectionField) {
        chunk.push(sql.identifier(field.fieldAlias));
      } else if (is(field, SQL.Aliased) || is(field, SQL)) {
        const query = is(field, SQL.Aliased) ? field.sql : field;
        if (isSingleTable) {
          chunk.push(
            new SQL(
              query.queryChunks.map((c2) => {
                if (is(c2, Column)) {
                  return sql.identifier(c2.name);
                }
                return c2;
              })
            )
          );
        } else {
          chunk.push(query);
        }
        if (is(field, SQL.Aliased)) {
          chunk.push(sql` as ${sql.identifier(field.fieldAlias)}`);
        }
      } else if (is(field, Column)) {
        const tableName = field.table[Table.Symbol.Name];
        const columnName = field.name;
        if (isSingleTable) {
          chunk.push(sql.identifier(columnName));
        } else {
          chunk.push(sql`${sql.identifier(tableName)}.${sql.identifier(columnName)}`);
        }
      }
      if (i2 < columnsLen - 1) {
        chunk.push(sql`, `);
      }
      return chunk;
    });
    return sql.join(chunks);
  }
  buildSelectQuery({
    withList,
    fields,
    fieldsFlat,
    where,
    having,
    table: table2,
    joins,
    orderBy,
    groupBy,
    limit,
    offset,
    distinct,
    setOperators
  }) {
    const fieldsList = fieldsFlat ?? orderSelectedFields(fields);
    for (const f2 of fieldsList) {
      if (is(f2.field, Column) && getTableName(f2.field.table) !== (is(table2, Subquery) ? table2._.alias : is(table2, SQLiteViewBase) ? table2[ViewBaseConfig].name : is(table2, SQL) ? void 0 : getTableName(table2)) && !((table22) => joins?.some(
        ({ alias }) => alias === (table22[Table.Symbol.IsAlias] ? getTableName(table22) : table22[Table.Symbol.BaseName])
      ))(f2.field.table)) {
        const tableName = getTableName(f2.field.table);
        throw new Error(
          `Your "${f2.path.join("->")}" field references a column "${tableName}"."${f2.field.name}", but the table "${tableName}" is not part of the query! Did you forget to join it?`
        );
      }
    }
    const isSingleTable = !joins || joins.length === 0;
    const withSql = this.buildWithCTE(withList);
    const distinctSql = distinct ? sql` distinct` : void 0;
    const selection = this.buildSelection(fieldsList, { isSingleTable });
    const tableSql = (() => {
      if (is(table2, Table) && table2[Table.Symbol.OriginalName] !== table2[Table.Symbol.Name]) {
        return sql`${sql.identifier(table2[Table.Symbol.OriginalName])} ${sql.identifier(table2[Table.Symbol.Name])}`;
      }
      return table2;
    })();
    const joinsArray = [];
    if (joins) {
      for (const [index3, joinMeta] of joins.entries()) {
        if (index3 === 0) {
          joinsArray.push(sql` `);
        }
        const table22 = joinMeta.table;
        if (is(table22, SQLiteTable)) {
          const tableName = table22[SQLiteTable.Symbol.Name];
          const tableSchema = table22[SQLiteTable.Symbol.Schema];
          const origTableName = table22[SQLiteTable.Symbol.OriginalName];
          const alias = tableName === origTableName ? void 0 : joinMeta.alias;
          joinsArray.push(
            sql`${sql.raw(joinMeta.joinType)} join ${tableSchema ? sql`${sql.identifier(tableSchema)}.` : void 0}${sql.identifier(origTableName)}${alias && sql` ${sql.identifier(alias)}`} on ${joinMeta.on}`
          );
        } else {
          joinsArray.push(
            sql`${sql.raw(joinMeta.joinType)} join ${table22} on ${joinMeta.on}`
          );
        }
        if (index3 < joins.length - 1) {
          joinsArray.push(sql` `);
        }
      }
    }
    const joinsSql = sql.join(joinsArray);
    const whereSql = where ? sql` where ${where}` : void 0;
    const havingSql = having ? sql` having ${having}` : void 0;
    const orderByList = [];
    if (orderBy) {
      for (const [index3, orderByValue] of orderBy.entries()) {
        orderByList.push(orderByValue);
        if (index3 < orderBy.length - 1) {
          orderByList.push(sql`, `);
        }
      }
    }
    const groupByList = [];
    if (groupBy) {
      for (const [index3, groupByValue] of groupBy.entries()) {
        groupByList.push(groupByValue);
        if (index3 < groupBy.length - 1) {
          groupByList.push(sql`, `);
        }
      }
    }
    const groupBySql = groupByList.length > 0 ? sql` group by ${sql.join(groupByList)}` : void 0;
    const orderBySql = orderByList.length > 0 ? sql` order by ${sql.join(orderByList)}` : void 0;
    const limitSql = limit ? sql` limit ${limit}` : void 0;
    const offsetSql = offset ? sql` offset ${offset}` : void 0;
    const finalQuery = sql`${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}`;
    if (setOperators.length > 0) {
      return this.buildSetOperations(finalQuery, setOperators);
    }
    return finalQuery;
  }
  buildSetOperations(leftSelect, setOperators) {
    const [setOperator, ...rest] = setOperators;
    if (!setOperator) {
      throw new Error("Cannot pass undefined values to any set operator");
    }
    if (rest.length === 0) {
      return this.buildSetOperationQuery({ leftSelect, setOperator });
    }
    return this.buildSetOperations(
      this.buildSetOperationQuery({ leftSelect, setOperator }),
      rest
    );
  }
  buildSetOperationQuery({
    leftSelect,
    setOperator: { type, isAll, rightSelect, limit, orderBy, offset }
  }) {
    const leftChunk = sql`${leftSelect.getSQL()} `;
    const rightChunk = sql`${rightSelect.getSQL()}`;
    let orderBySql;
    if (orderBy && orderBy.length > 0) {
      const orderByValues = [];
      for (const singleOrderBy of orderBy) {
        if (is(singleOrderBy, SQLiteColumn)) {
          orderByValues.push(sql.identifier(singleOrderBy.name));
        } else if (is(singleOrderBy, SQL)) {
          for (let i2 = 0; i2 < singleOrderBy.queryChunks.length; i2++) {
            const chunk = singleOrderBy.queryChunks[i2];
            if (is(chunk, SQLiteColumn)) {
              singleOrderBy.queryChunks[i2] = sql.identifier(chunk.name);
            }
          }
          orderByValues.push(sql`${singleOrderBy}`);
        } else {
          orderByValues.push(sql`${singleOrderBy}`);
        }
      }
      orderBySql = sql` order by ${sql.join(orderByValues, sql`, `)}`;
    }
    const limitSql = limit ? sql` limit ${limit}` : void 0;
    const operatorChunk = sql.raw(`${type} ${isAll ? "all " : ""}`);
    const offsetSql = offset ? sql` offset ${offset}` : void 0;
    return sql`${leftChunk}${operatorChunk}${rightChunk}${orderBySql}${limitSql}${offsetSql}`;
  }
  buildInsertQuery({ table: table2, values, onConflict, returning, withList }) {
    const valuesSqlList = [];
    const columns = table2[Table.Symbol.Columns];
    const colEntries = Object.entries(columns);
    const insertOrder = colEntries.map(([, column]) => sql.identifier(column.name));
    for (const [valueIndex, value] of values.entries()) {
      const valueList = [];
      for (const [fieldName, col] of colEntries) {
        const colValue = value[fieldName];
        if (colValue === void 0 || is(colValue, Param) && colValue.value === void 0) {
          let defaultValue;
          if (col.default !== null && col.default !== void 0) {
            defaultValue = is(col.default, SQL) ? col.default : sql.param(col.default, col);
          } else if (col.defaultFn !== void 0) {
            const defaultFnResult = col.defaultFn();
            defaultValue = is(defaultFnResult, SQL) ? defaultFnResult : sql.param(defaultFnResult, col);
          } else if (!col.default && col.onUpdateFn !== void 0) {
            const onUpdateFnResult = col.onUpdateFn();
            defaultValue = is(onUpdateFnResult, SQL) ? onUpdateFnResult : sql.param(onUpdateFnResult, col);
          } else {
            defaultValue = sql`null`;
          }
          valueList.push(defaultValue);
        } else {
          valueList.push(colValue);
        }
      }
      valuesSqlList.push(valueList);
      if (valueIndex < values.length - 1) {
        valuesSqlList.push(sql`, `);
      }
    }
    const withSql = this.buildWithCTE(withList);
    const valuesSql = sql.join(valuesSqlList);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
    const onConflictSql = onConflict ? sql` on conflict ${onConflict}` : void 0;
    return sql`${withSql}insert into ${table2} ${insertOrder} values ${valuesSql}${onConflictSql}${returningSql}`;
  }
  sqlToQuery(sql2) {
    return sql2.toQuery({
      escapeName: this.escapeName,
      escapeParam: this.escapeParam,
      escapeString: this.escapeString
    });
  }
  buildRelationalQuery({
    fullSchema,
    schema,
    tableNamesMap,
    table: table2,
    tableConfig,
    queryConfig: config3,
    tableAlias,
    nestedQueryRelation,
    joinOn
  }) {
    let selection = [];
    let limit, offset, orderBy = [], where;
    const joins = [];
    if (config3 === true) {
      const selectionEntries = Object.entries(tableConfig.columns);
      selection = selectionEntries.map(([key2, value]) => ({
        dbKey: value.name,
        tsKey: key2,
        field: aliasedTableColumn(value, tableAlias),
        relationTableTsKey: void 0,
        isJson: false,
        selection: []
      }));
    } else {
      const aliasedColumns = Object.fromEntries(
        Object.entries(tableConfig.columns).map(([key2, value]) => [key2, aliasedTableColumn(value, tableAlias)])
      );
      if (config3.where) {
        const whereSql = typeof config3.where === "function" ? config3.where(aliasedColumns, getOperators()) : config3.where;
        where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
      }
      const fieldsSelection = [];
      let selectedColumns = [];
      if (config3.columns) {
        let isIncludeMode = false;
        for (const [field, value] of Object.entries(config3.columns)) {
          if (value === void 0) {
            continue;
          }
          if (field in tableConfig.columns) {
            if (!isIncludeMode && value === true) {
              isIncludeMode = true;
            }
            selectedColumns.push(field);
          }
        }
        if (selectedColumns.length > 0) {
          selectedColumns = isIncludeMode ? selectedColumns.filter((c2) => config3.columns?.[c2] === true) : Object.keys(tableConfig.columns).filter((key2) => !selectedColumns.includes(key2));
        }
      } else {
        selectedColumns = Object.keys(tableConfig.columns);
      }
      for (const field of selectedColumns) {
        const column = tableConfig.columns[field];
        fieldsSelection.push({ tsKey: field, value: column });
      }
      let selectedRelations = [];
      if (config3.with) {
        selectedRelations = Object.entries(config3.with).filter((entry) => !!entry[1]).map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey] }));
      }
      let extras;
      if (config3.extras) {
        extras = typeof config3.extras === "function" ? config3.extras(aliasedColumns, { sql }) : config3.extras;
        for (const [tsKey, value] of Object.entries(extras)) {
          fieldsSelection.push({
            tsKey,
            value: mapColumnsInAliasedSQLToAlias(value, tableAlias)
          });
        }
      }
      for (const { tsKey, value } of fieldsSelection) {
        selection.push({
          dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey].name,
          tsKey,
          field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
          relationTableTsKey: void 0,
          isJson: false,
          selection: []
        });
      }
      let orderByOrig = typeof config3.orderBy === "function" ? config3.orderBy(aliasedColumns, getOrderByOperators()) : config3.orderBy ?? [];
      if (!Array.isArray(orderByOrig)) {
        orderByOrig = [orderByOrig];
      }
      orderBy = orderByOrig.map((orderByValue) => {
        if (is(orderByValue, Column)) {
          return aliasedTableColumn(orderByValue, tableAlias);
        }
        return mapColumnsInSQLToAlias(orderByValue, tableAlias);
      });
      limit = config3.limit;
      offset = config3.offset;
      for (const {
        tsKey: selectedRelationTsKey,
        queryConfig: selectedRelationConfigValue,
        relation
      } of selectedRelations) {
        const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
        const relationTableName = relation.referencedTable[Table.Symbol.Name];
        const relationTableTsName = tableNamesMap[relationTableName];
        const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
        const joinOn2 = and(
          ...normalizedRelation.fields.map(
            (field2, i2) => eq(
              aliasedTableColumn(normalizedRelation.references[i2], relationTableAlias),
              aliasedTableColumn(field2, tableAlias)
            )
          )
        );
        const builtRelation = this.buildRelationalQuery({
          fullSchema,
          schema,
          tableNamesMap,
          table: fullSchema[relationTableTsName],
          tableConfig: schema[relationTableTsName],
          queryConfig: is(relation, One) ? selectedRelationConfigValue === true ? { limit: 1 } : { ...selectedRelationConfigValue, limit: 1 } : selectedRelationConfigValue,
          tableAlias: relationTableAlias,
          joinOn: joinOn2,
          nestedQueryRelation: relation
        });
        const field = sql`(${builtRelation.sql})`.as(selectedRelationTsKey);
        selection.push({
          dbKey: selectedRelationTsKey,
          tsKey: selectedRelationTsKey,
          field,
          relationTableTsKey: relationTableTsName,
          isJson: true,
          selection: builtRelation.selection
        });
      }
    }
    if (selection.length === 0) {
      throw new DrizzleError({
        message: `No fields selected for table "${tableConfig.tsName}" ("${tableAlias}"). You need to have at least one item in "columns", "with" or "extras". If you need to select all columns, omit the "columns" key or set it to undefined.`
      });
    }
    let result;
    where = and(joinOn, where);
    if (nestedQueryRelation) {
      let field = sql`json_array(${sql.join(
        selection.map(
          ({ field: field2 }) => is(field2, SQLiteColumn) ? sql.identifier(field2.name) : is(field2, SQL.Aliased) ? field2.sql : field2
        ),
        sql`, `
      )})`;
      if (is(nestedQueryRelation, Many)) {
        field = sql`coalesce(json_group_array(${field}), json_array())`;
      }
      const nestedSelection = [{
        dbKey: "data",
        tsKey: "data",
        field: field.as("data"),
        isJson: true,
        relationTableTsKey: tableConfig.tsName,
        selection
      }];
      const needsSubquery = limit !== void 0 || offset !== void 0 || orderBy.length > 0;
      if (needsSubquery) {
        result = this.buildSelectQuery({
          table: aliasedTable(table2, tableAlias),
          fields: {},
          fieldsFlat: [
            {
              path: [],
              field: sql.raw("*")
            }
          ],
          where,
          limit,
          offset,
          orderBy,
          setOperators: []
        });
        where = void 0;
        limit = void 0;
        offset = void 0;
        orderBy = void 0;
      } else {
        result = aliasedTable(table2, tableAlias);
      }
      result = this.buildSelectQuery({
        table: is(result, SQLiteTable) ? result : new Subquery(result, {}, tableAlias),
        fields: {},
        fieldsFlat: nestedSelection.map(({ field: field2 }) => ({
          path: [],
          field: is(field2, Column) ? aliasedTableColumn(field2, tableAlias) : field2
        })),
        joins,
        where,
        limit,
        offset,
        orderBy,
        setOperators: []
      });
    } else {
      result = this.buildSelectQuery({
        table: aliasedTable(table2, tableAlias),
        fields: {},
        fieldsFlat: selection.map(({ field }) => ({
          path: [],
          field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field
        })),
        joins,
        where,
        limit,
        offset,
        orderBy,
        setOperators: []
      });
    }
    return {
      tableTsKey: tableConfig.tsName,
      sql: result,
      selection
    };
  }
};
_a65 = entityKind;
__publicField(SQLiteDialect, _a65, "SQLiteDialect");
var _a66;
var SQLiteSyncDialect = class extends SQLiteDialect {
  migrate(migrations, session, config3) {
    const migrationsTable = config3 === void 0 ? "__drizzle_migrations" : typeof config3 === "string" ? "__drizzle_migrations" : config3.migrationsTable ?? "__drizzle_migrations";
    const migrationTableCreate = sql`
			CREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsTable)} (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at numeric
			)
		`;
    session.run(migrationTableCreate);
    const dbMigrations = session.values(
      sql`SELECT id, hash, created_at FROM ${sql.identifier(migrationsTable)} ORDER BY created_at DESC LIMIT 1`
    );
    const lastDbMigration = dbMigrations[0] ?? void 0;
    session.run(sql`BEGIN`);
    try {
      for (const migration of migrations) {
        if (!lastDbMigration || Number(lastDbMigration[2]) < migration.folderMillis) {
          for (const stmt of migration.sql) {
            session.run(sql.raw(stmt));
          }
          session.run(
            sql`INSERT INTO ${sql.identifier(migrationsTable)} ("hash", "created_at") VALUES(${migration.hash}, ${migration.folderMillis})`
          );
        }
      }
      session.run(sql`COMMIT`);
    } catch (e2) {
      session.run(sql`ROLLBACK`);
      throw e2;
    }
  }
};
_a66 = entityKind;
__publicField(SQLiteSyncDialect, _a66, "SQLiteSyncDialect");
var _a67;
var SQLiteAsyncDialect = class extends SQLiteDialect {
  async migrate(migrations, session, config3) {
    const migrationsTable = config3 === void 0 ? "__drizzle_migrations" : typeof config3 === "string" ? "__drizzle_migrations" : config3.migrationsTable ?? "__drizzle_migrations";
    const migrationTableCreate = sql`
			CREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsTable)} (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at numeric
			)
		`;
    await session.run(migrationTableCreate);
    const dbMigrations = await session.values(
      sql`SELECT id, hash, created_at FROM ${sql.identifier(migrationsTable)} ORDER BY created_at DESC LIMIT 1`
    );
    const lastDbMigration = dbMigrations[0] ?? void 0;
    await session.transaction(async (tx) => {
      for (const migration of migrations) {
        if (!lastDbMigration || Number(lastDbMigration[2]) < migration.folderMillis) {
          for (const stmt of migration.sql) {
            await tx.run(sql.raw(stmt));
          }
          await tx.run(
            sql`INSERT INTO ${sql.identifier(migrationsTable)} ("hash", "created_at") VALUES(${migration.hash}, ${migration.folderMillis})`
          );
        }
      }
    });
  }
};
_a67 = entityKind;
__publicField(SQLiteAsyncDialect, _a67, "SQLiteAsyncDialect");

// node_modules/drizzle-orm/sqlite-core/query-builders/select.js
init_process();
init_buffer();

// node_modules/drizzle-orm/query-builders/query-builder.js
init_process();
init_buffer();
var _a68;
var TypedQueryBuilder = class {
  /** @internal */
  getSelectedFields() {
    return this._.selectedFields;
  }
};
_a68 = entityKind;
__publicField(TypedQueryBuilder, _a68, "TypedQueryBuilder");

// node_modules/drizzle-orm/sqlite-core/query-builders/select.js
var _a69;
var SQLiteSelectBuilder = class {
  fields;
  session;
  dialect;
  withList;
  distinct;
  constructor(config3) {
    this.fields = config3.fields;
    this.session = config3.session;
    this.dialect = config3.dialect;
    this.withList = config3.withList;
    this.distinct = config3.distinct;
  }
  from(source) {
    const isPartialSelect = !!this.fields;
    let fields;
    if (this.fields) {
      fields = this.fields;
    } else if (is(source, Subquery)) {
      fields = Object.fromEntries(
        Object.keys(source._.selectedFields).map((key2) => [key2, source[key2]])
      );
    } else if (is(source, SQLiteViewBase)) {
      fields = source[ViewBaseConfig].selectedFields;
    } else if (is(source, SQL)) {
      fields = {};
    } else {
      fields = getTableColumns(source);
    }
    return new SQLiteSelectBase({
      table: source,
      fields,
      isPartialSelect,
      session: this.session,
      dialect: this.dialect,
      withList: this.withList,
      distinct: this.distinct
    });
  }
};
_a69 = entityKind;
__publicField(SQLiteSelectBuilder, _a69, "SQLiteSelectBuilder");
var _a70;
var SQLiteSelectQueryBuilderBase = class extends TypedQueryBuilder {
  _;
  /** @internal */
  config;
  joinsNotNullableMap;
  tableName;
  isPartialSelect;
  session;
  dialect;
  constructor({ table: table2, fields, isPartialSelect, session, dialect, withList, distinct }) {
    super();
    this.config = {
      withList,
      table: table2,
      fields: { ...fields },
      distinct,
      setOperators: []
    };
    this.isPartialSelect = isPartialSelect;
    this.session = session;
    this.dialect = dialect;
    this._ = {
      selectedFields: fields
    };
    this.tableName = getTableLikeName(table2);
    this.joinsNotNullableMap = typeof this.tableName === "string" ? { [this.tableName]: true } : {};
  }
  createJoin(joinType) {
    return (table2, on3) => {
      const baseTableName = this.tableName;
      const tableName = getTableLikeName(table2);
      if (typeof tableName === "string" && this.config.joins?.some((join3) => join3.alias === tableName)) {
        throw new Error(`Alias "${tableName}" is already used in this query`);
      }
      if (!this.isPartialSelect) {
        if (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === "string") {
          this.config.fields = {
            [baseTableName]: this.config.fields
          };
        }
        if (typeof tableName === "string" && !is(table2, SQL)) {
          const selection = is(table2, Subquery) ? table2._.selectedFields : is(table2, View) ? table2[ViewBaseConfig].selectedFields : table2[Table.Symbol.Columns];
          this.config.fields[tableName] = selection;
        }
      }
      if (typeof on3 === "function") {
        on3 = on3(
          new Proxy(
            this.config.fields,
            new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
          )
        );
      }
      if (!this.config.joins) {
        this.config.joins = [];
      }
      this.config.joins.push({ on: on3, table: table2, joinType, alias: tableName });
      if (typeof tableName === "string") {
        switch (joinType) {
          case "left": {
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
          case "right": {
            this.joinsNotNullableMap = Object.fromEntries(
              Object.entries(this.joinsNotNullableMap).map(([key2]) => [key2, false])
            );
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "inner": {
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "full": {
            this.joinsNotNullableMap = Object.fromEntries(
              Object.entries(this.joinsNotNullableMap).map(([key2]) => [key2, false])
            );
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
        }
      }
      return this;
    };
  }
  /**
   * Executes a `left join` operation by adding another table to the current query.
   *
   * Calling this method associates each row of the table with the corresponding row from the joined table, if a match is found. If no matching row exists, it sets all columns of the joined table to null.
   *
   * See docs: {@link https://orm.drizzle.team/docs/joins#left-join}
   *
   * @param table the table to join.
   * @param on the `on` clause.
   *
   * @example
   *
   * ```ts
   * // Select all users and their pets
   * const usersWithPets: { user: User; pets: Pet | null }[] = await db.select()
   *   .from(users)
   *   .leftJoin(pets, eq(users.id, pets.ownerId))
   *
   * // Select userId and petId
   * const usersIdsAndPetIds: { userId: number; petId: number | null }[] = await db.select({
   *   userId: users.id,
   *   petId: pets.id,
   * })
   *   .from(users)
   *   .leftJoin(pets, eq(users.id, pets.ownerId))
   * ```
   */
  leftJoin = this.createJoin("left");
  /**
   * Executes a `right join` operation by adding another table to the current query.
   *
   * Calling this method associates each row of the joined table with the corresponding row from the main table, if a match is found. If no matching row exists, it sets all columns of the main table to null.
   *
   * See docs: {@link https://orm.drizzle.team/docs/joins#right-join}
   *
   * @param table the table to join.
   * @param on the `on` clause.
   *
   * @example
   *
   * ```ts
   * // Select all users and their pets
   * const usersWithPets: { user: User | null; pets: Pet }[] = await db.select()
   *   .from(users)
   *   .rightJoin(pets, eq(users.id, pets.ownerId))
   *
   * // Select userId and petId
   * const usersIdsAndPetIds: { userId: number | null; petId: number }[] = await db.select({
   *   userId: users.id,
   *   petId: pets.id,
   * })
   *   .from(users)
   *   .rightJoin(pets, eq(users.id, pets.ownerId))
   * ```
   */
  rightJoin = this.createJoin("right");
  /**
   * Executes an `inner join` operation, creating a new table by combining rows from two tables that have matching values.
   *
   * Calling this method retrieves rows that have corresponding entries in both joined tables. Rows without matching entries in either table are excluded, resulting in a table that includes only matching pairs.
   *
   * See docs: {@link https://orm.drizzle.team/docs/joins#inner-join}
   *
   * @param table the table to join.
   * @param on the `on` clause.
   *
   * @example
   *
   * ```ts
   * // Select all users and their pets
   * const usersWithPets: { user: User; pets: Pet }[] = await db.select()
   *   .from(users)
   *   .innerJoin(pets, eq(users.id, pets.ownerId))
   *
   * // Select userId and petId
   * const usersIdsAndPetIds: { userId: number; petId: number }[] = await db.select({
   *   userId: users.id,
   *   petId: pets.id,
   * })
   *   .from(users)
   *   .innerJoin(pets, eq(users.id, pets.ownerId))
   * ```
   */
  innerJoin = this.createJoin("inner");
  /**
   * Executes a `full join` operation by combining rows from two tables into a new table.
   *
   * Calling this method retrieves all rows from both main and joined tables, merging rows with matching values and filling in `null` for non-matching columns.
   *
   * See docs: {@link https://orm.drizzle.team/docs/joins#full-join}
   *
   * @param table the table to join.
   * @param on the `on` clause.
   *
   * @example
   *
   * ```ts
   * // Select all users and their pets
   * const usersWithPets: { user: User | null; pets: Pet | null }[] = await db.select()
   *   .from(users)
   *   .fullJoin(pets, eq(users.id, pets.ownerId))
   *
   * // Select userId and petId
   * const usersIdsAndPetIds: { userId: number | null; petId: number | null }[] = await db.select({
   *   userId: users.id,
   *   petId: pets.id,
   * })
   *   .from(users)
   *   .fullJoin(pets, eq(users.id, pets.ownerId))
   * ```
   */
  fullJoin = this.createJoin("full");
  createSetOperator(type, isAll) {
    return (rightSelection) => {
      const rightSelect = typeof rightSelection === "function" ? rightSelection(getSQLiteSetOperators()) : rightSelection;
      if (!haveSameKeys(this.getSelectedFields(), rightSelect.getSelectedFields())) {
        throw new Error(
          "Set operator error (union / intersect / except): selected fields are not the same or are in a different order"
        );
      }
      this.config.setOperators.push({ type, isAll, rightSelect });
      return this;
    };
  }
  /**
   * Adds `union` set operator to the query.
   *
   * Calling this method will combine the result sets of the `select` statements and remove any duplicate rows that appear across them.
   *
   * See docs: {@link https://orm.drizzle.team/docs/set-operations#union}
   *
   * @example
   *
   * ```ts
   * // Select all unique names from customers and users tables
   * await db.select({ name: users.name })
   *   .from(users)
   *   .union(
   *     db.select({ name: customers.name }).from(customers)
   *   );
   * // or
   * import { union } from 'drizzle-orm/sqlite-core'
   *
   * await union(
   *   db.select({ name: users.name }).from(users),
   *   db.select({ name: customers.name }).from(customers)
   * );
   * ```
   */
  union = this.createSetOperator("union", false);
  /**
   * Adds `union all` set operator to the query.
   *
   * Calling this method will combine the result-set of the `select` statements and keep all duplicate rows that appear across them.
   *
   * See docs: {@link https://orm.drizzle.team/docs/set-operations#union-all}
   *
   * @example
   *
   * ```ts
   * // Select all transaction ids from both online and in-store sales
   * await db.select({ transaction: onlineSales.transactionId })
   *   .from(onlineSales)
   *   .unionAll(
   *     db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)
   *   );
   * // or
   * import { unionAll } from 'drizzle-orm/sqlite-core'
   *
   * await unionAll(
   *   db.select({ transaction: onlineSales.transactionId }).from(onlineSales),
   *   db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)
   * );
   * ```
   */
  unionAll = this.createSetOperator("union", true);
  /**
   * Adds `intersect` set operator to the query.
   *
   * Calling this method will retain only the rows that are present in both result sets and eliminate duplicates.
   *
   * See docs: {@link https://orm.drizzle.team/docs/set-operations#intersect}
   *
   * @example
   *
   * ```ts
   * // Select course names that are offered in both departments A and B
   * await db.select({ courseName: depA.courseName })
   *   .from(depA)
   *   .intersect(
   *     db.select({ courseName: depB.courseName }).from(depB)
   *   );
   * // or
   * import { intersect } from 'drizzle-orm/sqlite-core'
   *
   * await intersect(
   *   db.select({ courseName: depA.courseName }).from(depA),
   *   db.select({ courseName: depB.courseName }).from(depB)
   * );
   * ```
   */
  intersect = this.createSetOperator("intersect", false);
  /**
   * Adds `except` set operator to the query.
   *
   * Calling this method will retrieve all unique rows from the left query, except for the rows that are present in the result set of the right query.
   *
   * See docs: {@link https://orm.drizzle.team/docs/set-operations#except}
   *
   * @example
   *
   * ```ts
   * // Select all courses offered in department A but not in department B
   * await db.select({ courseName: depA.courseName })
   *   .from(depA)
   *   .except(
   *     db.select({ courseName: depB.courseName }).from(depB)
   *   );
   * // or
   * import { except } from 'drizzle-orm/sqlite-core'
   *
   * await except(
   *   db.select({ courseName: depA.courseName }).from(depA),
   *   db.select({ courseName: depB.courseName }).from(depB)
   * );
   * ```
   */
  except = this.createSetOperator("except", false);
  /** @internal */
  addSetOperators(setOperators) {
    this.config.setOperators.push(...setOperators);
    return this;
  }
  /**
   * Adds a `where` clause to the query.
   *
   * Calling this method will select only those rows that fulfill a specified condition.
   *
   * See docs: {@link https://orm.drizzle.team/docs/select#filtering}
   *
   * @param where the `where` clause.
   *
   * @example
   * You can use conditional operators and `sql function` to filter the rows to be selected.
   *
   * ```ts
   * // Select all cars with green color
   * await db.select().from(cars).where(eq(cars.color, 'green'));
   * // or
   * await db.select().from(cars).where(sql`${cars.color} = 'green'`)
   * ```
   *
   * You can logically combine conditional operators with `and()` and `or()` operators:
   *
   * ```ts
   * // Select all BMW cars with a green color
   * await db.select().from(cars).where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));
   *
   * // Select all cars with the green or blue color
   * await db.select().from(cars).where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));
   * ```
   */
  where(where) {
    if (typeof where === "function") {
      where = where(
        new Proxy(
          this.config.fields,
          new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
        )
      );
    }
    this.config.where = where;
    return this;
  }
  /**
   * Adds a `having` clause to the query.
   *
   * Calling this method will select only those rows that fulfill a specified condition. It is typically used with aggregate functions to filter the aggregated data based on a specified condition.
   *
   * See docs: {@link https://orm.drizzle.team/docs/select#aggregations}
   *
   * @param having the `having` clause.
   *
   * @example
   *
   * ```ts
   * // Select all brands with more than one car
   * await db.select({
   * 	brand: cars.brand,
   * 	count: sql<number>`cast(count(${cars.id}) as int)`,
   * })
   *   .from(cars)
   *   .groupBy(cars.brand)
   *   .having(({ count }) => gt(count, 1));
   * ```
   */
  having(having) {
    if (typeof having === "function") {
      having = having(
        new Proxy(
          this.config.fields,
          new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
        )
      );
    }
    this.config.having = having;
    return this;
  }
  groupBy(...columns) {
    if (typeof columns[0] === "function") {
      const groupBy = columns[0](
        new Proxy(
          this.config.fields,
          new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })
        )
      );
      this.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];
    } else {
      this.config.groupBy = columns;
    }
    return this;
  }
  orderBy(...columns) {
    if (typeof columns[0] === "function") {
      const orderBy = columns[0](
        new Proxy(
          this.config.fields,
          new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })
        )
      );
      const orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];
      if (this.config.setOperators.length > 0) {
        this.config.setOperators.at(-1).orderBy = orderByArray;
      } else {
        this.config.orderBy = orderByArray;
      }
    } else {
      const orderByArray = columns;
      if (this.config.setOperators.length > 0) {
        this.config.setOperators.at(-1).orderBy = orderByArray;
      } else {
        this.config.orderBy = orderByArray;
      }
    }
    return this;
  }
  /**
   * Adds a `limit` clause to the query.
   *
   * Calling this method will set the maximum number of rows that will be returned by this query.
   *
   * See docs: {@link https://orm.drizzle.team/docs/select#limit--offset}
   *
   * @param limit the `limit` clause.
   *
   * @example
   *
   * ```ts
   * // Get the first 10 people from this query.
   * await db.select().from(people).limit(10);
   * ```
   */
  limit(limit) {
    if (this.config.setOperators.length > 0) {
      this.config.setOperators.at(-1).limit = limit;
    } else {
      this.config.limit = limit;
    }
    return this;
  }
  /**
   * Adds an `offset` clause to the query.
   *
   * Calling this method will skip a number of rows when returning results from this query.
   *
   * See docs: {@link https://orm.drizzle.team/docs/select#limit--offset}
   *
   * @param offset the `offset` clause.
   *
   * @example
   *
   * ```ts
   * // Get the 10th-20th people from this query.
   * await db.select().from(people).offset(10).limit(10);
   * ```
   */
  offset(offset) {
    if (this.config.setOperators.length > 0) {
      this.config.setOperators.at(-1).offset = offset;
    } else {
      this.config.offset = offset;
    }
    return this;
  }
  /** @internal */
  getSQL() {
    return this.dialect.buildSelectQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  as(alias) {
    return new Proxy(
      new Subquery(this.getSQL(), this.config.fields, alias),
      new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
    );
  }
  /** @internal */
  getSelectedFields() {
    return new Proxy(
      this.config.fields,
      new SelectionProxyHandler({ alias: this.tableName, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
    );
  }
  $dynamic() {
    return this;
  }
};
_a70 = entityKind;
__publicField(SQLiteSelectQueryBuilderBase, _a70, "SQLiteSelectQueryBuilder");
var _a71;
var SQLiteSelectBase = class extends SQLiteSelectQueryBuilderBase {
  /** @internal */
  _prepare(isOneTimeQuery = true) {
    if (!this.session) {
      throw new Error("Cannot execute a query on a query builder. Please use a database instance instead.");
    }
    const fieldsList = orderSelectedFields(this.config.fields);
    const query = this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](
      this.dialect.sqlToQuery(this.getSQL()),
      fieldsList,
      "all",
      true
    );
    query.joinsNotNullableMap = this.joinsNotNullableMap;
    return query;
  }
  prepare() {
    return this._prepare(false);
  }
  run = (placeholderValues) => {
    return this._prepare().run(placeholderValues);
  };
  all = (placeholderValues) => {
    return this._prepare().all(placeholderValues);
  };
  get = (placeholderValues) => {
    return this._prepare().get(placeholderValues);
  };
  values = (placeholderValues) => {
    return this._prepare().values(placeholderValues);
  };
  async execute() {
    return this.all();
  }
};
_a71 = entityKind;
__publicField(SQLiteSelectBase, _a71, "SQLiteSelect");
applyMixins(SQLiteSelectBase, [QueryPromise]);
function createSetOperator(type, isAll) {
  return (leftSelect, rightSelect, ...restSelects) => {
    const setOperators = [rightSelect, ...restSelects].map((select) => ({
      type,
      isAll,
      rightSelect: select
    }));
    for (const setOperator of setOperators) {
      if (!haveSameKeys(leftSelect.getSelectedFields(), setOperator.rightSelect.getSelectedFields())) {
        throw new Error(
          "Set operator error (union / intersect / except): selected fields are not the same or are in a different order"
        );
      }
    }
    return leftSelect.addSetOperators(setOperators);
  };
}
var getSQLiteSetOperators = () => ({
  union,
  unionAll,
  intersect,
  except
});
var union = createSetOperator("union", false);
var unionAll = createSetOperator("union", true);
var intersect = createSetOperator("intersect", false);
var except = createSetOperator("except", false);

// node_modules/drizzle-orm/sqlite-core/query-builders/query-builder.js
var _a72;
var QueryBuilder = class {
  dialect;
  $with(alias) {
    const queryBuilder = this;
    return {
      as(qb) {
        if (typeof qb === "function") {
          qb = qb(queryBuilder);
        }
        return new Proxy(
          new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias, true),
          new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
        );
      }
    };
  }
  with(...queries) {
    const self2 = this;
    function select(fields) {
      return new SQLiteSelectBuilder({
        fields: fields ?? void 0,
        session: void 0,
        dialect: self2.getDialect(),
        withList: queries
      });
    }
    function selectDistinct(fields) {
      return new SQLiteSelectBuilder({
        fields: fields ?? void 0,
        session: void 0,
        dialect: self2.getDialect(),
        withList: queries,
        distinct: true
      });
    }
    return { select, selectDistinct };
  }
  select(fields) {
    return new SQLiteSelectBuilder({ fields: fields ?? void 0, session: void 0, dialect: this.getDialect() });
  }
  selectDistinct(fields) {
    return new SQLiteSelectBuilder({
      fields: fields ?? void 0,
      session: void 0,
      dialect: this.getDialect(),
      distinct: true
    });
  }
  // Lazy load dialect to avoid circular dependency
  getDialect() {
    if (!this.dialect) {
      this.dialect = new SQLiteSyncDialect();
    }
    return this.dialect;
  }
};
_a72 = entityKind;
__publicField(QueryBuilder, _a72, "SQLiteQueryBuilder");

// node_modules/drizzle-orm/sqlite-core/query-builders/update.js
init_process();
init_buffer();
var _a73;
var SQLiteUpdateBuilder = class {
  constructor(table2, session, dialect, withList) {
    this.table = table2;
    this.session = session;
    this.dialect = dialect;
    this.withList = withList;
  }
  set(values) {
    return new SQLiteUpdateBase(
      this.table,
      mapUpdateSet(this.table, values),
      this.session,
      this.dialect,
      this.withList
    );
  }
};
_a73 = entityKind;
__publicField(SQLiteUpdateBuilder, _a73, "SQLiteUpdateBuilder");
var _a74;
var SQLiteUpdateBase = class extends QueryPromise {
  constructor(table2, set, session, dialect, withList) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { set, table: table2, withList };
  }
  /** @internal */
  config;
  /**
   * Adds a 'where' clause to the query.
   *
   * Calling this method will update only those rows that fulfill a specified condition.
   *
   * See docs: {@link https://orm.drizzle.team/docs/update}
   *
   * @param where the 'where' clause.
   *
   * @example
   * You can use conditional operators and `sql function` to filter the rows to be updated.
   *
   * ```ts
   * // Update all cars with green color
   * db.update(cars).set({ color: 'red' })
   *   .where(eq(cars.color, 'green'));
   * // or
   * db.update(cars).set({ color: 'red' })
   *   .where(sql`${cars.color} = 'green'`)
   * ```
   *
   * You can logically combine conditional operators with `and()` and `or()` operators:
   *
   * ```ts
   * // Update all BMW cars with a green color
   * db.update(cars).set({ color: 'red' })
   *   .where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));
   *
   * // Update all cars with the green or blue color
   * db.update(cars).set({ color: 'red' })
   *   .where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));
   * ```
   */
  where(where) {
    this.config.where = where;
    return this;
  }
  returning(fields = this.config.table[SQLiteTable.Symbol.Columns]) {
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  /** @internal */
  getSQL() {
    return this.dialect.buildUpdateQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  /** @internal */
  _prepare(isOneTimeQuery = true) {
    return this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](
      this.dialect.sqlToQuery(this.getSQL()),
      this.config.returning,
      this.config.returning ? "all" : "run",
      true
    );
  }
  prepare() {
    return this._prepare(false);
  }
  run = (placeholderValues) => {
    return this._prepare().run(placeholderValues);
  };
  all = (placeholderValues) => {
    return this._prepare().all(placeholderValues);
  };
  get = (placeholderValues) => {
    return this._prepare().get(placeholderValues);
  };
  values = (placeholderValues) => {
    return this._prepare().values(placeholderValues);
  };
  async execute() {
    return this.config.returning ? this.all() : this.run();
  }
  $dynamic() {
    return this;
  }
};
_a74 = entityKind;
__publicField(SQLiteUpdateBase, _a74, "SQLiteUpdate");

// node_modules/drizzle-orm/sqlite-core/query-builders/query.js
init_process();
init_buffer();
var _a75;
var RelationalQueryBuilder = class {
  constructor(mode, fullSchema, schema, tableNamesMap, table2, tableConfig, dialect, session) {
    this.mode = mode;
    this.fullSchema = fullSchema;
    this.schema = schema;
    this.tableNamesMap = tableNamesMap;
    this.table = table2;
    this.tableConfig = tableConfig;
    this.dialect = dialect;
    this.session = session;
  }
  findMany(config3) {
    return this.mode === "sync" ? new SQLiteSyncRelationalQuery(
      this.fullSchema,
      this.schema,
      this.tableNamesMap,
      this.table,
      this.tableConfig,
      this.dialect,
      this.session,
      config3 ? config3 : {},
      "many"
    ) : new SQLiteRelationalQuery(
      this.fullSchema,
      this.schema,
      this.tableNamesMap,
      this.table,
      this.tableConfig,
      this.dialect,
      this.session,
      config3 ? config3 : {},
      "many"
    );
  }
  findFirst(config3) {
    return this.mode === "sync" ? new SQLiteSyncRelationalQuery(
      this.fullSchema,
      this.schema,
      this.tableNamesMap,
      this.table,
      this.tableConfig,
      this.dialect,
      this.session,
      config3 ? { ...config3, limit: 1 } : { limit: 1 },
      "first"
    ) : new SQLiteRelationalQuery(
      this.fullSchema,
      this.schema,
      this.tableNamesMap,
      this.table,
      this.tableConfig,
      this.dialect,
      this.session,
      config3 ? { ...config3, limit: 1 } : { limit: 1 },
      "first"
    );
  }
};
_a75 = entityKind;
__publicField(RelationalQueryBuilder, _a75, "SQLiteAsyncRelationalQueryBuilder");
var _a76;
var SQLiteRelationalQuery = class extends QueryPromise {
  constructor(fullSchema, schema, tableNamesMap, table2, tableConfig, dialect, session, config3, mode) {
    super();
    this.fullSchema = fullSchema;
    this.schema = schema;
    this.tableNamesMap = tableNamesMap;
    this.table = table2;
    this.tableConfig = tableConfig;
    this.dialect = dialect;
    this.session = session;
    this.config = config3;
    this.mode = mode;
  }
  /** @internal */
  mode;
  /** @internal */
  getSQL() {
    return this.dialect.buildRelationalQuery({
      fullSchema: this.fullSchema,
      schema: this.schema,
      tableNamesMap: this.tableNamesMap,
      table: this.table,
      tableConfig: this.tableConfig,
      queryConfig: this.config,
      tableAlias: this.tableConfig.tsName
    }).sql;
  }
  /** @internal */
  _prepare(isOneTimeQuery = false) {
    const { query, builtQuery } = this._toSQL();
    return this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](
      builtQuery,
      void 0,
      this.mode === "first" ? "get" : "all",
      true,
      (rawRows, mapColumnValue) => {
        const rows = rawRows.map(
          (row) => mapRelationalRow(this.schema, this.tableConfig, row, query.selection, mapColumnValue)
        );
        if (this.mode === "first") {
          return rows[0];
        }
        return rows;
      }
    );
  }
  prepare() {
    return this._prepare(false);
  }
  _toSQL() {
    const query = this.dialect.buildRelationalQuery({
      fullSchema: this.fullSchema,
      schema: this.schema,
      tableNamesMap: this.tableNamesMap,
      table: this.table,
      tableConfig: this.tableConfig,
      queryConfig: this.config,
      tableAlias: this.tableConfig.tsName
    });
    const builtQuery = this.dialect.sqlToQuery(query.sql);
    return { query, builtQuery };
  }
  toSQL() {
    return this._toSQL().builtQuery;
  }
  /** @internal */
  executeRaw() {
    if (this.mode === "first") {
      return this._prepare(false).get();
    }
    return this._prepare(false).all();
  }
  async execute() {
    return this.executeRaw();
  }
};
_a76 = entityKind;
__publicField(SQLiteRelationalQuery, _a76, "SQLiteAsyncRelationalQuery");
var _a77;
var SQLiteSyncRelationalQuery = class extends SQLiteRelationalQuery {
  sync() {
    return this.executeRaw();
  }
};
_a77 = entityKind;
__publicField(SQLiteSyncRelationalQuery, _a77, "SQLiteSyncRelationalQuery");

// node_modules/drizzle-orm/sqlite-core/query-builders/raw.js
init_process();
init_buffer();
var _a78;
var SQLiteRaw = class extends QueryPromise {
  constructor(execute, getSQL, action, dialect, mapBatchResult) {
    super();
    this.execute = execute;
    this.getSQL = getSQL;
    this.dialect = dialect;
    this.mapBatchResult = mapBatchResult;
    this.config = { action };
  }
  /** @internal */
  config;
  getQuery() {
    return { ...this.dialect.sqlToQuery(this.getSQL()), method: this.config.action };
  }
  mapResult(result, isFromBatch) {
    return isFromBatch ? this.mapBatchResult(result) : result;
  }
  _prepare() {
    return this;
  }
  /** @internal */
  isResponseInArrayMode() {
    return false;
  }
};
_a78 = entityKind;
__publicField(SQLiteRaw, _a78, "SQLiteRaw");

// node_modules/drizzle-orm/sqlite-core/db.js
var _a79;
var BaseSQLiteDatabase = class {
  constructor(resultKind, dialect, session, schema) {
    this.resultKind = resultKind;
    this.dialect = dialect;
    this.session = session;
    this._ = schema ? {
      schema: schema.schema,
      fullSchema: schema.fullSchema,
      tableNamesMap: schema.tableNamesMap
    } : {
      schema: void 0,
      fullSchema: {},
      tableNamesMap: {}
    };
    this.query = {};
    const query = this.query;
    if (this._.schema) {
      for (const [tableName, columns] of Object.entries(this._.schema)) {
        query[tableName] = new RelationalQueryBuilder(
          resultKind,
          schema.fullSchema,
          this._.schema,
          this._.tableNamesMap,
          schema.fullSchema[tableName],
          columns,
          dialect,
          session
        );
      }
    }
  }
  query;
  /**
   * Creates a subquery that defines a temporary named result set as a CTE.
   *
   * It is useful for breaking down complex queries into simpler parts and for reusing the result set in subsequent parts of the query.
   *
   * See docs: {@link https://orm.drizzle.team/docs/select#with-clause}
   *
   * @param alias The alias for the subquery.
   *
   * Failure to provide an alias will result in a DrizzleTypeError, preventing the subquery from being referenced in other queries.
   *
   * @example
   *
   * ```ts
   * // Create a subquery with alias 'sq' and use it in the select query
   * const sq = db.$with('sq').as(db.select().from(users).where(eq(users.id, 42)));
   *
   * const result = await db.with(sq).select().from(sq);
   * ```
   *
   * To select arbitrary SQL values as fields in a CTE and reference them in other CTEs or in the main query, you need to add aliases to them:
   *
   * ```ts
   * // Select an arbitrary SQL value as a field in a CTE and reference it in the main query
   * const sq = db.$with('sq').as(db.select({
   *   name: sql<string>`upper(${users.name})`.as('name'),
   * })
   * .from(users));
   *
   * const result = await db.with(sq).select({ name: sq.name }).from(sq);
   * ```
   */
  $with(alias) {
    return {
      as(qb) {
        if (typeof qb === "function") {
          qb = qb(new QueryBuilder());
        }
        return new Proxy(
          new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias, true),
          new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
        );
      }
    };
  }
  /**
   * Incorporates a previously defined CTE (using `$with`) into the main query.
   *
   * This method allows the main query to reference a temporary named result set.
   *
   * See docs: {@link https://orm.drizzle.team/docs/select#with-clause}
   *
   * @param queries The CTEs to incorporate into the main query.
   *
   * @example
   *
   * ```ts
   * // Define a subquery 'sq' as a CTE using $with
   * const sq = db.$with('sq').as(db.select().from(users).where(eq(users.id, 42)));
   *
   * // Incorporate the CTE 'sq' into the main query and select from it
   * const result = await db.with(sq).select().from(sq);
   * ```
   */
  with(...queries) {
    const self2 = this;
    function select(fields) {
      return new SQLiteSelectBuilder({
        fields: fields ?? void 0,
        session: self2.session,
        dialect: self2.dialect,
        withList: queries
      });
    }
    function selectDistinct(fields) {
      return new SQLiteSelectBuilder({
        fields: fields ?? void 0,
        session: self2.session,
        dialect: self2.dialect,
        withList: queries,
        distinct: true
      });
    }
    function update(table2) {
      return new SQLiteUpdateBuilder(table2, self2.session, self2.dialect, queries);
    }
    function insert(into) {
      return new SQLiteInsertBuilder(into, self2.session, self2.dialect, queries);
    }
    function delete_(from3) {
      return new SQLiteDeleteBase(from3, self2.session, self2.dialect, queries);
    }
    return { select, selectDistinct, update, insert, delete: delete_ };
  }
  select(fields) {
    return new SQLiteSelectBuilder({ fields: fields ?? void 0, session: this.session, dialect: this.dialect });
  }
  selectDistinct(fields) {
    return new SQLiteSelectBuilder({
      fields: fields ?? void 0,
      session: this.session,
      dialect: this.dialect,
      distinct: true
    });
  }
  /**
   * Creates an update query.
   *
   * Calling this method without `.where()` clause will update all rows in a table. The `.where()` clause specifies which rows should be updated.
   *
   * Use `.set()` method to specify which values to update.
   *
   * See docs: {@link https://orm.drizzle.team/docs/update}
   *
   * @param table The table to update.
   *
   * @example
   *
   * ```ts
   * // Update all rows in the 'cars' table
   * await db.update(cars).set({ color: 'red' });
   *
   * // Update rows with filters and conditions
   * await db.update(cars).set({ color: 'red' }).where(eq(cars.brand, 'BMW'));
   *
   * // Update with returning clause
   * const updatedCar: Car[] = await db.update(cars)
   *   .set({ color: 'red' })
   *   .where(eq(cars.id, 1))
   *   .returning();
   * ```
   */
  update(table2) {
    return new SQLiteUpdateBuilder(table2, this.session, this.dialect);
  }
  /**
   * Creates an insert query.
   *
   * Calling this method will create new rows in a table. Use `.values()` method to specify which values to insert.
   *
   * See docs: {@link https://orm.drizzle.team/docs/insert}
   *
   * @param table The table to insert into.
   *
   * @example
   *
   * ```ts
   * // Insert one row
   * await db.insert(cars).values({ brand: 'BMW' });
   *
   * // Insert multiple rows
   * await db.insert(cars).values([{ brand: 'BMW' }, { brand: 'Porsche' }]);
   *
   * // Insert with returning clause
   * const insertedCar: Car[] = await db.insert(cars)
   *   .values({ brand: 'BMW' })
   *   .returning();
   * ```
   */
  insert(into) {
    return new SQLiteInsertBuilder(into, this.session, this.dialect);
  }
  /**
   * Creates a delete query.
   *
   * Calling this method without `.where()` clause will delete all rows in a table. The `.where()` clause specifies which rows should be deleted.
   *
   * See docs: {@link https://orm.drizzle.team/docs/delete}
   *
   * @param table The table to delete from.
   *
   * @example
   *
   * ```ts
   * // Delete all rows in the 'cars' table
   * await db.delete(cars);
   *
   * // Delete rows with filters and conditions
   * await db.delete(cars).where(eq(cars.color, 'green'));
   *
   * // Delete with returning clause
   * const deletedCar: Car[] = await db.delete(cars)
   *   .where(eq(cars.id, 1))
   *   .returning();
   * ```
   */
  delete(from3) {
    return new SQLiteDeleteBase(from3, this.session, this.dialect);
  }
  run(query) {
    const sql2 = query.getSQL();
    if (this.resultKind === "async") {
      return new SQLiteRaw(
        async () => this.session.run(sql2),
        () => sql2,
        "run",
        this.dialect,
        this.session.extractRawRunValueFromBatchResult.bind(this.session)
      );
    }
    return this.session.run(sql2);
  }
  all(query) {
    const sql2 = query.getSQL();
    if (this.resultKind === "async") {
      return new SQLiteRaw(
        async () => this.session.all(sql2),
        () => sql2,
        "all",
        this.dialect,
        this.session.extractRawAllValueFromBatchResult.bind(this.session)
      );
    }
    return this.session.all(sql2);
  }
  get(query) {
    const sql2 = query.getSQL();
    if (this.resultKind === "async") {
      return new SQLiteRaw(
        async () => this.session.get(sql2),
        () => sql2,
        "get",
        this.dialect,
        this.session.extractRawGetValueFromBatchResult.bind(this.session)
      );
    }
    return this.session.get(sql2);
  }
  values(query) {
    const sql2 = query.getSQL();
    if (this.resultKind === "async") {
      return new SQLiteRaw(
        async () => this.session.values(sql2),
        () => sql2,
        "values",
        this.dialect,
        this.session.extractRawValuesValueFromBatchResult.bind(this.session)
      );
    }
    return this.session.values(sql2);
  }
  transaction(transaction, config3) {
    return this.session.transaction(transaction, config3);
  }
};
_a79 = entityKind;
__publicField(BaseSQLiteDatabase, _a79, "BaseSQLiteDatabase");

// node_modules/drizzle-orm/d1/session.js
init_process();
init_buffer();

// node_modules/drizzle-orm/sqlite-core/session.js
init_process();
init_buffer();
var _a80;
var ExecuteResultSync = class extends QueryPromise {
  constructor(resultCb) {
    super();
    this.resultCb = resultCb;
  }
  async execute() {
    return this.resultCb();
  }
  sync() {
    return this.resultCb();
  }
};
_a80 = entityKind;
__publicField(ExecuteResultSync, _a80, "ExecuteResultSync");
var _a81;
var SQLitePreparedQuery = class {
  constructor(mode, executeMethod, query) {
    this.mode = mode;
    this.executeMethod = executeMethod;
    this.query = query;
  }
  /** @internal */
  joinsNotNullableMap;
  getQuery() {
    return this.query;
  }
  mapRunResult(result, _isFromBatch) {
    return result;
  }
  mapAllResult(_result, _isFromBatch) {
    throw new Error("Not implemented");
  }
  mapGetResult(_result, _isFromBatch) {
    throw new Error("Not implemented");
  }
  execute(placeholderValues) {
    if (this.mode === "async") {
      return this[this.executeMethod](placeholderValues);
    }
    return new ExecuteResultSync(() => this[this.executeMethod](placeholderValues));
  }
  mapResult(response, isFromBatch) {
    switch (this.executeMethod) {
      case "run": {
        return this.mapRunResult(response, isFromBatch);
      }
      case "all": {
        return this.mapAllResult(response, isFromBatch);
      }
      case "get": {
        return this.mapGetResult(response, isFromBatch);
      }
    }
  }
};
_a81 = entityKind;
__publicField(SQLitePreparedQuery, _a81, "PreparedQuery");
var _a82;
var SQLiteSession = class {
  constructor(dialect) {
    this.dialect = dialect;
  }
  prepareOneTimeQuery(query, fields, executeMethod, isResponseInArrayMode) {
    return this.prepareQuery(query, fields, executeMethod, isResponseInArrayMode);
  }
  run(query) {
    const staticQuery = this.dialect.sqlToQuery(query);
    try {
      return this.prepareOneTimeQuery(staticQuery, void 0, "run", false).run();
    } catch (err) {
      throw new DrizzleError({ cause: err, message: `Failed to run the query '${staticQuery.sql}'` });
    }
  }
  /** @internal */
  extractRawRunValueFromBatchResult(result) {
    return result;
  }
  all(query) {
    return this.prepareOneTimeQuery(this.dialect.sqlToQuery(query), void 0, "run", false).all();
  }
  /** @internal */
  extractRawAllValueFromBatchResult(_result) {
    throw new Error("Not implemented");
  }
  get(query) {
    return this.prepareOneTimeQuery(this.dialect.sqlToQuery(query), void 0, "run", false).get();
  }
  /** @internal */
  extractRawGetValueFromBatchResult(_result) {
    throw new Error("Not implemented");
  }
  values(query) {
    return this.prepareOneTimeQuery(this.dialect.sqlToQuery(query), void 0, "run", false).values();
  }
  /** @internal */
  extractRawValuesValueFromBatchResult(_result) {
    throw new Error("Not implemented");
  }
};
_a82 = entityKind;
__publicField(SQLiteSession, _a82, "SQLiteSession");
var _a83;
var SQLiteTransaction = class extends BaseSQLiteDatabase {
  constructor(resultType, dialect, session, schema, nestedIndex = 0) {
    super(resultType, dialect, session, schema);
    this.schema = schema;
    this.nestedIndex = nestedIndex;
  }
  rollback() {
    throw new TransactionRollbackError();
  }
};
_a83 = entityKind;
__publicField(SQLiteTransaction, _a83, "SQLiteTransaction");

// node_modules/drizzle-orm/d1/session.js
var _a84;
var SQLiteD1Session = class extends SQLiteSession {
  constructor(client, dialect, schema, options = {}) {
    super(dialect);
    this.client = client;
    this.schema = schema;
    this.options = options;
    this.logger = options.logger ?? new NoopLogger();
  }
  logger;
  prepareQuery(query, fields, executeMethod, isResponseInArrayMode, customResultMapper) {
    const stmt = this.client.prepare(query.sql);
    return new D1PreparedQuery(
      stmt,
      query,
      this.logger,
      fields,
      executeMethod,
      isResponseInArrayMode,
      customResultMapper
    );
  }
  async batch(queries) {
    const preparedQueries = [];
    const builtQueries = [];
    for (const query of queries) {
      const preparedQuery = query._prepare();
      const builtQuery = preparedQuery.getQuery();
      preparedQueries.push(preparedQuery);
      if (builtQuery.params.length > 0) {
        builtQueries.push(preparedQuery.stmt.bind(...builtQuery.params));
      } else {
        const builtQuery2 = preparedQuery.getQuery();
        builtQueries.push(
          this.client.prepare(builtQuery2.sql).bind(...builtQuery2.params)
        );
      }
    }
    const batchResults = await this.client.batch(builtQueries);
    return batchResults.map((result, i2) => preparedQueries[i2].mapResult(result, true));
  }
  extractRawAllValueFromBatchResult(result) {
    return result.results;
  }
  extractRawGetValueFromBatchResult(result) {
    return result.results[0];
  }
  extractRawValuesValueFromBatchResult(result) {
    return d1ToRawMapping(result.results);
  }
  async transaction(transaction, config3) {
    const tx = new D1Transaction("async", this.dialect, this, this.schema);
    await this.run(sql.raw(`begin${config3?.behavior ? " " + config3.behavior : ""}`));
    try {
      const result = await transaction(tx);
      await this.run(sql`commit`);
      return result;
    } catch (err) {
      await this.run(sql`rollback`);
      throw err;
    }
  }
};
_a84 = entityKind;
__publicField(SQLiteD1Session, _a84, "SQLiteD1Session");
var _a85;
var _D1Transaction = class extends SQLiteTransaction {
  async transaction(transaction) {
    const savepointName = `sp${this.nestedIndex}`;
    const tx = new _D1Transaction("async", this.dialect, this.session, this.schema, this.nestedIndex + 1);
    await this.session.run(sql.raw(`savepoint ${savepointName}`));
    try {
      const result = await transaction(tx);
      await this.session.run(sql.raw(`release savepoint ${savepointName}`));
      return result;
    } catch (err) {
      await this.session.run(sql.raw(`rollback to savepoint ${savepointName}`));
      throw err;
    }
  }
};
var D1Transaction = _D1Transaction;
_a85 = entityKind;
__publicField(D1Transaction, _a85, "D1Transaction");
function d1ToRawMapping(results) {
  const rows = [];
  for (const row of results) {
    const entry = Object.keys(row).map((k2) => row[k2]);
    rows.push(entry);
  }
  return rows;
}
var _a86;
var D1PreparedQuery = class extends SQLitePreparedQuery {
  constructor(stmt, query, logger2, fields, executeMethod, _isResponseInArrayMode, customResultMapper) {
    super("async", executeMethod, query);
    this.logger = logger2;
    this._isResponseInArrayMode = _isResponseInArrayMode;
    this.customResultMapper = customResultMapper;
    this.fields = fields;
    this.stmt = stmt;
  }
  /** @internal */
  customResultMapper;
  /** @internal */
  fields;
  /** @internal */
  stmt;
  run(placeholderValues) {
    const params = fillPlaceholders(this.query.params, placeholderValues ?? {});
    this.logger.logQuery(this.query.sql, params);
    return this.stmt.bind(...params).run();
  }
  async all(placeholderValues) {
    const { fields, query, logger: logger2, stmt, customResultMapper } = this;
    if (!fields && !customResultMapper) {
      const params = fillPlaceholders(query.params, placeholderValues ?? {});
      logger2.logQuery(query.sql, params);
      return stmt.bind(...params).all().then(({ results }) => this.mapAllResult(results));
    }
    const rows = await this.values(placeholderValues);
    return this.mapAllResult(rows);
  }
  mapAllResult(rows, isFromBatch) {
    if (isFromBatch) {
      rows = d1ToRawMapping(rows.results);
    }
    if (!this.fields && !this.customResultMapper) {
      return rows;
    }
    if (this.customResultMapper) {
      return this.customResultMapper(rows);
    }
    return rows.map((row) => mapResultRow(this.fields, row, this.joinsNotNullableMap));
  }
  async get(placeholderValues) {
    const { fields, joinsNotNullableMap, query, logger: logger2, stmt, customResultMapper } = this;
    if (!fields && !customResultMapper) {
      const params = fillPlaceholders(query.params, placeholderValues ?? {});
      logger2.logQuery(query.sql, params);
      return stmt.bind(...params).all().then(({ results }) => results[0]);
    }
    const rows = await this.values(placeholderValues);
    if (!rows[0]) {
      return void 0;
    }
    if (customResultMapper) {
      return customResultMapper(rows);
    }
    return mapResultRow(fields, rows[0], joinsNotNullableMap);
  }
  mapGetResult(result, isFromBatch) {
    if (isFromBatch) {
      result = d1ToRawMapping(result.results)[0];
    }
    if (!this.fields && !this.customResultMapper) {
      return result;
    }
    if (this.customResultMapper) {
      return this.customResultMapper([result]);
    }
    return mapResultRow(this.fields, result, this.joinsNotNullableMap);
  }
  values(placeholderValues) {
    const params = fillPlaceholders(this.query.params, placeholderValues ?? {});
    this.logger.logQuery(this.query.sql, params);
    return this.stmt.bind(...params).raw();
  }
  /** @internal */
  isResponseInArrayMode() {
    return this._isResponseInArrayMode;
  }
};
_a86 = entityKind;
__publicField(D1PreparedQuery, _a86, "D1PreparedQuery");

// node_modules/drizzle-orm/d1/driver.js
var _a87;
var DrizzleD1Database = class extends BaseSQLiteDatabase {
  async batch(batch) {
    return this.session.batch(batch);
  }
};
_a87 = entityKind;
__publicField(DrizzleD1Database, _a87, "D1Database");
function drizzle(client, config3 = {}) {
  const dialect = new SQLiteAsyncDialect();
  let logger2;
  if (config3.logger === true) {
    logger2 = new DefaultLogger();
  } else if (config3.logger !== false) {
    logger2 = config3.logger;
  }
  let schema;
  if (config3.schema) {
    const tablesConfig = extractTablesRelationalConfig(
      config3.schema,
      createTableRelationsHelpers
    );
    schema = {
      fullSchema: config3.schema,
      schema: tablesConfig.tables,
      tableNamesMap: tablesConfig.tableNamesMap
    };
  }
  const session = new SQLiteD1Session(client, dialect, schema, { logger: logger2 });
  return new DrizzleD1Database("async", dialect, session, schema);
}

// node_modules/elysia/dist/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/value/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/errors/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/errors/errors.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/system/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/system/policy.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/value/guard/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/value/guard/guard.mjs
init_process();
init_buffer();
function IsAsyncIterator(value) {
  return IsObject(value) && Symbol.asyncIterator in value;
}
function IsIterator(value) {
  return IsObject(value) && Symbol.iterator in value;
}
function IsStandardObject(value) {
  return IsObject(value) && (Object.getPrototypeOf(value) === Object.prototype || Object.getPrototypeOf(value) === null);
}
function IsPromise(value) {
  return value instanceof Promise;
}
function IsDate(value) {
  return value instanceof Date && Number.isFinite(value.getTime());
}
function IsTypedArray(value) {
  return ArrayBuffer.isView(value);
}
function IsUint8Array(value) {
  return value instanceof globalThis.Uint8Array;
}
function HasPropertyKey(value, key2) {
  return key2 in value;
}
function IsObject(value) {
  return value !== null && typeof value === "object";
}
function IsArray(value) {
  return Array.isArray(value) && !ArrayBuffer.isView(value);
}
function IsUndefined(value) {
  return value === void 0;
}
function IsNull(value) {
  return value === null;
}
function IsBoolean(value) {
  return typeof value === "boolean";
}
function IsNumber(value) {
  return typeof value === "number";
}
function IsInteger(value) {
  return Number.isInteger(value);
}
function IsBigInt(value) {
  return typeof value === "bigint";
}
function IsString(value) {
  return typeof value === "string";
}
function IsFunction(value) {
  return typeof value === "function";
}
function IsSymbol(value) {
  return typeof value === "symbol";
}
function IsValueType(value) {
  return IsBigInt(value) || IsBoolean(value) || IsNull(value) || IsNumber(value) || IsString(value) || IsSymbol(value) || IsUndefined(value);
}

// node_modules/@sinclair/typebox/build/esm/system/policy.mjs
var TypeSystemPolicy;
(function(TypeSystemPolicy2) {
  TypeSystemPolicy2.ExactOptionalPropertyTypes = false;
  TypeSystemPolicy2.AllowArrayObject = false;
  TypeSystemPolicy2.AllowNaN = false;
  TypeSystemPolicy2.AllowNullVoid = false;
  function IsExactOptionalProperty(value, key2) {
    return TypeSystemPolicy2.ExactOptionalPropertyTypes ? key2 in value : value[key2] !== void 0;
  }
  TypeSystemPolicy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value) {
    const isObject4 = IsObject(value);
    return TypeSystemPolicy2.AllowArrayObject ? isObject4 : isObject4 && !IsArray(value);
  }
  TypeSystemPolicy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value) {
    return IsObjectLike(value) && !(value instanceof Date) && !(value instanceof Uint8Array);
  }
  TypeSystemPolicy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value) {
    return TypeSystemPolicy2.AllowNaN ? IsNumber(value) : Number.isFinite(value);
  }
  TypeSystemPolicy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value) {
    const isUndefined2 = IsUndefined(value);
    return TypeSystemPolicy2.AllowNullVoid ? isUndefined2 || value === null : isUndefined2;
  }
  TypeSystemPolicy2.IsVoidLike = IsVoidLike;
})(TypeSystemPolicy || (TypeSystemPolicy = {}));

// node_modules/@sinclair/typebox/build/esm/system/system.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/registry/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/registry/format.mjs
var format_exports = {};
__export(format_exports, {
  Clear: () => Clear,
  Delete: () => Delete,
  Entries: () => Entries,
  Get: () => Get,
  Has: () => Has,
  Set: () => Set2
});
init_process();
init_buffer();
var map = /* @__PURE__ */ new Map();
function Entries() {
  return new Map(map);
}
function Clear() {
  return map.clear();
}
function Delete(format3) {
  return map.delete(format3);
}
function Has(format3) {
  return map.has(format3);
}
function Set2(format3, func) {
  map.set(format3, func);
}
function Get(format3) {
  return map.get(format3);
}

// node_modules/@sinclair/typebox/build/esm/type/registry/type.mjs
var type_exports = {};
__export(type_exports, {
  Clear: () => Clear2,
  Delete: () => Delete2,
  Entries: () => Entries2,
  Get: () => Get2,
  Has: () => Has2,
  Set: () => Set3
});
init_process();
init_buffer();
var map2 = /* @__PURE__ */ new Map();
function Entries2() {
  return new Map(map2);
}
function Clear2() {
  return map2.clear();
}
function Delete2(kind) {
  return map2.delete(kind);
}
function Has2(kind) {
  return map2.has(kind);
}
function Set3(kind, func) {
  map2.set(kind, func);
}
function Get2(kind) {
  return map2.get(kind);
}

// node_modules/@sinclair/typebox/build/esm/type/unsafe/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/unsafe/unsafe.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/symbols/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/symbols/symbols.mjs
init_process();
init_buffer();
var TransformKind = Symbol.for("TypeBox.Transform");
var ReadonlyKind = Symbol.for("TypeBox.Readonly");
var OptionalKind = Symbol.for("TypeBox.Optional");
var Hint = Symbol.for("TypeBox.Hint");
var Kind = Symbol.for("TypeBox.Kind");

// node_modules/@sinclair/typebox/build/esm/type/unsafe/unsafe.mjs
function Unsafe(options = {}) {
  return {
    ...options,
    [Kind]: options[Kind] ?? "Unsafe"
  };
}

// node_modules/@sinclair/typebox/build/esm/type/error/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/error/error.mjs
init_process();
init_buffer();
var TypeBoxError = class extends Error {
  constructor(message2) {
    super(message2);
  }
};

// node_modules/@sinclair/typebox/build/esm/system/system.mjs
var TypeSystemDuplicateTypeKind = class extends TypeBoxError {
  constructor(kind) {
    super(`Duplicate type kind '${kind}' detected`);
  }
};
var TypeSystemDuplicateFormat = class extends TypeBoxError {
  constructor(kind) {
    super(`Duplicate string format '${kind}' detected`);
  }
};
var TypeSystem;
(function(TypeSystem2) {
  function Type2(kind, check) {
    if (type_exports.Has(kind))
      throw new TypeSystemDuplicateTypeKind(kind);
    type_exports.Set(kind, check);
    return (options = {}) => Unsafe({ ...options, [Kind]: kind });
  }
  TypeSystem2.Type = Type2;
  function Format2(format3, check) {
    if (format_exports.Has(format3))
      throw new TypeSystemDuplicateFormat(format3);
    format_exports.Set(format3, check);
    return format3;
  }
  TypeSystem2.Format = Format2;
})(TypeSystem || (TypeSystem = {}));

// node_modules/@sinclair/typebox/build/esm/type/keyof/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-from-mapped-result.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/mapped/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/mapped/mapped-key.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/mapped/mapped-result.mjs
init_process();
init_buffer();
function MappedResult(properties) {
  return {
    [Kind]: "MappedResult",
    properties
  };
}

// node_modules/@sinclair/typebox/build/esm/type/mapped/mapped.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/clone/type.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/clone/value.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/guard/value.mjs
var value_exports = {};
__export(value_exports, {
  IsArray: () => IsArray2,
  IsAsyncIterator: () => IsAsyncIterator2,
  IsBigInt: () => IsBigInt2,
  IsBoolean: () => IsBoolean2,
  IsDate: () => IsDate2,
  IsFunction: () => IsFunction2,
  IsIterator: () => IsIterator2,
  IsNull: () => IsNull2,
  IsNumber: () => IsNumber2,
  IsObject: () => IsObject2,
  IsRegExp: () => IsRegExp,
  IsString: () => IsString2,
  IsSymbol: () => IsSymbol2,
  IsUint8Array: () => IsUint8Array2,
  IsUndefined: () => IsUndefined2
});
init_process();
init_buffer();
function IsAsyncIterator2(value) {
  return IsObject2(value) && !IsArray2(value) && !IsUint8Array2(value) && Symbol.asyncIterator in value;
}
function IsArray2(value) {
  return Array.isArray(value);
}
function IsBigInt2(value) {
  return typeof value === "bigint";
}
function IsBoolean2(value) {
  return typeof value === "boolean";
}
function IsDate2(value) {
  return value instanceof globalThis.Date;
}
function IsFunction2(value) {
  return typeof value === "function";
}
function IsIterator2(value) {
  return IsObject2(value) && !IsArray2(value) && !IsUint8Array2(value) && Symbol.iterator in value;
}
function IsNull2(value) {
  return value === null;
}
function IsNumber2(value) {
  return typeof value === "number";
}
function IsObject2(value) {
  return typeof value === "object" && value !== null;
}
function IsRegExp(value) {
  return value instanceof globalThis.RegExp;
}
function IsString2(value) {
  return typeof value === "string";
}
function IsSymbol2(value) {
  return typeof value === "symbol";
}
function IsUint8Array2(value) {
  return value instanceof globalThis.Uint8Array;
}
function IsUndefined2(value) {
  return value === void 0;
}

// node_modules/@sinclair/typebox/build/esm/type/clone/value.mjs
function ArrayType(value) {
  return value.map((value2) => Visit(value2));
}
function DateType(value) {
  return new Date(value.getTime());
}
function Uint8ArrayType(value) {
  return new Uint8Array(value);
}
function RegExpType(value) {
  return new RegExp(value.source, value.flags);
}
function ObjectType(value) {
  const result = {};
  for (const key2 of Object.getOwnPropertyNames(value)) {
    result[key2] = Visit(value[key2]);
  }
  for (const key2 of Object.getOwnPropertySymbols(value)) {
    result[key2] = Visit(value[key2]);
  }
  return result;
}
function Visit(value) {
  return IsArray2(value) ? ArrayType(value) : IsDate2(value) ? DateType(value) : IsUint8Array2(value) ? Uint8ArrayType(value) : IsRegExp(value) ? RegExpType(value) : IsObject2(value) ? ObjectType(value) : value;
}
function Clone(value) {
  return Visit(value);
}

// node_modules/@sinclair/typebox/build/esm/type/clone/type.mjs
function CloneRest(schemas) {
  return schemas.map((schema) => CloneType(schema));
}
function CloneType(schema, options = {}) {
  return { ...Clone(schema), ...options };
}

// node_modules/@sinclair/typebox/build/esm/type/discard/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/discard/discard.mjs
init_process();
init_buffer();
function DiscardKey(value, key2) {
  const { [key2]: _, ...rest } = value;
  return rest;
}
function Discard(value, keys3) {
  return keys3.reduce((acc, key2) => DiscardKey(acc, key2), value);
}

// node_modules/@sinclair/typebox/build/esm/type/array/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/array/array.mjs
init_process();
init_buffer();
function Array2(schema, options = {}) {
  return {
    ...options,
    [Kind]: "Array",
    type: "array",
    items: CloneType(schema)
  };
}

// node_modules/@sinclair/typebox/build/esm/type/async-iterator/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/async-iterator/async-iterator.mjs
init_process();
init_buffer();
function AsyncIterator(items, options = {}) {
  return {
    ...options,
    [Kind]: "AsyncIterator",
    type: "AsyncIterator",
    items: CloneType(items)
  };
}

// node_modules/@sinclair/typebox/build/esm/type/constructor/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/constructor/constructor.mjs
init_process();
init_buffer();
function Constructor(parameters, returns, options) {
  return {
    ...options,
    [Kind]: "Constructor",
    type: "Constructor",
    parameters: CloneRest(parameters),
    returns: CloneType(returns)
  };
}

// node_modules/@sinclair/typebox/build/esm/type/function/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/function/function.mjs
init_process();
init_buffer();
function Function2(parameters, returns, options) {
  return {
    ...options,
    [Kind]: "Function",
    type: "Function",
    parameters: CloneRest(parameters),
    returns: CloneType(returns)
  };
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-key.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/never/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/never/never.mjs
init_process();
init_buffer();
function Never(options = {}) {
  return {
    ...options,
    [Kind]: "Never",
    not: {}
  };
}

// node_modules/@sinclair/typebox/build/esm/type/intersect/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-evaluated.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/optional/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/optional/optional-from-mapped-result.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/optional/optional.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/guard/kind.mjs
init_process();
init_buffer();
function IsReadonly(value) {
  return IsObject2(value) && value[ReadonlyKind] === "Readonly";
}
function IsOptional(value) {
  return IsObject2(value) && value[OptionalKind] === "Optional";
}
function IsAny(value) {
  return IsKindOf(value, "Any");
}
function IsArray3(value) {
  return IsKindOf(value, "Array");
}
function IsAsyncIterator3(value) {
  return IsKindOf(value, "AsyncIterator");
}
function IsBigInt3(value) {
  return IsKindOf(value, "BigInt");
}
function IsBoolean3(value) {
  return IsKindOf(value, "Boolean");
}
function IsConstructor(value) {
  return IsKindOf(value, "Constructor");
}
function IsDate3(value) {
  return IsKindOf(value, "Date");
}
function IsFunction3(value) {
  return IsKindOf(value, "Function");
}
function IsInteger2(value) {
  return IsKindOf(value, "Integer");
}
function IsIntersect(value) {
  return IsKindOf(value, "Intersect");
}
function IsIterator3(value) {
  return IsKindOf(value, "Iterator");
}
function IsKindOf(value, kind) {
  return IsObject2(value) && Kind in value && value[Kind] === kind;
}
function IsLiteral(value) {
  return IsKindOf(value, "Literal");
}
function IsMappedKey(value) {
  return IsKindOf(value, "MappedKey");
}
function IsMappedResult(value) {
  return IsKindOf(value, "MappedResult");
}
function IsNever(value) {
  return IsKindOf(value, "Never");
}
function IsNot(value) {
  return IsKindOf(value, "Not");
}
function IsNull3(value) {
  return IsKindOf(value, "Null");
}
function IsNumber3(value) {
  return IsKindOf(value, "Number");
}
function IsObject3(value) {
  return IsKindOf(value, "Object");
}
function IsPromise2(value) {
  return IsKindOf(value, "Promise");
}
function IsRecord(value) {
  return IsKindOf(value, "Record");
}
function IsRef(value) {
  return IsKindOf(value, "Ref");
}
function IsRegExp2(value) {
  return IsKindOf(value, "RegExp");
}
function IsString3(value) {
  return IsKindOf(value, "String");
}
function IsSymbol3(value) {
  return IsKindOf(value, "Symbol");
}
function IsTemplateLiteral(value) {
  return IsKindOf(value, "TemplateLiteral");
}
function IsThis(value) {
  return IsKindOf(value, "This");
}
function IsTransform(value) {
  return IsObject2(value) && TransformKind in value;
}
function IsTuple(value) {
  return IsKindOf(value, "Tuple");
}
function IsUndefined3(value) {
  return IsKindOf(value, "Undefined");
}
function IsUnion(value) {
  return IsKindOf(value, "Union");
}
function IsUint8Array3(value) {
  return IsKindOf(value, "Uint8Array");
}
function IsUnknown(value) {
  return IsKindOf(value, "Unknown");
}
function IsUnsafe(value) {
  return IsKindOf(value, "Unsafe");
}
function IsVoid(value) {
  return IsKindOf(value, "Void");
}
function IsKind(value) {
  return IsObject2(value) && Kind in value && IsString2(value[Kind]);
}
function IsSchema(value) {
  return IsAny(value) || IsArray3(value) || IsBoolean3(value) || IsBigInt3(value) || IsAsyncIterator3(value) || IsConstructor(value) || IsDate3(value) || IsFunction3(value) || IsInteger2(value) || IsIntersect(value) || IsIterator3(value) || IsLiteral(value) || IsMappedKey(value) || IsMappedResult(value) || IsNever(value) || IsNot(value) || IsNull3(value) || IsNumber3(value) || IsObject3(value) || IsPromise2(value) || IsRecord(value) || IsRef(value) || IsRegExp2(value) || IsString3(value) || IsSymbol3(value) || IsTemplateLiteral(value) || IsThis(value) || IsTuple(value) || IsUndefined3(value) || IsUnion(value) || IsUint8Array3(value) || IsUnknown(value) || IsUnsafe(value) || IsVoid(value) || IsKind(value);
}

// node_modules/@sinclair/typebox/build/esm/type/optional/optional.mjs
function RemoveOptional(schema) {
  return Discard(CloneType(schema), [OptionalKind]);
}
function AddOptional(schema) {
  return { ...CloneType(schema), [OptionalKind]: "Optional" };
}
function OptionalWithFlag(schema, F2) {
  return F2 === false ? RemoveOptional(schema) : AddOptional(schema);
}
function Optional(schema, enable) {
  const F2 = enable ?? true;
  return IsMappedResult(schema) ? OptionalFromMappedResult(schema, F2) : OptionalWithFlag(schema, F2);
}

// node_modules/@sinclair/typebox/build/esm/type/optional/optional-from-mapped-result.mjs
function FromProperties(P2, F2) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P2))
    Acc[K2] = Optional(P2[K2], F2);
  return Acc;
}
function FromMappedResult(R2, F2) {
  return FromProperties(R2.properties, F2);
}
function OptionalFromMappedResult(R2, F2) {
  const P2 = FromMappedResult(R2, F2);
  return MappedResult(P2);
}

// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-create.mjs
init_process();
init_buffer();
function IntersectCreate(T2, options) {
  const allObjects = T2.every((schema) => IsObject3(schema));
  const clonedUnevaluatedProperties = IsSchema(options.unevaluatedProperties) ? { unevaluatedProperties: CloneType(options.unevaluatedProperties) } : {};
  return options.unevaluatedProperties === false || IsSchema(options.unevaluatedProperties) || allObjects ? { ...options, ...clonedUnevaluatedProperties, [Kind]: "Intersect", type: "object", allOf: CloneRest(T2) } : { ...options, ...clonedUnevaluatedProperties, [Kind]: "Intersect", allOf: CloneRest(T2) };
}

// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-evaluated.mjs
function IsIntersectOptional(T2) {
  return T2.every((L2) => IsOptional(L2));
}
function RemoveOptionalFromType(T2) {
  return Discard(T2, [OptionalKind]);
}
function RemoveOptionalFromRest(T2) {
  return T2.map((L2) => IsOptional(L2) ? RemoveOptionalFromType(L2) : L2);
}
function ResolveIntersect(T2, options) {
  return IsIntersectOptional(T2) ? Optional(IntersectCreate(RemoveOptionalFromRest(T2), options)) : IntersectCreate(RemoveOptionalFromRest(T2), options);
}
function IntersectEvaluated(T2, options = {}) {
  if (T2.length === 0)
    return Never(options);
  if (T2.length === 1)
    return CloneType(T2[0], options);
  if (T2.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return ResolveIntersect(T2, options);
}

// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-type.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect.mjs
init_process();
init_buffer();
function Intersect(T2, options = {}) {
  if (T2.length === 0)
    return Never(options);
  if (T2.length === 1)
    return CloneType(T2[0], options);
  if (T2.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return IntersectCreate(T2, options);
}

// node_modules/@sinclair/typebox/build/esm/type/union/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/union/union-evaluated.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/union/union-create.mjs
init_process();
init_buffer();
function UnionCreate(T2, options) {
  return { ...options, [Kind]: "Union", anyOf: CloneRest(T2) };
}

// node_modules/@sinclair/typebox/build/esm/type/union/union-evaluated.mjs
function IsUnionOptional(T2) {
  return T2.some((L2) => IsOptional(L2));
}
function RemoveOptionalFromRest2(T2) {
  return T2.map((L2) => IsOptional(L2) ? RemoveOptionalFromType2(L2) : L2);
}
function RemoveOptionalFromType2(T2) {
  return Discard(T2, [OptionalKind]);
}
function ResolveUnion(T2, options) {
  return IsUnionOptional(T2) ? Optional(UnionCreate(RemoveOptionalFromRest2(T2), options)) : UnionCreate(RemoveOptionalFromRest2(T2), options);
}
function UnionEvaluated(T2, options = {}) {
  return T2.length === 0 ? Never(options) : T2.length === 1 ? CloneType(T2[0], options) : ResolveUnion(T2, options);
}

// node_modules/@sinclair/typebox/build/esm/type/union/union-type.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/union/union.mjs
init_process();
init_buffer();
function Union(T2, options = {}) {
  return T2.length === 0 ? Never(options) : T2.length === 1 ? CloneType(T2[0], options) : UnionCreate(T2, options);
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-property-keys.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/template-literal/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/template-literal/finite.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/template-literal/parse.mjs
init_process();
init_buffer();
var TemplateLiteralParserError = class extends TypeBoxError {
};
function Unescape(pattern) {
  return pattern.replace(/\\\$/g, "$").replace(/\\\*/g, "*").replace(/\\\^/g, "^").replace(/\\\|/g, "|").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}
function IsNonEscaped(pattern, index3, char) {
  return pattern[index3] === char && pattern.charCodeAt(index3 - 1) !== 92;
}
function IsOpenParen(pattern, index3) {
  return IsNonEscaped(pattern, index3, "(");
}
function IsCloseParen(pattern, index3) {
  return IsNonEscaped(pattern, index3, ")");
}
function IsSeparator(pattern, index3) {
  return IsNonEscaped(pattern, index3, "|");
}
function IsGroup(pattern) {
  if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
    return false;
  let count2 = 0;
  for (let index3 = 0; index3 < pattern.length; index3++) {
    if (IsOpenParen(pattern, index3))
      count2 += 1;
    if (IsCloseParen(pattern, index3))
      count2 -= 1;
    if (count2 === 0 && index3 !== pattern.length - 1)
      return false;
  }
  return true;
}
function InGroup(pattern) {
  return pattern.slice(1, pattern.length - 1);
}
function IsPrecedenceOr(pattern) {
  let count2 = 0;
  for (let index3 = 0; index3 < pattern.length; index3++) {
    if (IsOpenParen(pattern, index3))
      count2 += 1;
    if (IsCloseParen(pattern, index3))
      count2 -= 1;
    if (IsSeparator(pattern, index3) && count2 === 0)
      return true;
  }
  return false;
}
function IsPrecedenceAnd(pattern) {
  for (let index3 = 0; index3 < pattern.length; index3++) {
    if (IsOpenParen(pattern, index3))
      return true;
  }
  return false;
}
function Or(pattern) {
  let [count2, start] = [0, 0];
  const expressions = [];
  for (let index3 = 0; index3 < pattern.length; index3++) {
    if (IsOpenParen(pattern, index3))
      count2 += 1;
    if (IsCloseParen(pattern, index3))
      count2 -= 1;
    if (IsSeparator(pattern, index3) && count2 === 0) {
      const range2 = pattern.slice(start, index3);
      if (range2.length > 0)
        expressions.push(TemplateLiteralParse(range2));
      start = index3 + 1;
    }
  }
  const range = pattern.slice(start);
  if (range.length > 0)
    expressions.push(TemplateLiteralParse(range));
  if (expressions.length === 0)
    return { type: "const", const: "" };
  if (expressions.length === 1)
    return expressions[0];
  return { type: "or", expr: expressions };
}
function And(pattern) {
  function Group(value, index3) {
    if (!IsOpenParen(value, index3))
      throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
    let count2 = 0;
    for (let scan = index3; scan < value.length; scan++) {
      if (IsOpenParen(value, scan))
        count2 += 1;
      if (IsCloseParen(value, scan))
        count2 -= 1;
      if (count2 === 0)
        return [index3, scan];
    }
    throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
  }
  function Range(pattern2, index3) {
    for (let scan = index3; scan < pattern2.length; scan++) {
      if (IsOpenParen(pattern2, scan))
        return [index3, scan];
    }
    return [index3, pattern2.length];
  }
  const expressions = [];
  for (let index3 = 0; index3 < pattern.length; index3++) {
    if (IsOpenParen(pattern, index3)) {
      const [start, end] = Group(pattern, index3);
      const range = pattern.slice(start, end + 1);
      expressions.push(TemplateLiteralParse(range));
      index3 = end;
    } else {
      const [start, end] = Range(pattern, index3);
      const range = pattern.slice(start, end);
      if (range.length > 0)
        expressions.push(TemplateLiteralParse(range));
      index3 = end - 1;
    }
  }
  return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
}
function TemplateLiteralParse(pattern) {
  return IsGroup(pattern) ? TemplateLiteralParse(InGroup(pattern)) : IsPrecedenceOr(pattern) ? Or(pattern) : IsPrecedenceAnd(pattern) ? And(pattern) : { type: "const", const: Unescape(pattern) };
}
function TemplateLiteralParseExact(pattern) {
  return TemplateLiteralParse(pattern.slice(1, pattern.length - 1));
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/finite.mjs
var TemplateLiteralFiniteError = class extends TypeBoxError {
};
function IsNumberExpression(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
}
function IsBooleanExpression(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
}
function IsStringExpression(expression) {
  return expression.type === "const" && expression.const === ".*";
}
function IsTemplateLiteralExpressionFinite(expression) {
  return IsNumberExpression(expression) || IsStringExpression(expression) ? false : IsBooleanExpression(expression) ? true : expression.type === "and" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "or" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "const" ? true : (() => {
    throw new TemplateLiteralFiniteError(`Unknown expression type`);
  })();
}
function IsTemplateLiteralFinite(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression);
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/generate.mjs
init_process();
init_buffer();
var TemplateLiteralGenerateError = class extends TypeBoxError {
};
function* GenerateReduce(buffer) {
  if (buffer.length === 1)
    return yield* buffer[0];
  for (const left of buffer[0]) {
    for (const right of GenerateReduce(buffer.slice(1))) {
      yield `${left}${right}`;
    }
  }
}
function* GenerateAnd(expression) {
  return yield* GenerateReduce(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate(expr)]));
}
function* GenerateOr(expression) {
  for (const expr of expression.expr)
    yield* TemplateLiteralExpressionGenerate(expr);
}
function* GenerateConst(expression) {
  return yield expression.const;
}
function* TemplateLiteralExpressionGenerate(expression) {
  return expression.type === "and" ? yield* GenerateAnd(expression) : expression.type === "or" ? yield* GenerateOr(expression) : expression.type === "const" ? yield* GenerateConst(expression) : (() => {
    throw new TemplateLiteralGenerateError("Unknown expression");
  })();
}
function TemplateLiteralGenerate(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression) ? [...TemplateLiteralExpressionGenerate(expression)] : [];
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/syntax.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/literal/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/literal/literal.mjs
init_process();
init_buffer();
function Literal(value, options = {}) {
  return {
    ...options,
    [Kind]: "Literal",
    const: value,
    type: typeof value
  };
}

// node_modules/@sinclair/typebox/build/esm/type/boolean/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/boolean/boolean.mjs
init_process();
init_buffer();
function Boolean2(options = {}) {
  return {
    ...options,
    [Kind]: "Boolean",
    type: "boolean"
  };
}

// node_modules/@sinclair/typebox/build/esm/type/bigint/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/bigint/bigint.mjs
init_process();
init_buffer();
function BigInt2(options = {}) {
  return {
    ...options,
    [Kind]: "BigInt",
    type: "bigint"
  };
}

// node_modules/@sinclair/typebox/build/esm/type/number/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/number/number.mjs
init_process();
init_buffer();
function Number2(options = {}) {
  return {
    ...options,
    [Kind]: "Number",
    type: "number"
  };
}

// node_modules/@sinclair/typebox/build/esm/type/string/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/string/string.mjs
init_process();
init_buffer();
function String2(options = {}) {
  return { ...options, [Kind]: "String", type: "string" };
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/syntax.mjs
function* FromUnion(syntax) {
  const trim = syntax.trim().replace(/"|'/g, "");
  return trim === "boolean" ? yield Boolean2() : trim === "number" ? yield Number2() : trim === "bigint" ? yield BigInt2() : trim === "string" ? yield String2() : yield (() => {
    const literals = trim.split("|").map((literal) => Literal(literal.trim()));
    return literals.length === 0 ? Never() : literals.length === 1 ? literals[0] : UnionEvaluated(literals);
  })();
}
function* FromTerminal(syntax) {
  if (syntax[1] !== "{") {
    const L2 = Literal("$");
    const R2 = FromSyntax(syntax.slice(1));
    return yield* [L2, ...R2];
  }
  for (let i2 = 2; i2 < syntax.length; i2++) {
    if (syntax[i2] === "}") {
      const L2 = FromUnion(syntax.slice(2, i2));
      const R2 = FromSyntax(syntax.slice(i2 + 1));
      return yield* [...L2, ...R2];
    }
  }
  yield Literal(syntax);
}
function* FromSyntax(syntax) {
  for (let i2 = 0; i2 < syntax.length; i2++) {
    if (syntax[i2] === "$") {
      const L2 = Literal(syntax.slice(0, i2));
      const R2 = FromTerminal(syntax.slice(i2));
      return yield* [L2, ...R2];
    }
  }
  yield Literal(syntax);
}
function TemplateLiteralSyntax(syntax) {
  return [...FromSyntax(syntax)];
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/pattern.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/patterns/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/patterns/patterns.mjs
init_process();
init_buffer();
var PatternBoolean = "(true|false)";
var PatternNumber = "(0|[1-9][0-9]*)";
var PatternString = "(.*)";
var PatternBooleanExact = `^${PatternBoolean}$`;
var PatternNumberExact = `^${PatternNumber}$`;
var PatternStringExact = `^${PatternString}$`;

// node_modules/@sinclair/typebox/build/esm/type/template-literal/pattern.mjs
var TemplateLiteralPatternError = class extends TypeBoxError {
};
function Escape(value) {
  return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Visit2(schema, acc) {
  return IsTemplateLiteral(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : IsUnion(schema) ? `(${schema.anyOf.map((schema2) => Visit2(schema2, acc)).join("|")})` : IsNumber3(schema) ? `${acc}${PatternNumber}` : IsInteger2(schema) ? `${acc}${PatternNumber}` : IsBigInt3(schema) ? `${acc}${PatternNumber}` : IsString3(schema) ? `${acc}${PatternString}` : IsLiteral(schema) ? `${acc}${Escape(schema.const.toString())}` : IsBoolean3(schema) ? `${acc}${PatternBoolean}` : (() => {
    throw new TemplateLiteralPatternError(`Unexpected Kind '${schema[Kind]}'`);
  })();
}
function TemplateLiteralPattern(kinds) {
  return `^${kinds.map((schema) => Visit2(schema, "")).join("")}$`;
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/union.mjs
init_process();
init_buffer();
function TemplateLiteralToUnion(schema) {
  const R2 = TemplateLiteralGenerate(schema);
  const L2 = R2.map((S2) => Literal(S2));
  return UnionEvaluated(L2);
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/template-literal.mjs
init_process();
init_buffer();
function TemplateLiteral(unresolved, options = {}) {
  const pattern = IsString2(unresolved) ? TemplateLiteralPattern(TemplateLiteralSyntax(unresolved)) : TemplateLiteralPattern(unresolved);
  return { ...options, [Kind]: "TemplateLiteral", type: "string", pattern };
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-property-keys.mjs
function FromTemplateLiteral(T2) {
  const R2 = TemplateLiteralGenerate(T2);
  return R2.map((S2) => S2.toString());
}
function FromUnion2(T2) {
  const Acc = [];
  for (const L2 of T2)
    Acc.push(...IndexPropertyKeys(L2));
  return Acc;
}
function FromLiteral(T2) {
  return [T2.toString()];
}
function IndexPropertyKeys(T2) {
  return [...new Set(IsTemplateLiteral(T2) ? FromTemplateLiteral(T2) : IsUnion(T2) ? FromUnion2(T2.anyOf) : IsLiteral(T2) ? FromLiteral(T2.const) : IsNumber3(T2) ? ["[number]"] : IsInteger2(T2) ? ["[number]"] : [])];
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-result.mjs
init_process();
init_buffer();
function FromProperties2(T2, P2, options) {
  const Acc = {};
  for (const K2 of Object.getOwnPropertyNames(P2)) {
    Acc[K2] = Index(T2, IndexPropertyKeys(P2[K2]), options);
  }
  return Acc;
}
function FromMappedResult2(T2, R2, options) {
  return FromProperties2(T2, R2.properties, options);
}
function IndexFromMappedResult(T2, R2, options) {
  const P2 = FromMappedResult2(T2, R2, options);
  return MappedResult(P2);
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed.mjs
function FromRest(T2, K2) {
  return T2.map((L2) => IndexFromPropertyKey(L2, K2));
}
function FromIntersectRest(T2) {
  return T2.filter((L2) => !IsNever(L2));
}
function FromIntersect(T2, K2) {
  return IntersectEvaluated(FromIntersectRest(FromRest(T2, K2)));
}
function FromUnionRest(T2) {
  return T2.some((L2) => IsNever(L2)) ? [] : T2;
}
function FromUnion3(T2, K2) {
  return UnionEvaluated(FromUnionRest(FromRest(T2, K2)));
}
function FromTuple(T2, K2) {
  return K2 in T2 ? T2[K2] : K2 === "[number]" ? UnionEvaluated(T2) : Never();
}
function FromArray(T2, K2) {
  return K2 === "[number]" ? T2 : Never();
}
function FromProperty(T2, K2) {
  return K2 in T2 ? T2[K2] : Never();
}
function IndexFromPropertyKey(T2, K2) {
  return IsIntersect(T2) ? FromIntersect(T2.allOf, K2) : IsUnion(T2) ? FromUnion3(T2.anyOf, K2) : IsTuple(T2) ? FromTuple(T2.items ?? [], K2) : IsArray3(T2) ? FromArray(T2.items, K2) : IsObject3(T2) ? FromProperty(T2.properties, K2) : Never();
}
function IndexFromPropertyKeys(T2, K2) {
  return K2.map((L2) => IndexFromPropertyKey(T2, L2));
}
function FromSchema(T2, K2) {
  return UnionEvaluated(IndexFromPropertyKeys(T2, K2));
}
function Index(T2, K2, options = {}) {
  return IsMappedResult(K2) ? CloneType(IndexFromMappedResult(T2, K2, options)) : IsMappedKey(K2) ? CloneType(IndexFromMappedKey(T2, K2, options)) : IsSchema(K2) ? CloneType(FromSchema(T2, IndexPropertyKeys(K2)), options) : CloneType(FromSchema(T2, K2), options);
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-key.mjs
function MappedIndexPropertyKey(T2, K2, options) {
  return { [K2]: Index(T2, [K2], options) };
}
function MappedIndexPropertyKeys(T2, K2, options) {
  return K2.reduce((Acc, L2) => {
    return { ...Acc, ...MappedIndexPropertyKey(T2, L2, options) };
  }, {});
}
function MappedIndexProperties(T2, K2, options) {
  return MappedIndexPropertyKeys(T2, K2.keys, options);
}
function IndexFromMappedKey(T2, K2, options) {
  const P2 = MappedIndexProperties(T2, K2, options);
  return MappedResult(P2);
}

// node_modules/@sinclair/typebox/build/esm/type/iterator/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/iterator/iterator.mjs
init_process();
init_buffer();
function Iterator(items, options = {}) {
  return {
    ...options,
    [Kind]: "Iterator",
    type: "Iterator",
    items: CloneType(items)
  };
}

// node_modules/@sinclair/typebox/build/esm/type/object/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/object/object.mjs
init_process();
init_buffer();
function _Object(properties, options = {}) {
  const propertyKeys = globalThis.Object.getOwnPropertyNames(properties);
  const optionalKeys = propertyKeys.filter((key2) => IsOptional(properties[key2]));
  const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));
  const clonedAdditionalProperties = IsSchema(options.additionalProperties) ? { additionalProperties: CloneType(options.additionalProperties) } : {};
  const clonedProperties = {};
  for (const key2 of propertyKeys)
    clonedProperties[key2] = CloneType(properties[key2]);
  return requiredKeys.length > 0 ? { ...options, ...clonedAdditionalProperties, [Kind]: "Object", type: "object", properties: clonedProperties, required: requiredKeys } : { ...options, ...clonedAdditionalProperties, [Kind]: "Object", type: "object", properties: clonedProperties };
}
var Object2 = _Object;

// node_modules/@sinclair/typebox/build/esm/type/promise/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/promise/promise.mjs
init_process();
init_buffer();
function Promise2(item, options = {}) {
  return {
    ...options,
    [Kind]: "Promise",
    type: "Promise",
    item: CloneType(item)
  };
}

// node_modules/@sinclair/typebox/build/esm/type/readonly/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/readonly/readonly-from-mapped-result.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/readonly/readonly.mjs
init_process();
init_buffer();
function RemoveReadonly(schema) {
  return Discard(CloneType(schema), [ReadonlyKind]);
}
function AddReadonly(schema) {
  return { ...CloneType(schema), [ReadonlyKind]: "Readonly" };
}
function ReadonlyWithFlag(schema, F2) {
  return F2 === false ? RemoveReadonly(schema) : AddReadonly(schema);
}
function Readonly(schema, enable) {
  const F2 = enable ?? true;
  return IsMappedResult(schema) ? ReadonlyFromMappedResult(schema, F2) : ReadonlyWithFlag(schema, F2);
}

// node_modules/@sinclair/typebox/build/esm/type/readonly/readonly-from-mapped-result.mjs
function FromProperties3(K2, F2) {
  const Acc = {};
  for (const K22 of globalThis.Object.getOwnPropertyNames(K2))
    Acc[K22] = Readonly(K2[K22], F2);
  return Acc;
}
function FromMappedResult3(R2, F2) {
  return FromProperties3(R2.properties, F2);
}
function ReadonlyFromMappedResult(R2, F2) {
  const P2 = FromMappedResult3(R2, F2);
  return MappedResult(P2);
}

// node_modules/@sinclair/typebox/build/esm/type/tuple/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/tuple/tuple.mjs
init_process();
init_buffer();
function Tuple(items, options = {}) {
  const [additionalItems, minItems, maxItems] = [false, items.length, items.length];
  return items.length > 0 ? { ...options, [Kind]: "Tuple", type: "array", items: CloneRest(items), additionalItems, minItems, maxItems } : { ...options, [Kind]: "Tuple", type: "array", minItems, maxItems };
}

// node_modules/@sinclair/typebox/build/esm/type/sets/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/sets/set.mjs
init_process();
init_buffer();
function SetIncludes(T2, S2) {
  return T2.includes(S2);
}
function SetDistinct(T2) {
  return [...new Set(T2)];
}
function SetIntersect(T2, S2) {
  return T2.filter((L2) => S2.includes(L2));
}
function SetIntersectManyResolve(T2, Init) {
  return T2.reduce((Acc, L2) => {
    return SetIntersect(Acc, L2);
  }, Init);
}
function SetIntersectMany(T2) {
  return T2.length === 1 ? T2[0] : T2.length > 1 ? SetIntersectManyResolve(T2.slice(1), T2[0]) : [];
}
function SetUnionMany(T2) {
  const Acc = [];
  for (const L2 of T2)
    Acc.push(...L2);
  return Acc;
}

// node_modules/@sinclair/typebox/build/esm/type/mapped/mapped.mjs
function FromMappedResult4(K2, P2) {
  return K2 in P2 ? FromSchemaType(K2, P2[K2]) : MappedResult(P2);
}
function MappedKeyToKnownMappedResultProperties(K2) {
  return { [K2]: Literal(K2) };
}
function MappedKeyToUnknownMappedResultProperties(P2) {
  const Acc = {};
  for (const L2 of P2)
    Acc[L2] = Literal(L2);
  return Acc;
}
function MappedKeyToMappedResultProperties(K2, P2) {
  return SetIncludes(P2, K2) ? MappedKeyToKnownMappedResultProperties(K2) : MappedKeyToUnknownMappedResultProperties(P2);
}
function FromMappedKey(K2, P2) {
  const R2 = MappedKeyToMappedResultProperties(K2, P2);
  return FromMappedResult4(K2, R2);
}
function FromRest2(K2, T2) {
  return T2.map((L2) => FromSchemaType(K2, L2));
}
function FromProperties4(K2, T2) {
  const Acc = {};
  for (const K22 of globalThis.Object.getOwnPropertyNames(T2))
    Acc[K22] = FromSchemaType(K2, T2[K22]);
  return Acc;
}
function FromSchemaType(K2, T2) {
  return (
    // unevaluated modifier types
    IsOptional(T2) ? Optional(FromSchemaType(K2, Discard(T2, [OptionalKind]))) : IsReadonly(T2) ? Readonly(FromSchemaType(K2, Discard(T2, [ReadonlyKind]))) : (
      // unevaluated mapped types
      IsMappedResult(T2) ? FromMappedResult4(K2, T2.properties) : IsMappedKey(T2) ? FromMappedKey(K2, T2.keys) : (
        // unevaluated types
        IsConstructor(T2) ? Constructor(FromRest2(K2, T2.parameters), FromSchemaType(K2, T2.returns)) : IsFunction3(T2) ? Function2(FromRest2(K2, T2.parameters), FromSchemaType(K2, T2.returns)) : IsAsyncIterator3(T2) ? AsyncIterator(FromSchemaType(K2, T2.items)) : IsIterator3(T2) ? Iterator(FromSchemaType(K2, T2.items)) : IsIntersect(T2) ? Intersect(FromRest2(K2, T2.allOf)) : IsUnion(T2) ? Union(FromRest2(K2, T2.anyOf)) : IsTuple(T2) ? Tuple(FromRest2(K2, T2.items ?? [])) : IsObject3(T2) ? Object2(FromProperties4(K2, T2.properties)) : IsArray3(T2) ? Array2(FromSchemaType(K2, T2.items)) : IsPromise2(T2) ? Promise2(FromSchemaType(K2, T2.item)) : T2
      )
    )
  );
}
function MappedFunctionReturnType(K2, T2) {
  const Acc = {};
  for (const L2 of K2)
    Acc[L2] = FromSchemaType(L2, T2);
  return Acc;
}
function Mapped(key2, map9, options = {}) {
  const K2 = IsSchema(key2) ? IndexPropertyKeys(key2) : key2;
  const RT = map9({ [Kind]: "MappedKey", keys: K2 });
  const R2 = MappedFunctionReturnType(K2, RT);
  return CloneType(Object2(R2), options);
}

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-property-keys.mjs
init_process();
init_buffer();
function FromRest3(T2) {
  const Acc = [];
  for (const L2 of T2)
    Acc.push(KeyOfPropertyKeys(L2));
  return Acc;
}
function FromIntersect2(T2) {
  const C2 = FromRest3(T2);
  const R2 = SetUnionMany(C2);
  return R2;
}
function FromUnion4(T2) {
  const C2 = FromRest3(T2);
  const R2 = SetIntersectMany(C2);
  return R2;
}
function FromTuple2(T2) {
  return T2.map((_, I2) => I2.toString());
}
function FromArray2(_) {
  return ["[number]"];
}
function FromProperties5(T2) {
  return globalThis.Object.getOwnPropertyNames(T2);
}
function FromPatternProperties(patternProperties) {
  if (!includePatternProperties)
    return [];
  const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);
  return patternPropertyKeys.map((key2) => {
    return key2[0] === "^" && key2[key2.length - 1] === "$" ? key2.slice(1, key2.length - 1) : key2;
  });
}
function KeyOfPropertyKeys(T2) {
  return IsIntersect(T2) ? FromIntersect2(T2.allOf) : IsUnion(T2) ? FromUnion4(T2.anyOf) : IsTuple(T2) ? FromTuple2(T2.items ?? []) : IsArray3(T2) ? FromArray2(T2.items) : IsObject3(T2) ? FromProperties5(T2.properties) : IsRecord(T2) ? FromPatternProperties(T2.patternProperties) : [];
}
var includePatternProperties = false;
function KeyOfPattern(schema) {
  includePatternProperties = true;
  const keys3 = KeyOfPropertyKeys(schema);
  includePatternProperties = false;
  const pattern = keys3.map((key2) => `(${key2})`);
  return `^(${pattern.join("|")})$`;
}

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof.mjs
function KeyOfPropertyKeysToRest(T2) {
  return T2.map((L2) => L2 === "[number]" ? Number2() : Literal(L2));
}
function KeyOf(T2, options = {}) {
  if (IsMappedResult(T2)) {
    return KeyOfFromMappedResult(T2, options);
  } else {
    const K2 = KeyOfPropertyKeys(T2);
    const S2 = KeyOfPropertyKeysToRest(K2);
    const U2 = UnionEvaluated(S2);
    return CloneType(U2, options);
  }
}

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-from-mapped-result.mjs
function FromProperties6(K2, options) {
  const Acc = {};
  for (const K22 of globalThis.Object.getOwnPropertyNames(K2))
    Acc[K22] = KeyOf(K2[K22], options);
  return Acc;
}
function FromMappedResult5(R2, options) {
  return FromProperties6(R2.properties, options);
}
function KeyOfFromMappedResult(R2, options) {
  const P2 = FromMappedResult5(R2, options);
  return MappedResult(P2);
}

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-property-entries.mjs
init_process();
init_buffer();
function KeyOfPropertyEntries(schema) {
  const keys3 = KeyOfPropertyKeys(schema);
  const schemas = IndexFromPropertyKeys(schema, keys3);
  return keys3.map((_, index3) => [keys3[index3], schemas[index3]]);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends-undefined.mjs
init_process();
init_buffer();
function Intersect2(schema) {
  return schema.allOf.every((schema2) => ExtendsUndefinedCheck(schema2));
}
function Union2(schema) {
  return schema.anyOf.some((schema2) => ExtendsUndefinedCheck(schema2));
}
function Not(schema) {
  return !ExtendsUndefinedCheck(schema.not);
}
function ExtendsUndefinedCheck(schema) {
  return schema[Kind] === "Intersect" ? Intersect2(schema) : schema[Kind] === "Union" ? Union2(schema) : schema[Kind] === "Not" ? Not(schema) : schema[Kind] === "Undefined" ? true : false;
}

// node_modules/@sinclair/typebox/build/esm/errors/function.mjs
init_process();
init_buffer();
function DefaultErrorFunction(error3) {
  switch (error3.errorType) {
    case ValueErrorType.ArrayContains:
      return "Expected array to contain at least one matching value";
    case ValueErrorType.ArrayMaxContains:
      return `Expected array to contain no more than ${error3.schema.maxContains} matching values`;
    case ValueErrorType.ArrayMinContains:
      return `Expected array to contain at least ${error3.schema.minContains} matching values`;
    case ValueErrorType.ArrayMaxItems:
      return `Expected array length to be less or equal to ${error3.schema.maxItems}`;
    case ValueErrorType.ArrayMinItems:
      return `Expected array length to be greater or equal to ${error3.schema.minItems}`;
    case ValueErrorType.ArrayUniqueItems:
      return "Expected array elements to be unique";
    case ValueErrorType.Array:
      return "Expected array";
    case ValueErrorType.AsyncIterator:
      return "Expected AsyncIterator";
    case ValueErrorType.BigIntExclusiveMaximum:
      return `Expected bigint to be less than ${error3.schema.exclusiveMaximum}`;
    case ValueErrorType.BigIntExclusiveMinimum:
      return `Expected bigint to be greater than ${error3.schema.exclusiveMinimum}`;
    case ValueErrorType.BigIntMaximum:
      return `Expected bigint to be less or equal to ${error3.schema.maximum}`;
    case ValueErrorType.BigIntMinimum:
      return `Expected bigint to be greater or equal to ${error3.schema.minimum}`;
    case ValueErrorType.BigIntMultipleOf:
      return `Expected bigint to be a multiple of ${error3.schema.multipleOf}`;
    case ValueErrorType.BigInt:
      return "Expected bigint";
    case ValueErrorType.Boolean:
      return "Expected boolean";
    case ValueErrorType.DateExclusiveMinimumTimestamp:
      return `Expected Date timestamp to be greater than ${error3.schema.exclusiveMinimumTimestamp}`;
    case ValueErrorType.DateExclusiveMaximumTimestamp:
      return `Expected Date timestamp to be less than ${error3.schema.exclusiveMaximumTimestamp}`;
    case ValueErrorType.DateMinimumTimestamp:
      return `Expected Date timestamp to be greater or equal to ${error3.schema.minimumTimestamp}`;
    case ValueErrorType.DateMaximumTimestamp:
      return `Expected Date timestamp to be less or equal to ${error3.schema.maximumTimestamp}`;
    case ValueErrorType.DateMultipleOfTimestamp:
      return `Expected Date timestamp to be a multiple of ${error3.schema.multipleOfTimestamp}`;
    case ValueErrorType.Date:
      return "Expected Date";
    case ValueErrorType.Function:
      return "Expected function";
    case ValueErrorType.IntegerExclusiveMaximum:
      return `Expected integer to be less than ${error3.schema.exclusiveMaximum}`;
    case ValueErrorType.IntegerExclusiveMinimum:
      return `Expected integer to be greater than ${error3.schema.exclusiveMinimum}`;
    case ValueErrorType.IntegerMaximum:
      return `Expected integer to be less or equal to ${error3.schema.maximum}`;
    case ValueErrorType.IntegerMinimum:
      return `Expected integer to be greater or equal to ${error3.schema.minimum}`;
    case ValueErrorType.IntegerMultipleOf:
      return `Expected integer to be a multiple of ${error3.schema.multipleOf}`;
    case ValueErrorType.Integer:
      return "Expected integer";
    case ValueErrorType.IntersectUnevaluatedProperties:
      return "Unexpected property";
    case ValueErrorType.Intersect:
      return "Expected all values to match";
    case ValueErrorType.Iterator:
      return "Expected Iterator";
    case ValueErrorType.Literal:
      return `Expected ${typeof error3.schema.const === "string" ? `'${error3.schema.const}'` : error3.schema.const}`;
    case ValueErrorType.Never:
      return "Never";
    case ValueErrorType.Not:
      return "Value should not match";
    case ValueErrorType.Null:
      return "Expected null";
    case ValueErrorType.NumberExclusiveMaximum:
      return `Expected number to be less than ${error3.schema.exclusiveMaximum}`;
    case ValueErrorType.NumberExclusiveMinimum:
      return `Expected number to be greater than ${error3.schema.exclusiveMinimum}`;
    case ValueErrorType.NumberMaximum:
      return `Expected number to be less or equal to ${error3.schema.maximum}`;
    case ValueErrorType.NumberMinimum:
      return `Expected number to be greater or equal to ${error3.schema.minimum}`;
    case ValueErrorType.NumberMultipleOf:
      return `Expected number to be a multiple of ${error3.schema.multipleOf}`;
    case ValueErrorType.Number:
      return "Expected number";
    case ValueErrorType.Object:
      return "Expected object";
    case ValueErrorType.ObjectAdditionalProperties:
      return "Unexpected property";
    case ValueErrorType.ObjectMaxProperties:
      return `Expected object to have no more than ${error3.schema.maxProperties} properties`;
    case ValueErrorType.ObjectMinProperties:
      return `Expected object to have at least ${error3.schema.minProperties} properties`;
    case ValueErrorType.ObjectRequiredProperty:
      return "Required property";
    case ValueErrorType.Promise:
      return "Expected Promise";
    case ValueErrorType.RegExp:
      return "Expected string to match regular expression";
    case ValueErrorType.StringFormatUnknown:
      return `Unknown format '${error3.schema.format}'`;
    case ValueErrorType.StringFormat:
      return `Expected string to match '${error3.schema.format}' format`;
    case ValueErrorType.StringMaxLength:
      return `Expected string length less or equal to ${error3.schema.maxLength}`;
    case ValueErrorType.StringMinLength:
      return `Expected string length greater or equal to ${error3.schema.minLength}`;
    case ValueErrorType.StringPattern:
      return `Expected string to match '${error3.schema.pattern}'`;
    case ValueErrorType.String:
      return "Expected string";
    case ValueErrorType.Symbol:
      return "Expected symbol";
    case ValueErrorType.TupleLength:
      return `Expected tuple to have ${error3.schema.maxItems || 0} elements`;
    case ValueErrorType.Tuple:
      return "Expected tuple";
    case ValueErrorType.Uint8ArrayMaxByteLength:
      return `Expected byte length less or equal to ${error3.schema.maxByteLength}`;
    case ValueErrorType.Uint8ArrayMinByteLength:
      return `Expected byte length greater or equal to ${error3.schema.minByteLength}`;
    case ValueErrorType.Uint8Array:
      return "Expected Uint8Array";
    case ValueErrorType.Undefined:
      return "Expected undefined";
    case ValueErrorType.Union:
      return "Expected union value";
    case ValueErrorType.Void:
      return "Expected void";
    case ValueErrorType.Kind:
      return `Expected kind '${error3.schema[Kind]}'`;
    default:
      return "Unknown error type";
  }
}
var errorFunction = DefaultErrorFunction;
function GetErrorFunction() {
  return errorFunction;
}

// node_modules/@sinclair/typebox/build/esm/value/deref/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/value/deref/deref.mjs
init_process();
init_buffer();
var TypeDereferenceError = class extends TypeBoxError {
  constructor(schema) {
    super(`Unable to dereference schema with $id '${schema.$id}'`);
    this.schema = schema;
  }
};
function Resolve(schema, references) {
  const target = references.find((target2) => target2.$id === schema.$ref);
  if (target === void 0)
    throw new TypeDereferenceError(schema);
  return Deref(target, references);
}
function Deref(schema, references) {
  return schema[Kind] === "This" || schema[Kind] === "Ref" ? Resolve(schema, references) : schema;
}

// node_modules/@sinclair/typebox/build/esm/value/hash/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/value/hash/hash.mjs
init_process();
init_buffer();
var ValueHashError = class extends TypeBoxError {
  constructor(value) {
    super(`Unable to hash value`);
    this.value = value;
  }
};
var ByteMarker;
(function(ByteMarker2) {
  ByteMarker2[ByteMarker2["Undefined"] = 0] = "Undefined";
  ByteMarker2[ByteMarker2["Null"] = 1] = "Null";
  ByteMarker2[ByteMarker2["Boolean"] = 2] = "Boolean";
  ByteMarker2[ByteMarker2["Number"] = 3] = "Number";
  ByteMarker2[ByteMarker2["String"] = 4] = "String";
  ByteMarker2[ByteMarker2["Object"] = 5] = "Object";
  ByteMarker2[ByteMarker2["Array"] = 6] = "Array";
  ByteMarker2[ByteMarker2["Date"] = 7] = "Date";
  ByteMarker2[ByteMarker2["Uint8Array"] = 8] = "Uint8Array";
  ByteMarker2[ByteMarker2["Symbol"] = 9] = "Symbol";
  ByteMarker2[ByteMarker2["BigInt"] = 10] = "BigInt";
})(ByteMarker || (ByteMarker = {}));
var Accumulator = BigInt("14695981039346656037");
var [Prime, Size] = [BigInt("1099511628211"), BigInt("2") ** BigInt("64")];
var Bytes = Array.from({ length: 256 }).map((_, i2) => BigInt(i2));
var F64 = new Float64Array(1);
var F64In = new DataView(F64.buffer);
var F64Out = new Uint8Array(F64.buffer);
function* NumberToBytes(value) {
  const byteCount = value === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value) + 1) / 8);
  for (let i2 = 0; i2 < byteCount; i2++) {
    yield value >> 8 * (byteCount - 1 - i2) & 255;
  }
}
function ArrayType2(value) {
  FNV1A64(ByteMarker.Array);
  for (const item of value) {
    Visit3(item);
  }
}
function BooleanType(value) {
  FNV1A64(ByteMarker.Boolean);
  FNV1A64(value ? 1 : 0);
}
function BigIntType(value) {
  FNV1A64(ByteMarker.BigInt);
  F64In.setBigInt64(0, value);
  for (const byte2 of F64Out) {
    FNV1A64(byte2);
  }
}
function DateType2(value) {
  FNV1A64(ByteMarker.Date);
  Visit3(value.getTime());
}
function NullType(value) {
  FNV1A64(ByteMarker.Null);
}
function NumberType(value) {
  FNV1A64(ByteMarker.Number);
  F64In.setFloat64(0, value);
  for (const byte2 of F64Out) {
    FNV1A64(byte2);
  }
}
function ObjectType2(value) {
  FNV1A64(ByteMarker.Object);
  for (const key2 of globalThis.Object.getOwnPropertyNames(value).sort()) {
    Visit3(key2);
    Visit3(value[key2]);
  }
}
function StringType(value) {
  FNV1A64(ByteMarker.String);
  for (let i2 = 0; i2 < value.length; i2++) {
    for (const byte2 of NumberToBytes(value.charCodeAt(i2))) {
      FNV1A64(byte2);
    }
  }
}
function SymbolType(value) {
  FNV1A64(ByteMarker.Symbol);
  Visit3(value.description);
}
function Uint8ArrayType2(value) {
  FNV1A64(ByteMarker.Uint8Array);
  for (let i2 = 0; i2 < value.length; i2++) {
    FNV1A64(value[i2]);
  }
}
function UndefinedType(value) {
  return FNV1A64(ByteMarker.Undefined);
}
function Visit3(value) {
  if (IsArray(value))
    return ArrayType2(value);
  if (IsBoolean(value))
    return BooleanType(value);
  if (IsBigInt(value))
    return BigIntType(value);
  if (IsDate(value))
    return DateType2(value);
  if (IsNull(value))
    return NullType(value);
  if (IsNumber(value))
    return NumberType(value);
  if (IsStandardObject(value))
    return ObjectType2(value);
  if (IsString(value))
    return StringType(value);
  if (IsSymbol(value))
    return SymbolType(value);
  if (IsUint8Array(value))
    return Uint8ArrayType2(value);
  if (IsUndefined(value))
    return UndefinedType(value);
  throw new ValueHashError(value);
}
function FNV1A64(byte2) {
  Accumulator = Accumulator ^ Bytes[byte2];
  Accumulator = Accumulator * Prime % Size;
}
function Hash(value) {
  Accumulator = BigInt("14695981039346656037");
  Visit3(value);
  return Accumulator;
}

// node_modules/@sinclair/typebox/build/esm/errors/errors.mjs
var ValueErrorType;
(function(ValueErrorType2) {
  ValueErrorType2[ValueErrorType2["ArrayContains"] = 0] = "ArrayContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxContains"] = 1] = "ArrayMaxContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxItems"] = 2] = "ArrayMaxItems";
  ValueErrorType2[ValueErrorType2["ArrayMinContains"] = 3] = "ArrayMinContains";
  ValueErrorType2[ValueErrorType2["ArrayMinItems"] = 4] = "ArrayMinItems";
  ValueErrorType2[ValueErrorType2["ArrayUniqueItems"] = 5] = "ArrayUniqueItems";
  ValueErrorType2[ValueErrorType2["Array"] = 6] = "Array";
  ValueErrorType2[ValueErrorType2["AsyncIterator"] = 7] = "AsyncIterator";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMaximum"] = 8] = "BigIntExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMinimum"] = 9] = "BigIntExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMaximum"] = 10] = "BigIntMaximum";
  ValueErrorType2[ValueErrorType2["BigIntMinimum"] = 11] = "BigIntMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMultipleOf"] = 12] = "BigIntMultipleOf";
  ValueErrorType2[ValueErrorType2["BigInt"] = 13] = "BigInt";
  ValueErrorType2[ValueErrorType2["Boolean"] = 14] = "Boolean";
  ValueErrorType2[ValueErrorType2["DateExclusiveMaximumTimestamp"] = 15] = "DateExclusiveMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateExclusiveMinimumTimestamp"] = 16] = "DateExclusiveMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMaximumTimestamp"] = 17] = "DateMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMinimumTimestamp"] = 18] = "DateMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMultipleOfTimestamp"] = 19] = "DateMultipleOfTimestamp";
  ValueErrorType2[ValueErrorType2["Date"] = 20] = "Date";
  ValueErrorType2[ValueErrorType2["Function"] = 21] = "Function";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMaximum"] = 22] = "IntegerExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMinimum"] = 23] = "IntegerExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMaximum"] = 24] = "IntegerMaximum";
  ValueErrorType2[ValueErrorType2["IntegerMinimum"] = 25] = "IntegerMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMultipleOf"] = 26] = "IntegerMultipleOf";
  ValueErrorType2[ValueErrorType2["Integer"] = 27] = "Integer";
  ValueErrorType2[ValueErrorType2["IntersectUnevaluatedProperties"] = 28] = "IntersectUnevaluatedProperties";
  ValueErrorType2[ValueErrorType2["Intersect"] = 29] = "Intersect";
  ValueErrorType2[ValueErrorType2["Iterator"] = 30] = "Iterator";
  ValueErrorType2[ValueErrorType2["Kind"] = 31] = "Kind";
  ValueErrorType2[ValueErrorType2["Literal"] = 32] = "Literal";
  ValueErrorType2[ValueErrorType2["Never"] = 33] = "Never";
  ValueErrorType2[ValueErrorType2["Not"] = 34] = "Not";
  ValueErrorType2[ValueErrorType2["Null"] = 35] = "Null";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMaximum"] = 36] = "NumberExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMinimum"] = 37] = "NumberExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["NumberMaximum"] = 38] = "NumberMaximum";
  ValueErrorType2[ValueErrorType2["NumberMinimum"] = 39] = "NumberMinimum";
  ValueErrorType2[ValueErrorType2["NumberMultipleOf"] = 40] = "NumberMultipleOf";
  ValueErrorType2[ValueErrorType2["Number"] = 41] = "Number";
  ValueErrorType2[ValueErrorType2["ObjectAdditionalProperties"] = 42] = "ObjectAdditionalProperties";
  ValueErrorType2[ValueErrorType2["ObjectMaxProperties"] = 43] = "ObjectMaxProperties";
  ValueErrorType2[ValueErrorType2["ObjectMinProperties"] = 44] = "ObjectMinProperties";
  ValueErrorType2[ValueErrorType2["ObjectRequiredProperty"] = 45] = "ObjectRequiredProperty";
  ValueErrorType2[ValueErrorType2["Object"] = 46] = "Object";
  ValueErrorType2[ValueErrorType2["Promise"] = 47] = "Promise";
  ValueErrorType2[ValueErrorType2["RegExp"] = 48] = "RegExp";
  ValueErrorType2[ValueErrorType2["StringFormatUnknown"] = 49] = "StringFormatUnknown";
  ValueErrorType2[ValueErrorType2["StringFormat"] = 50] = "StringFormat";
  ValueErrorType2[ValueErrorType2["StringMaxLength"] = 51] = "StringMaxLength";
  ValueErrorType2[ValueErrorType2["StringMinLength"] = 52] = "StringMinLength";
  ValueErrorType2[ValueErrorType2["StringPattern"] = 53] = "StringPattern";
  ValueErrorType2[ValueErrorType2["String"] = 54] = "String";
  ValueErrorType2[ValueErrorType2["Symbol"] = 55] = "Symbol";
  ValueErrorType2[ValueErrorType2["TupleLength"] = 56] = "TupleLength";
  ValueErrorType2[ValueErrorType2["Tuple"] = 57] = "Tuple";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMaxByteLength"] = 58] = "Uint8ArrayMaxByteLength";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMinByteLength"] = 59] = "Uint8ArrayMinByteLength";
  ValueErrorType2[ValueErrorType2["Uint8Array"] = 60] = "Uint8Array";
  ValueErrorType2[ValueErrorType2["Undefined"] = 61] = "Undefined";
  ValueErrorType2[ValueErrorType2["Union"] = 62] = "Union";
  ValueErrorType2[ValueErrorType2["Void"] = 63] = "Void";
})(ValueErrorType || (ValueErrorType = {}));
var ValueErrorsUnknownTypeError = class extends TypeBoxError {
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
};
function EscapeKey(key2) {
  return key2.replace(/~/g, "~0").replace(/\//g, "~1");
}
function IsDefined(value) {
  return value !== void 0;
}
var ValueErrorIterator = class {
  constructor(iterator) {
    this.iterator = iterator;
  }
  [Symbol.iterator]() {
    return this.iterator;
  }
  /** Returns the first value error or undefined if no errors */
  First() {
    const next = this.iterator.next();
    return next.done ? void 0 : next.value;
  }
};
function Create(errorType, schema, path2, value) {
  return { type: errorType, schema, path: path2, value, message: GetErrorFunction()({ errorType, path: path2, schema, value }) };
}
function* FromAny(schema, references, path2, value) {
}
function* FromArray3(schema, references, path2, value) {
  if (!IsArray(value)) {
    return yield Create(ValueErrorType.Array, schema, path2, value);
  }
  if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {
    yield Create(ValueErrorType.ArrayMinItems, schema, path2, value);
  }
  if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {
    yield Create(ValueErrorType.ArrayMaxItems, schema, path2, value);
  }
  for (let i2 = 0; i2 < value.length; i2++) {
    yield* Visit4(schema.items, references, `${path2}/${i2}`, value[i2]);
  }
  if (schema.uniqueItems === true && !function() {
    const set = /* @__PURE__ */ new Set();
    for (const element2 of value) {
      const hashed = Hash(element2);
      if (set.has(hashed)) {
        return false;
      } else {
        set.add(hashed);
      }
    }
    return true;
  }()) {
    yield Create(ValueErrorType.ArrayUniqueItems, schema, path2, value);
  }
  if (!(IsDefined(schema.contains) || IsDefined(schema.minContains) || IsDefined(schema.maxContains))) {
    return;
  }
  const containsSchema = IsDefined(schema.contains) ? schema.contains : Never();
  const containsCount = value.reduce((acc, value2, index3) => Visit4(containsSchema, references, `${path2}${index3}`, value2).next().done === true ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    yield Create(ValueErrorType.ArrayContains, schema, path2, value);
  }
  if (IsNumber(schema.minContains) && containsCount < schema.minContains) {
    yield Create(ValueErrorType.ArrayMinContains, schema, path2, value);
  }
  if (IsNumber(schema.maxContains) && containsCount > schema.maxContains) {
    yield Create(ValueErrorType.ArrayMaxContains, schema, path2, value);
  }
}
function* FromAsyncIterator(schema, references, path2, value) {
  if (!IsAsyncIterator(value))
    yield Create(ValueErrorType.AsyncIterator, schema, path2, value);
}
function* FromBigInt(schema, references, path2, value) {
  if (!IsBigInt(value))
    return yield Create(ValueErrorType.BigInt, schema, path2, value);
  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path2, value);
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path2, value);
  }
  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
    yield Create(ValueErrorType.BigIntMaximum, schema, path2, value);
  }
  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
    yield Create(ValueErrorType.BigIntMinimum, schema, path2, value);
  }
  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
    yield Create(ValueErrorType.BigIntMultipleOf, schema, path2, value);
  }
}
function* FromBoolean(schema, references, path2, value) {
  if (!IsBoolean(value))
    yield Create(ValueErrorType.Boolean, schema, path2, value);
}
function* FromConstructor(schema, references, path2, value) {
  yield* Visit4(schema.returns, references, path2, value.prototype);
}
function* FromDate(schema, references, path2, value) {
  if (!IsDate(value))
    return yield Create(ValueErrorType.Date, schema, path2, value);
  if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path2, value);
  }
  if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path2, value);
  }
  if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
    yield Create(ValueErrorType.DateMaximumTimestamp, schema, path2, value);
  }
  if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
    yield Create(ValueErrorType.DateMinimumTimestamp, schema, path2, value);
  }
  if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
    yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path2, value);
  }
}
function* FromFunction(schema, references, path2, value) {
  if (!IsFunction(value))
    yield Create(ValueErrorType.Function, schema, path2, value);
}
function* FromInteger(schema, references, path2, value) {
  if (!IsInteger(value))
    return yield Create(ValueErrorType.Integer, schema, path2, value);
  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path2, value);
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path2, value);
  }
  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
    yield Create(ValueErrorType.IntegerMaximum, schema, path2, value);
  }
  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
    yield Create(ValueErrorType.IntegerMinimum, schema, path2, value);
  }
  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.IntegerMultipleOf, schema, path2, value);
  }
}
function* FromIntersect3(schema, references, path2, value) {
  for (const inner of schema.allOf) {
    const next = Visit4(inner, references, path2, value).next();
    if (!next.done) {
      yield Create(ValueErrorType.Intersect, schema, path2, value);
      yield next.value;
    }
  }
  if (schema.unevaluatedProperties === false) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value)) {
      if (!keyCheck.test(valueKey)) {
        yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path2}/${valueKey}`, value);
      }
    }
  }
  if (typeof schema.unevaluatedProperties === "object") {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value)) {
      if (!keyCheck.test(valueKey)) {
        const next = Visit4(schema.unevaluatedProperties, references, `${path2}/${valueKey}`, value[valueKey]).next();
        if (!next.done)
          yield next.value;
      }
    }
  }
}
function* FromIterator(schema, references, path2, value) {
  if (!IsIterator(value))
    yield Create(ValueErrorType.Iterator, schema, path2, value);
}
function* FromLiteral2(schema, references, path2, value) {
  if (!(value === schema.const))
    yield Create(ValueErrorType.Literal, schema, path2, value);
}
function* FromNever(schema, references, path2, value) {
  yield Create(ValueErrorType.Never, schema, path2, value);
}
function* FromNot(schema, references, path2, value) {
  if (Visit4(schema.not, references, path2, value).next().done === true)
    yield Create(ValueErrorType.Not, schema, path2, value);
}
function* FromNull(schema, references, path2, value) {
  if (!IsNull(value))
    yield Create(ValueErrorType.Null, schema, path2, value);
}
function* FromNumber(schema, references, path2, value) {
  if (!TypeSystemPolicy.IsNumberLike(value))
    return yield Create(ValueErrorType.Number, schema, path2, value);
  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path2, value);
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path2, value);
  }
  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
    yield Create(ValueErrorType.NumberMaximum, schema, path2, value);
  }
  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
    yield Create(ValueErrorType.NumberMinimum, schema, path2, value);
  }
  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.NumberMultipleOf, schema, path2, value);
  }
}
function* FromObject(schema, references, path2, value) {
  if (!TypeSystemPolicy.IsObjectLike(value))
    return yield Create(ValueErrorType.Object, schema, path2, value);
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path2, value);
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path2, value);
  }
  const requiredKeys = Array.isArray(schema.required) ? schema.required : [];
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  const unknownKeys = Object.getOwnPropertyNames(value);
  for (const requiredKey of requiredKeys) {
    if (unknownKeys.includes(requiredKey))
      continue;
    yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path2}/${EscapeKey(requiredKey)}`, void 0);
  }
  if (schema.additionalProperties === false) {
    for (const valueKey of unknownKeys) {
      if (!knownKeys.includes(valueKey)) {
        yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path2}/${EscapeKey(valueKey)}`, value[valueKey]);
      }
    }
  }
  if (typeof schema.additionalProperties === "object") {
    for (const valueKey of unknownKeys) {
      if (knownKeys.includes(valueKey))
        continue;
      yield* Visit4(schema.additionalProperties, references, `${path2}/${EscapeKey(valueKey)}`, value[valueKey]);
    }
  }
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      yield* Visit4(property, references, `${path2}/${EscapeKey(knownKey)}`, value[knownKey]);
      if (ExtendsUndefinedCheck(schema) && !(knownKey in value)) {
        yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path2}/${EscapeKey(knownKey)}`, void 0);
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value, knownKey)) {
        yield* Visit4(property, references, `${path2}/${EscapeKey(knownKey)}`, value[knownKey]);
      }
    }
  }
}
function* FromPromise(schema, references, path2, value) {
  if (!IsPromise(value))
    yield Create(ValueErrorType.Promise, schema, path2, value);
}
function* FromRecord(schema, references, path2, value) {
  if (!TypeSystemPolicy.IsRecordLike(value))
    return yield Create(ValueErrorType.Object, schema, path2, value);
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path2, value);
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path2, value);
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex2 = new RegExp(patternKey);
  for (const [propertyKey, propertyValue] of Object.entries(value)) {
    if (regex2.test(propertyKey))
      yield* Visit4(patternSchema, references, `${path2}/${EscapeKey(propertyKey)}`, propertyValue);
  }
  if (typeof schema.additionalProperties === "object") {
    for (const [propertyKey, propertyValue] of Object.entries(value)) {
      if (!regex2.test(propertyKey))
        yield* Visit4(schema.additionalProperties, references, `${path2}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
  if (schema.additionalProperties === false) {
    for (const [propertyKey, propertyValue] of Object.entries(value)) {
      if (regex2.test(propertyKey))
        continue;
      return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path2}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
}
function* FromRef(schema, references, path2, value) {
  yield* Visit4(Deref(schema, references), references, path2, value);
}
function* FromRegExp(schema, references, path2, value) {
  if (!IsString(value))
    return yield Create(ValueErrorType.String, schema, path2, value);
  if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path2, value);
  }
  if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path2, value);
  }
  const regex2 = new RegExp(schema.source, schema.flags);
  if (!regex2.test(value)) {
    return yield Create(ValueErrorType.RegExp, schema, path2, value);
  }
}
function* FromString(schema, references, path2, value) {
  if (!IsString(value))
    return yield Create(ValueErrorType.String, schema, path2, value);
  if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path2, value);
  }
  if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path2, value);
  }
  if (IsString(schema.pattern)) {
    const regex2 = new RegExp(schema.pattern);
    if (!regex2.test(value)) {
      yield Create(ValueErrorType.StringPattern, schema, path2, value);
    }
  }
  if (IsString(schema.format)) {
    if (!format_exports.Has(schema.format)) {
      yield Create(ValueErrorType.StringFormatUnknown, schema, path2, value);
    } else {
      const format3 = format_exports.Get(schema.format);
      if (!format3(value)) {
        yield Create(ValueErrorType.StringFormat, schema, path2, value);
      }
    }
  }
}
function* FromSymbol(schema, references, path2, value) {
  if (!IsSymbol(value))
    yield Create(ValueErrorType.Symbol, schema, path2, value);
}
function* FromTemplateLiteral2(schema, references, path2, value) {
  if (!IsString(value))
    return yield Create(ValueErrorType.String, schema, path2, value);
  const regex2 = new RegExp(schema.pattern);
  if (!regex2.test(value)) {
    yield Create(ValueErrorType.StringPattern, schema, path2, value);
  }
}
function* FromThis(schema, references, path2, value) {
  yield* Visit4(Deref(schema, references), references, path2, value);
}
function* FromTuple3(schema, references, path2, value) {
  if (!IsArray(value))
    return yield Create(ValueErrorType.Tuple, schema, path2, value);
  if (schema.items === void 0 && !(value.length === 0)) {
    return yield Create(ValueErrorType.TupleLength, schema, path2, value);
  }
  if (!(value.length === schema.maxItems)) {
    return yield Create(ValueErrorType.TupleLength, schema, path2, value);
  }
  if (!schema.items) {
    return;
  }
  for (let i2 = 0; i2 < schema.items.length; i2++) {
    yield* Visit4(schema.items[i2], references, `${path2}/${i2}`, value[i2]);
  }
}
function* FromUndefined(schema, references, path2, value) {
  if (!IsUndefined(value))
    yield Create(ValueErrorType.Undefined, schema, path2, value);
}
function* FromUnion5(schema, references, path2, value) {
  let count2 = 0;
  for (const subschema of schema.anyOf) {
    const errors2 = [...Visit4(subschema, references, path2, value)];
    if (errors2.length === 0)
      return;
    count2 += errors2.length;
  }
  if (count2 > 0) {
    yield Create(ValueErrorType.Union, schema, path2, value);
  }
}
function* FromUint8Array(schema, references, path2, value) {
  if (!IsUint8Array(value))
    return yield Create(ValueErrorType.Uint8Array, schema, path2, value);
  if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path2, value);
  }
  if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path2, value);
  }
}
function* FromUnknown(schema, references, path2, value) {
}
function* FromVoid(schema, references, path2, value) {
  if (!TypeSystemPolicy.IsVoidLike(value))
    yield Create(ValueErrorType.Void, schema, path2, value);
}
function* FromKind(schema, references, path2, value) {
  const check = type_exports.Get(schema[Kind]);
  if (!check(schema, value))
    yield Create(ValueErrorType.Kind, schema, path2, value);
}
function* Visit4(schema, references, path2, value) {
  const references_ = IsDefined(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return yield* FromAny(schema_, references_, path2, value);
    case "Array":
      return yield* FromArray3(schema_, references_, path2, value);
    case "AsyncIterator":
      return yield* FromAsyncIterator(schema_, references_, path2, value);
    case "BigInt":
      return yield* FromBigInt(schema_, references_, path2, value);
    case "Boolean":
      return yield* FromBoolean(schema_, references_, path2, value);
    case "Constructor":
      return yield* FromConstructor(schema_, references_, path2, value);
    case "Date":
      return yield* FromDate(schema_, references_, path2, value);
    case "Function":
      return yield* FromFunction(schema_, references_, path2, value);
    case "Integer":
      return yield* FromInteger(schema_, references_, path2, value);
    case "Intersect":
      return yield* FromIntersect3(schema_, references_, path2, value);
    case "Iterator":
      return yield* FromIterator(schema_, references_, path2, value);
    case "Literal":
      return yield* FromLiteral2(schema_, references_, path2, value);
    case "Never":
      return yield* FromNever(schema_, references_, path2, value);
    case "Not":
      return yield* FromNot(schema_, references_, path2, value);
    case "Null":
      return yield* FromNull(schema_, references_, path2, value);
    case "Number":
      return yield* FromNumber(schema_, references_, path2, value);
    case "Object":
      return yield* FromObject(schema_, references_, path2, value);
    case "Promise":
      return yield* FromPromise(schema_, references_, path2, value);
    case "Record":
      return yield* FromRecord(schema_, references_, path2, value);
    case "Ref":
      return yield* FromRef(schema_, references_, path2, value);
    case "RegExp":
      return yield* FromRegExp(schema_, references_, path2, value);
    case "String":
      return yield* FromString(schema_, references_, path2, value);
    case "Symbol":
      return yield* FromSymbol(schema_, references_, path2, value);
    case "TemplateLiteral":
      return yield* FromTemplateLiteral2(schema_, references_, path2, value);
    case "This":
      return yield* FromThis(schema_, references_, path2, value);
    case "Tuple":
      return yield* FromTuple3(schema_, references_, path2, value);
    case "Undefined":
      return yield* FromUndefined(schema_, references_, path2, value);
    case "Union":
      return yield* FromUnion5(schema_, references_, path2, value);
    case "Uint8Array":
      return yield* FromUint8Array(schema_, references_, path2, value);
    case "Unknown":
      return yield* FromUnknown(schema_, references_, path2, value);
    case "Void":
      return yield* FromVoid(schema_, references_, path2, value);
    default:
      if (!type_exports.Has(schema_[Kind]))
        throw new ValueErrorsUnknownTypeError(schema);
      return yield* FromKind(schema_, references_, path2, value);
  }
}
function Errors(...args) {
  const iterator = args.length === 3 ? Visit4(args[0], args[1], "", args[2]) : Visit4(args[0], [], "", args[1]);
  return new ValueErrorIterator(iterator);
}

// node_modules/@sinclair/typebox/build/esm/value/cast/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/value/cast/cast.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/value/create/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/value/create/create.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/value/check/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/value/check/check.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/extends/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/extends/extends-check.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/any/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/any/any.mjs
init_process();
init_buffer();
function Any(options = {}) {
  return { ...options, [Kind]: "Any" };
}

// node_modules/@sinclair/typebox/build/esm/type/unknown/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/unknown/unknown.mjs
init_process();
init_buffer();
function Unknown(options = {}) {
  return {
    ...options,
    [Kind]: "Unknown"
  };
}

// node_modules/@sinclair/typebox/build/esm/type/guard/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/guard/type.mjs
var type_exports2 = {};
__export(type_exports2, {
  IsAny: () => IsAny2,
  IsArray: () => IsArray4,
  IsAsyncIterator: () => IsAsyncIterator4,
  IsBigInt: () => IsBigInt4,
  IsBoolean: () => IsBoolean4,
  IsConstructor: () => IsConstructor2,
  IsDate: () => IsDate4,
  IsFunction: () => IsFunction4,
  IsInteger: () => IsInteger3,
  IsIntersect: () => IsIntersect2,
  IsIterator: () => IsIterator4,
  IsKind: () => IsKind2,
  IsKindOf: () => IsKindOf2,
  IsLiteral: () => IsLiteral2,
  IsLiteralBoolean: () => IsLiteralBoolean,
  IsLiteralNumber: () => IsLiteralNumber,
  IsLiteralString: () => IsLiteralString,
  IsLiteralValue: () => IsLiteralValue,
  IsMappedKey: () => IsMappedKey2,
  IsMappedResult: () => IsMappedResult2,
  IsNever: () => IsNever2,
  IsNot: () => IsNot2,
  IsNull: () => IsNull4,
  IsNumber: () => IsNumber4,
  IsObject: () => IsObject4,
  IsOptional: () => IsOptional2,
  IsPromise: () => IsPromise3,
  IsProperties: () => IsProperties,
  IsReadonly: () => IsReadonly2,
  IsRecord: () => IsRecord2,
  IsRecursive: () => IsRecursive,
  IsRef: () => IsRef2,
  IsRegExp: () => IsRegExp3,
  IsSchema: () => IsSchema2,
  IsString: () => IsString4,
  IsSymbol: () => IsSymbol4,
  IsTemplateLiteral: () => IsTemplateLiteral2,
  IsThis: () => IsThis2,
  IsTransform: () => IsTransform2,
  IsTuple: () => IsTuple2,
  IsUint8Array: () => IsUint8Array4,
  IsUndefined: () => IsUndefined4,
  IsUnion: () => IsUnion2,
  IsUnionLiteral: () => IsUnionLiteral,
  IsUnknown: () => IsUnknown2,
  IsUnsafe: () => IsUnsafe2,
  IsVoid: () => IsVoid2,
  TypeGuardUnknownTypeError: () => TypeGuardUnknownTypeError
});
init_process();
init_buffer();
var TypeGuardUnknownTypeError = class extends TypeBoxError {
};
var KnownTypes = [
  "Any",
  "Array",
  "AsyncIterator",
  "BigInt",
  "Boolean",
  "Constructor",
  "Date",
  "Enum",
  "Function",
  "Integer",
  "Intersect",
  "Iterator",
  "Literal",
  "MappedKey",
  "MappedResult",
  "Not",
  "Null",
  "Number",
  "Object",
  "Promise",
  "Record",
  "Ref",
  "RegExp",
  "String",
  "Symbol",
  "TemplateLiteral",
  "This",
  "Tuple",
  "Undefined",
  "Union",
  "Uint8Array",
  "Unknown",
  "Void"
];
function IsPattern(value) {
  try {
    new RegExp(value);
    return true;
  } catch {
    return false;
  }
}
function IsControlCharacterFree(value) {
  if (!IsString2(value))
    return false;
  for (let i2 = 0; i2 < value.length; i2++) {
    const code4 = value.charCodeAt(i2);
    if (code4 >= 7 && code4 <= 13 || code4 === 27 || code4 === 127) {
      return false;
    }
  }
  return true;
}
function IsAdditionalProperties(value) {
  return IsOptionalBoolean(value) || IsSchema2(value);
}
function IsOptionalBigInt(value) {
  return IsUndefined2(value) || IsBigInt2(value);
}
function IsOptionalNumber(value) {
  return IsUndefined2(value) || IsNumber2(value);
}
function IsOptionalBoolean(value) {
  return IsUndefined2(value) || IsBoolean2(value);
}
function IsOptionalString(value) {
  return IsUndefined2(value) || IsString2(value);
}
function IsOptionalPattern(value) {
  return IsUndefined2(value) || IsString2(value) && IsControlCharacterFree(value) && IsPattern(value);
}
function IsOptionalFormat(value) {
  return IsUndefined2(value) || IsString2(value) && IsControlCharacterFree(value);
}
function IsOptionalSchema(value) {
  return IsUndefined2(value) || IsSchema2(value);
}
function IsReadonly2(value) {
  return IsObject2(value) && value[ReadonlyKind] === "Readonly";
}
function IsOptional2(value) {
  return IsObject2(value) && value[OptionalKind] === "Optional";
}
function IsAny2(value) {
  return IsKindOf2(value, "Any") && IsOptionalString(value.$id);
}
function IsArray4(value) {
  return IsKindOf2(value, "Array") && value.type === "array" && IsOptionalString(value.$id) && IsSchema2(value.items) && IsOptionalNumber(value.minItems) && IsOptionalNumber(value.maxItems) && IsOptionalBoolean(value.uniqueItems) && IsOptionalSchema(value.contains) && IsOptionalNumber(value.minContains) && IsOptionalNumber(value.maxContains);
}
function IsAsyncIterator4(value) {
  return IsKindOf2(value, "AsyncIterator") && value.type === "AsyncIterator" && IsOptionalString(value.$id) && IsSchema2(value.items);
}
function IsBigInt4(value) {
  return IsKindOf2(value, "BigInt") && value.type === "bigint" && IsOptionalString(value.$id) && IsOptionalBigInt(value.exclusiveMaximum) && IsOptionalBigInt(value.exclusiveMinimum) && IsOptionalBigInt(value.maximum) && IsOptionalBigInt(value.minimum) && IsOptionalBigInt(value.multipleOf);
}
function IsBoolean4(value) {
  return IsKindOf2(value, "Boolean") && value.type === "boolean" && IsOptionalString(value.$id);
}
function IsConstructor2(value) {
  return IsKindOf2(value, "Constructor") && value.type === "Constructor" && IsOptionalString(value.$id) && IsArray2(value.parameters) && value.parameters.every((schema) => IsSchema2(schema)) && IsSchema2(value.returns);
}
function IsDate4(value) {
  return IsKindOf2(value, "Date") && value.type === "Date" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximumTimestamp) && IsOptionalNumber(value.exclusiveMinimumTimestamp) && IsOptionalNumber(value.maximumTimestamp) && IsOptionalNumber(value.minimumTimestamp) && IsOptionalNumber(value.multipleOfTimestamp);
}
function IsFunction4(value) {
  return IsKindOf2(value, "Function") && value.type === "Function" && IsOptionalString(value.$id) && IsArray2(value.parameters) && value.parameters.every((schema) => IsSchema2(schema)) && IsSchema2(value.returns);
}
function IsInteger3(value) {
  return IsKindOf2(value, "Integer") && value.type === "integer" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximum) && IsOptionalNumber(value.exclusiveMinimum) && IsOptionalNumber(value.maximum) && IsOptionalNumber(value.minimum) && IsOptionalNumber(value.multipleOf);
}
function IsProperties(value) {
  return IsObject2(value) && Object.entries(value).every(([key2, schema]) => IsControlCharacterFree(key2) && IsSchema2(schema));
}
function IsIntersect2(value) {
  return IsKindOf2(value, "Intersect") && (IsString2(value.type) && value.type !== "object" ? false : true) && IsArray2(value.allOf) && value.allOf.every((schema) => IsSchema2(schema) && !IsTransform2(schema)) && IsOptionalString(value.type) && (IsOptionalBoolean(value.unevaluatedProperties) || IsOptionalSchema(value.unevaluatedProperties)) && IsOptionalString(value.$id);
}
function IsIterator4(value) {
  return IsKindOf2(value, "Iterator") && value.type === "Iterator" && IsOptionalString(value.$id) && IsSchema2(value.items);
}
function IsKindOf2(value, kind) {
  return IsObject2(value) && Kind in value && value[Kind] === kind;
}
function IsLiteralString(value) {
  return IsLiteral2(value) && IsString2(value.const);
}
function IsLiteralNumber(value) {
  return IsLiteral2(value) && IsNumber2(value.const);
}
function IsLiteralBoolean(value) {
  return IsLiteral2(value) && IsBoolean2(value.const);
}
function IsLiteral2(value) {
  return IsKindOf2(value, "Literal") && IsOptionalString(value.$id) && IsLiteralValue(value.const);
}
function IsLiteralValue(value) {
  return IsBoolean2(value) || IsNumber2(value) || IsString2(value);
}
function IsMappedKey2(value) {
  return IsKindOf2(value, "MappedKey") && IsArray2(value.keys) && value.keys.every((key2) => IsNumber2(key2) || IsString2(key2));
}
function IsMappedResult2(value) {
  return IsKindOf2(value, "MappedResult") && IsProperties(value.properties);
}
function IsNever2(value) {
  return IsKindOf2(value, "Never") && IsObject2(value.not) && Object.getOwnPropertyNames(value.not).length === 0;
}
function IsNot2(value) {
  return IsKindOf2(value, "Not") && IsSchema2(value.not);
}
function IsNull4(value) {
  return IsKindOf2(value, "Null") && value.type === "null" && IsOptionalString(value.$id);
}
function IsNumber4(value) {
  return IsKindOf2(value, "Number") && value.type === "number" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximum) && IsOptionalNumber(value.exclusiveMinimum) && IsOptionalNumber(value.maximum) && IsOptionalNumber(value.minimum) && IsOptionalNumber(value.multipleOf);
}
function IsObject4(value) {
  return IsKindOf2(value, "Object") && value.type === "object" && IsOptionalString(value.$id) && IsProperties(value.properties) && IsAdditionalProperties(value.additionalProperties) && IsOptionalNumber(value.minProperties) && IsOptionalNumber(value.maxProperties);
}
function IsPromise3(value) {
  return IsKindOf2(value, "Promise") && value.type === "Promise" && IsOptionalString(value.$id) && IsSchema2(value.item);
}
function IsRecord2(value) {
  return IsKindOf2(value, "Record") && value.type === "object" && IsOptionalString(value.$id) && IsAdditionalProperties(value.additionalProperties) && IsObject2(value.patternProperties) && ((schema) => {
    const keys3 = Object.getOwnPropertyNames(schema.patternProperties);
    return keys3.length === 1 && IsPattern(keys3[0]) && IsObject2(schema.patternProperties) && IsSchema2(schema.patternProperties[keys3[0]]);
  })(value);
}
function IsRecursive(value) {
  return IsObject2(value) && Hint in value && value[Hint] === "Recursive";
}
function IsRef2(value) {
  return IsKindOf2(value, "Ref") && IsOptionalString(value.$id) && IsString2(value.$ref);
}
function IsRegExp3(value) {
  return IsKindOf2(value, "RegExp") && IsOptionalString(value.$id) && IsString2(value.source) && IsString2(value.flags) && IsOptionalNumber(value.maxLength) && IsOptionalNumber(value.minLength);
}
function IsString4(value) {
  return IsKindOf2(value, "String") && value.type === "string" && IsOptionalString(value.$id) && IsOptionalNumber(value.minLength) && IsOptionalNumber(value.maxLength) && IsOptionalPattern(value.pattern) && IsOptionalFormat(value.format);
}
function IsSymbol4(value) {
  return IsKindOf2(value, "Symbol") && value.type === "symbol" && IsOptionalString(value.$id);
}
function IsTemplateLiteral2(value) {
  return IsKindOf2(value, "TemplateLiteral") && value.type === "string" && IsString2(value.pattern) && value.pattern[0] === "^" && value.pattern[value.pattern.length - 1] === "$";
}
function IsThis2(value) {
  return IsKindOf2(value, "This") && IsOptionalString(value.$id) && IsString2(value.$ref);
}
function IsTransform2(value) {
  return IsObject2(value) && TransformKind in value;
}
function IsTuple2(value) {
  return IsKindOf2(value, "Tuple") && value.type === "array" && IsOptionalString(value.$id) && IsNumber2(value.minItems) && IsNumber2(value.maxItems) && value.minItems === value.maxItems && // empty
  (IsUndefined2(value.items) && IsUndefined2(value.additionalItems) && value.minItems === 0 || IsArray2(value.items) && value.items.every((schema) => IsSchema2(schema)));
}
function IsUndefined4(value) {
  return IsKindOf2(value, "Undefined") && value.type === "undefined" && IsOptionalString(value.$id);
}
function IsUnionLiteral(value) {
  return IsUnion2(value) && value.anyOf.every((schema) => IsLiteralString(schema) || IsLiteralNumber(schema));
}
function IsUnion2(value) {
  return IsKindOf2(value, "Union") && IsOptionalString(value.$id) && IsObject2(value) && IsArray2(value.anyOf) && value.anyOf.every((schema) => IsSchema2(schema));
}
function IsUint8Array4(value) {
  return IsKindOf2(value, "Uint8Array") && value.type === "Uint8Array" && IsOptionalString(value.$id) && IsOptionalNumber(value.minByteLength) && IsOptionalNumber(value.maxByteLength);
}
function IsUnknown2(value) {
  return IsKindOf2(value, "Unknown") && IsOptionalString(value.$id);
}
function IsUnsafe2(value) {
  return IsKindOf2(value, "Unsafe");
}
function IsVoid2(value) {
  return IsKindOf2(value, "Void") && value.type === "void" && IsOptionalString(value.$id);
}
function IsKind2(value) {
  return IsObject2(value) && Kind in value && IsString2(value[Kind]) && !KnownTypes.includes(value[Kind]);
}
function IsSchema2(value) {
  return IsObject2(value) && (IsAny2(value) || IsArray4(value) || IsBoolean4(value) || IsBigInt4(value) || IsAsyncIterator4(value) || IsConstructor2(value) || IsDate4(value) || IsFunction4(value) || IsInteger3(value) || IsIntersect2(value) || IsIterator4(value) || IsLiteral2(value) || IsMappedKey2(value) || IsMappedResult2(value) || IsNever2(value) || IsNot2(value) || IsNull4(value) || IsNumber4(value) || IsObject4(value) || IsPromise3(value) || IsRecord2(value) || IsRef2(value) || IsRegExp3(value) || IsString4(value) || IsSymbol4(value) || IsTemplateLiteral2(value) || IsThis2(value) || IsTuple2(value) || IsUndefined4(value) || IsUnion2(value) || IsUint8Array4(value) || IsUnknown2(value) || IsUnsafe2(value) || IsVoid2(value) || IsKind2(value));
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends-check.mjs
var ExtendsResolverError = class extends TypeBoxError {
};
var ExtendsResult;
(function(ExtendsResult2) {
  ExtendsResult2[ExtendsResult2["Union"] = 0] = "Union";
  ExtendsResult2[ExtendsResult2["True"] = 1] = "True";
  ExtendsResult2[ExtendsResult2["False"] = 2] = "False";
})(ExtendsResult || (ExtendsResult = {}));
function IntoBooleanResult(result) {
  return result === ExtendsResult.False ? result : ExtendsResult.True;
}
function Throw(message2) {
  throw new ExtendsResolverError(message2);
}
function IsStructuralRight(right) {
  return type_exports2.IsNever(right) || type_exports2.IsIntersect(right) || type_exports2.IsUnion(right) || type_exports2.IsUnknown(right) || type_exports2.IsAny(right);
}
function StructuralRight(left, right) {
  return type_exports2.IsNever(right) ? FromNeverRight(left, right) : type_exports2.IsIntersect(right) ? FromIntersectRight(left, right) : type_exports2.IsUnion(right) ? FromUnionRight(left, right) : type_exports2.IsUnknown(right) ? FromUnknownRight(left, right) : type_exports2.IsAny(right) ? FromAnyRight(left, right) : Throw("StructuralRight");
}
function FromAnyRight(left, right) {
  return ExtendsResult.True;
}
function FromAny2(left, right) {
  return type_exports2.IsIntersect(right) ? FromIntersectRight(left, right) : type_exports2.IsUnion(right) && right.anyOf.some((schema) => type_exports2.IsAny(schema) || type_exports2.IsUnknown(schema)) ? ExtendsResult.True : type_exports2.IsUnion(right) ? ExtendsResult.Union : type_exports2.IsUnknown(right) ? ExtendsResult.True : type_exports2.IsAny(right) ? ExtendsResult.True : ExtendsResult.Union;
}
function FromArrayRight(left, right) {
  return type_exports2.IsUnknown(left) ? ExtendsResult.False : type_exports2.IsAny(left) ? ExtendsResult.Union : type_exports2.IsNever(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromArray4(left, right) {
  return type_exports2.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : !type_exports2.IsArray(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.items, right.items));
}
function FromAsyncIterator2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !type_exports2.IsAsyncIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.items, right.items));
}
function FromBigInt2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports2.IsObject(right) ? FromObjectRight(left, right) : type_exports2.IsRecord(right) ? FromRecordRight(left, right) : type_exports2.IsBigInt(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromBooleanRight(left, right) {
  return type_exports2.IsLiteralBoolean(left) ? ExtendsResult.True : type_exports2.IsBoolean(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromBoolean2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports2.IsObject(right) ? FromObjectRight(left, right) : type_exports2.IsRecord(right) ? FromRecordRight(left, right) : type_exports2.IsBoolean(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromConstructor2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports2.IsObject(right) ? FromObjectRight(left, right) : !type_exports2.IsConstructor(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index3) => IntoBooleanResult(Visit5(right.parameters[index3], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.returns, right.returns));
}
function FromDate2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports2.IsObject(right) ? FromObjectRight(left, right) : type_exports2.IsRecord(right) ? FromRecordRight(left, right) : type_exports2.IsDate(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromFunction2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports2.IsObject(right) ? FromObjectRight(left, right) : !type_exports2.IsFunction(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index3) => IntoBooleanResult(Visit5(right.parameters[index3], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.returns, right.returns));
}
function FromIntegerRight(left, right) {
  return type_exports2.IsLiteral(left) && value_exports.IsNumber(left.const) ? ExtendsResult.True : type_exports2.IsNumber(left) || type_exports2.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromInteger2(left, right) {
  return type_exports2.IsInteger(right) || type_exports2.IsNumber(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : type_exports2.IsObject(right) ? FromObjectRight(left, right) : type_exports2.IsRecord(right) ? FromRecordRight(left, right) : ExtendsResult.False;
}
function FromIntersectRight(left, right) {
  return right.allOf.every((schema) => Visit5(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromIntersect4(left, right) {
  return left.allOf.some((schema) => Visit5(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromIterator2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !type_exports2.IsIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.items, right.items));
}
function FromLiteral3(left, right) {
  return type_exports2.IsLiteral(right) && right.const === left.const ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : type_exports2.IsObject(right) ? FromObjectRight(left, right) : type_exports2.IsRecord(right) ? FromRecordRight(left, right) : type_exports2.IsString(right) ? FromStringRight(left, right) : type_exports2.IsNumber(right) ? FromNumberRight(left, right) : type_exports2.IsInteger(right) ? FromIntegerRight(left, right) : type_exports2.IsBoolean(right) ? FromBooleanRight(left, right) : ExtendsResult.False;
}
function FromNeverRight(left, right) {
  return ExtendsResult.False;
}
function FromNever2(left, right) {
  return ExtendsResult.True;
}
function UnwrapTNot(schema) {
  let [current, depth] = [schema, 0];
  while (true) {
    if (!type_exports2.IsNot(current))
      break;
    current = current.not;
    depth += 1;
  }
  return depth % 2 === 0 ? current : Unknown();
}
function FromNot2(left, right) {
  return type_exports2.IsNot(left) ? Visit5(UnwrapTNot(left), right) : type_exports2.IsNot(right) ? Visit5(left, UnwrapTNot(right)) : Throw("Invalid fallthrough for Not");
}
function FromNull2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports2.IsObject(right) ? FromObjectRight(left, right) : type_exports2.IsRecord(right) ? FromRecordRight(left, right) : type_exports2.IsNull(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromNumberRight(left, right) {
  return type_exports2.IsLiteralNumber(left) ? ExtendsResult.True : type_exports2.IsNumber(left) || type_exports2.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromNumber2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports2.IsObject(right) ? FromObjectRight(left, right) : type_exports2.IsRecord(right) ? FromRecordRight(left, right) : type_exports2.IsInteger(right) || type_exports2.IsNumber(right) ? ExtendsResult.True : ExtendsResult.False;
}
function IsObjectPropertyCount(schema, count2) {
  return Object.getOwnPropertyNames(schema.properties).length === count2;
}
function IsObjectStringLike(schema) {
  return IsObjectArrayLike(schema);
}
function IsObjectSymbolLike(schema) {
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "description" in schema.properties && type_exports2.IsUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (type_exports2.IsString(schema.properties.description.anyOf[0]) && type_exports2.IsUndefined(schema.properties.description.anyOf[1]) || type_exports2.IsString(schema.properties.description.anyOf[1]) && type_exports2.IsUndefined(schema.properties.description.anyOf[0]));
}
function IsObjectNumberLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectBooleanLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectBigIntLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectDateLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectUint8ArrayLike(schema) {
  return IsObjectArrayLike(schema);
}
function IsObjectFunctionLike(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit5(schema.properties["length"], length)) === ExtendsResult.True;
}
function IsObjectConstructorLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectArrayLike(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit5(schema.properties["length"], length)) === ExtendsResult.True;
}
function IsObjectPromiseLike(schema) {
  const then = Function2([Any()], Any());
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "then" in schema.properties && IntoBooleanResult(Visit5(schema.properties["then"], then)) === ExtendsResult.True;
}
function Property(left, right) {
  return Visit5(left, right) === ExtendsResult.False ? ExtendsResult.False : type_exports2.IsOptional(left) && !type_exports2.IsOptional(right) ? ExtendsResult.False : ExtendsResult.True;
}
function FromObjectRight(left, right) {
  return type_exports2.IsUnknown(left) ? ExtendsResult.False : type_exports2.IsAny(left) ? ExtendsResult.Union : type_exports2.IsNever(left) || type_exports2.IsLiteralString(left) && IsObjectStringLike(right) || type_exports2.IsLiteralNumber(left) && IsObjectNumberLike(right) || type_exports2.IsLiteralBoolean(left) && IsObjectBooleanLike(right) || type_exports2.IsSymbol(left) && IsObjectSymbolLike(right) || type_exports2.IsBigInt(left) && IsObjectBigIntLike(right) || type_exports2.IsString(left) && IsObjectStringLike(right) || type_exports2.IsSymbol(left) && IsObjectSymbolLike(right) || type_exports2.IsNumber(left) && IsObjectNumberLike(right) || type_exports2.IsInteger(left) && IsObjectNumberLike(right) || type_exports2.IsBoolean(left) && IsObjectBooleanLike(right) || type_exports2.IsUint8Array(left) && IsObjectUint8ArrayLike(right) || type_exports2.IsDate(left) && IsObjectDateLike(right) || type_exports2.IsConstructor(left) && IsObjectConstructorLike(right) || type_exports2.IsFunction(left) && IsObjectFunctionLike(right) ? ExtendsResult.True : type_exports2.IsRecord(left) && type_exports2.IsString(RecordKey(left)) ? (() => {
    return right[Hint] === "Record" ? ExtendsResult.True : ExtendsResult.False;
  })() : type_exports2.IsRecord(left) && type_exports2.IsNumber(RecordKey(left)) ? (() => {
    return IsObjectPropertyCount(right, 0) ? ExtendsResult.True : ExtendsResult.False;
  })() : ExtendsResult.False;
}
function FromObject2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports2.IsRecord(right) ? FromRecordRight(left, right) : !type_exports2.IsObject(right) ? ExtendsResult.False : (() => {
    for (const key2 of Object.getOwnPropertyNames(right.properties)) {
      if (!(key2 in left.properties) && !type_exports2.IsOptional(right.properties[key2])) {
        return ExtendsResult.False;
      }
      if (type_exports2.IsOptional(right.properties[key2])) {
        return ExtendsResult.True;
      }
      if (Property(left.properties[key2], right.properties[key2]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })();
}
function FromPromise2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports2.IsObject(right) && IsObjectPromiseLike(right) ? ExtendsResult.True : !type_exports2.IsPromise(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.item, right.item));
}
function RecordKey(schema) {
  return PatternNumberExact in schema.patternProperties ? Number2() : PatternStringExact in schema.patternProperties ? String2() : Throw("Unknown record key pattern");
}
function RecordValue(schema) {
  return PatternNumberExact in schema.patternProperties ? schema.patternProperties[PatternNumberExact] : PatternStringExact in schema.patternProperties ? schema.patternProperties[PatternStringExact] : Throw("Unable to get record value schema");
}
function FromRecordRight(left, right) {
  const [Key, Value] = [RecordKey(right), RecordValue(right)];
  return type_exports2.IsLiteralString(left) && type_exports2.IsNumber(Key) && IntoBooleanResult(Visit5(left, Value)) === ExtendsResult.True ? ExtendsResult.True : type_exports2.IsUint8Array(left) && type_exports2.IsNumber(Key) ? Visit5(left, Value) : type_exports2.IsString(left) && type_exports2.IsNumber(Key) ? Visit5(left, Value) : type_exports2.IsArray(left) && type_exports2.IsNumber(Key) ? Visit5(left, Value) : type_exports2.IsObject(left) ? (() => {
    for (const key2 of Object.getOwnPropertyNames(left.properties)) {
      if (Property(Value, left.properties[key2]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })() : ExtendsResult.False;
}
function FromRecord2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports2.IsObject(right) ? FromObjectRight(left, right) : !type_exports2.IsRecord(right) ? ExtendsResult.False : Visit5(RecordValue(left), RecordValue(right));
}
function FromRegExp2(left, right) {
  const L2 = type_exports2.IsRegExp(left) ? String2() : left;
  const R2 = type_exports2.IsRegExp(right) ? String2() : right;
  return Visit5(L2, R2);
}
function FromStringRight(left, right) {
  return type_exports2.IsLiteral(left) && value_exports.IsString(left.const) ? ExtendsResult.True : type_exports2.IsString(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromString2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports2.IsObject(right) ? FromObjectRight(left, right) : type_exports2.IsRecord(right) ? FromRecordRight(left, right) : type_exports2.IsString(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromSymbol2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports2.IsObject(right) ? FromObjectRight(left, right) : type_exports2.IsRecord(right) ? FromRecordRight(left, right) : type_exports2.IsSymbol(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromTemplateLiteral3(left, right) {
  return type_exports2.IsTemplateLiteral(left) ? Visit5(TemplateLiteralToUnion(left), right) : type_exports2.IsTemplateLiteral(right) ? Visit5(left, TemplateLiteralToUnion(right)) : Throw("Invalid fallthrough for TemplateLiteral");
}
function IsArrayOfTuple(left, right) {
  return type_exports2.IsArray(right) && left.items !== void 0 && left.items.every((schema) => Visit5(schema, right.items) === ExtendsResult.True);
}
function FromTupleRight(left, right) {
  return type_exports2.IsNever(left) ? ExtendsResult.True : type_exports2.IsUnknown(left) ? ExtendsResult.False : type_exports2.IsAny(left) ? ExtendsResult.Union : ExtendsResult.False;
}
function FromTuple4(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports2.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : type_exports2.IsArray(right) && IsArrayOfTuple(left, right) ? ExtendsResult.True : !type_exports2.IsTuple(right) ? ExtendsResult.False : value_exports.IsUndefined(left.items) && !value_exports.IsUndefined(right.items) || !value_exports.IsUndefined(left.items) && value_exports.IsUndefined(right.items) ? ExtendsResult.False : value_exports.IsUndefined(left.items) && !value_exports.IsUndefined(right.items) ? ExtendsResult.True : left.items.every((schema, index3) => Visit5(schema, right.items[index3]) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUint8Array2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports2.IsObject(right) ? FromObjectRight(left, right) : type_exports2.IsRecord(right) ? FromRecordRight(left, right) : type_exports2.IsUint8Array(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUndefined2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports2.IsObject(right) ? FromObjectRight(left, right) : type_exports2.IsRecord(right) ? FromRecordRight(left, right) : type_exports2.IsVoid(right) ? FromVoidRight(left, right) : type_exports2.IsUndefined(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnionRight(left, right) {
  return right.anyOf.some((schema) => Visit5(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnion6(left, right) {
  return left.anyOf.every((schema) => Visit5(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnknownRight(left, right) {
  return ExtendsResult.True;
}
function FromUnknown2(left, right) {
  return type_exports2.IsNever(right) ? FromNeverRight(left, right) : type_exports2.IsIntersect(right) ? FromIntersectRight(left, right) : type_exports2.IsUnion(right) ? FromUnionRight(left, right) : type_exports2.IsAny(right) ? FromAnyRight(left, right) : type_exports2.IsString(right) ? FromStringRight(left, right) : type_exports2.IsNumber(right) ? FromNumberRight(left, right) : type_exports2.IsInteger(right) ? FromIntegerRight(left, right) : type_exports2.IsBoolean(right) ? FromBooleanRight(left, right) : type_exports2.IsArray(right) ? FromArrayRight(left, right) : type_exports2.IsTuple(right) ? FromTupleRight(left, right) : type_exports2.IsObject(right) ? FromObjectRight(left, right) : type_exports2.IsUnknown(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromVoidRight(left, right) {
  return type_exports2.IsUndefined(left) ? ExtendsResult.True : type_exports2.IsUndefined(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromVoid2(left, right) {
  return type_exports2.IsIntersect(right) ? FromIntersectRight(left, right) : type_exports2.IsUnion(right) ? FromUnionRight(left, right) : type_exports2.IsUnknown(right) ? FromUnknownRight(left, right) : type_exports2.IsAny(right) ? FromAnyRight(left, right) : type_exports2.IsObject(right) ? FromObjectRight(left, right) : type_exports2.IsVoid(right) ? ExtendsResult.True : ExtendsResult.False;
}
function Visit5(left, right) {
  return (
    // resolvable
    type_exports2.IsTemplateLiteral(left) || type_exports2.IsTemplateLiteral(right) ? FromTemplateLiteral3(left, right) : type_exports2.IsRegExp(left) || type_exports2.IsRegExp(right) ? FromRegExp2(left, right) : type_exports2.IsNot(left) || type_exports2.IsNot(right) ? FromNot2(left, right) : (
      // standard
      type_exports2.IsAny(left) ? FromAny2(left, right) : type_exports2.IsArray(left) ? FromArray4(left, right) : type_exports2.IsBigInt(left) ? FromBigInt2(left, right) : type_exports2.IsBoolean(left) ? FromBoolean2(left, right) : type_exports2.IsAsyncIterator(left) ? FromAsyncIterator2(left, right) : type_exports2.IsConstructor(left) ? FromConstructor2(left, right) : type_exports2.IsDate(left) ? FromDate2(left, right) : type_exports2.IsFunction(left) ? FromFunction2(left, right) : type_exports2.IsInteger(left) ? FromInteger2(left, right) : type_exports2.IsIntersect(left) ? FromIntersect4(left, right) : type_exports2.IsIterator(left) ? FromIterator2(left, right) : type_exports2.IsLiteral(left) ? FromLiteral3(left, right) : type_exports2.IsNever(left) ? FromNever2(left, right) : type_exports2.IsNull(left) ? FromNull2(left, right) : type_exports2.IsNumber(left) ? FromNumber2(left, right) : type_exports2.IsObject(left) ? FromObject2(left, right) : type_exports2.IsRecord(left) ? FromRecord2(left, right) : type_exports2.IsString(left) ? FromString2(left, right) : type_exports2.IsSymbol(left) ? FromSymbol2(left, right) : type_exports2.IsTuple(left) ? FromTuple4(left, right) : type_exports2.IsPromise(left) ? FromPromise2(left, right) : type_exports2.IsUint8Array(left) ? FromUint8Array2(left, right) : type_exports2.IsUndefined(left) ? FromUndefined2(left, right) : type_exports2.IsUnion(left) ? FromUnion6(left, right) : type_exports2.IsUnknown(left) ? FromUnknown2(left, right) : type_exports2.IsVoid(left) ? FromVoid2(left, right) : Throw(`Unknown left type operand '${left[Kind]}'`)
    )
  );
}
function ExtendsCheck(left, right) {
  return Visit5(left, right);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-key.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/extends/extends.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-result.mjs
init_process();
init_buffer();
function FromProperties7(P2, Right, True, False, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P2))
    Acc[K2] = Extends(P2[K2], Right, True, False, options);
  return Acc;
}
function FromMappedResult6(Left, Right, True, False, options) {
  return FromProperties7(Left.properties, Right, True, False, options);
}
function ExtendsFromMappedResult(Left, Right, True, False, options) {
  const P2 = FromMappedResult6(Left, Right, True, False, options);
  return MappedResult(P2);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends.mjs
function ExtendsResolve(left, right, trueType, falseType) {
  const R2 = ExtendsCheck(left, right);
  return R2 === ExtendsResult.Union ? Union([trueType, falseType]) : R2 === ExtendsResult.True ? trueType : falseType;
}
function Extends(L2, R2, T2, F2, options = {}) {
  return IsMappedResult(L2) ? ExtendsFromMappedResult(L2, R2, T2, F2, options) : IsMappedKey(L2) ? CloneType(ExtendsFromMappedKey(L2, R2, T2, F2, options)) : CloneType(ExtendsResolve(L2, R2, T2, F2), options);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-key.mjs
function FromPropertyKey(K2, U2, L2, R2, options) {
  return {
    [K2]: Extends(Literal(K2), U2, L2, R2, options)
  };
}
function FromPropertyKeys(K2, U2, L2, R2, options) {
  return K2.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey(LK, U2, L2, R2, options) };
  }, {});
}
function FromMappedKey2(K2, U2, L2, R2, options) {
  return FromPropertyKeys(K2.keys, U2, L2, R2, options);
}
function ExtendsFromMappedKey(T2, U2, L2, R2, options) {
  const P2 = FromMappedKey2(T2, U2, L2, R2, options);
  return MappedResult(P2);
}

// node_modules/@sinclair/typebox/build/esm/value/check/check.mjs
var ValueCheckUnknownTypeError = class extends TypeBoxError {
  constructor(schema) {
    super(`Unknown type`);
    this.schema = schema;
  }
};
function IsAnyOrUnknown(schema) {
  return schema[Kind] === "Any" || schema[Kind] === "Unknown";
}
function IsDefined2(value) {
  return value !== void 0;
}
function FromAny3(schema, references, value) {
  return true;
}
function FromArray5(schema, references, value) {
  if (!IsArray(value))
    return false;
  if (IsDefined2(schema.minItems) && !(value.length >= schema.minItems)) {
    return false;
  }
  if (IsDefined2(schema.maxItems) && !(value.length <= schema.maxItems)) {
    return false;
  }
  if (!value.every((value2) => Visit6(schema.items, references, value2))) {
    return false;
  }
  if (schema.uniqueItems === true && !function() {
    const set = /* @__PURE__ */ new Set();
    for (const element2 of value) {
      const hashed = Hash(element2);
      if (set.has(hashed)) {
        return false;
      } else {
        set.add(hashed);
      }
    }
    return true;
  }()) {
    return false;
  }
  if (!(IsDefined2(schema.contains) || IsNumber(schema.minContains) || IsNumber(schema.maxContains))) {
    return true;
  }
  const containsSchema = IsDefined2(schema.contains) ? schema.contains : Never();
  const containsCount = value.reduce((acc, value2) => Visit6(containsSchema, references, value2) ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    return false;
  }
  if (IsNumber(schema.minContains) && containsCount < schema.minContains) {
    return false;
  }
  if (IsNumber(schema.maxContains) && containsCount > schema.maxContains) {
    return false;
  }
  return true;
}
function FromAsyncIterator3(schema, references, value) {
  return IsAsyncIterator(value);
}
function FromBigInt3(schema, references, value) {
  if (!IsBigInt(value))
    return false;
  if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
    return false;
  }
  return true;
}
function FromBoolean3(schema, references, value) {
  return IsBoolean(value);
}
function FromConstructor3(schema, references, value) {
  return Visit6(schema.returns, references, value.prototype);
}
function FromDate3(schema, references, value) {
  if (!IsDate(value))
    return false;
  if (IsDefined2(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
    return false;
  }
  return true;
}
function FromFunction3(schema, references, value) {
  return IsFunction(value);
}
function FromInteger3(schema, references, value) {
  if (!IsInteger(value)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    return false;
  }
  return true;
}
function FromIntersect5(schema, references, value) {
  const check1 = schema.allOf.every((schema2) => Visit6(schema2, references, value));
  if (schema.unevaluatedProperties === false) {
    const keyPattern = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value).every((key2) => keyPattern.test(key2));
    return check1 && check2;
  } else if (IsSchema2(schema.unevaluatedProperties)) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value).every((key2) => keyCheck.test(key2) || Visit6(schema.unevaluatedProperties, references, value[key2]));
    return check1 && check2;
  } else {
    return check1;
  }
}
function FromIterator3(schema, references, value) {
  return IsIterator(value);
}
function FromLiteral4(schema, references, value) {
  return value === schema.const;
}
function FromNever3(schema, references, value) {
  return false;
}
function FromNot3(schema, references, value) {
  return !Visit6(schema.not, references, value);
}
function FromNull3(schema, references, value) {
  return IsNull(value);
}
function FromNumber3(schema, references, value) {
  if (!TypeSystemPolicy.IsNumberLike(value))
    return false;
  if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    return false;
  }
  return true;
}
function FromObject3(schema, references, value) {
  if (!TypeSystemPolicy.IsObjectLike(value))
    return false;
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    return false;
  }
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      if (!Visit6(property, references, value[knownKey])) {
        return false;
      }
      if ((ExtendsUndefinedCheck(property) || IsAnyOrUnknown(property)) && !(knownKey in value)) {
        return false;
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value, knownKey) && !Visit6(property, references, value[knownKey])) {
        return false;
      }
    }
  }
  if (schema.additionalProperties === false) {
    const valueKeys = Object.getOwnPropertyNames(value);
    if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {
      return true;
    } else {
      return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
    }
  } else if (typeof schema.additionalProperties === "object") {
    const valueKeys = Object.getOwnPropertyNames(value);
    return valueKeys.every((key2) => knownKeys.includes(key2) || Visit6(schema.additionalProperties, references, value[key2]));
  } else {
    return true;
  }
}
function FromPromise3(schema, references, value) {
  return IsPromise(value);
}
function FromRecord3(schema, references, value) {
  if (!TypeSystemPolicy.IsRecordLike(value)) {
    return false;
  }
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    return false;
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex2 = new RegExp(patternKey);
  const check1 = Object.entries(value).every(([key2, value2]) => {
    return regex2.test(key2) ? Visit6(patternSchema, references, value2) : true;
  });
  const check2 = typeof schema.additionalProperties === "object" ? Object.entries(value).every(([key2, value2]) => {
    return !regex2.test(key2) ? Visit6(schema.additionalProperties, references, value2) : true;
  }) : true;
  const check3 = schema.additionalProperties === false ? Object.getOwnPropertyNames(value).every((key2) => {
    return regex2.test(key2);
  }) : true;
  return check1 && check2 && check3;
}
function FromRef2(schema, references, value) {
  return Visit6(Deref(schema, references), references, value);
}
function FromRegExp3(schema, references, value) {
  const regex2 = new RegExp(schema.source, schema.flags);
  if (IsDefined2(schema.minLength)) {
    if (!(value.length >= schema.minLength))
      return false;
  }
  if (IsDefined2(schema.maxLength)) {
    if (!(value.length <= schema.maxLength))
      return false;
  }
  return regex2.test(value);
}
function FromString3(schema, references, value) {
  if (!IsString(value)) {
    return false;
  }
  if (IsDefined2(schema.minLength)) {
    if (!(value.length >= schema.minLength))
      return false;
  }
  if (IsDefined2(schema.maxLength)) {
    if (!(value.length <= schema.maxLength))
      return false;
  }
  if (IsDefined2(schema.pattern)) {
    const regex2 = new RegExp(schema.pattern);
    if (!regex2.test(value))
      return false;
  }
  if (IsDefined2(schema.format)) {
    if (!format_exports.Has(schema.format))
      return false;
    const func = format_exports.Get(schema.format);
    return func(value);
  }
  return true;
}
function FromSymbol3(schema, references, value) {
  return IsSymbol(value);
}
function FromTemplateLiteral4(schema, references, value) {
  return IsString(value) && new RegExp(schema.pattern).test(value);
}
function FromThis2(schema, references, value) {
  return Visit6(Deref(schema, references), references, value);
}
function FromTuple5(schema, references, value) {
  if (!IsArray(value)) {
    return false;
  }
  if (schema.items === void 0 && !(value.length === 0)) {
    return false;
  }
  if (!(value.length === schema.maxItems)) {
    return false;
  }
  if (!schema.items) {
    return true;
  }
  for (let i2 = 0; i2 < schema.items.length; i2++) {
    if (!Visit6(schema.items[i2], references, value[i2]))
      return false;
  }
  return true;
}
function FromUndefined3(schema, references, value) {
  return IsUndefined(value);
}
function FromUnion7(schema, references, value) {
  return schema.anyOf.some((inner) => Visit6(inner, references, value));
}
function FromUint8Array3(schema, references, value) {
  if (!IsUint8Array(value)) {
    return false;
  }
  if (IsDefined2(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
    return false;
  }
  if (IsDefined2(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
    return false;
  }
  return true;
}
function FromUnknown3(schema, references, value) {
  return true;
}
function FromVoid3(schema, references, value) {
  return TypeSystemPolicy.IsVoidLike(value);
}
function FromKind2(schema, references, value) {
  if (!type_exports.Has(schema[Kind]))
    return false;
  const func = type_exports.Get(schema[Kind]);
  return func(schema, value);
}
function Visit6(schema, references, value) {
  const references_ = IsDefined2(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny3(schema_, references_, value);
    case "Array":
      return FromArray5(schema_, references_, value);
    case "AsyncIterator":
      return FromAsyncIterator3(schema_, references_, value);
    case "BigInt":
      return FromBigInt3(schema_, references_, value);
    case "Boolean":
      return FromBoolean3(schema_, references_, value);
    case "Constructor":
      return FromConstructor3(schema_, references_, value);
    case "Date":
      return FromDate3(schema_, references_, value);
    case "Function":
      return FromFunction3(schema_, references_, value);
    case "Integer":
      return FromInteger3(schema_, references_, value);
    case "Intersect":
      return FromIntersect5(schema_, references_, value);
    case "Iterator":
      return FromIterator3(schema_, references_, value);
    case "Literal":
      return FromLiteral4(schema_, references_, value);
    case "Never":
      return FromNever3(schema_, references_, value);
    case "Not":
      return FromNot3(schema_, references_, value);
    case "Null":
      return FromNull3(schema_, references_, value);
    case "Number":
      return FromNumber3(schema_, references_, value);
    case "Object":
      return FromObject3(schema_, references_, value);
    case "Promise":
      return FromPromise3(schema_, references_, value);
    case "Record":
      return FromRecord3(schema_, references_, value);
    case "Ref":
      return FromRef2(schema_, references_, value);
    case "RegExp":
      return FromRegExp3(schema_, references_, value);
    case "String":
      return FromString3(schema_, references_, value);
    case "Symbol":
      return FromSymbol3(schema_, references_, value);
    case "TemplateLiteral":
      return FromTemplateLiteral4(schema_, references_, value);
    case "This":
      return FromThis2(schema_, references_, value);
    case "Tuple":
      return FromTuple5(schema_, references_, value);
    case "Undefined":
      return FromUndefined3(schema_, references_, value);
    case "Union":
      return FromUnion7(schema_, references_, value);
    case "Uint8Array":
      return FromUint8Array3(schema_, references_, value);
    case "Unknown":
      return FromUnknown3(schema_, references_, value);
    case "Void":
      return FromVoid3(schema_, references_, value);
    default:
      if (!type_exports.Has(schema_[Kind]))
        throw new ValueCheckUnknownTypeError(schema_);
      return FromKind2(schema_, references_, value);
  }
}
function Check(...args) {
  return args.length === 3 ? Visit6(args[0], args[1], args[2]) : Visit6(args[0], [], args[1]);
}

// node_modules/@sinclair/typebox/build/esm/value/clone/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/value/clone/clone.mjs
init_process();
init_buffer();
function ObjectType3(value) {
  const Acc = {};
  for (const key2 of Object.getOwnPropertyNames(value)) {
    Acc[key2] = Clone2(value[key2]);
  }
  for (const key2 of Object.getOwnPropertySymbols(value)) {
    Acc[key2] = Clone2(value[key2]);
  }
  return Acc;
}
function ArrayType3(value) {
  return value.map((element2) => Clone2(element2));
}
function TypedArrayType(value) {
  return value.slice();
}
function DateType3(value) {
  return new Date(value.toISOString());
}
function ValueType(value) {
  return value;
}
function Clone2(value) {
  if (IsArray(value))
    return ArrayType3(value);
  if (IsDate(value))
    return DateType3(value);
  if (IsStandardObject(value))
    return ObjectType3(value);
  if (IsTypedArray(value))
    return TypedArrayType(value);
  if (IsValueType(value))
    return ValueType(value);
  throw new Error("ValueClone: Unable to clone value");
}

// node_modules/@sinclair/typebox/build/esm/value/create/create.mjs
var ValueCreateError = class extends TypeBoxError {
  constructor(schema, message2) {
    super(message2);
    this.schema = schema;
  }
};
function FromDefault(value) {
  return typeof value === "function" ? value : Clone2(value);
}
function FromAny4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
}
function FromArray6(schema, references) {
  if (schema.uniqueItems === true && !HasPropertyKey(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the uniqueItems constraint requires a default value");
  } else if ("contains" in schema && !HasPropertyKey(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the contains constraint requires a default value");
  } else if ("default" in schema) {
    return FromDefault(schema.default);
  } else if (schema.minItems !== void 0) {
    return Array.from({ length: schema.minItems }).map((item) => {
      return Visit7(schema.items, references);
    });
  } else {
    return [];
  }
}
function FromAsyncIterator4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return async function* () {
    }();
  }
}
function FromBigInt4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return BigInt(0);
  }
}
function FromBoolean4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return false;
  }
}
function FromConstructor4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value = Visit7(schema.returns, references);
    if (typeof value === "object" && !Array.isArray(value)) {
      return class {
        constructor() {
          for (const [key2, val2] of Object.entries(value)) {
            const self2 = this;
            self2[key2] = val2;
          }
        }
      };
    } else {
      return class {
      };
    }
  }
}
function FromDate4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimumTimestamp !== void 0) {
    return new Date(schema.minimumTimestamp);
  } else {
    return /* @__PURE__ */ new Date();
  }
}
function FromFunction4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return () => Visit7(schema.returns, references);
  }
}
function FromInteger4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== void 0) {
    return schema.minimum;
  } else {
    return 0;
  }
}
function FromIntersect6(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value = schema.allOf.reduce((acc, schema2) => {
      const next = Visit7(schema2, references);
      return typeof next === "object" ? { ...acc, ...next } : next;
    }, {});
    if (!Check(schema, references, value))
      throw new ValueCreateError(schema, "Intersect produced invalid value. Consider using a default value.");
    return value;
  }
}
function FromIterator4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return function* () {
    }();
  }
}
function FromLiteral5(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return schema.const;
  }
}
function FromNever4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Never types cannot be created. Consider using a default value.");
  }
}
function FromNot4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Not types must have a default value");
  }
}
function FromNull4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return null;
  }
}
function FromNumber4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== void 0) {
    return schema.minimum;
  } else {
    return 0;
  }
}
function FromObject4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const required = new Set(schema.required);
    const Acc = {};
    for (const [key2, subschema] of Object.entries(schema.properties)) {
      if (!required.has(key2))
        continue;
      Acc[key2] = Visit7(subschema, references);
    }
    return Acc;
  }
}
function FromPromise4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Promise.resolve(Visit7(schema.item, references));
  }
}
function FromRecord4(schema, references) {
  const [keyPattern, valueSchema] = Object.entries(schema.patternProperties)[0];
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (!(keyPattern === PatternStringExact || keyPattern === PatternNumberExact)) {
    const propertyKeys = keyPattern.slice(1, keyPattern.length - 1).split("|");
    const Acc = {};
    for (const key2 of propertyKeys)
      Acc[key2] = Visit7(valueSchema, references);
    return Acc;
  } else {
    return {};
  }
}
function FromRef3(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit7(Deref(schema, references), references);
  }
}
function FromRegExp4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "RegExp types cannot be created. Consider using a default value.");
  }
}
function FromString4(schema, references) {
  if (schema.pattern !== void 0) {
    if (!HasPropertyKey(schema, "default")) {
      throw new ValueCreateError(schema, "String types with patterns must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else if (schema.format !== void 0) {
    if (!HasPropertyKey(schema, "default")) {
      throw new ValueCreateError(schema, "String types with formats must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else {
    if (HasPropertyKey(schema, "default")) {
      return FromDefault(schema.default);
    } else if (schema.minLength !== void 0) {
      return Array.from({ length: schema.minLength }).map(() => " ").join("");
    } else {
      return "";
    }
  }
}
function FromSymbol4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if ("value" in schema) {
    return Symbol.for(schema.value);
  } else {
    return Symbol();
  }
}
function FromTemplateLiteral5(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (!IsTemplateLiteralFinite(schema))
    throw new ValueCreateError(schema, "Can only create template literals that produce a finite variants. Consider using a default value.");
  const generated = TemplateLiteralGenerate(schema);
  return generated[0];
}
function FromThis3(schema, references) {
  if (recursiveDepth++ > recursiveMaxDepth)
    throw new ValueCreateError(schema, "Cannot create recursive type as it appears possibly infinite. Consider using a default.");
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit7(Deref(schema, references), references);
  }
}
function FromTuple6(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (schema.items === void 0) {
    return [];
  } else {
    return Array.from({ length: schema.minItems }).map((_, index3) => Visit7(schema.items[index3], references));
  }
}
function FromUndefined4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return void 0;
  }
}
function FromUnion8(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.anyOf.length === 0) {
    throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
  } else {
    return Visit7(schema.anyOf[0], references);
  }
}
function FromUint8Array4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minByteLength !== void 0) {
    return new Uint8Array(schema.minByteLength);
  } else {
    return new Uint8Array(0);
  }
}
function FromUnknown4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
}
function FromVoid4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return void 0;
  }
}
function FromKind3(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new Error("User defined types must specify a default value");
  }
}
function Visit7(schema, references) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny4(schema_, references_);
    case "Array":
      return FromArray6(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator4(schema_, references_);
    case "BigInt":
      return FromBigInt4(schema_, references_);
    case "Boolean":
      return FromBoolean4(schema_, references_);
    case "Constructor":
      return FromConstructor4(schema_, references_);
    case "Date":
      return FromDate4(schema_, references_);
    case "Function":
      return FromFunction4(schema_, references_);
    case "Integer":
      return FromInteger4(schema_, references_);
    case "Intersect":
      return FromIntersect6(schema_, references_);
    case "Iterator":
      return FromIterator4(schema_, references_);
    case "Literal":
      return FromLiteral5(schema_, references_);
    case "Never":
      return FromNever4(schema_, references_);
    case "Not":
      return FromNot4(schema_, references_);
    case "Null":
      return FromNull4(schema_, references_);
    case "Number":
      return FromNumber4(schema_, references_);
    case "Object":
      return FromObject4(schema_, references_);
    case "Promise":
      return FromPromise4(schema_, references_);
    case "Record":
      return FromRecord4(schema_, references_);
    case "Ref":
      return FromRef3(schema_, references_);
    case "RegExp":
      return FromRegExp4(schema_, references_);
    case "String":
      return FromString4(schema_, references_);
    case "Symbol":
      return FromSymbol4(schema_, references_);
    case "TemplateLiteral":
      return FromTemplateLiteral5(schema_, references_);
    case "This":
      return FromThis3(schema_, references_);
    case "Tuple":
      return FromTuple6(schema_, references_);
    case "Undefined":
      return FromUndefined4(schema_, references_);
    case "Union":
      return FromUnion8(schema_, references_);
    case "Uint8Array":
      return FromUint8Array4(schema_, references_);
    case "Unknown":
      return FromUnknown4(schema_, references_);
    case "Void":
      return FromVoid4(schema_, references_);
    default:
      if (!type_exports.Has(schema_[Kind]))
        throw new ValueCreateError(schema_, "Unknown type");
      return FromKind3(schema_, references_);
  }
}
var recursiveMaxDepth = 512;
var recursiveDepth = 0;
function Create2(...args) {
  recursiveDepth = 0;
  return args.length === 2 ? Visit7(args[0], args[1]) : Visit7(args[0], []);
}

// node_modules/@sinclair/typebox/build/esm/value/cast/cast.mjs
var ValueCastError = class extends TypeBoxError {
  constructor(schema, message2) {
    super(message2);
    this.schema = schema;
  }
};
function ScoreUnion(schema, references, value) {
  if (schema[Kind] === "Object" && typeof value === "object" && !IsNull(value)) {
    const object = schema;
    const keys3 = Object.getOwnPropertyNames(value);
    const entries = Object.entries(object.properties);
    const [point5, max] = [1 / entries.length, entries.length];
    return entries.reduce((acc, [key2, schema2]) => {
      const literal = schema2[Kind] === "Literal" && schema2.const === value[key2] ? max : 0;
      const checks2 = Check(schema2, references, value[key2]) ? point5 : 0;
      const exists2 = keys3.includes(key2) ? point5 : 0;
      return acc + (literal + checks2 + exists2);
    }, 0);
  } else {
    return Check(schema, references, value) ? 1 : 0;
  }
}
function SelectUnion(union2, references, value) {
  const schemas = union2.anyOf.map((schema) => Deref(schema, references));
  let [select, best] = [schemas[0], 0];
  for (const schema of schemas) {
    const score = ScoreUnion(schema, references, value);
    if (score > best) {
      select = schema;
      best = score;
    }
  }
  return select;
}
function CastUnion(union2, references, value) {
  if ("default" in union2) {
    return typeof value === "function" ? union2.default : Clone2(union2.default);
  } else {
    const schema = SelectUnion(union2, references, value);
    return Cast(schema, references, value);
  }
}
function DefaultClone(schema, references, value) {
  return Check(schema, references, value) ? Clone2(value) : Create2(schema, references);
}
function Default(schema, references, value) {
  return Check(schema, references, value) ? value : Create2(schema, references);
}
function FromArray7(schema, references, value) {
  if (Check(schema, references, value))
    return Clone2(value);
  const created = IsArray(value) ? Clone2(value) : Create2(schema, references);
  const minimum = IsNumber(schema.minItems) && created.length < schema.minItems ? [...created, ...Array.from({ length: schema.minItems - created.length }, () => null)] : created;
  const maximum = IsNumber(schema.maxItems) && minimum.length > schema.maxItems ? minimum.slice(0, schema.maxItems) : minimum;
  const casted = maximum.map((value2) => Visit8(schema.items, references, value2));
  if (schema.uniqueItems !== true)
    return casted;
  const unique = [...new Set(casted)];
  if (!Check(schema, references, unique))
    throw new ValueCastError(schema, "Array cast produced invalid data due to uniqueItems constraint");
  return unique;
}
function FromConstructor5(schema, references, value) {
  if (Check(schema, references, value))
    return Create2(schema, references);
  const required = new Set(schema.returns.required || []);
  const result = function() {
  };
  for (const [key2, property] of Object.entries(schema.returns.properties)) {
    if (!required.has(key2) && value.prototype[key2] === void 0)
      continue;
    result.prototype[key2] = Visit8(property, references, value.prototype[key2]);
  }
  return result;
}
function FromIntersect7(schema, references, value) {
  const created = Create2(schema, references);
  const mapped = IsStandardObject(created) && IsStandardObject(value) ? { ...created, ...value } : value;
  return Check(schema, references, mapped) ? mapped : Create2(schema, references);
}
function FromNever5(schema, references, value) {
  throw new ValueCastError(schema, "Never types cannot be cast");
}
function FromObject5(schema, references, value) {
  if (Check(schema, references, value))
    return value;
  if (value === null || typeof value !== "object")
    return Create2(schema, references);
  const required = new Set(schema.required || []);
  const result = {};
  for (const [key2, property] of Object.entries(schema.properties)) {
    if (!required.has(key2) && value[key2] === void 0)
      continue;
    result[key2] = Visit8(property, references, value[key2]);
  }
  if (typeof schema.additionalProperties === "object") {
    const propertyNames = Object.getOwnPropertyNames(schema.properties);
    for (const propertyName of Object.getOwnPropertyNames(value)) {
      if (propertyNames.includes(propertyName))
        continue;
      result[propertyName] = Visit8(schema.additionalProperties, references, value[propertyName]);
    }
  }
  return result;
}
function FromRecord5(schema, references, value) {
  if (Check(schema, references, value))
    return Clone2(value);
  if (value === null || typeof value !== "object" || Array.isArray(value) || value instanceof Date)
    return Create2(schema, references);
  const subschemaPropertyName = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const subschema = schema.patternProperties[subschemaPropertyName];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value)) {
    result[propKey] = Visit8(subschema, references, propValue);
  }
  return result;
}
function FromRef4(schema, references, value) {
  return Visit8(Deref(schema, references), references, value);
}
function FromThis4(schema, references, value) {
  return Visit8(Deref(schema, references), references, value);
}
function FromTuple7(schema, references, value) {
  if (Check(schema, references, value))
    return Clone2(value);
  if (!IsArray(value))
    return Create2(schema, references);
  if (schema.items === void 0)
    return [];
  return schema.items.map((schema2, index3) => Visit8(schema2, references, value[index3]));
}
function FromUnion9(schema, references, value) {
  return Check(schema, references, value) ? Clone2(value) : CastUnion(schema, references, value);
}
function Visit8(schema, references, value) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray7(schema_, references_, value);
    case "Constructor":
      return FromConstructor5(schema_, references_, value);
    case "Intersect":
      return FromIntersect7(schema_, references_, value);
    case "Never":
      return FromNever5(schema_, references_, value);
    case "Object":
      return FromObject5(schema_, references_, value);
    case "Record":
      return FromRecord5(schema_, references_, value);
    case "Ref":
      return FromRef4(schema_, references_, value);
    case "This":
      return FromThis4(schema_, references_, value);
    case "Tuple":
      return FromTuple7(schema_, references_, value);
    case "Union":
      return FromUnion9(schema_, references_, value);
    case "Date":
    case "Symbol":
    case "Uint8Array":
      return DefaultClone(schema, references, value);
    default:
      return Default(schema_, references_, value);
  }
}
function Cast(...args) {
  return args.length === 3 ? Visit8(args[0], args[1], args[2]) : Visit8(args[0], [], args[1]);
}

// node_modules/@sinclair/typebox/build/esm/value/clean/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/value/clean/clean.mjs
init_process();
init_buffer();
function IsCheckable(schema) {
  return IsSchema2(schema) && schema[Kind] !== "Unsafe";
}
function FromArray8(schema, references, value) {
  if (!IsArray(value))
    return value;
  return value.map((value2) => Visit9(schema.items, references, value2));
}
function FromIntersect8(schema, references, value) {
  const unevaluatedProperties = schema.unevaluatedProperties;
  const intersections = schema.allOf.map((schema2) => Visit9(schema2, references, Clone2(value)));
  const composite = intersections.reduce((acc, value2) => IsObject(value2) ? { ...acc, ...value2 } : value2, {});
  if (!IsObject(value) || !IsObject(composite) || !IsSchema2(unevaluatedProperties))
    return composite;
  const knownkeys = KeyOfPropertyKeys(schema);
  for (const key2 of Object.getOwnPropertyNames(value)) {
    if (knownkeys.includes(key2))
      continue;
    if (Check(unevaluatedProperties, references, value[key2])) {
      composite[key2] = Visit9(unevaluatedProperties, references, value[key2]);
    }
  }
  return composite;
}
function FromObject6(schema, references, value) {
  if (!IsObject(value) || IsArray(value))
    return value;
  const additionalProperties = schema.additionalProperties;
  for (const key2 of Object.getOwnPropertyNames(value)) {
    if (key2 in schema.properties) {
      value[key2] = Visit9(schema.properties[key2], references, value[key2]);
      continue;
    }
    if (IsSchema2(additionalProperties) && Check(additionalProperties, references, value[key2])) {
      value[key2] = Visit9(additionalProperties, references, value[key2]);
      continue;
    }
    delete value[key2];
  }
  return value;
}
function FromRecord6(schema, references, value) {
  if (!IsObject(value))
    return value;
  const additionalProperties = schema.additionalProperties;
  const propertyKeys = Object.getOwnPropertyNames(value);
  const [propertyKey, propertySchema] = Object.entries(schema.patternProperties)[0];
  const propertyKeyTest = new RegExp(propertyKey);
  for (const key2 of propertyKeys) {
    if (propertyKeyTest.test(key2)) {
      value[key2] = Visit9(propertySchema, references, value[key2]);
      continue;
    }
    if (IsSchema2(additionalProperties) && Check(additionalProperties, references, value[key2])) {
      value[key2] = Visit9(additionalProperties, references, value[key2]);
      continue;
    }
    delete value[key2];
  }
  return value;
}
function FromRef5(schema, references, value) {
  return Visit9(Deref(schema, references), references, value);
}
function FromThis5(schema, references, value) {
  return Visit9(Deref(schema, references), references, value);
}
function FromTuple8(schema, references, value) {
  if (!IsArray(value))
    return value;
  if (IsUndefined(schema.items))
    return [];
  const length = Math.min(value.length, schema.items.length);
  for (let i2 = 0; i2 < length; i2++) {
    value[i2] = Visit9(schema.items[i2], references, value[i2]);
  }
  return value.length > length ? value.slice(0, length) : value;
}
function FromUnion10(schema, references, value) {
  for (const inner of schema.anyOf) {
    if (IsCheckable(inner) && Check(inner, references, value)) {
      return Visit9(inner, references, value);
    }
  }
  return value;
}
function Visit9(schema, references, value) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray8(schema_, references_, value);
    case "Intersect":
      return FromIntersect8(schema_, references_, value);
    case "Object":
      return FromObject6(schema_, references_, value);
    case "Record":
      return FromRecord6(schema_, references_, value);
    case "Ref":
      return FromRef5(schema_, references_, value);
    case "This":
      return FromThis5(schema_, references_, value);
    case "Tuple":
      return FromTuple8(schema_, references_, value);
    case "Union":
      return FromUnion10(schema_, references_, value);
    default:
      return value;
  }
}
function Clean(...args) {
  return args.length === 3 ? Visit9(args[0], args[1], args[2]) : Visit9(args[0], [], args[1]);
}

// node_modules/@sinclair/typebox/build/esm/value/convert/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/value/convert/convert.mjs
init_process();
init_buffer();
function IsStringNumeric(value) {
  return IsString(value) && !isNaN(value) && !isNaN(parseFloat(value));
}
function IsValueToString(value) {
  return IsBigInt(value) || IsBoolean(value) || IsNumber(value);
}
function IsValueTrue(value) {
  return value === true || IsNumber(value) && value === 1 || IsBigInt(value) && value === BigInt("1") || IsString(value) && (value.toLowerCase() === "true" || value === "1");
}
function IsValueFalse(value) {
  return value === false || IsNumber(value) && (value === 0 || Object.is(value, -0)) || IsBigInt(value) && value === BigInt("0") || IsString(value) && (value.toLowerCase() === "false" || value === "0" || value === "-0");
}
function IsTimeStringWithTimeZone(value) {
  return IsString(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
}
function IsTimeStringWithoutTimeZone(value) {
  return IsString(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
}
function IsDateTimeStringWithTimeZone(value) {
  return IsString(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
}
function IsDateTimeStringWithoutTimeZone(value) {
  return IsString(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
}
function IsDateString(value) {
  return IsString(value) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(value);
}
function TryConvertLiteralString(value, target) {
  const conversion = TryConvertString(value);
  return conversion === target ? conversion : value;
}
function TryConvertLiteralNumber(value, target) {
  const conversion = TryConvertNumber(value);
  return conversion === target ? conversion : value;
}
function TryConvertLiteralBoolean(value, target) {
  const conversion = TryConvertBoolean(value);
  return conversion === target ? conversion : value;
}
function TryConvertLiteral(schema, value) {
  return IsString(schema.const) ? TryConvertLiteralString(value, schema.const) : IsNumber(schema.const) ? TryConvertLiteralNumber(value, schema.const) : IsBoolean(schema.const) ? TryConvertLiteralBoolean(value, schema.const) : Clone2(value);
}
function TryConvertBoolean(value) {
  return IsValueTrue(value) ? true : IsValueFalse(value) ? false : value;
}
function TryConvertBigInt(value) {
  return IsStringNumeric(value) ? BigInt(parseInt(value)) : IsNumber(value) ? BigInt(value | 0) : IsValueFalse(value) ? BigInt(0) : IsValueTrue(value) ? BigInt(1) : value;
}
function TryConvertString(value) {
  return IsValueToString(value) ? value.toString() : IsSymbol(value) && value.description !== void 0 ? value.description.toString() : value;
}
function TryConvertNumber(value) {
  return IsStringNumeric(value) ? parseFloat(value) : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
}
function TryConvertInteger(value) {
  return IsStringNumeric(value) ? parseInt(value) : IsNumber(value) ? value | 0 : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
}
function TryConvertNull(value) {
  return IsString(value) && value.toLowerCase() === "null" ? null : value;
}
function TryConvertUndefined(value) {
  return IsString(value) && value === "undefined" ? void 0 : value;
}
function TryConvertDate(value) {
  return IsDate(value) ? value : IsNumber(value) ? new Date(value) : IsValueTrue(value) ? /* @__PURE__ */ new Date(1) : IsValueFalse(value) ? /* @__PURE__ */ new Date(0) : IsStringNumeric(value) ? new Date(parseInt(value)) : IsTimeStringWithoutTimeZone(value) ? /* @__PURE__ */ new Date(`1970-01-01T${value}.000Z`) : IsTimeStringWithTimeZone(value) ? /* @__PURE__ */ new Date(`1970-01-01T${value}`) : IsDateTimeStringWithoutTimeZone(value) ? /* @__PURE__ */ new Date(`${value}.000Z`) : IsDateTimeStringWithTimeZone(value) ? new Date(value) : IsDateString(value) ? /* @__PURE__ */ new Date(`${value}T00:00:00.000Z`) : value;
}
function Default2(value) {
  return value;
}
function FromArray9(schema, references, value) {
  const elements = IsArray(value) ? value : [value];
  return elements.map((element2) => Visit10(schema.items, references, element2));
}
function FromBigInt5(schema, references, value) {
  return TryConvertBigInt(value);
}
function FromBoolean5(schema, references, value) {
  return TryConvertBoolean(value);
}
function FromDate5(schema, references, value) {
  return TryConvertDate(value);
}
function FromInteger5(schema, references, value) {
  return TryConvertInteger(value);
}
function FromIntersect9(schema, references, value) {
  return schema.allOf.reduce((value2, schema2) => Visit10(schema2, references, value2), value);
}
function FromLiteral6(schema, references, value) {
  return TryConvertLiteral(schema, value);
}
function FromNull5(schema, references, value) {
  return TryConvertNull(value);
}
function FromNumber5(schema, references, value) {
  return TryConvertNumber(value);
}
function FromObject7(schema, references, value) {
  const isConvertable = IsObject(value);
  if (!isConvertable)
    return value;
  const result = {};
  for (const key2 of Object.keys(value)) {
    result[key2] = HasPropertyKey(schema.properties, key2) ? Visit10(schema.properties[key2], references, value[key2]) : value[key2];
  }
  return result;
}
function FromRecord7(schema, references, value) {
  const propertyKey = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[propertyKey];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value)) {
    result[propKey] = Visit10(property, references, propValue);
  }
  return result;
}
function FromRef6(schema, references, value) {
  return Visit10(Deref(schema, references), references, value);
}
function FromString5(schema, references, value) {
  return TryConvertString(value);
}
function FromSymbol5(schema, references, value) {
  return IsString(value) || IsNumber(value) ? Symbol(value) : value;
}
function FromThis6(schema, references, value) {
  return Visit10(Deref(schema, references), references, value);
}
function FromTuple9(schema, references, value) {
  const isConvertable = IsArray(value) && !IsUndefined(schema.items);
  if (!isConvertable)
    return value;
  return value.map((value2, index3) => {
    return index3 < schema.items.length ? Visit10(schema.items[index3], references, value2) : value2;
  });
}
function FromUndefined5(schema, references, value) {
  return TryConvertUndefined(value);
}
function FromUnion11(schema, references, value) {
  for (const subschema of schema.anyOf) {
    const converted = Visit10(subschema, references, value);
    if (!Check(subschema, references, converted))
      continue;
    return converted;
  }
  return value;
}
function Visit10(schema, references, value) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray9(schema_, references_, value);
    case "BigInt":
      return FromBigInt5(schema_, references_, value);
    case "Boolean":
      return FromBoolean5(schema_, references_, value);
    case "Date":
      return FromDate5(schema_, references_, value);
    case "Integer":
      return FromInteger5(schema_, references_, value);
    case "Intersect":
      return FromIntersect9(schema_, references_, value);
    case "Literal":
      return FromLiteral6(schema_, references_, value);
    case "Null":
      return FromNull5(schema_, references_, value);
    case "Number":
      return FromNumber5(schema_, references_, value);
    case "Object":
      return FromObject7(schema_, references_, value);
    case "Record":
      return FromRecord7(schema_, references_, value);
    case "Ref":
      return FromRef6(schema_, references_, value);
    case "String":
      return FromString5(schema_, references_, value);
    case "Symbol":
      return FromSymbol5(schema_, references_, value);
    case "This":
      return FromThis6(schema_, references_, value);
    case "Tuple":
      return FromTuple9(schema_, references_, value);
    case "Undefined":
      return FromUndefined5(schema_, references_, value);
    case "Union":
      return FromUnion11(schema_, references_, value);
    default:
      return Default2(value);
  }
}
function Convert(...args) {
  return args.length === 3 ? Visit10(args[0], args[1], args[2]) : Visit10(args[0], [], args[1]);
}

// node_modules/@sinclair/typebox/build/esm/value/default/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/value/default/default.mjs
init_process();
init_buffer();
function ValueOrDefault(schema, value) {
  return value === void 0 && "default" in schema ? Clone2(schema.default) : value;
}
function IsCheckable2(schema) {
  return IsSchema2(schema) && schema[Kind] !== "Unsafe";
}
function IsDefaultSchema(value) {
  return IsSchema2(value) && "default" in value;
}
function FromArray10(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsArray(defaulted))
    return defaulted;
  for (let i2 = 0; i2 < defaulted.length; i2++) {
    defaulted[i2] = Visit11(schema.items, references, defaulted[i2]);
  }
  return defaulted;
}
function FromIntersect10(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  return schema.allOf.reduce((acc, schema2) => {
    const next = Visit11(schema2, references, defaulted);
    return IsObject(next) ? { ...acc, ...next } : next;
  }, {});
}
function FromObject8(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsObject(defaulted))
    return defaulted;
  const additionalPropertiesSchema = schema.additionalProperties;
  const knownPropertyKeys = Object.getOwnPropertyNames(schema.properties);
  for (const key2 of knownPropertyKeys) {
    if (!IsDefaultSchema(schema.properties[key2]))
      continue;
    defaulted[key2] = Visit11(schema.properties[key2], references, defaulted[key2]);
  }
  if (!IsDefaultSchema(additionalPropertiesSchema))
    return defaulted;
  for (const key2 of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKeys.includes(key2))
      continue;
    defaulted[key2] = Visit11(additionalPropertiesSchema, references, defaulted[key2]);
  }
  return defaulted;
}
function FromRecord8(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsObject(defaulted))
    return defaulted;
  const additionalPropertiesSchema = schema.additionalProperties;
  const [propertyKeyPattern, propertySchema] = Object.entries(schema.patternProperties)[0];
  const knownPropertyKey = new RegExp(propertyKeyPattern);
  for (const key2 of Object.getOwnPropertyNames(defaulted)) {
    if (!(knownPropertyKey.test(key2) && IsDefaultSchema(propertySchema)))
      continue;
    defaulted[key2] = Visit11(propertySchema, references, defaulted[key2]);
  }
  if (!IsDefaultSchema(additionalPropertiesSchema))
    return defaulted;
  for (const key2 of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKey.test(key2))
      continue;
    defaulted[key2] = Visit11(additionalPropertiesSchema, references, defaulted[key2]);
  }
  return defaulted;
}
function FromRef7(schema, references, value) {
  return Visit11(Deref(schema, references), references, ValueOrDefault(schema, value));
}
function FromThis7(schema, references, value) {
  return Visit11(Deref(schema, references), references, value);
}
function FromTuple10(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsArray(defaulted) || IsUndefined(schema.items))
    return defaulted;
  const [items, max] = [schema.items, Math.max(schema.items.length, defaulted.length)];
  for (let i2 = 0; i2 < max; i2++) {
    if (i2 < items.length)
      defaulted[i2] = Visit11(items[i2], references, defaulted[i2]);
  }
  return defaulted;
}
function FromUnion12(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  for (const inner of schema.anyOf) {
    const result = Visit11(inner, references, defaulted);
    if (IsCheckable2(inner) && Check(inner, result)) {
      return result;
    }
  }
  return defaulted;
}
function Visit11(schema, references, value) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray10(schema_, references_, value);
    case "Intersect":
      return FromIntersect10(schema_, references_, value);
    case "Object":
      return FromObject8(schema_, references_, value);
    case "Record":
      return FromRecord8(schema_, references_, value);
    case "Ref":
      return FromRef7(schema_, references_, value);
    case "This":
      return FromThis7(schema_, references_, value);
    case "Tuple":
      return FromTuple10(schema_, references_, value);
    case "Union":
      return FromUnion12(schema_, references_, value);
    default:
      return ValueOrDefault(schema_, value);
  }
}
function Default3(...args) {
  return args.length === 3 ? Visit11(args[0], args[1], args[2]) : Visit11(args[0], [], args[1]);
}

// node_modules/@sinclair/typebox/build/esm/value/delta/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/value/delta/delta.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/value/pointer/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/value/pointer/pointer.mjs
var pointer_exports = {};
__export(pointer_exports, {
  Delete: () => Delete3,
  Format: () => Format,
  Get: () => Get3,
  Has: () => Has3,
  Set: () => Set4,
  ValuePointerRootDeleteError: () => ValuePointerRootDeleteError,
  ValuePointerRootSetError: () => ValuePointerRootSetError
});
init_process();
init_buffer();
var ValuePointerRootSetError = class extends TypeBoxError {
  constructor(value, path2, update) {
    super("Cannot set root value");
    this.value = value;
    this.path = path2;
    this.update = update;
  }
};
var ValuePointerRootDeleteError = class extends TypeBoxError {
  constructor(value, path2) {
    super("Cannot delete root value");
    this.value = value;
    this.path = path2;
  }
};
function Escape2(component) {
  return component.indexOf("~") === -1 ? component : component.replace(/~1/g, "/").replace(/~0/g, "~");
}
function* Format(pointer) {
  if (pointer === "")
    return;
  let [start, end] = [0, 0];
  for (let i2 = 0; i2 < pointer.length; i2++) {
    const char = pointer.charAt(i2);
    if (char === "/") {
      if (i2 === 0) {
        start = i2 + 1;
      } else {
        end = i2;
        yield Escape2(pointer.slice(start, end));
        start = i2 + 1;
      }
    } else {
      end = i2;
    }
  }
  yield Escape2(pointer.slice(start));
}
function Set4(value, pointer, update) {
  if (pointer === "")
    throw new ValuePointerRootSetError(value, pointer, update);
  let [owner, next, key2] = [null, value, ""];
  for (const component of Format(pointer)) {
    if (next[component] === void 0)
      next[component] = {};
    owner = next;
    next = next[component];
    key2 = component;
  }
  owner[key2] = update;
}
function Delete3(value, pointer) {
  if (pointer === "")
    throw new ValuePointerRootDeleteError(value, pointer);
  let [owner, next, key2] = [null, value, ""];
  for (const component of Format(pointer)) {
    if (next[component] === void 0 || next[component] === null)
      return;
    owner = next;
    next = next[component];
    key2 = component;
  }
  if (Array.isArray(owner)) {
    const index3 = parseInt(key2);
    owner.splice(index3, 1);
  } else {
    delete owner[key2];
  }
}
function Has3(value, pointer) {
  if (pointer === "")
    return true;
  let [owner, next, key2] = [null, value, ""];
  for (const component of Format(pointer)) {
    if (next[component] === void 0)
      return false;
    owner = next;
    next = next[component];
    key2 = component;
  }
  return Object.getOwnPropertyNames(owner).includes(key2);
}
function Get3(value, pointer) {
  if (pointer === "")
    return value;
  let current = value;
  for (const component of Format(pointer)) {
    if (current[component] === void 0)
      return void 0;
    current = current[component];
  }
  return current;
}

// node_modules/@sinclair/typebox/build/esm/value/delta/delta.mjs
var Insert = Object2({
  type: Literal("insert"),
  path: String2(),
  value: Unknown()
});
var Update = Object2({
  type: Literal("update"),
  path: String2(),
  value: Unknown()
});
var Delete4 = Object2({
  type: Literal("delete"),
  path: String2()
});
var Edit = Union([Insert, Update, Delete4]);
var ValueDeltaError = class extends TypeBoxError {
  constructor(value, message2) {
    super(message2);
    this.value = value;
  }
};
var ValueDeltaSymbolError = class extends ValueDeltaError {
  constructor(value) {
    super(value, "Cannot diff objects with symbol keys");
    this.value = value;
  }
};
function CreateUpdate(path2, value) {
  return { type: "update", path: path2, value };
}
function CreateInsert(path2, value) {
  return { type: "insert", path: path2, value };
}
function CreateDelete(path2) {
  return { type: "delete", path: path2 };
}
function* ObjectType4(path2, current, next) {
  if (!IsStandardObject(next))
    return yield CreateUpdate(path2, next);
  const currentKeys = [...globalThis.Object.keys(current), ...globalThis.Object.getOwnPropertySymbols(current)];
  const nextKeys = [...globalThis.Object.keys(next), ...globalThis.Object.getOwnPropertySymbols(next)];
  for (const key2 of currentKeys) {
    if (IsSymbol(key2))
      throw new ValueDeltaSymbolError(key2);
    if (IsUndefined(next[key2]) && nextKeys.includes(key2))
      yield CreateUpdate(`${path2}/${globalThis.String(key2)}`, void 0);
  }
  for (const key2 of nextKeys) {
    if (IsUndefined(current[key2]) || IsUndefined(next[key2]))
      continue;
    if (IsSymbol(key2))
      throw new ValueDeltaSymbolError(key2);
    yield* Visit12(`${path2}/${globalThis.String(key2)}`, current[key2], next[key2]);
  }
  for (const key2 of nextKeys) {
    if (IsSymbol(key2))
      throw new ValueDeltaSymbolError(key2);
    if (IsUndefined(current[key2]))
      yield CreateInsert(`${path2}/${globalThis.String(key2)}`, next[key2]);
  }
  for (const key2 of currentKeys.reverse()) {
    if (IsSymbol(key2))
      throw new ValueDeltaSymbolError(key2);
    if (IsUndefined(next[key2]) && !nextKeys.includes(key2))
      yield CreateDelete(`${path2}/${globalThis.String(key2)}`);
  }
}
function* ArrayType4(path2, current, next) {
  if (!IsArray(next))
    return yield CreateUpdate(path2, next);
  for (let i2 = 0; i2 < Math.min(current.length, next.length); i2++) {
    yield* Visit12(`${path2}/${i2}`, current[i2], next[i2]);
  }
  for (let i2 = 0; i2 < next.length; i2++) {
    if (i2 < current.length)
      continue;
    yield CreateInsert(`${path2}/${i2}`, next[i2]);
  }
  for (let i2 = current.length - 1; i2 >= 0; i2--) {
    if (i2 < next.length)
      continue;
    yield CreateDelete(`${path2}/${i2}`);
  }
}
function* TypedArrayType2(path2, current, next) {
  if (!IsTypedArray(next) || current.length !== next.length || globalThis.Object.getPrototypeOf(current).constructor.name !== globalThis.Object.getPrototypeOf(next).constructor.name)
    return yield CreateUpdate(path2, next);
  for (let i2 = 0; i2 < Math.min(current.length, next.length); i2++) {
    yield* Visit12(`${path2}/${i2}`, current[i2], next[i2]);
  }
}
function* ValueType2(path2, current, next) {
  if (current === next)
    return;
  yield CreateUpdate(path2, next);
}
function* Visit12(path2, current, next) {
  if (IsStandardObject(current))
    return yield* ObjectType4(path2, current, next);
  if (IsArray(current))
    return yield* ArrayType4(path2, current, next);
  if (IsTypedArray(current))
    return yield* TypedArrayType2(path2, current, next);
  if (IsValueType(current))
    return yield* ValueType2(path2, current, next);
  throw new ValueDeltaError(current, "Unable to create diff edits for unknown value");
}
function Diff(current, next) {
  return [...Visit12("", current, next)];
}
function IsRootUpdate(edits) {
  return edits.length > 0 && edits[0].path === "" && edits[0].type === "update";
}
function IsIdentity(edits) {
  return edits.length === 0;
}
function Patch(current, edits) {
  if (IsRootUpdate(edits)) {
    return Clone2(edits[0].value);
  }
  if (IsIdentity(edits)) {
    return Clone2(current);
  }
  const clone = Clone2(current);
  for (const edit of edits) {
    switch (edit.type) {
      case "insert": {
        pointer_exports.Set(clone, edit.path, edit.value);
        break;
      }
      case "update": {
        pointer_exports.Set(clone, edit.path, edit.value);
        break;
      }
      case "delete": {
        pointer_exports.Delete(clone, edit.path);
        break;
      }
    }
  }
  return clone;
}

// node_modules/@sinclair/typebox/build/esm/value/equal/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/value/equal/equal.mjs
init_process();
init_buffer();
function ObjectType5(left, right) {
  if (!IsStandardObject(right))
    return false;
  const leftKeys = [...Object.keys(left), ...Object.getOwnPropertySymbols(left)];
  const rightKeys = [...Object.keys(right), ...Object.getOwnPropertySymbols(right)];
  if (leftKeys.length !== rightKeys.length)
    return false;
  return leftKeys.every((key2) => Equal(left[key2], right[key2]));
}
function DateType4(left, right) {
  return IsDate(right) && left.getTime() === right.getTime();
}
function ArrayType5(left, right) {
  if (!IsArray(right) || left.length !== right.length)
    return false;
  return left.every((value, index3) => Equal(value, right[index3]));
}
function TypedArrayType3(left, right) {
  if (!IsTypedArray(right) || left.length !== right.length || Object.getPrototypeOf(left).constructor.name !== Object.getPrototypeOf(right).constructor.name)
    return false;
  return left.every((value, index3) => Equal(value, right[index3]));
}
function ValueType3(left, right) {
  return left === right;
}
function Equal(left, right) {
  if (IsStandardObject(left))
    return ObjectType5(left, right);
  if (IsDate(left))
    return DateType4(left, right);
  if (IsTypedArray(left))
    return TypedArrayType3(left, right);
  if (IsArray(left))
    return ArrayType5(left, right);
  if (IsValueType(left))
    return ValueType3(left, right);
  throw new Error("ValueEquals: Unable to compare value");
}

// node_modules/@sinclair/typebox/build/esm/value/mutate/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/value/mutate/mutate.mjs
init_process();
init_buffer();
var ValueMutateError = class extends TypeBoxError {
  constructor(message2) {
    super(message2);
  }
};
function ObjectType6(root4, path2, current, next) {
  if (!IsStandardObject(current)) {
    pointer_exports.Set(root4, path2, Clone2(next));
  } else {
    const currentKeys = Object.getOwnPropertyNames(current);
    const nextKeys = Object.getOwnPropertyNames(next);
    for (const currentKey of currentKeys) {
      if (!nextKeys.includes(currentKey)) {
        delete current[currentKey];
      }
    }
    for (const nextKey of nextKeys) {
      if (!currentKeys.includes(nextKey)) {
        current[nextKey] = null;
      }
    }
    for (const nextKey of nextKeys) {
      Visit13(root4, `${path2}/${nextKey}`, current[nextKey], next[nextKey]);
    }
  }
}
function ArrayType6(root4, path2, current, next) {
  if (!IsArray(current)) {
    pointer_exports.Set(root4, path2, Clone2(next));
  } else {
    for (let index3 = 0; index3 < next.length; index3++) {
      Visit13(root4, `${path2}/${index3}`, current[index3], next[index3]);
    }
    current.splice(next.length);
  }
}
function TypedArrayType4(root4, path2, current, next) {
  if (IsTypedArray(current) && current.length === next.length) {
    for (let i2 = 0; i2 < current.length; i2++) {
      current[i2] = next[i2];
    }
  } else {
    pointer_exports.Set(root4, path2, Clone2(next));
  }
}
function ValueType4(root4, path2, current, next) {
  if (current === next)
    return;
  pointer_exports.Set(root4, path2, next);
}
function Visit13(root4, path2, current, next) {
  if (IsArray(next))
    return ArrayType6(root4, path2, current, next);
  if (IsTypedArray(next))
    return TypedArrayType4(root4, path2, current, next);
  if (IsStandardObject(next))
    return ObjectType6(root4, path2, current, next);
  if (IsValueType(next))
    return ValueType4(root4, path2, current, next);
}
function IsNonMutableValue(value) {
  return IsTypedArray(value) || IsValueType(value);
}
function IsMismatchedValue(current, next) {
  return IsStandardObject(current) && IsArray(next) || IsArray(current) && IsStandardObject(next);
}
function Mutate(current, next) {
  if (IsNonMutableValue(current) || IsNonMutableValue(next))
    throw new ValueMutateError("Only object and array types can be mutated at the root level");
  if (IsMismatchedValue(current, next))
    throw new ValueMutateError("Cannot assign due type mismatch of assignable values");
  Visit13(current, "", current, next);
}

// node_modules/@sinclair/typebox/build/esm/value/transform/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/value/transform/decode.mjs
init_process();
init_buffer();
var TransformDecodeCheckError = class extends TypeBoxError {
  constructor(schema, value, error3) {
    super(`Unable to decode value as it does not match the expected schema`);
    this.schema = schema;
    this.value = value;
    this.error = error3;
  }
};
var TransformDecodeError = class extends TypeBoxError {
  constructor(schema, path2, value, error3) {
    super(error3 instanceof Error ? error3.message : "Unknown error");
    this.schema = schema;
    this.path = path2;
    this.value = value;
    this.error = error3;
  }
};
function Default4(schema, path2, value) {
  try {
    return IsTransform2(schema) ? schema[TransformKind].Decode(value) : value;
  } catch (error3) {
    throw new TransformDecodeError(schema, path2, value, error3);
  }
}
function FromArray11(schema, references, path2, value) {
  return IsArray(value) ? Default4(schema, path2, value.map((value2, index3) => Visit14(schema.items, references, `${path2}/${index3}`, value2))) : Default4(schema, path2, value);
}
function FromIntersect11(schema, references, path2, value) {
  if (!IsStandardObject(value) || IsValueType(value))
    return Default4(schema, path2, value);
  const knownEntries = KeyOfPropertyEntries(schema);
  const knownKeys = knownEntries.map((entry) => entry[0]);
  const knownProperties = { ...value };
  for (const [knownKey, knownSchema] of knownEntries)
    if (knownKey in knownProperties) {
      knownProperties[knownKey] = Visit14(knownSchema, references, `${path2}/${knownKey}`, knownProperties[knownKey]);
    }
  if (!IsTransform2(schema.unevaluatedProperties)) {
    return Default4(schema, path2, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  const unknownProperties = { ...knownProperties };
  for (const key2 of unknownKeys)
    if (!knownKeys.includes(key2)) {
      unknownProperties[key2] = Default4(unevaluatedProperties, `${path2}/${key2}`, unknownProperties[key2]);
    }
  return Default4(schema, path2, unknownProperties);
}
function FromNot5(schema, references, path2, value) {
  return Default4(schema, path2, Visit14(schema.not, references, path2, value));
}
function FromObject9(schema, references, path2, value) {
  if (!IsStandardObject(value))
    return Default4(schema, path2, value);
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = { ...value };
  for (const key2 of knownKeys)
    if (key2 in knownProperties) {
      knownProperties[key2] = Visit14(schema.properties[key2], references, `${path2}/${key2}`, knownProperties[key2]);
    }
  if (!IsSchema2(schema.additionalProperties)) {
    return Default4(schema, path2, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = { ...knownProperties };
  for (const key2 of unknownKeys)
    if (!knownKeys.includes(key2)) {
      unknownProperties[key2] = Default4(additionalProperties, `${path2}/${key2}`, unknownProperties[key2]);
    }
  return Default4(schema, path2, unknownProperties);
}
function FromRecord9(schema, references, path2, value) {
  if (!IsStandardObject(value))
    return Default4(schema, path2, value);
  const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern);
  const knownProperties = { ...value };
  for (const key2 of Object.getOwnPropertyNames(value))
    if (knownKeys.test(key2)) {
      knownProperties[key2] = Visit14(schema.patternProperties[pattern], references, `${path2}/${key2}`, knownProperties[key2]);
    }
  if (!IsSchema2(schema.additionalProperties)) {
    return Default4(schema, path2, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = { ...knownProperties };
  for (const key2 of unknownKeys)
    if (!knownKeys.test(key2)) {
      unknownProperties[key2] = Default4(additionalProperties, `${path2}/${key2}`, unknownProperties[key2]);
    }
  return Default4(schema, path2, unknownProperties);
}
function FromRef8(schema, references, path2, value) {
  const target = Deref(schema, references);
  return Default4(schema, path2, Visit14(target, references, path2, value));
}
function FromThis8(schema, references, path2, value) {
  const target = Deref(schema, references);
  return Default4(schema, path2, Visit14(target, references, path2, value));
}
function FromTuple11(schema, references, path2, value) {
  return IsArray(value) && IsArray(schema.items) ? Default4(schema, path2, schema.items.map((schema2, index3) => Visit14(schema2, references, `${path2}/${index3}`, value[index3]))) : Default4(schema, path2, value);
}
function FromUnion13(schema, references, path2, value) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value))
      continue;
    const decoded = Visit14(subschema, references, path2, value);
    return Default4(schema, path2, decoded);
  }
  return Default4(schema, path2, value);
}
function Visit14(schema, references, path2, value) {
  const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray11(schema_, references_, path2, value);
    case "Intersect":
      return FromIntersect11(schema_, references_, path2, value);
    case "Not":
      return FromNot5(schema_, references_, path2, value);
    case "Object":
      return FromObject9(schema_, references_, path2, value);
    case "Record":
      return FromRecord9(schema_, references_, path2, value);
    case "Ref":
      return FromRef8(schema_, references_, path2, value);
    case "Symbol":
      return Default4(schema_, path2, value);
    case "This":
      return FromThis8(schema_, references_, path2, value);
    case "Tuple":
      return FromTuple11(schema_, references_, path2, value);
    case "Union":
      return FromUnion13(schema_, references_, path2, value);
    default:
      return Default4(schema_, path2, value);
  }
}
function TransformDecode(schema, references, value) {
  return Visit14(schema, references, "", value);
}

// node_modules/@sinclair/typebox/build/esm/value/transform/encode.mjs
init_process();
init_buffer();
var TransformEncodeCheckError = class extends TypeBoxError {
  constructor(schema, value, error3) {
    super(`The encoded value does not match the expected schema`);
    this.schema = schema;
    this.value = value;
    this.error = error3;
  }
};
var TransformEncodeError = class extends TypeBoxError {
  constructor(schema, path2, value, error3) {
    super(`${error3 instanceof Error ? error3.message : "Unknown error"}`);
    this.schema = schema;
    this.path = path2;
    this.value = value;
    this.error = error3;
  }
};
function Default5(schema, path2, value) {
  try {
    return IsTransform2(schema) ? schema[TransformKind].Encode(value) : value;
  } catch (error3) {
    throw new TransformEncodeError(schema, path2, value, error3);
  }
}
function FromArray12(schema, references, path2, value) {
  const defaulted = Default5(schema, path2, value);
  return IsArray(defaulted) ? defaulted.map((value2, index3) => Visit15(schema.items, references, `${path2}/${index3}`, value2)) : defaulted;
}
function FromIntersect12(schema, references, path2, value) {
  const defaulted = Default5(schema, path2, value);
  if (!IsStandardObject(value) || IsValueType(value))
    return defaulted;
  const knownEntries = KeyOfPropertyEntries(schema);
  const knownKeys = knownEntries.map((entry) => entry[0]);
  const knownProperties = { ...defaulted };
  for (const [knownKey, knownSchema] of knownEntries)
    if (knownKey in knownProperties) {
      knownProperties[knownKey] = Visit15(knownSchema, references, `${path2}/${knownKey}`, knownProperties[knownKey]);
    }
  if (!IsTransform2(schema.unevaluatedProperties)) {
    return Default5(schema, path2, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  const properties = { ...knownProperties };
  for (const key2 of unknownKeys)
    if (!knownKeys.includes(key2)) {
      properties[key2] = Default5(unevaluatedProperties, `${path2}/${key2}`, properties[key2]);
    }
  return properties;
}
function FromNot6(schema, references, path2, value) {
  return Default5(schema.not, path2, Default5(schema, path2, value));
}
function FromObject10(schema, references, path2, value) {
  const defaulted = Default5(schema, path2, value);
  if (!IsStandardObject(defaulted))
    return defaulted;
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = { ...defaulted };
  for (const key2 of knownKeys)
    if (key2 in knownProperties) {
      knownProperties[key2] = Visit15(schema.properties[key2], references, `${path2}/${key2}`, knownProperties[key2]);
    }
  if (!IsSchema2(schema.additionalProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const properties = { ...knownProperties };
  for (const key2 of unknownKeys)
    if (!knownKeys.includes(key2)) {
      properties[key2] = Default5(additionalProperties, `${path2}/${key2}`, properties[key2]);
    }
  return properties;
}
function FromRecord10(schema, references, path2, value) {
  const defaulted = Default5(schema, path2, value);
  if (!IsStandardObject(value))
    return defaulted;
  const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern);
  const knownProperties = { ...defaulted };
  for (const key2 of Object.getOwnPropertyNames(value))
    if (knownKeys.test(key2)) {
      knownProperties[key2] = Visit15(schema.patternProperties[pattern], references, `${path2}/${key2}`, knownProperties[key2]);
    }
  if (!IsSchema2(schema.additionalProperties)) {
    return Default5(schema, path2, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const properties = { ...knownProperties };
  for (const key2 of unknownKeys)
    if (!knownKeys.test(key2)) {
      properties[key2] = Default5(additionalProperties, `${path2}/${key2}`, properties[key2]);
    }
  return properties;
}
function FromRef9(schema, references, path2, value) {
  const target = Deref(schema, references);
  const resolved = Visit15(target, references, path2, value);
  return Default5(schema, path2, resolved);
}
function FromThis9(schema, references, path2, value) {
  const target = Deref(schema, references);
  const resolved = Visit15(target, references, path2, value);
  return Default5(schema, path2, resolved);
}
function FromTuple12(schema, references, path2, value) {
  const value1 = Default5(schema, path2, value);
  return IsArray(schema.items) ? schema.items.map((schema2, index3) => Visit15(schema2, references, `${path2}/${index3}`, value1[index3])) : [];
}
function FromUnion14(schema, references, path2, value) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value))
      continue;
    const value1 = Visit15(subschema, references, path2, value);
    return Default5(schema, path2, value1);
  }
  for (const subschema of schema.anyOf) {
    const value1 = Visit15(subschema, references, path2, value);
    if (!Check(schema, references, value1))
      continue;
    return Default5(schema, path2, value1);
  }
  return Default5(schema, path2, value);
}
function Visit15(schema, references, path2, value) {
  const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray12(schema_, references_, path2, value);
    case "Intersect":
      return FromIntersect12(schema_, references_, path2, value);
    case "Not":
      return FromNot6(schema_, references_, path2, value);
    case "Object":
      return FromObject10(schema_, references_, path2, value);
    case "Record":
      return FromRecord10(schema_, references_, path2, value);
    case "Ref":
      return FromRef9(schema_, references_, path2, value);
    case "This":
      return FromThis9(schema_, references_, path2, value);
    case "Tuple":
      return FromTuple12(schema_, references_, path2, value);
    case "Union":
      return FromUnion14(schema_, references_, path2, value);
    default:
      return Default5(schema_, path2, value);
  }
}
function TransformEncode(schema, references, value) {
  return Visit15(schema, references, "", value);
}

// node_modules/@sinclair/typebox/build/esm/value/transform/has.mjs
init_process();
init_buffer();
function FromArray13(schema, references) {
  return IsTransform2(schema) || Visit16(schema.items, references);
}
function FromAsyncIterator5(schema, references) {
  return IsTransform2(schema) || Visit16(schema.items, references);
}
function FromConstructor6(schema, references) {
  return IsTransform2(schema) || Visit16(schema.returns, references) || schema.parameters.some((schema2) => Visit16(schema2, references));
}
function FromFunction5(schema, references) {
  return IsTransform2(schema) || Visit16(schema.returns, references) || schema.parameters.some((schema2) => Visit16(schema2, references));
}
function FromIntersect13(schema, references) {
  return IsTransform2(schema) || IsTransform2(schema.unevaluatedProperties) || schema.allOf.some((schema2) => Visit16(schema2, references));
}
function FromIterator5(schema, references) {
  return IsTransform2(schema) || Visit16(schema.items, references);
}
function FromNot7(schema, references) {
  return IsTransform2(schema) || Visit16(schema.not, references);
}
function FromObject11(schema, references) {
  return IsTransform2(schema) || Object.values(schema.properties).some((schema2) => Visit16(schema2, references)) || IsSchema2(schema.additionalProperties) && Visit16(schema.additionalProperties, references);
}
function FromPromise5(schema, references) {
  return IsTransform2(schema) || Visit16(schema.item, references);
}
function FromRecord11(schema, references) {
  const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[pattern];
  return IsTransform2(schema) || Visit16(property, references) || IsSchema2(schema.additionalProperties) && IsTransform2(schema.additionalProperties);
}
function FromRef10(schema, references) {
  if (IsTransform2(schema))
    return true;
  return Visit16(Deref(schema, references), references);
}
function FromThis10(schema, references) {
  if (IsTransform2(schema))
    return true;
  return Visit16(Deref(schema, references), references);
}
function FromTuple13(schema, references) {
  return IsTransform2(schema) || !IsUndefined(schema.items) && schema.items.some((schema2) => Visit16(schema2, references));
}
function FromUnion15(schema, references) {
  return IsTransform2(schema) || schema.anyOf.some((schema2) => Visit16(schema2, references));
}
function Visit16(schema, references) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  if (schema.$id && visited.has(schema.$id))
    return false;
  if (schema.$id)
    visited.add(schema.$id);
  switch (schema[Kind]) {
    case "Array":
      return FromArray13(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator5(schema_, references_);
    case "Constructor":
      return FromConstructor6(schema_, references_);
    case "Function":
      return FromFunction5(schema_, references_);
    case "Intersect":
      return FromIntersect13(schema_, references_);
    case "Iterator":
      return FromIterator5(schema_, references_);
    case "Not":
      return FromNot7(schema_, references_);
    case "Object":
      return FromObject11(schema_, references_);
    case "Promise":
      return FromPromise5(schema_, references_);
    case "Record":
      return FromRecord11(schema_, references_);
    case "Ref":
      return FromRef10(schema_, references_);
    case "This":
      return FromThis10(schema_, references_);
    case "Tuple":
      return FromTuple13(schema_, references_);
    case "Union":
      return FromUnion15(schema_, references_);
    default:
      return IsTransform2(schema);
  }
}
var visited = /* @__PURE__ */ new Set();
function HasTransform(schema, references) {
  visited.clear();
  return Visit16(schema, references);
}

// node_modules/@sinclair/typebox/build/esm/value/value/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/value/value/value.mjs
var value_exports2 = {};
__export(value_exports2, {
  Cast: () => Cast2,
  Check: () => Check2,
  Clean: () => Clean2,
  Clone: () => Clone3,
  Convert: () => Convert2,
  Create: () => Create3,
  Decode: () => Decode,
  Default: () => Default6,
  Diff: () => Diff2,
  Encode: () => Encode,
  Equal: () => Equal2,
  Errors: () => Errors2,
  Hash: () => Hash2,
  Mutate: () => Mutate2,
  Patch: () => Patch2
});
init_process();
init_buffer();
function Cast2(...args) {
  return Cast.apply(Cast, args);
}
function Create3(...args) {
  return Create2.apply(Create2, args);
}
function Check2(...args) {
  return Check.apply(Check, args);
}
function Clean2(...args) {
  return Clean.apply(Clean, args);
}
function Convert2(...args) {
  return Convert.apply(Convert, args);
}
function Clone3(value) {
  return Clone2(value);
}
function Decode(...args) {
  const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  if (!Check2(schema, references, value))
    throw new TransformDecodeCheckError(schema, value, Errors2(schema, references, value).First());
  return HasTransform(schema, references) ? TransformDecode(schema, references, value) : value;
}
function Default6(...args) {
  return Default3.apply(Default3, args);
}
function Encode(...args) {
  const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  const encoded = HasTransform(schema, references) ? TransformEncode(schema, references, value) : value;
  if (!Check2(schema, references, encoded))
    throw new TransformEncodeCheckError(schema, encoded, Errors2(schema, references, encoded).First());
  return encoded;
}
function Errors2(...args) {
  return Errors.apply(Errors, args);
}
function Equal2(left, right) {
  return Equal(left, right);
}
function Diff2(current, next) {
  return Diff(current, next);
}
function Hash2(value) {
  return Hash(value);
}
function Patch2(current, edits) {
  return Patch(current, edits);
}
function Mutate2(current, next) {
  Mutate(current, next);
}

// node_modules/@sinclair/typebox/build/esm/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/clone/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/helpers/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/helpers/helpers.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/awaited/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/awaited/awaited.mjs
init_process();
init_buffer();
function FromRest4(T2) {
  return T2.map((L2) => AwaitedResolve(L2));
}
function FromIntersect14(T2) {
  return Intersect(FromRest4(T2));
}
function FromUnion16(T2) {
  return Union(FromRest4(T2));
}
function FromPromise6(T2) {
  return AwaitedResolve(T2);
}
function AwaitedResolve(T2) {
  return IsIntersect(T2) ? FromIntersect14(T2.allOf) : IsUnion(T2) ? FromUnion16(T2.anyOf) : IsPromise2(T2) ? FromPromise6(T2.item) : T2;
}
function Awaited(T2, options = {}) {
  return CloneType(AwaitedResolve(T2), options);
}

// node_modules/@sinclair/typebox/build/esm/type/composite/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/composite/composite.mjs
init_process();
init_buffer();
function CompositeKeys(T2) {
  const Acc = [];
  for (const L2 of T2)
    Acc.push(...KeyOfPropertyKeys(L2));
  return SetDistinct(Acc);
}
function FilterNever(T2) {
  return T2.filter((L2) => !IsNever(L2));
}
function CompositeProperty(T2, K2) {
  const Acc = [];
  for (const L2 of T2)
    Acc.push(...IndexFromPropertyKeys(L2, [K2]));
  return FilterNever(Acc);
}
function CompositeProperties(T2, K2) {
  const Acc = {};
  for (const L2 of K2) {
    Acc[L2] = IntersectEvaluated(CompositeProperty(T2, L2));
  }
  return Acc;
}
function Composite(T2, options = {}) {
  const K2 = CompositeKeys(T2);
  const P2 = CompositeProperties(T2, K2);
  const R2 = Object2(P2, options);
  return R2;
}

// node_modules/@sinclair/typebox/build/esm/type/const/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/const/const.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/date/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/date/date.mjs
init_process();
init_buffer();
function Date2(options = {}) {
  return {
    ...options,
    [Kind]: "Date",
    type: "Date"
  };
}

// node_modules/@sinclair/typebox/build/esm/type/null/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/null/null.mjs
init_process();
init_buffer();
function Null(options = {}) {
  return {
    ...options,
    [Kind]: "Null",
    type: "null"
  };
}

// node_modules/@sinclair/typebox/build/esm/type/symbol/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/symbol/symbol.mjs
init_process();
init_buffer();
function Symbol2(options) {
  return { ...options, [Kind]: "Symbol", type: "symbol" };
}

// node_modules/@sinclair/typebox/build/esm/type/undefined/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/undefined/undefined.mjs
init_process();
init_buffer();
function Undefined(options = {}) {
  return { ...options, [Kind]: "Undefined", type: "undefined" };
}

// node_modules/@sinclair/typebox/build/esm/type/uint8array/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/uint8array/uint8array.mjs
init_process();
init_buffer();
function Uint8Array2(options = {}) {
  return { ...options, [Kind]: "Uint8Array", type: "Uint8Array" };
}

// node_modules/@sinclair/typebox/build/esm/type/const/const.mjs
function FromArray14(T2) {
  return T2.map((L2) => FromValue(L2, false));
}
function FromProperties8(value) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(value))
    Acc[K2] = Readonly(FromValue(value[K2], false));
  return Acc;
}
function ConditionalReadonly(T2, root4) {
  return root4 === true ? T2 : Readonly(T2);
}
function FromValue(value, root4) {
  return IsAsyncIterator2(value) ? ConditionalReadonly(Any(), root4) : IsIterator2(value) ? ConditionalReadonly(Any(), root4) : IsArray2(value) ? Readonly(Tuple(FromArray14(value))) : IsUint8Array2(value) ? Uint8Array2() : IsDate2(value) ? Date2() : IsObject2(value) ? ConditionalReadonly(Object2(FromProperties8(value)), root4) : IsFunction2(value) ? ConditionalReadonly(Function2([], Unknown()), root4) : IsUndefined2(value) ? Undefined() : IsNull2(value) ? Null() : IsSymbol2(value) ? Symbol2() : IsBigInt2(value) ? BigInt2() : IsNumber2(value) ? Literal(value) : IsBoolean2(value) ? Literal(value) : IsString2(value) ? Literal(value) : Object2({});
}
function Const(T2, options = {}) {
  return CloneType(FromValue(T2, true), options);
}

// node_modules/@sinclair/typebox/build/esm/type/constructor-parameters/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/constructor-parameters/constructor-parameters.mjs
init_process();
init_buffer();
function ConstructorParameters(schema, options = {}) {
  return Tuple(CloneRest(schema.parameters), { ...options });
}

// node_modules/@sinclair/typebox/build/esm/type/deref/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/deref/deref.mjs
init_process();
init_buffer();
function FromRest5(schema, references) {
  return schema.map((schema2) => Deref2(schema2, references));
}
function FromProperties9(properties, references) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties)) {
    Acc[K2] = Deref2(properties[K2], references);
  }
  return Acc;
}
function FromConstructor7(schema, references) {
  schema.parameters = FromRest5(schema.parameters, references);
  schema.returns = Deref2(schema.returns, references);
  return schema;
}
function FromFunction6(schema, references) {
  schema.parameters = FromRest5(schema.parameters, references);
  schema.returns = Deref2(schema.returns, references);
  return schema;
}
function FromIntersect15(schema, references) {
  schema.allOf = FromRest5(schema.allOf, references);
  return schema;
}
function FromUnion17(schema, references) {
  schema.anyOf = FromRest5(schema.anyOf, references);
  return schema;
}
function FromTuple14(schema, references) {
  if (IsUndefined2(schema.items))
    return schema;
  schema.items = FromRest5(schema.items, references);
  return schema;
}
function FromArray15(schema, references) {
  schema.items = Deref2(schema.items, references);
  return schema;
}
function FromObject12(schema, references) {
  schema.properties = FromProperties9(schema.properties, references);
  return schema;
}
function FromPromise7(schema, references) {
  schema.item = Deref2(schema.item, references);
  return schema;
}
function FromAsyncIterator6(schema, references) {
  schema.items = Deref2(schema.items, references);
  return schema;
}
function FromIterator6(schema, references) {
  schema.items = Deref2(schema.items, references);
  return schema;
}
function FromRef11(schema, references) {
  const target = references.find((remote) => remote.$id === schema.$ref);
  if (target === void 0)
    throw Error(`Unable to dereference schema with $id ${schema.$ref}`);
  const discard = Discard(target, ["$id"]);
  return Deref2(discard, references);
}
function DerefResolve(schema, references) {
  return IsConstructor(schema) ? FromConstructor7(schema, references) : IsFunction3(schema) ? FromFunction6(schema, references) : IsIntersect(schema) ? FromIntersect15(schema, references) : IsUnion(schema) ? FromUnion17(schema, references) : IsTuple(schema) ? FromTuple14(schema, references) : IsArray3(schema) ? FromArray15(schema, references) : IsObject3(schema) ? FromObject12(schema, references) : IsPromise2(schema) ? FromPromise7(schema, references) : IsAsyncIterator3(schema) ? FromAsyncIterator6(schema, references) : IsIterator3(schema) ? FromIterator6(schema, references) : IsRef(schema) ? FromRef11(schema, references) : schema;
}
function Deref2(schema, references) {
  return DerefResolve(CloneType(schema), CloneRest(references));
}

// node_modules/@sinclair/typebox/build/esm/type/enum/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/enum/enum.mjs
init_process();
init_buffer();
function Enum(item, options = {}) {
  if (IsUndefined2(item))
    throw new Error("Enum undefined or empty");
  const values1 = globalThis.Object.getOwnPropertyNames(item).filter((key2) => isNaN(key2)).map((key2) => item[key2]);
  const values2 = [...new Set(values1)];
  const anyOf = values2.map((value) => Literal(value));
  return Union(anyOf, { ...options, [Hint]: "Enum" });
}

// node_modules/@sinclair/typebox/build/esm/type/exclude/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-mapped-result.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-template-literal.mjs
init_process();
init_buffer();
function ExcludeFromTemplateLiteral(L2, R2) {
  return Exclude(TemplateLiteralToUnion(L2), R2);
}

// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude.mjs
function ExcludeRest(L2, R2) {
  const excluded = L2.filter((inner) => ExtendsCheck(inner, R2) === ExtendsResult.False);
  return excluded.length === 1 ? excluded[0] : Union(excluded);
}
function Exclude(L2, R2, options = {}) {
  if (IsTemplateLiteral(L2))
    return CloneType(ExcludeFromTemplateLiteral(L2, R2), options);
  if (IsMappedResult(L2))
    return CloneType(ExcludeFromMappedResult(L2, R2), options);
  return CloneType(IsUnion(L2) ? ExcludeRest(L2.anyOf, R2) : ExtendsCheck(L2, R2) !== ExtendsResult.False ? Never() : L2, options);
}

// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-mapped-result.mjs
function FromProperties10(P2, U2) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P2))
    Acc[K2] = Exclude(P2[K2], U2);
  return Acc;
}
function FromMappedResult7(R2, T2) {
  return FromProperties10(R2.properties, T2);
}
function ExcludeFromMappedResult(R2, T2) {
  const P2 = FromMappedResult7(R2, T2);
  return MappedResult(P2);
}

// node_modules/@sinclair/typebox/build/esm/type/extract/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-mapped-result.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/extract/extract.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-template-literal.mjs
init_process();
init_buffer();
function ExtractFromTemplateLiteral(L2, R2) {
  return Extract(TemplateLiteralToUnion(L2), R2);
}

// node_modules/@sinclair/typebox/build/esm/type/extract/extract.mjs
function ExtractRest(L2, R2) {
  const extracted = L2.filter((inner) => ExtendsCheck(inner, R2) !== ExtendsResult.False);
  return extracted.length === 1 ? extracted[0] : Union(extracted);
}
function Extract(L2, R2, options = {}) {
  if (IsTemplateLiteral(L2))
    return CloneType(ExtractFromTemplateLiteral(L2, R2), options);
  if (IsMappedResult(L2))
    return CloneType(ExtractFromMappedResult(L2, R2), options);
  return CloneType(IsUnion(L2) ? ExtractRest(L2.anyOf, R2) : ExtendsCheck(L2, R2) !== ExtendsResult.False ? L2 : Never(), options);
}

// node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-mapped-result.mjs
function FromProperties11(P2, T2) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P2))
    Acc[K2] = Extract(P2[K2], T2);
  return Acc;
}
function FromMappedResult8(R2, T2) {
  return FromProperties11(R2.properties, T2);
}
function ExtractFromMappedResult(R2, T2) {
  const P2 = FromMappedResult8(R2, T2);
  return MappedResult(P2);
}

// node_modules/@sinclair/typebox/build/esm/type/instance-type/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/instance-type/instance-type.mjs
init_process();
init_buffer();
function InstanceType(schema, options = {}) {
  return CloneType(schema.returns, options);
}

// node_modules/@sinclair/typebox/build/esm/type/integer/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/integer/integer.mjs
init_process();
init_buffer();
function Integer(options = {}) {
  return {
    ...options,
    [Kind]: "Integer",
    type: "integer"
  };
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/capitalize.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic-from-mapped-key.mjs
init_process();
init_buffer();
function MappedIntrinsicPropertyKey(K2, M2, options) {
  return {
    [K2]: Intrinsic(Literal(K2), M2, options)
  };
}
function MappedIntrinsicPropertyKeys(K2, M2, options) {
  return K2.reduce((Acc, L2) => {
    return { ...Acc, ...MappedIntrinsicPropertyKey(L2, M2, options) };
  }, {});
}
function MappedIntrinsicProperties(T2, M2, options) {
  return MappedIntrinsicPropertyKeys(T2["keys"], M2, options);
}
function IntrinsicFromMappedKey(T2, M2, options) {
  const P2 = MappedIntrinsicProperties(T2, M2, options);
  return MappedResult(P2);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic.mjs
function ApplyUncapitalize(value) {
  const [first, rest] = [value.slice(0, 1), value.slice(1)];
  return [first.toLowerCase(), rest].join("");
}
function ApplyCapitalize(value) {
  const [first, rest] = [value.slice(0, 1), value.slice(1)];
  return [first.toUpperCase(), rest].join("");
}
function ApplyUppercase(value) {
  return value.toUpperCase();
}
function ApplyLowercase(value) {
  return value.toLowerCase();
}
function FromTemplateLiteral6(schema, mode, options) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  const finite = IsTemplateLiteralExpressionFinite(expression);
  if (!finite)
    return { ...schema, pattern: FromLiteralValue(schema.pattern, mode) };
  const strings = [...TemplateLiteralExpressionGenerate(expression)];
  const literals = strings.map((value) => Literal(value));
  const mapped = FromRest6(literals, mode);
  const union2 = Union(mapped);
  return TemplateLiteral([union2], options);
}
function FromLiteralValue(value, mode) {
  return typeof value === "string" ? mode === "Uncapitalize" ? ApplyUncapitalize(value) : mode === "Capitalize" ? ApplyCapitalize(value) : mode === "Uppercase" ? ApplyUppercase(value) : mode === "Lowercase" ? ApplyLowercase(value) : value : value.toString();
}
function FromRest6(T2, M2) {
  return T2.map((L2) => Intrinsic(L2, M2));
}
function Intrinsic(schema, mode, options = {}) {
  return (
    // Intrinsic-Mapped-Inference
    IsMappedKey(schema) ? IntrinsicFromMappedKey(schema, mode, options) : (
      // Standard-Inference
      IsTemplateLiteral(schema) ? FromTemplateLiteral6(schema, mode, schema) : IsUnion(schema) ? Union(FromRest6(schema.anyOf, mode), options) : IsLiteral(schema) ? Literal(FromLiteralValue(schema.const, mode), options) : schema
    )
  );
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/capitalize.mjs
function Capitalize(T2, options = {}) {
  return Intrinsic(T2, "Capitalize", options);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/lowercase.mjs
init_process();
init_buffer();
function Lowercase(T2, options = {}) {
  return Intrinsic(T2, "Lowercase", options);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/uncapitalize.mjs
init_process();
init_buffer();
function Uncapitalize(T2, options = {}) {
  return Intrinsic(T2, "Uncapitalize", options);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/uppercase.mjs
init_process();
init_buffer();
function Uppercase(T2, options = {}) {
  return Intrinsic(T2, "Uppercase", options);
}

// node_modules/@sinclair/typebox/build/esm/type/not/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/not/not.mjs
init_process();
init_buffer();
function Not2(schema, options) {
  return {
    ...options,
    [Kind]: "Not",
    not: CloneType(schema)
  };
}

// node_modules/@sinclair/typebox/build/esm/type/omit/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-key.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/omit/omit.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-result.mjs
init_process();
init_buffer();
function FromProperties12(P2, K2, options) {
  const Acc = {};
  for (const K22 of globalThis.Object.getOwnPropertyNames(P2))
    Acc[K22] = Omit(P2[K22], K2, options);
  return Acc;
}
function FromMappedResult9(R2, K2, options) {
  return FromProperties12(R2.properties, K2, options);
}
function OmitFromMappedResult(R2, K2, options) {
  const P2 = FromMappedResult9(R2, K2, options);
  return MappedResult(P2);
}

// node_modules/@sinclair/typebox/build/esm/type/omit/omit.mjs
function FromIntersect16(T2, K2) {
  return T2.map((T3) => OmitResolve(T3, K2));
}
function FromUnion18(T2, K2) {
  return T2.map((T3) => OmitResolve(T3, K2));
}
function FromProperty2(T2, K2) {
  const { [K2]: _, ...R2 } = T2;
  return R2;
}
function FromProperties13(T2, K2) {
  return K2.reduce((T3, K22) => FromProperty2(T3, K22), T2);
}
function OmitResolve(T2, K2) {
  return IsIntersect(T2) ? Intersect(FromIntersect16(T2.allOf, K2)) : IsUnion(T2) ? Union(FromUnion18(T2.anyOf, K2)) : IsObject3(T2) ? Object2(FromProperties13(T2.properties, K2)) : Object2({});
}
function Omit(T2, K2, options = {}) {
  if (IsMappedKey(K2))
    return OmitFromMappedKey(T2, K2, options);
  if (IsMappedResult(T2))
    return OmitFromMappedResult(T2, K2, options);
  const I2 = IsSchema(K2) ? IndexPropertyKeys(K2) : K2;
  const D2 = Discard(T2, [TransformKind, "$id", "required"]);
  const R2 = CloneType(OmitResolve(T2, I2), options);
  return { ...D2, ...R2 };
}

// node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-key.mjs
function FromPropertyKey2(T2, K2, options) {
  return {
    [K2]: Omit(T2, [K2], options)
  };
}
function FromPropertyKeys2(T2, K2, options) {
  return K2.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey2(T2, LK, options) };
  }, {});
}
function FromMappedKey3(T2, K2, options) {
  return FromPropertyKeys2(T2, K2.keys, options);
}
function OmitFromMappedKey(T2, K2, options) {
  const P2 = FromMappedKey3(T2, K2, options);
  return MappedResult(P2);
}

// node_modules/@sinclair/typebox/build/esm/type/parameters/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/parameters/parameters.mjs
init_process();
init_buffer();
function Parameters(schema, options = {}) {
  return Tuple(CloneRest(schema.parameters), { ...options });
}

// node_modules/@sinclair/typebox/build/esm/type/partial/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/partial/partial-from-mapped-result.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/partial/partial.mjs
init_process();
init_buffer();
function FromRest7(T2) {
  return T2.map((L2) => PartialResolve(L2));
}
function FromProperties14(T2) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(T2))
    Acc[K2] = Optional(T2[K2]);
  return Acc;
}
function PartialResolve(T2) {
  return IsIntersect(T2) ? Intersect(FromRest7(T2.allOf)) : IsUnion(T2) ? Union(FromRest7(T2.anyOf)) : IsObject3(T2) ? Object2(FromProperties14(T2.properties)) : Object2({});
}
function Partial(T2, options = {}) {
  if (IsMappedResult(T2))
    return PartialFromMappedResult(T2, options);
  const D2 = Discard(T2, [TransformKind, "$id", "required"]);
  const R2 = CloneType(PartialResolve(T2), options);
  return { ...D2, ...R2 };
}

// node_modules/@sinclair/typebox/build/esm/type/partial/partial-from-mapped-result.mjs
function FromProperties15(K2, options) {
  const Acc = {};
  for (const K22 of globalThis.Object.getOwnPropertyNames(K2))
    Acc[K22] = Partial(K2[K22], options);
  return Acc;
}
function FromMappedResult10(R2, options) {
  return FromProperties15(R2.properties, options);
}
function PartialFromMappedResult(R2, options) {
  const P2 = FromMappedResult10(R2, options);
  return MappedResult(P2);
}

// node_modules/@sinclair/typebox/build/esm/type/pick/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-key.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/pick/pick.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-result.mjs
init_process();
init_buffer();
function FromProperties16(P2, K2, options) {
  const Acc = {};
  for (const K22 of globalThis.Object.getOwnPropertyNames(P2))
    Acc[K22] = Pick(P2[K22], K2, options);
  return Acc;
}
function FromMappedResult11(R2, K2, options) {
  return FromProperties16(R2.properties, K2, options);
}
function PickFromMappedResult(R2, K2, options) {
  const P2 = FromMappedResult11(R2, K2, options);
  return MappedResult(P2);
}

// node_modules/@sinclair/typebox/build/esm/type/pick/pick.mjs
function FromIntersect17(T2, K2) {
  return T2.map((T3) => PickResolve(T3, K2));
}
function FromUnion19(T2, K2) {
  return T2.map((T3) => PickResolve(T3, K2));
}
function FromProperties17(T2, K2) {
  const Acc = {};
  for (const K22 of K2)
    if (K22 in T2)
      Acc[K22] = T2[K22];
  return Acc;
}
function PickResolve(T2, K2) {
  return IsIntersect(T2) ? Intersect(FromIntersect17(T2.allOf, K2)) : IsUnion(T2) ? Union(FromUnion19(T2.anyOf, K2)) : IsObject3(T2) ? Object2(FromProperties17(T2.properties, K2)) : Object2({});
}
function Pick(T2, K2, options = {}) {
  if (IsMappedKey(K2))
    return PickFromMappedKey(T2, K2, options);
  if (IsMappedResult(T2))
    return PickFromMappedResult(T2, K2, options);
  const I2 = IsSchema(K2) ? IndexPropertyKeys(K2) : K2;
  const D2 = Discard(T2, [TransformKind, "$id", "required"]);
  const R2 = CloneType(PickResolve(T2, I2), options);
  return { ...D2, ...R2 };
}

// node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-key.mjs
function FromPropertyKey3(T2, K2, options) {
  return {
    [K2]: Pick(T2, [K2], options)
  };
}
function FromPropertyKeys3(T2, K2, options) {
  return K2.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey3(T2, LK, options) };
  }, {});
}
function FromMappedKey4(T2, K2, options) {
  return FromPropertyKeys3(T2, K2.keys, options);
}
function PickFromMappedKey(T2, K2, options) {
  const P2 = FromMappedKey4(T2, K2, options);
  return MappedResult(P2);
}

// node_modules/@sinclair/typebox/build/esm/type/readonly-optional/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/readonly-optional/readonly-optional.mjs
init_process();
init_buffer();
function ReadonlyOptional(schema) {
  return Readonly(Optional(schema));
}

// node_modules/@sinclair/typebox/build/esm/type/record/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/record/record.mjs
init_process();
init_buffer();
function RecordCreateFromPattern(pattern, T2, options) {
  return {
    ...options,
    [Kind]: "Record",
    type: "object",
    patternProperties: { [pattern]: CloneType(T2) }
  };
}
function RecordCreateFromKeys(K2, T2, options) {
  const Acc = {};
  for (const K22 of K2)
    Acc[K22] = CloneType(T2);
  return Object2(Acc, { ...options, [Hint]: "Record" });
}
function FromTemplateLiteralKey(K2, T2, options) {
  return IsTemplateLiteralFinite(K2) ? RecordCreateFromKeys(IndexPropertyKeys(K2), T2, options) : RecordCreateFromPattern(K2.pattern, T2, options);
}
function FromUnionKey(K2, T2, options) {
  return RecordCreateFromKeys(IndexPropertyKeys(Union(K2)), T2, options);
}
function FromLiteralKey(K2, T2, options) {
  return RecordCreateFromKeys([K2.toString()], T2, options);
}
function FromRegExpKey(K2, T2, options) {
  return RecordCreateFromPattern(K2.source, T2, options);
}
function FromStringKey(K2, T2, options) {
  const pattern = IsUndefined2(K2.pattern) ? PatternStringExact : K2.pattern;
  return RecordCreateFromPattern(pattern, T2, options);
}
function FromIntegerKey(_, T2, options) {
  return RecordCreateFromPattern(PatternNumberExact, T2, options);
}
function FromNumberKey(_, T2, options) {
  return RecordCreateFromPattern(PatternNumberExact, T2, options);
}
function Record(K2, T2, options = {}) {
  return IsUnion(K2) ? FromUnionKey(K2.anyOf, T2, options) : IsTemplateLiteral(K2) ? FromTemplateLiteralKey(K2, T2, options) : IsLiteral(K2) ? FromLiteralKey(K2.const, T2, options) : IsInteger2(K2) ? FromIntegerKey(K2, T2, options) : IsNumber3(K2) ? FromNumberKey(K2, T2, options) : IsRegExp2(K2) ? FromRegExpKey(K2, T2, options) : IsString3(K2) ? FromStringKey(K2, T2, options) : Never(options);
}

// node_modules/@sinclair/typebox/build/esm/type/recursive/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/recursive/recursive.mjs
init_process();
init_buffer();
var Ordinal = 0;
function Recursive(callback, options = {}) {
  if (IsUndefined2(options.$id))
    options.$id = `T${Ordinal++}`;
  const thisType = callback({ [Kind]: "This", $ref: `${options.$id}` });
  thisType.$id = options.$id;
  return CloneType({ ...options, [Hint]: "Recursive", ...thisType });
}

// node_modules/@sinclair/typebox/build/esm/type/ref/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/ref/ref.mjs
init_process();
init_buffer();
function Ref(unresolved, options = {}) {
  if (IsString2(unresolved))
    return { ...options, [Kind]: "Ref", $ref: unresolved };
  if (IsUndefined2(unresolved.$id))
    throw new Error("Reference target type must specify an $id");
  return {
    ...options,
    [Kind]: "Ref",
    $ref: unresolved.$id
  };
}

// node_modules/@sinclair/typebox/build/esm/type/regexp/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/regexp/regexp.mjs
init_process();
init_buffer();
function RegExp2(unresolved, options = {}) {
  const expr = IsString2(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
  return { ...options, [Kind]: "RegExp", type: "RegExp", source: expr.source, flags: expr.flags };
}

// node_modules/@sinclair/typebox/build/esm/type/required/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/required/required-from-mapped-result.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/required/required.mjs
init_process();
init_buffer();
function FromRest8(T2) {
  return T2.map((L2) => RequiredResolve(L2));
}
function FromProperties18(T2) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(T2))
    Acc[K2] = Discard(T2[K2], [OptionalKind]);
  return Acc;
}
function RequiredResolve(T2) {
  return IsIntersect(T2) ? Intersect(FromRest8(T2.allOf)) : IsUnion(T2) ? Union(FromRest8(T2.anyOf)) : IsObject3(T2) ? Object2(FromProperties18(T2.properties)) : Object2({});
}
function Required(T2, options = {}) {
  if (IsMappedResult(T2)) {
    return RequiredFromMappedResult(T2, options);
  } else {
    const D2 = Discard(T2, [TransformKind, "$id", "required"]);
    const R2 = CloneType(RequiredResolve(T2), options);
    return { ...D2, ...R2 };
  }
}

// node_modules/@sinclair/typebox/build/esm/type/required/required-from-mapped-result.mjs
function FromProperties19(P2, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P2))
    Acc[K2] = Required(P2[K2], options);
  return Acc;
}
function FromMappedResult12(R2, options) {
  return FromProperties19(R2.properties, options);
}
function RequiredFromMappedResult(R2, options) {
  const P2 = FromMappedResult12(R2, options);
  return MappedResult(P2);
}

// node_modules/@sinclair/typebox/build/esm/type/rest/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/rest/rest.mjs
init_process();
init_buffer();
function RestResolve(T2) {
  return IsIntersect(T2) ? CloneRest(T2.allOf) : IsUnion(T2) ? CloneRest(T2.anyOf) : IsTuple(T2) ? CloneRest(T2.items ?? []) : [];
}
function Rest(T2) {
  return CloneRest(RestResolve(T2));
}

// node_modules/@sinclair/typebox/build/esm/type/return-type/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/return-type/return-type.mjs
init_process();
init_buffer();
function ReturnType(schema, options = {}) {
  return CloneType(schema.returns, options);
}

// node_modules/@sinclair/typebox/build/esm/type/schema/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/schema/anyschema.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/schema/schema.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/static/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/static/static.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/strict/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/strict/strict.mjs
init_process();
init_buffer();
function Strict(schema) {
  return JSON.parse(JSON.stringify(schema));
}

// node_modules/@sinclair/typebox/build/esm/type/transform/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/transform/transform.mjs
init_process();
init_buffer();
var TransformDecodeBuilder = class {
  constructor(schema) {
    this.schema = schema;
  }
  Decode(decode3) {
    return new TransformEncodeBuilder(this.schema, decode3);
  }
};
var TransformEncodeBuilder = class {
  constructor(schema, decode3) {
    this.schema = schema;
    this.decode = decode3;
  }
  EncodeTransform(encode3, schema) {
    const Encode2 = (value) => schema[TransformKind].Encode(encode3(value));
    const Decode2 = (value) => this.decode(schema[TransformKind].Decode(value));
    const Codec = { Encode: Encode2, Decode: Decode2 };
    return { ...schema, [TransformKind]: Codec };
  }
  EncodeSchema(encode3, schema) {
    const Codec = { Decode: this.decode, Encode: encode3 };
    return { ...schema, [TransformKind]: Codec };
  }
  Encode(encode3) {
    const schema = CloneType(this.schema);
    return IsTransform(schema) ? this.EncodeTransform(encode3, schema) : this.EncodeSchema(encode3, schema);
  }
};
function Transform(schema) {
  return new TransformDecodeBuilder(schema);
}

// node_modules/@sinclair/typebox/build/esm/type/void/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/void/void.mjs
init_process();
init_buffer();
function Void(options = {}) {
  return {
    ...options,
    [Kind]: "Void",
    type: "void"
  };
}

// node_modules/@sinclair/typebox/build/esm/type/type/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/type/json.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/type/type.mjs
var type_exports3 = {};
__export(type_exports3, {
  Any: () => Any,
  Array: () => Array2,
  AsyncIterator: () => AsyncIterator,
  Awaited: () => Awaited,
  BigInt: () => BigInt2,
  Boolean: () => Boolean2,
  Capitalize: () => Capitalize,
  Composite: () => Composite,
  Const: () => Const,
  Constructor: () => Constructor,
  ConstructorParameters: () => ConstructorParameters,
  Date: () => Date2,
  Deref: () => Deref2,
  Enum: () => Enum,
  Exclude: () => Exclude,
  Extends: () => Extends,
  Extract: () => Extract,
  Function: () => Function2,
  Index: () => Index,
  InstanceType: () => InstanceType,
  Integer: () => Integer,
  Intersect: () => Intersect,
  Iterator: () => Iterator,
  KeyOf: () => KeyOf,
  Literal: () => Literal,
  Lowercase: () => Lowercase,
  Mapped: () => Mapped,
  Never: () => Never,
  Not: () => Not2,
  Null: () => Null,
  Number: () => Number2,
  Object: () => Object2,
  Omit: () => Omit,
  Optional: () => Optional,
  Parameters: () => Parameters,
  Partial: () => Partial,
  Pick: () => Pick,
  Promise: () => Promise2,
  Readonly: () => Readonly,
  ReadonlyOptional: () => ReadonlyOptional,
  Record: () => Record,
  Recursive: () => Recursive,
  Ref: () => Ref,
  RegExp: () => RegExp2,
  Required: () => Required,
  Rest: () => Rest,
  ReturnType: () => ReturnType,
  Strict: () => Strict,
  String: () => String2,
  Symbol: () => Symbol2,
  TemplateLiteral: () => TemplateLiteral,
  Transform: () => Transform,
  Tuple: () => Tuple,
  Uint8Array: () => Uint8Array2,
  Uncapitalize: () => Uncapitalize,
  Undefined: () => Undefined,
  Union: () => Union,
  Unknown: () => Unknown,
  Unsafe: () => Unsafe,
  Uppercase: () => Uppercase,
  Void: () => Void
});
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/type/javascript.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/type/type/index.mjs
var Type = type_exports3;

// node_modules/@sinclair/typebox/build/esm/compiler/index.mjs
init_process();
init_buffer();

// node_modules/@sinclair/typebox/build/esm/compiler/compiler.mjs
init_process();
init_buffer();
var TypeCheck = class {
  constructor(schema, references, checkFunc, code4) {
    this.schema = schema;
    this.references = references;
    this.checkFunc = checkFunc;
    this.code = code4;
    this.hasTransform = HasTransform(schema, references);
  }
  /** Returns the generated assertion code used to validate this type. */
  Code() {
    return this.code;
  }
  /** Returns an iterator for each error in this value. */
  Errors(value) {
    return Errors(this.schema, this.references, value);
  }
  /** Returns true if the value matches the compiled type. */
  Check(value) {
    return this.checkFunc(value);
  }
  /** Decodes a value or throws if error */
  Decode(value) {
    if (!this.checkFunc(value))
      throw new TransformDecodeCheckError(this.schema, value, this.Errors(value).First());
    return this.hasTransform ? TransformDecode(this.schema, this.references, value) : value;
  }
  /** Encodes a value or throws if error */
  Encode(value) {
    const encoded = this.hasTransform ? TransformEncode(this.schema, this.references, value) : value;
    if (!this.checkFunc(encoded))
      throw new TransformEncodeCheckError(this.schema, value, this.Errors(value).First());
    return encoded;
  }
};
var Character;
(function(Character2) {
  function DollarSign(code4) {
    return code4 === 36;
  }
  Character2.DollarSign = DollarSign;
  function IsUnderscore(code4) {
    return code4 === 95;
  }
  Character2.IsUnderscore = IsUnderscore;
  function IsAlpha(code4) {
    return code4 >= 65 && code4 <= 90 || code4 >= 97 && code4 <= 122;
  }
  Character2.IsAlpha = IsAlpha;
  function IsNumeric(code4) {
    return code4 >= 48 && code4 <= 57;
  }
  Character2.IsNumeric = IsNumeric;
})(Character || (Character = {}));
var MemberExpression;
(function(MemberExpression2) {
  function IsFirstCharacterNumeric(value) {
    if (value.length === 0)
      return false;
    return Character.IsNumeric(value.charCodeAt(0));
  }
  function IsAccessor(value) {
    if (IsFirstCharacterNumeric(value))
      return false;
    for (let i2 = 0; i2 < value.length; i2++) {
      const code4 = value.charCodeAt(i2);
      const check = Character.IsAlpha(code4) || Character.IsNumeric(code4) || Character.DollarSign(code4) || Character.IsUnderscore(code4);
      if (!check)
        return false;
    }
    return true;
  }
  function EscapeHyphen(key2) {
    return key2.replace(/'/g, "\\'");
  }
  function Encode2(object, key2) {
    return IsAccessor(key2) ? `${object}.${key2}` : `${object}['${EscapeHyphen(key2)}']`;
  }
  MemberExpression2.Encode = Encode2;
})(MemberExpression || (MemberExpression = {}));
var Identifier;
(function(Identifier2) {
  function Encode2($id) {
    const buffer = [];
    for (let i2 = 0; i2 < $id.length; i2++) {
      const code4 = $id.charCodeAt(i2);
      if (Character.IsNumeric(code4) || Character.IsAlpha(code4)) {
        buffer.push($id.charAt(i2));
      } else {
        buffer.push(`_${code4}_`);
      }
    }
    return buffer.join("").replace(/__/g, "_");
  }
  Identifier2.Encode = Encode2;
})(Identifier || (Identifier = {}));
var LiteralString;
(function(LiteralString2) {
  function Escape3(content3) {
    return content3.replace(/'/g, "\\'");
  }
  LiteralString2.Escape = Escape3;
})(LiteralString || (LiteralString = {}));
var TypeCompilerUnknownTypeError = class extends TypeBoxError {
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
};
var TypeCompilerTypeGuardError = class extends TypeBoxError {
  constructor(schema) {
    super("Preflight validation check failed to guard for the given schema");
    this.schema = schema;
  }
};
var Policy;
(function(Policy2) {
  function IsExactOptionalProperty(value, key2, expression) {
    return TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${key2}' in ${value} ? ${expression} : true)` : `(${MemberExpression.Encode(value, key2)} !== undefined ? ${expression} : true)`;
  }
  Policy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}))` : `(typeof ${value} === 'object' && ${value} !== null)`;
  }
  Policy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}) && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))` : `(typeof ${value} === 'object' && ${value} !== null && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))`;
  }
  Policy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value) {
    return TypeSystemPolicy.AllowNaN ? `typeof ${value} === 'number'` : `Number.isFinite(${value})`;
  }
  Policy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value) {
    return TypeSystemPolicy.AllowNullVoid ? `(${value} === undefined || ${value} === null)` : `${value} === undefined`;
  }
  Policy2.IsVoidLike = IsVoidLike;
})(Policy || (Policy = {}));
var TypeCompiler;
(function(TypeCompiler2) {
  function IsAnyOrUnknown2(schema) {
    return schema[Kind] === "Any" || schema[Kind] === "Unknown";
  }
  function* FromAny5(schema, references, value) {
    yield "true";
  }
  function* FromArray16(schema, references, value) {
    yield `Array.isArray(${value})`;
    const [parameter, accumulator] = [CreateParameter("value", "any"), CreateParameter("acc", "number")];
    if (IsNumber(schema.maxItems))
      yield `${value}.length <= ${schema.maxItems}`;
    if (IsNumber(schema.minItems))
      yield `${value}.length >= ${schema.minItems}`;
    const elementExpression = CreateExpression(schema.items, references, "value");
    yield `${value}.every((${parameter}) => ${elementExpression})`;
    if (IsSchema2(schema.contains) || IsNumber(schema.minContains) || IsNumber(schema.maxContains)) {
      const containsSchema = IsSchema2(schema.contains) ? schema.contains : Never();
      const checkExpression = CreateExpression(containsSchema, references, "value");
      const checkMinContains = IsNumber(schema.minContains) ? [`(count >= ${schema.minContains})`] : [];
      const checkMaxContains = IsNumber(schema.maxContains) ? [`(count <= ${schema.maxContains})`] : [];
      const checkCount = `const count = value.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`;
      const check = [`(count > 0)`, ...checkMinContains, ...checkMaxContains].join(" && ");
      yield `((${parameter}) => { ${checkCount}; return ${check}})(${value})`;
    }
    if (schema.uniqueItems === true) {
      const check = `const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true`;
      const block = `const set = new Set(); for(const element of value) { ${check} }`;
      yield `((${parameter}) => { ${block} )(${value})`;
    }
  }
  function* FromAsyncIterator7(schema, references, value) {
    yield `(typeof value === 'object' && Symbol.asyncIterator in ${value})`;
  }
  function* FromBigInt6(schema, references, value) {
    yield `(typeof ${value} === 'bigint')`;
    if (IsBigInt(schema.exclusiveMaximum))
      yield `${value} < BigInt(${schema.exclusiveMaximum})`;
    if (IsBigInt(schema.exclusiveMinimum))
      yield `${value} > BigInt(${schema.exclusiveMinimum})`;
    if (IsBigInt(schema.maximum))
      yield `${value} <= BigInt(${schema.maximum})`;
    if (IsBigInt(schema.minimum))
      yield `${value} >= BigInt(${schema.minimum})`;
    if (IsBigInt(schema.multipleOf))
      yield `(${value} % BigInt(${schema.multipleOf})) === 0`;
  }
  function* FromBoolean6(schema, references, value) {
    yield `(typeof ${value} === 'boolean')`;
  }
  function* FromConstructor8(schema, references, value) {
    yield* Visit17(schema.returns, references, `${value}.prototype`);
  }
  function* FromDate6(schema, references, value) {
    yield `(${value} instanceof Date) && Number.isFinite(${value}.getTime())`;
    if (IsNumber(schema.exclusiveMaximumTimestamp))
      yield `${value}.getTime() < ${schema.exclusiveMaximumTimestamp}`;
    if (IsNumber(schema.exclusiveMinimumTimestamp))
      yield `${value}.getTime() > ${schema.exclusiveMinimumTimestamp}`;
    if (IsNumber(schema.maximumTimestamp))
      yield `${value}.getTime() <= ${schema.maximumTimestamp}`;
    if (IsNumber(schema.minimumTimestamp))
      yield `${value}.getTime() >= ${schema.minimumTimestamp}`;
    if (IsNumber(schema.multipleOfTimestamp))
      yield `(${value}.getTime() % ${schema.multipleOfTimestamp}) === 0`;
  }
  function* FromFunction7(schema, references, value) {
    yield `(typeof ${value} === 'function')`;
  }
  function* FromInteger6(schema, references, value) {
    yield `Number.isInteger(${value})`;
    if (IsNumber(schema.exclusiveMaximum))
      yield `${value} < ${schema.exclusiveMaximum}`;
    if (IsNumber(schema.exclusiveMinimum))
      yield `${value} > ${schema.exclusiveMinimum}`;
    if (IsNumber(schema.maximum))
      yield `${value} <= ${schema.maximum}`;
    if (IsNumber(schema.minimum))
      yield `${value} >= ${schema.minimum}`;
    if (IsNumber(schema.multipleOf))
      yield `(${value} % ${schema.multipleOf}) === 0`;
  }
  function* FromIntersect18(schema, references, value) {
    const check1 = schema.allOf.map((schema2) => CreateExpression(schema2, references, value)).join(" && ");
    if (schema.unevaluatedProperties === false) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema))};`);
      const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key))`;
      yield `(${check1} && ${check2})`;
    } else if (IsSchema2(schema.unevaluatedProperties)) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema))};`);
      const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema.unevaluatedProperties, references, `${value}[key]`)})`;
      yield `(${check1} && ${check2})`;
    } else {
      yield `(${check1})`;
    }
  }
  function* FromIterator7(schema, references, value) {
    yield `(typeof value === 'object' && Symbol.iterator in ${value})`;
  }
  function* FromLiteral7(schema, references, value) {
    if (typeof schema.const === "number" || typeof schema.const === "boolean") {
      yield `(${value} === ${schema.const})`;
    } else {
      yield `(${value} === '${LiteralString.Escape(schema.const)}')`;
    }
  }
  function* FromNever6(schema, references, value) {
    yield `false`;
  }
  function* FromNot8(schema, references, value) {
    const expression = CreateExpression(schema.not, references, value);
    yield `(!${expression})`;
  }
  function* FromNull6(schema, references, value) {
    yield `(${value} === null)`;
  }
  function* FromNumber6(schema, references, value) {
    yield Policy.IsNumberLike(value);
    if (IsNumber(schema.exclusiveMaximum))
      yield `${value} < ${schema.exclusiveMaximum}`;
    if (IsNumber(schema.exclusiveMinimum))
      yield `${value} > ${schema.exclusiveMinimum}`;
    if (IsNumber(schema.maximum))
      yield `${value} <= ${schema.maximum}`;
    if (IsNumber(schema.minimum))
      yield `${value} >= ${schema.minimum}`;
    if (IsNumber(schema.multipleOf))
      yield `(${value} % ${schema.multipleOf}) === 0`;
  }
  function* FromObject13(schema, references, value) {
    yield Policy.IsObjectLike(value);
    if (IsNumber(schema.minProperties))
      yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;
    if (IsNumber(schema.maxProperties))
      yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;
    const knownKeys = Object.getOwnPropertyNames(schema.properties);
    for (const knownKey of knownKeys) {
      const memberExpression = MemberExpression.Encode(value, knownKey);
      const property = schema.properties[knownKey];
      if (schema.required && schema.required.includes(knownKey)) {
        yield* Visit17(property, references, memberExpression);
        if (ExtendsUndefinedCheck(property) || IsAnyOrUnknown2(property))
          yield `('${knownKey}' in ${value})`;
      } else {
        const expression = CreateExpression(property, references, memberExpression);
        yield Policy.IsExactOptionalProperty(value, knownKey, expression);
      }
    }
    if (schema.additionalProperties === false) {
      if (schema.required && schema.required.length === knownKeys.length) {
        yield `Object.getOwnPropertyNames(${value}).length === ${knownKeys.length}`;
      } else {
        const keys3 = `[${knownKeys.map((key2) => `'${key2}'`).join(", ")}]`;
        yield `Object.getOwnPropertyNames(${value}).every(key => ${keys3}.includes(key))`;
      }
    }
    if (typeof schema.additionalProperties === "object") {
      const expression = CreateExpression(schema.additionalProperties, references, `${value}[key]`);
      const keys3 = `[${knownKeys.map((key2) => `'${key2}'`).join(", ")}]`;
      yield `(Object.getOwnPropertyNames(${value}).every(key => ${keys3}.includes(key) || ${expression}))`;
    }
  }
  function* FromPromise8(schema, references, value) {
    yield `(typeof value === 'object' && typeof ${value}.then === 'function')`;
  }
  function* FromRecord12(schema, references, value) {
    yield Policy.IsRecordLike(value);
    if (IsNumber(schema.minProperties))
      yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;
    if (IsNumber(schema.maxProperties))
      yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;
    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
    const variable = CreateVariable(`${new RegExp(patternKey)}`);
    const check1 = CreateExpression(patternSchema, references, "value");
    const check2 = IsSchema2(schema.additionalProperties) ? CreateExpression(schema.additionalProperties, references, value) : schema.additionalProperties === false ? "false" : "true";
    const expression = `(${variable}.test(key) ? ${check1} : ${check2})`;
    yield `(Object.entries(${value}).every(([key, value]) => ${expression}))`;
  }
  function* FromRef12(schema, references, value) {
    const target = Deref(schema, references);
    if (state.functions.has(schema.$ref))
      return yield `${CreateFunctionName(schema.$ref)}(${value})`;
    yield* Visit17(target, references, value);
  }
  function* FromRegExp5(schema, references, value) {
    const variable = CreateVariable(`${new RegExp(schema.source, schema.flags)};`);
    yield `(typeof ${value} === 'string')`;
    if (IsNumber(schema.maxLength))
      yield `${value}.length <= ${schema.maxLength}`;
    if (IsNumber(schema.minLength))
      yield `${value}.length >= ${schema.minLength}`;
    yield `${variable}.test(${value})`;
  }
  function* FromString6(schema, references, value) {
    yield `(typeof ${value} === 'string')`;
    if (IsNumber(schema.maxLength))
      yield `${value}.length <= ${schema.maxLength}`;
    if (IsNumber(schema.minLength))
      yield `${value}.length >= ${schema.minLength}`;
    if (schema.pattern !== void 0) {
      const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
      yield `${variable}.test(${value})`;
    }
    if (schema.format !== void 0) {
      yield `format('${schema.format}', ${value})`;
    }
  }
  function* FromSymbol6(schema, references, value) {
    yield `(typeof ${value} === 'symbol')`;
  }
  function* FromTemplateLiteral7(schema, references, value) {
    yield `(typeof ${value} === 'string')`;
    const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
    yield `${variable}.test(${value})`;
  }
  function* FromThis11(schema, references, value) {
    yield `${CreateFunctionName(schema.$ref)}(${value})`;
  }
  function* FromTuple15(schema, references, value) {
    yield `Array.isArray(${value})`;
    if (schema.items === void 0)
      return yield `${value}.length === 0`;
    yield `(${value}.length === ${schema.maxItems})`;
    for (let i2 = 0; i2 < schema.items.length; i2++) {
      const expression = CreateExpression(schema.items[i2], references, `${value}[${i2}]`);
      yield `${expression}`;
    }
  }
  function* FromUndefined6(schema, references, value) {
    yield `${value} === undefined`;
  }
  function* FromUnion20(schema, references, value) {
    const expressions = schema.anyOf.map((schema2) => CreateExpression(schema2, references, value));
    yield `(${expressions.join(" || ")})`;
  }
  function* FromUint8Array5(schema, references, value) {
    yield `${value} instanceof Uint8Array`;
    if (IsNumber(schema.maxByteLength))
      yield `(${value}.length <= ${schema.maxByteLength})`;
    if (IsNumber(schema.minByteLength))
      yield `(${value}.length >= ${schema.minByteLength})`;
  }
  function* FromUnknown5(schema, references, value) {
    yield "true";
  }
  function* FromVoid5(schema, references, value) {
    yield Policy.IsVoidLike(value);
  }
  function* FromKind4(schema, references, value) {
    const instance = state.instances.size;
    state.instances.set(instance, schema);
    yield `kind('${schema[Kind]}', ${instance}, ${value})`;
  }
  function* Visit17(schema, references, value, useHoisting = true) {
    const references_ = IsString(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    if (useHoisting && IsString(schema.$id)) {
      const functionName = CreateFunctionName(schema.$id);
      if (state.functions.has(functionName)) {
        return yield `${functionName}(${value})`;
      } else {
        const functionCode = CreateFunction(functionName, schema, references, "value", false);
        state.functions.set(functionName, functionCode);
        return yield `${functionName}(${value})`;
      }
    }
    switch (schema_[Kind]) {
      case "Any":
        return yield* FromAny5(schema_, references_, value);
      case "Array":
        return yield* FromArray16(schema_, references_, value);
      case "AsyncIterator":
        return yield* FromAsyncIterator7(schema_, references_, value);
      case "BigInt":
        return yield* FromBigInt6(schema_, references_, value);
      case "Boolean":
        return yield* FromBoolean6(schema_, references_, value);
      case "Constructor":
        return yield* FromConstructor8(schema_, references_, value);
      case "Date":
        return yield* FromDate6(schema_, references_, value);
      case "Function":
        return yield* FromFunction7(schema_, references_, value);
      case "Integer":
        return yield* FromInteger6(schema_, references_, value);
      case "Intersect":
        return yield* FromIntersect18(schema_, references_, value);
      case "Iterator":
        return yield* FromIterator7(schema_, references_, value);
      case "Literal":
        return yield* FromLiteral7(schema_, references_, value);
      case "Never":
        return yield* FromNever6(schema_, references_, value);
      case "Not":
        return yield* FromNot8(schema_, references_, value);
      case "Null":
        return yield* FromNull6(schema_, references_, value);
      case "Number":
        return yield* FromNumber6(schema_, references_, value);
      case "Object":
        return yield* FromObject13(schema_, references_, value);
      case "Promise":
        return yield* FromPromise8(schema_, references_, value);
      case "Record":
        return yield* FromRecord12(schema_, references_, value);
      case "Ref":
        return yield* FromRef12(schema_, references_, value);
      case "RegExp":
        return yield* FromRegExp5(schema_, references_, value);
      case "String":
        return yield* FromString6(schema_, references_, value);
      case "Symbol":
        return yield* FromSymbol6(schema_, references_, value);
      case "TemplateLiteral":
        return yield* FromTemplateLiteral7(schema_, references_, value);
      case "This":
        return yield* FromThis11(schema_, references_, value);
      case "Tuple":
        return yield* FromTuple15(schema_, references_, value);
      case "Undefined":
        return yield* FromUndefined6(schema_, references_, value);
      case "Union":
        return yield* FromUnion20(schema_, references_, value);
      case "Uint8Array":
        return yield* FromUint8Array5(schema_, references_, value);
      case "Unknown":
        return yield* FromUnknown5(schema_, references_, value);
      case "Void":
        return yield* FromVoid5(schema_, references_, value);
      default:
        if (!type_exports.Has(schema_[Kind]))
          throw new TypeCompilerUnknownTypeError(schema);
        return yield* FromKind4(schema_, references_, value);
    }
  }
  const state = {
    language: "javascript",
    // target language
    functions: /* @__PURE__ */ new Map(),
    // local functions
    variables: /* @__PURE__ */ new Map(),
    // local variables
    instances: /* @__PURE__ */ new Map()
    // exterior kind instances
  };
  function CreateExpression(schema, references, value, useHoisting = true) {
    return `(${[...Visit17(schema, references, value, useHoisting)].join(" && ")})`;
  }
  function CreateFunctionName($id) {
    return `check_${Identifier.Encode($id)}`;
  }
  function CreateVariable(expression) {
    const variableName = `local_${state.variables.size}`;
    state.variables.set(variableName, `const ${variableName} = ${expression}`);
    return variableName;
  }
  function CreateFunction(name, schema, references, value, useHoisting = true) {
    const [newline, pad] = ["\n", (length) => "".padStart(length, " ")];
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const expression = [...Visit17(schema, references, value, useHoisting)].map((expression2) => `${pad(4)}${expression2}`).join(` &&${newline}`);
    return `function ${name}(${parameter})${returns} {${newline}${pad(2)}return (${newline}${expression}${newline}${pad(2)})
}`;
  }
  function CreateParameter(name, type) {
    const annotation = state.language === "typescript" ? `: ${type}` : "";
    return `${name}${annotation}`;
  }
  function CreateReturns(type) {
    return state.language === "typescript" ? `: ${type}` : "";
  }
  function Build(schema, references, options) {
    const functionCode = CreateFunction("check", schema, references, "value");
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const functions = [...state.functions.values()];
    const variables = [...state.variables.values()];
    const checkFunction = IsString(schema.$id) ? `return function check(${parameter})${returns} {
  return ${CreateFunctionName(schema.$id)}(value)
}` : `return ${functionCode}`;
    return [...variables, ...functions, checkFunction].join("\n");
  }
  function Code(...args) {
    const defaults = { language: "javascript" };
    const [schema, references, options] = args.length === 2 && IsArray(args[1]) ? [args[0], args[1], defaults] : args.length === 2 && !IsArray(args[1]) ? [args[0], [], args[1]] : args.length === 3 ? [args[0], args[1], args[2]] : args.length === 1 ? [args[0], [], defaults] : [null, [], defaults];
    state.language = options.language;
    state.variables.clear();
    state.functions.clear();
    state.instances.clear();
    if (!IsSchema2(schema))
      throw new TypeCompilerTypeGuardError(schema);
    for (const schema2 of references)
      if (!IsSchema2(schema2))
        throw new TypeCompilerTypeGuardError(schema2);
    return Build(schema, references, options);
  }
  TypeCompiler2.Code = Code;
  function Compile(schema, references = []) {
    const generatedCode = Code(schema, references, { language: "javascript" });
    const compiledFunction = globalThis.Function("kind", "format", "hash", generatedCode);
    const instances = new Map(state.instances);
    function typeRegistryFunction(kind, instance, value) {
      if (!type_exports.Has(kind) || !instances.has(instance))
        return false;
      const checkFunc = type_exports.Get(kind);
      const schema2 = instances.get(instance);
      return checkFunc(schema2, value);
    }
    function formatRegistryFunction(format3, value) {
      if (!format_exports.Has(format3))
        return false;
      const checkFunc = format_exports.Get(format3);
      return checkFunc(value);
    }
    function hashFunction(value) {
      return Hash(value);
    }
    const checkFunction = compiledFunction(typeRegistryFunction, formatRegistryFunction, hashFunction);
    return new TypeCheck(schema, references, checkFunction, generatedCode);
  }
  TypeCompiler2.Compile = Compile;
})(TypeCompiler || (TypeCompiler = {}));

// node_modules/elysia/dist/index.mjs
var import_cookie = __toESM(require_cookie(), 1);
var import_cookie2 = __toESM(require_cookie(), 1);
var import_fast_decode_uri_component = __toESM(require_fast_decode_uri_component(), 1);
var import_fast_decode_uri_component2 = __toESM(require_fast_decode_uri_component(), 1);
var import_fast_decode_uri_component3 = __toESM(require_fast_decode_uri_component(), 1);
var createNode = (part, inert) => {
  const inertMap = inert?.length ? {} : null;
  if (inertMap)
    for (const child of inert)
      inertMap[child.part.charCodeAt(0)] = child;
  return {
    part,
    store: null,
    inert: inertMap,
    params: null,
    wildcardStore: null
  };
};
var cloneNode = (node3, part) => ({
  ...node3,
  part
});
var createParamNode = (name) => ({
  name,
  store: null,
  inert: null
});
var _a88;
var Memoirist = (_a88 = class {
  root = {};
  history = [];
  add(method, path2, store, {
    ignoreError = false,
    ignoreHistory = false
  } = {}) {
    if (typeof path2 !== "string")
      throw new TypeError("Route path must be a string");
    if (path2 === "")
      path2 = "/";
    else if (path2[0] !== "/")
      path2 = `/${path2}`;
    const isWildcard = path2[path2.length - 1] === "*";
    const optionalParams = path2.match(_a88.regex.optionalParams);
    if (optionalParams) {
      const originalPath = path2.replaceAll("?", "");
      this.add(method, originalPath, store, {
        ignoreError
      });
      for (let i2 = 0; i2 < optionalParams.length; i2++) {
        let newPath = path2.replace("/" + optionalParams[i2], "");
        this.add(method, newPath, store, {
          ignoreError: true
        });
      }
      return store;
    }
    if (optionalParams)
      path2 = path2.replaceAll("?", "");
    if (this.history.find(([m2, p3, s2]) => m2 === method && p3 === path2))
      return store;
    if (isWildcard || optionalParams && path2.charCodeAt(path2.length - 1) === 63)
      path2 = path2.slice(0, -1);
    if (!ignoreHistory)
      this.history.push([method, path2, store]);
    const inertParts = path2.split(_a88.regex.static);
    const paramParts = path2.match(_a88.regex.params) || [];
    if (inertParts[inertParts.length - 1] === "")
      inertParts.pop();
    let node3;
    if (!this.root[method])
      node3 = this.root[method] = createNode("/");
    else
      node3 = this.root[method];
    let paramPartsIndex = 0;
    for (let i2 = 0; i2 < inertParts.length; ++i2) {
      let part = inertParts[i2];
      if (i2 > 0) {
        const param = paramParts[paramPartsIndex++].slice(1);
        if (node3.params === null)
          node3.params = createParamNode(param);
        else if (node3.params.name !== param) {
          if (ignoreError)
            return store;
          else
            throw new Error(
              `Cannot create route "${path2}" with parameter "${param}" because a route already exists with a different parameter name ("${node3.params.name}") in the same location`
            );
        }
        const params = node3.params;
        if (params.inert === null) {
          node3 = params.inert = createNode(part);
          continue;
        }
        node3 = params.inert;
      }
      for (let j2 = 0; ; ) {
        if (j2 === part.length) {
          if (j2 < node3.part.length) {
            const childNode = cloneNode(node3, node3.part.slice(j2));
            Object.assign(node3, createNode(part, [childNode]));
          }
          break;
        }
        if (j2 === node3.part.length) {
          if (node3.inert === null)
            node3.inert = {};
          const inert = node3.inert[part.charCodeAt(j2)];
          if (inert) {
            node3 = inert;
            part = part.slice(j2);
            j2 = 0;
            continue;
          }
          const childNode = createNode(part.slice(j2));
          node3.inert[part.charCodeAt(j2)] = childNode;
          node3 = childNode;
          break;
        }
        if (part[j2] !== node3.part[j2]) {
          const existingChild = cloneNode(node3, node3.part.slice(j2));
          const newChild = createNode(part.slice(j2));
          Object.assign(
            node3,
            createNode(node3.part.slice(0, j2), [
              existingChild,
              newChild
            ])
          );
          node3 = newChild;
          break;
        }
        ++j2;
      }
    }
    if (paramPartsIndex < paramParts.length) {
      const param = paramParts[paramPartsIndex];
      const name = param.slice(1);
      if (node3.params === null)
        node3.params = createParamNode(name);
      else if (node3.params.name !== name) {
        if (ignoreError)
          return store;
        else
          throw new Error(
            `Cannot create route "${path2}" with parameter "${name}" because a route already exists with a different parameter name ("${node3.params.name}") in the same location`
          );
      }
      if (node3.params.store === null)
        node3.params.store = store;
      return node3.params.store;
    }
    if (isWildcard) {
      if (node3.wildcardStore === null)
        node3.wildcardStore = store;
      return node3.wildcardStore;
    }
    if (node3.store === null)
      node3.store = store;
    return node3.store;
  }
  find(method, url) {
    const root4 = this.root[method];
    if (!root4)
      return null;
    return matchRoute(url, url.length, root4, 0);
  }
}, __publicField(_a88, "regex", {
  static: /:.+?(?=\/|$)/,
  params: /:.+?(?=\/|$)/g,
  optionalParams: /:.+?\?(?=\/|$)/g
}), _a88);
var matchRoute = (url, urlLength, node3, startIndex) => {
  const part = node3.part;
  const length = part.length;
  const endIndex = startIndex + length;
  if (length > 1) {
    if (endIndex > urlLength)
      return null;
    if (length < 15) {
      for (let i2 = 1, j2 = startIndex + 1; i2 < length; ++i2, ++j2)
        if (part.charCodeAt(i2) !== url.charCodeAt(j2))
          return null;
    } else if (url.slice(startIndex, endIndex) !== part)
      return null;
  }
  if (endIndex === urlLength) {
    if (node3.store !== null)
      return {
        store: node3.store,
        params: {}
      };
    if (node3.wildcardStore !== null)
      return {
        store: node3.wildcardStore,
        params: { "*": "" }
      };
    return null;
  }
  if (node3.inert !== null) {
    const inert = node3.inert[url.charCodeAt(endIndex)];
    if (inert !== void 0) {
      const route = matchRoute(url, urlLength, inert, endIndex);
      if (route !== null)
        return route;
    }
  }
  if (node3.params !== null) {
    const { store, name, inert } = node3.params;
    const slashIndex = url.indexOf("/", endIndex);
    if (slashIndex !== endIndex) {
      if (slashIndex === -1 || slashIndex >= urlLength) {
        if (store !== null) {
          const params = {};
          params[name] = url.substring(endIndex, urlLength);
          return {
            store,
            params
          };
        }
      } else if (inert !== null) {
        const route = matchRoute(url, urlLength, inert, slashIndex);
        if (route !== null) {
          route.params[name] = url.substring(endIndex, slashIndex);
          return route;
        }
      }
    }
  }
  if (node3.wildcardStore !== null)
    return {
      store: node3.wildcardStore,
      params: {
        "*": url.substring(endIndex, urlLength)
      }
    };
  return null;
};
var hasReturn = (fn) => {
  const fnLiteral = typeof fn === "object" ? fn.fn.toString() : typeof fn === "string" ? fn.toString() : fn;
  const parenthesisEnd = fnLiteral.indexOf(")");
  if (fnLiteral.charCodeAt(parenthesisEnd + 2) === 61 && fnLiteral.charCodeAt(parenthesisEnd + 5) !== 123) {
    return true;
  }
  return fnLiteral.includes("return");
};
var separateFunction = (code4) => {
  if (code4.startsWith("async"))
    code4 = code4.slice(5);
  code4 = code4.trimStart();
  let index3 = -1;
  if (code4.charCodeAt(0) === 40) {
    index3 = code4.indexOf("=>", code4.indexOf(")"));
    if (index3 !== -1) {
      let bracketEndIndex = index3;
      while (bracketEndIndex > 0)
        if (code4.charCodeAt(--bracketEndIndex) === 41)
          break;
      let body3 = code4.slice(index3 + 2);
      if (body3.charCodeAt(0) === 32)
        body3 = body3.trimStart();
      return [
        code4.slice(1, bracketEndIndex),
        body3,
        {
          isArrowReturn: body3.charCodeAt(0) !== 123
        }
      ];
    }
  }
  if (code4.startsWith("function")) {
    index3 = code4.indexOf("(");
    const end = code4.indexOf(")");
    return [
      code4.slice(index3 + 1, end),
      code4.slice(end + 2),
      {
        isArrowReturn: false
      }
    ];
  }
  const start = code4.indexOf("(");
  if (start !== -1) {
    const sep2 = code4.indexOf("\n", 2);
    const parameter = code4.slice(0, sep2);
    const end = parameter.lastIndexOf(")") + 1;
    const body3 = code4.slice(sep2 + 1);
    return [
      parameter.slice(start, end),
      "{" + body3,
      {
        isArrowReturn: false
      }
    ];
  }
  const x2 = code4.split("\n", 2);
  return [x2[0], x2[1], { isArrowReturn: false }];
};
var bracketPairRange = (parameter) => {
  const start = parameter.indexOf("{");
  if (start === -1)
    return [-1, 0];
  let end = start + 1;
  let deep = 1;
  for (; end < parameter.length; end++) {
    const char = parameter.charCodeAt(end);
    if (char === 123)
      deep++;
    else if (char === 125)
      deep--;
    if (deep === 0)
      break;
  }
  if (deep !== 0)
    return [0, parameter.length];
  return [start, end + 1];
};
var bracketPairRangeReverse = (parameter) => {
  const end = parameter.lastIndexOf("}");
  if (end === -1)
    return [-1, 0];
  let start = end - 1;
  let deep = 1;
  for (; start >= 0; start--) {
    const char = parameter.charCodeAt(start);
    if (char === 125)
      deep++;
    else if (char === 123)
      deep--;
    if (deep === 0)
      break;
  }
  if (deep !== 0)
    return [-1, 0];
  return [start, end + 1];
};
var removeColonAlias = (parameter) => {
  while (true) {
    const start = parameter.indexOf(":");
    if (start === -1)
      break;
    let end = parameter.indexOf(",", start);
    if (end === -1)
      end = parameter.indexOf("}", start) - 1;
    if (end === -2)
      end = parameter.length;
    parameter = parameter.slice(0, start) + parameter.slice(end);
  }
  return parameter;
};
var retrieveRootParamters = (parameter) => {
  let hasParenthesis = false;
  if (parameter.charCodeAt(0) === 40)
    parameter = parameter.slice(1, -1);
  if (parameter.charCodeAt(0) === 123) {
    hasParenthesis = true;
    parameter = parameter.slice(1, -1);
  }
  parameter = parameter.replace(/( |\t|\n)/g, "").trim();
  let parameters = [];
  while (true) {
    let [start, end] = bracketPairRange(parameter);
    if (start === -1)
      break;
    parameters.push(parameter.slice(0, start - 1));
    if (parameter.charCodeAt(end) === 44)
      end++;
    parameter = parameter.slice(end);
  }
  parameter = removeColonAlias(parameter);
  if (parameter)
    parameters = parameters.concat(parameter.split(","));
  const newParameters = [];
  for (const p3 of parameters) {
    if (p3.indexOf(",") === -1) {
      newParameters.push(p3);
      continue;
    }
    for (const q2 of p3.split(","))
      newParameters.push(q2.trim());
  }
  parameters = newParameters;
  return {
    hasParenthesis,
    parameters
  };
};
var findParameterReference = (parameter, inference) => {
  const { parameters, hasParenthesis } = retrieveRootParamters(parameter);
  if (!inference.query && parameters.includes("query"))
    inference.query = true;
  if (!inference.headers && parameters.includes("headers"))
    inference.headers = true;
  if (!inference.body && parameters.includes("body"))
    inference.body = true;
  if (!inference.cookie && parameters.includes("cookie"))
    inference.cookie = true;
  if (!inference.set && parameters.includes("set"))
    inference.set = true;
  if (!inference.server && parameters.includes("server"))
    inference.server = true;
  if (hasParenthesis)
    return `{ ${parameters.join(", ")} }`;
  return parameters.join(", ");
};
var findEndIndex = (type, content3, index3) => {
  const newLineIndex = content3.indexOf(type + "\n", index3);
  const newTabIndex = content3.indexOf(type + "	", index3);
  const commaIndex = content3.indexOf(type + ",", index3);
  const semicolonIndex = content3.indexOf(type + ";", index3);
  const emptyIndex = content3.indexOf(type + " ", index3);
  return [newLineIndex, newTabIndex, commaIndex, semicolonIndex, emptyIndex].filter((i2) => i2 > 0).sort((a2, b2) => a2 - b2)[0] || -1;
};
var findAlias = (type, body3, depth = 0) => {
  if (depth > 5)
    return [];
  const aliases = [];
  let content3 = body3;
  while (true) {
    let index3 = findEndIndex(" = " + type, content3);
    if (index3 === -1) {
      const lastIndex = content3.indexOf(" = " + type);
      if (lastIndex + 3 + type.length !== content3.length)
        break;
      index3 = lastIndex;
    }
    const part = content3.slice(0, index3);
    let variable = part.slice(part.lastIndexOf(" ") + 1);
    if (variable === "}") {
      const [start, end] = bracketPairRangeReverse(part);
      aliases.push(removeColonAlias(content3.slice(start, end)));
      content3 = content3.slice(index3 + 3 + type.length);
      continue;
    }
    while (variable.charCodeAt(0) === 44)
      variable = variable.slice(1);
    while (variable.charCodeAt(0) === 9)
      variable = variable.slice(1);
    if (!variable.includes("("))
      aliases.push(variable);
    content3 = content3.slice(index3 + 3 + type.length);
  }
  for (const alias of aliases) {
    if (alias.charCodeAt(0) === 123)
      continue;
    const deepAlias = findAlias(alias, body3);
    if (deepAlias.length > 0)
      aliases.push(...deepAlias);
  }
  return aliases;
};
var extractMainParameter = (parameter) => {
  if (!parameter)
    return;
  if (parameter.charCodeAt(0) !== 123)
    return parameter;
  parameter = parameter.slice(2, -2);
  const hasComma = parameter.includes(",");
  if (!hasComma) {
    if (parameter.includes("..."))
      return parameter.slice(parameter.indexOf("...") + 3);
    return;
  }
  const spreadIndex = parameter.indexOf("...");
  if (spreadIndex === -1)
    return;
  return parameter.slice(spreadIndex + 3).trimEnd();
};
var inferBodyReference = (code4, aliases, inference) => {
  const access = (type, alias) => code4.includes(alias + "." + type) || code4.includes(alias + '["' + type + '"]') || code4.includes(alias + "['" + type + "']");
  for (const alias of aliases) {
    if (!alias)
      continue;
    if (alias.charCodeAt(0) === 123) {
      const parameters = retrieveRootParamters(alias).parameters;
      if (!inference.query && parameters.includes("query"))
        inference.query = true;
      if (!inference.headers && parameters.includes("headers"))
        inference.headers = true;
      if (!inference.body && parameters.includes("body"))
        inference.body = true;
      if (!inference.cookie && parameters.includes("cookie"))
        inference.cookie = true;
      if (!inference.set && parameters.includes("set"))
        inference.set = true;
      if (!inference.query && parameters.includes("server"))
        inference.server = true;
      continue;
    }
    if (!inference.query && access("query", alias))
      inference.query = true;
    if (code4.includes("return " + alias) || code4.includes("return " + alias + ".query"))
      inference.query = true;
    if (!inference.headers && access("headers", alias))
      inference.headers = true;
    if (!inference.body && access("body", alias))
      inference.body = true;
    if (!inference.cookie && access("cookie", alias))
      inference.cookie = true;
    if (!inference.set && access("set", alias))
      inference.set = true;
    if (!inference.server && access("server", alias))
      inference.server = true;
    if (inference.query && inference.headers && inference.body && inference.cookie && inference.set && inference.server)
      break;
  }
  return aliases;
};
var isContextPassToFunction = (context, body3, inference) => {
  try {
    const captureFunction = new RegExp(`(?:\\w)\\((?:.*)?${context}`, "gs");
    captureFunction.test(body3);
    const nextChar = body3.charCodeAt(captureFunction.lastIndex);
    if (nextChar === 41 || nextChar === 44) {
      inference.query = true;
      inference.headers = true;
      inference.body = true;
      inference.cookie = true;
      inference.set = true;
      inference.server = true;
      return true;
    }
    return false;
  } catch (error22) {
    console.log(
      "[Sucrose] warning: unexpected isContextPassToFunction error, you may continue development as usual but please report the following to maintainers:"
    );
    console.log("--- body ---");
    console.log(body3);
    console.log("--- context ---");
    console.log(context);
    return true;
  }
};
var sucrose = (lifeCycle, inference = {
  query: false,
  headers: false,
  body: false,
  cookie: false,
  set: false,
  server: false
}) => {
  const events = [];
  if (lifeCycle.handler && typeof lifeCycle.handler === "function")
    events.push(lifeCycle.handler);
  if (lifeCycle.request?.length)
    events.push(...lifeCycle.request);
  if (lifeCycle.beforeHandle?.length)
    events.push(...lifeCycle.beforeHandle);
  if (lifeCycle.parse?.length)
    events.push(...lifeCycle.parse);
  if (lifeCycle.error?.length)
    events.push(...lifeCycle.error);
  if (lifeCycle.transform?.length)
    events.push(...lifeCycle.transform);
  if (lifeCycle.afterHandle?.length)
    events.push(...lifeCycle.afterHandle);
  if (lifeCycle.mapResponse?.length)
    events.push(...lifeCycle.mapResponse);
  if (lifeCycle.afterResponse?.length)
    events.push(...lifeCycle.afterResponse);
  for (const e2 of events) {
    if (!e2)
      continue;
    const event = "fn" in e2 ? e2.fn : e2;
    const [parameter, body3, { isArrowReturn }] = separateFunction(
      event.toString()
    );
    const rootParameters = findParameterReference(parameter, inference);
    const mainParameter = extractMainParameter(rootParameters);
    if (mainParameter) {
      const aliases = findAlias(mainParameter, body3);
      aliases.splice(0, -1, mainParameter);
      if (!isContextPassToFunction(mainParameter, body3, inference))
        inferBodyReference(body3, aliases, inference);
      if (!inference.query && body3.includes("return " + mainParameter + ".query"))
        inference.query = true;
    }
    if (inference.query && inference.headers && inference.body && inference.cookie && inference.set && inference.server)
      break;
  }
  return inference;
};
var fullFormats = {
  // date: http://tools.ietf.org/html/rfc3339#section-5.6
  date,
  // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
  time: getTime(true),
  "date-time": getDateTime(true),
  "iso-time": getTime(false),
  "iso-date-time": getDateTime(false),
  // duration: https://tools.ietf.org/html/rfc3339#appendix-A
  duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
  uri,
  "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
  // uri-template: https://tools.ietf.org/html/rfc6570
  "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
  // For the source: https://gist.github.com/dperini/729294
  // For test cases: https://mathiasbynens.be/demo/url-regex
  url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
  email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
  hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
  // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
  ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
  regex,
  // uuid: http://tools.ietf.org/html/rfc4122
  uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
  // JSON-pointer: https://tools.ietf.org/html/rfc6901
  // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
  "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
  "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
  // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
  "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
  // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
  // byte: https://github.com/miguelmota/is-base64
  byte,
  // signed 32 bit integer
  int32: { type: "number", validate: validateInt32 },
  // signed 64 bit integer
  int64: { type: "number", validate: validateInt64 },
  // C-type float
  float: { type: "number", validate: validateNumber },
  // C-type double
  double: { type: "number", validate: validateNumber },
  // hint to the UI to hide input strings
  password: true,
  // unchecked string payload
  binary: true
};
function isLeapYear(year2) {
  return year2 % 4 === 0 && (year2 % 100 !== 0 || year2 % 400 === 0);
}
var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function date(str) {
  const matches = DATE.exec(str);
  if (!matches)
    return false;
  const year2 = +matches[1];
  const month = +matches[2];
  const day2 = +matches[3];
  return month >= 1 && month <= 12 && day2 >= 1 && day2 <= (month === 2 && isLeapYear(year2) ? 29 : DAYS[month]);
}
var TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
function getTime(strictTimeZone) {
  return function time(str) {
    const matches = TIME.exec(str);
    if (!matches)
      return false;
    const hr = +matches[1];
    const min = +matches[2];
    const sec = +matches[3];
    const tz = matches[4];
    const tzSign = matches[5] === "-" ? -1 : 1;
    const tzH = +(matches[6] || 0);
    const tzM = +(matches[7] || 0);
    if (tzH > 23 || tzM > 59 || strictTimeZone && !tz)
      return false;
    if (hr <= 23 && min <= 59 && sec < 60)
      return true;
    const utcMin = min - tzM * tzSign;
    const utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
    return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
  };
}
var DATE_TIME_SEPARATOR = /t|\s/i;
function getDateTime(strictTimeZone) {
  const time = getTime(strictTimeZone);
  return function date_time(str) {
    const dateTime = str.split(DATE_TIME_SEPARATOR);
    return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1]);
  };
}
var NOT_URI_FRAGMENT = /\/|:/;
var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
function uri(str) {
  return NOT_URI_FRAGMENT.test(str) && URI.test(str);
}
var BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
function byte(str) {
  BYTE.lastIndex = 0;
  return BYTE.test(str);
}
var MIN_INT32 = -(2 ** 31);
var MAX_INT32 = 2 ** 31 - 1;
function validateInt32(value) {
  return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
}
function validateInt64(value) {
  return Number.isInteger(value);
}
function validateNumber() {
  return true;
}
var Z_ANCHOR = /[^\\]\\Z/;
function regex(str) {
  if (Z_ANCHOR.test(str))
    return false;
  try {
    new RegExp(str);
    return true;
  } catch (e2) {
    return false;
  }
}
var isISO8601 = /(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))/;
var isFormalDate = /(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s\d{2}\s\d{4}\s\d{2}:\d{2}:\d{2}\sGMT(?:\+|-)\d{4}\s\([^)]+\)/;
var isShortenDate = /^(?:(?:(?:(?:0?[1-9]|[12][0-9]|3[01])[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:19|20)\d{2})|(?:(?:19|20)\d{2}[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:0?[1-9]|[12][0-9]|3[01]))))(?:\s(?:1[012]|0?[1-9]):[0-5][0-9](?::[0-5][0-9])?(?:\s[AP]M)?)?$/;
var _validateDate = fullFormats.date;
var _validateDateTime = fullFormats["date-time"];
if (!format_exports.Has("date"))
  TypeSystem.Format("date", (value) => {
    const temp = value.replace(/"/g, "");
    if (isISO8601.test(temp) || isFormalDate.test(temp) || isShortenDate.test(temp) || _validateDate(temp)) {
      const date2 = new Date(temp);
      if (!Number.isNaN(date2.getTime()))
        return true;
    }
    return false;
  });
if (!format_exports.Has("date-time"))
  TypeSystem.Format("date-time", (value) => {
    const temp = value.replace(/"/g, "");
    if (isISO8601.test(temp) || isFormalDate.test(temp) || isShortenDate.test(temp) || _validateDateTime(temp)) {
      const date2 = new Date(temp);
      if (!Number.isNaN(date2.getTime()))
        return true;
    }
    return false;
  });
Object.entries(fullFormats).forEach((formatEntry) => {
  const [formatName, formatValue2] = formatEntry;
  if (!format_exports.Has(formatName)) {
    if (formatValue2 instanceof RegExp)
      TypeSystem.Format(formatName, (value) => formatValue2.test(value));
    else if (typeof formatValue2 === "function")
      TypeSystem.Format(formatName, formatValue2);
  }
});
var t = Object.assign({}, Type);
var parseFileUnit = (size) => {
  if (typeof size === "string")
    switch (size.slice(-1)) {
      case "k":
        return +size.slice(0, size.length - 1) * 1024;
      case "m":
        return +size.slice(0, size.length - 1) * 1048576;
      default:
        return +size;
    }
  return size;
};
var validateFile = (options, value) => {
  if (!(value instanceof Blob))
    return false;
  if (options.minSize && value.size < parseFileUnit(options.minSize))
    return false;
  if (options.maxSize && value.size > parseFileUnit(options.maxSize))
    return false;
  if (options.extension)
    if (typeof options.extension === "string") {
      if (!value.type.startsWith(options.extension))
        return false;
    } else {
      for (let i2 = 0; i2 < options.extension.length; i2++)
        if (value.type.startsWith(options.extension[i2]))
          return true;
      return false;
    }
  return true;
};
var File2 = type_exports.Get("Files") ?? TypeSystem.Type("File", validateFile);
var Files = type_exports.Get("Files") ?? TypeSystem.Type(
  "Files",
  (options, value) => {
    if (!Array.isArray(value))
      return validateFile(options, value);
    if (options.minItems && value.length < options.minItems)
      return false;
    if (options.maxItems && value.length > options.maxItems)
      return false;
    for (let i2 = 0; i2 < value.length; i2++)
      if (!validateFile(options, value[i2]))
        return false;
    return true;
  }
);
if (!format_exports.Has("numeric"))
  format_exports.Set("numeric", (value) => !!value && !isNaN(+value));
if (!format_exports.Has("boolean"))
  format_exports.Set(
    "boolean",
    (value) => value === "true" || value === "false"
  );
if (!format_exports.Has("ObjectString"))
  format_exports.Set("ObjectString", (value) => {
    let start = value.charCodeAt(0);
    if (start === 9 || start === 10 || start === 32)
      start = value.trimStart().charCodeAt(0);
    if (start !== 123 && start !== 91)
      return false;
    try {
      JSON.parse(value);
      return true;
    } catch {
      return false;
    }
  });
if (!format_exports.Has("ArrayString"))
  format_exports.Set("ArrayString", (value) => {
    let start = value.charCodeAt(0);
    if (start === 9 || start === 10 || start === 32)
      start = value.trimStart().charCodeAt(0);
    if (start !== 123 && start !== 91)
      return false;
    try {
      JSON.parse(value);
      return true;
    } catch {
      return false;
    }
  });
var ElysiaType = {
  Numeric: (property) => {
    const schema = Type.Number(property);
    return t.Transform(
      t.Union(
        [
          t.String({
            format: "numeric",
            default: 0
          }),
          t.Number(property)
        ],
        property
      )
    ).Decode((value) => {
      const number2 = +value;
      if (isNaN(number2))
        return value;
      if (property && !value_exports2.Check(schema, number2))
        throw new ValidationError("property", schema, number2);
      return number2;
    }).Encode((value) => value);
  },
  Date: (property) => {
    const schema = Type.Date(property);
    return t.Transform(
      t.Union(
        [
          Type.Date(property),
          t.String({
            format: "date",
            default: (/* @__PURE__ */ new Date()).toISOString()
          }),
          t.String({
            format: "date-time",
            default: (/* @__PURE__ */ new Date()).toISOString()
          })
        ],
        property
      )
    ).Decode((value) => {
      if (value instanceof Date)
        return value;
      const date2 = new Date(value);
      if (!value_exports2.Check(schema, date2))
        throw new ValidationError("property", schema, date2);
      return date2;
    }).Encode((value) => {
      if (typeof value === "string")
        return new Date(value);
      return value;
    });
  },
  BooleanString: (property) => {
    const schema = Type.Boolean(property);
    return t.Transform(
      t.Union(
        [
          t.String({
            format: "boolean",
            default: false
          }),
          t.Boolean(property)
        ],
        property
      )
    ).Decode((value) => {
      if (typeof value === "string")
        return value === "true";
      if (property && !value_exports2.Check(schema, value))
        throw new ValidationError("property", schema, value);
      return value;
    }).Encode((value) => value);
  },
  ObjectString: (properties, options) => {
    const schema = t.Object(properties, options);
    const defaultValue = JSON.stringify(value_exports2.Create(schema));
    let compiler2;
    try {
      compiler2 = TypeCompiler.Compile(schema);
    } catch {
    }
    return t.Transform(
      t.Union([
        t.String({
          format: "ObjectString",
          default: defaultValue
        }),
        schema
      ])
    ).Decode((value) => {
      if (typeof value === "string") {
        if (value.charCodeAt(0) !== 123)
          throw new ValidationError("property", schema, value);
        try {
          value = JSON.parse(value);
        } catch {
          throw new ValidationError("property", schema, value);
        }
        if (compiler2) {
          if (!compiler2.Check(value))
            throw new ValidationError("property", schema, value);
          return compiler2.Decode(value);
        }
        if (!value_exports2.Check(schema, value))
          throw new ValidationError("property", schema, value);
        return value_exports2.Decode(schema, value);
      }
      return value;
    }).Encode((value) => {
      if (typeof value === "string")
        try {
          value = JSON.parse(value);
        } catch {
          throw new ValidationError("property", schema, value);
        }
      if (!value_exports2.Check(schema, value))
        throw new ValidationError("property", schema, value);
      return JSON.stringify(value);
    });
  },
  ArrayString: (children = {}, options) => {
    const schema = t.Array(children, options);
    const defaultValue = JSON.stringify(value_exports2.Create(schema));
    let compiler2;
    try {
      compiler2 = TypeCompiler.Compile(schema);
    } catch {
    }
    return t.Transform(
      t.Union([
        t.String({
          format: "ArrayString",
          default: defaultValue
        }),
        schema
      ])
    ).Decode((value) => {
      if (typeof value === "string") {
        if (value.charCodeAt(0) !== 91)
          throw new ValidationError("property", schema, value);
        try {
          value = JSON.parse(value);
        } catch {
          throw new ValidationError("property", schema, value);
        }
        if (compiler2) {
          if (!compiler2.Check(value))
            throw new ValidationError("property", schema, value);
          return compiler2.Decode(value);
        }
        if (!value_exports2.Check(schema, value))
          throw new ValidationError("property", schema, value);
        return value_exports2.Decode(schema, value);
      }
      return value;
    }).Encode((value) => {
      if (typeof value === "string")
        try {
          value = JSON.parse(value);
        } catch {
          throw new ValidationError("property", schema, value);
        }
      if (!value_exports2.Check(schema, value))
        throw new ValidationError("property", schema, value);
      return JSON.stringify(value);
    });
  },
  File: File2,
  Files: (options = {}) => t.Transform(Files(options)).Decode((value) => {
    if (Array.isArray(value))
      return value;
    return [value];
  }).Encode((value) => value),
  Nullable: (schema) => t.Union([schema, t.Null()]),
  /**
   * Allow Optional, Nullable and Undefined
   */
  MaybeEmpty: (schema) => t.Union([schema, t.Null(), t.Undefined()]),
  Cookie: (properties, {
    domain: domain3,
    expires,
    httpOnly,
    maxAge,
    path: path2,
    priority,
    sameSite,
    secure,
    secrets,
    sign: sign2,
    ...options
  } = {}) => {
    const v2 = t.Object(properties, options);
    v2.config = {
      domain: domain3,
      expires,
      httpOnly,
      maxAge,
      path: path2,
      priority,
      sameSite,
      secure,
      secrets,
      sign: sign2
    };
    return v2;
  }
};
t.BooleanString = ElysiaType.BooleanString;
t.ObjectString = ElysiaType.ObjectString;
t.ArrayString = ElysiaType.ArrayString;
t.Numeric = ElysiaType.Numeric;
t.File = (arg = {}) => ElysiaType.File({
  default: "File",
  ...arg,
  extension: arg?.type,
  type: "string",
  format: "binary"
});
t.Files = (arg = {}) => ElysiaType.Files({
  ...arg,
  elysiaMeta: "Files",
  default: "Files",
  extension: arg?.type,
  type: "array",
  items: {
    ...arg,
    default: "Files",
    type: "string",
    format: "binary"
  }
});
t.Nullable = (schema) => ElysiaType.Nullable(schema);
t.MaybeEmpty = ElysiaType.MaybeEmpty;
t.Cookie = ElysiaType.Cookie;
t.Date = ElysiaType.Date;
var Cookie = class {
  constructor(name, jar, initial = {}) {
    this.name = name;
    this.jar = jar;
    this.initial = initial;
  }
  get cookie() {
    if (!(this.name in this.jar))
      return this.initial;
    return this.jar[this.name];
  }
  set cookie(jar) {
    if (!(this.name in this.jar))
      this.jar[this.name] = this.initial;
    this.jar[this.name] = jar;
  }
  get value() {
    return this.cookie.value;
  }
  set value(value) {
    if (!(this.name in this.jar))
      this.jar[this.name] = this.initial;
    this.jar[this.name].value = value;
  }
  get expires() {
    return this.cookie.expires;
  }
  set expires(expires) {
    this.cookie.expires = expires;
  }
  get maxAge() {
    return this.cookie.maxAge;
  }
  set maxAge(maxAge) {
    this.cookie.maxAge = maxAge;
  }
  get domain() {
    return this.cookie.domain;
  }
  set domain(domain3) {
    this.cookie.domain = domain3;
  }
  get path() {
    return this.cookie.path;
  }
  set path(path2) {
    this.cookie.path = path2;
  }
  get secure() {
    return this.cookie.secure;
  }
  set secure(secure) {
    this.cookie.secure = secure;
  }
  get httpOnly() {
    return this.cookie.httpOnly;
  }
  set httpOnly(httpOnly) {
    this.cookie.httpOnly = httpOnly;
  }
  get sameSite() {
    return this.cookie.sameSite;
  }
  set sameSite(sameSite) {
    this.cookie.sameSite = sameSite;
  }
  get priority() {
    return this.cookie.priority;
  }
  set priority(priority) {
    this.cookie.priority = priority;
  }
  get partitioned() {
    return this.cookie.partitioned;
  }
  set partitioned(partitioned) {
    this.cookie.partitioned = partitioned;
  }
  get secrets() {
    return this.cookie.secrets;
  }
  set secrets(secrets) {
    this.cookie.secrets = secrets;
  }
  update(config3) {
    this.cookie = Object.assign(
      this.cookie,
      typeof config3 === "function" ? config3(this.cookie) : config3
    );
    return this;
  }
  set(config3) {
    this.cookie = Object.assign(
      {
        ...this.initial,
        value: this.value
      },
      typeof config3 === "function" ? config3(this.cookie) : config3
    );
    return this;
  }
  remove() {
    if (this.value === void 0)
      return;
    this.set({
      expires: /* @__PURE__ */ new Date(0),
      maxAge: 0,
      value: ""
    });
    return this;
  }
  toString() {
    return typeof this.value === "object" ? JSON.stringify(this.value) : this.value?.toString() ?? "";
  }
};
var createCookieJar = (set, store, initial) => {
  if (!set.cookie)
    set.cookie = {};
  return new Proxy(store, {
    get(_, key2) {
      if (key2 in store)
        return new Cookie(
          key2,
          set.cookie,
          Object.assign({}, initial ?? {}, store[key2])
        );
      return new Cookie(
        key2,
        set.cookie,
        Object.assign({}, initial)
      );
    }
  });
};
var parseCookie = async (set, cookieString, {
  secrets,
  sign: sign2,
  ...initial
} = {}) => {
  if (!cookieString)
    return createCookieJar(set, {}, initial);
  const isStringKey = typeof secrets === "string";
  if (sign2 && sign2 !== true && !Array.isArray(sign2))
    sign2 = [sign2];
  const jar = {};
  const cookies = (0, import_cookie2.parse)(cookieString);
  for (const [name, v2] of Object.entries(cookies)) {
    let value = (0, import_fast_decode_uri_component.default)(v2);
    if (sign2 === true || sign2?.includes(name)) {
      if (!secrets)
        throw new Error("No secret is provided to cookie plugin");
      if (isStringKey) {
        const temp = await unsignCookie(value, secrets);
        if (temp === false)
          throw new InvalidCookieSignature(name);
        value = temp;
      } else {
        let decoded = true;
        for (let i2 = 0; i2 < secrets.length; i2++) {
          const temp = await unsignCookie(value, secrets[i2]);
          if (temp !== false) {
            decoded = true;
            value = temp;
            break;
          }
        }
        if (!decoded)
          throw new InvalidCookieSignature(name);
      }
    }
    jar[name] = {
      value
    };
  }
  return createCookieJar(set, jar, initial);
};
var hasHeaderShorthand = "toJSON" in new Headers();
var isNotEmpty = (obj) => {
  if (!obj)
    return false;
  for (const x2 in obj)
    return true;
  return false;
};
var handleFile = (response, set) => {
  const size = response.size;
  if (!set && size || size && set && set.status !== 206 && set.status !== 304 && set.status !== 412 && set.status !== 416) {
    if (set) {
      if (set.headers instanceof Headers) {
        if (hasHeaderShorthand)
          set.headers = set.headers.toJSON();
        else
          for (const [key2, value] of set.headers.entries())
            if (key2 in set.headers)
              set.headers[key2] = value;
      }
      return new Response(response, {
        status: set.status,
        headers: Object.assign(
          {
            "accept-ranges": "bytes",
            "content-range": `bytes 0-${size - 1}/${size}`
          },
          set.headers
        )
      });
    }
    return new Response(response, {
      headers: {
        "accept-ranges": "bytes",
        "content-range": `bytes 0-${size - 1}/${size}`
      }
    });
  }
  return new Response(response);
};
var parseSetCookies = (headers, setCookie) => {
  if (!headers)
    return headers;
  headers.delete("set-cookie");
  for (let i2 = 0; i2 < setCookie.length; i2++) {
    const index3 = setCookie[i2].indexOf("=");
    headers.append(
      "set-cookie",
      `${setCookie[i2].slice(0, index3)}=${setCookie[i2].slice(index3 + 1) || ""}`
    );
  }
  return headers;
};
var serializeCookie = (cookies) => {
  if (!cookies || !isNotEmpty(cookies))
    return void 0;
  const set = [];
  for (const [key2, property] of Object.entries(cookies)) {
    if (!key2 || !property)
      continue;
    const value = property.value;
    if (value === void 0 || value === null)
      continue;
    set.push(
      (0, import_cookie.serialize)(
        key2,
        typeof value === "object" ? JSON.stringify(value) : value + "",
        property
      )
    );
  }
  if (set.length === 0)
    return void 0;
  if (set.length === 1)
    return set[0];
  return set;
};
var handleStream = async (generator, set, request) => {
  let init3 = generator.next();
  if (init3 instanceof Promise)
    init3 = await init3;
  if (init3.done) {
    if (set)
      return mapResponse(init3.value, set, request);
    return mapCompactResponse(init3.value, request);
  }
  return new Response(
    new ReadableStream({
      async start(controller) {
        let end = false;
        request?.signal.addEventListener("abort", () => {
          end = true;
          try {
            controller.close();
          } catch {
          }
        });
        if (init3.value !== void 0 && init3.value !== null) {
          if (typeof init3.value === "object")
            try {
              controller.enqueue(
                Buffer2.from(JSON.stringify(init3.value))
              );
            } catch {
              controller.enqueue(Buffer2.from(init3.value.toString()));
            }
          else
            controller.enqueue(Buffer2.from(init3.value.toString()));
        }
        for await (const chunk of generator) {
          if (end)
            break;
          if (chunk === void 0 || chunk === null)
            continue;
          if (typeof chunk === "object")
            try {
              controller.enqueue(
                Buffer2.from(JSON.stringify(chunk))
              );
            } catch {
              controller.enqueue(Buffer2.from(chunk.toString()));
            }
          else
            controller.enqueue(Buffer2.from(chunk.toString()));
          await new Promise(
            (resolve2) => setTimeout(() => resolve2(), 0)
          );
        }
        try {
          controller.close();
        } catch {
        }
      }
    }),
    {
      ...set,
      headers: {
        // Manually set transfer-encoding for direct response, eg. app.handle, eden
        "transfer-encoding": "chunked",
        "content-type": "text/event-stream; charset=utf-8",
        ...set?.headers
      }
    }
  );
};
var mapResponse = (response, set, request) => {
  if (isNotEmpty(set.headers) || set.status !== 200 || set.redirect || set.cookie) {
    if (typeof set.status === "string")
      set.status = StatusMap[set.status];
    if (set.redirect) {
      set.headers.Location = set.redirect;
      if (!set.status || set.status < 300 || set.status >= 400)
        set.status = 302;
    }
    if (set.cookie && isNotEmpty(set.cookie)) {
      const cookie = serializeCookie(set.cookie);
      if (cookie)
        set.headers["set-cookie"] = cookie;
    }
    if (set.headers["set-cookie"] && Array.isArray(set.headers["set-cookie"])) {
      set.headers = parseSetCookies(
        new Headers(set.headers),
        set.headers["set-cookie"]
      );
    }
    switch (response?.constructor?.name) {
      case "String":
        return new Response(response, set);
      case "Blob":
        return handleFile(response, set);
      case "Array":
        return Response.json(response, set);
      case "Object":
        const status = response[ELYSIA_RESPONSE];
        if (status) {
          set.status = status;
          return mapResponse(response.response, set, request);
        }
        for (const value in Object.values(response)) {
          switch (value?.constructor?.name) {
            case "Blob":
            case "File":
            case "ArrayBuffer":
            case "FileRef":
              return new Response(form(response));
            default:
              break;
          }
        }
        return Response.json(response, set);
      case "ReadableStream":
        if (!set.headers["content-type"]?.startsWith(
          "text/event-stream"
        ))
          set.headers["content-type"] = "text/event-stream; charset=utf-8";
        request?.signal.addEventListener(
          "abort",
          {
            handleEvent() {
              if (!request?.signal.aborted)
                response.cancel(request);
            }
          },
          {
            once: true
          }
        );
        return new Response(
          response,
          set
        );
      case void 0:
        if (!response)
          return new Response("", set);
        return Response.json(response, set);
      case "Response":
        let isCookieSet = false;
        if (set.headers instanceof Headers)
          for (const key2 of set.headers.keys()) {
            if (key2 === "set-cookie") {
              if (isCookieSet)
                continue;
              isCookieSet = true;
              for (const cookie of set.headers.getSetCookie()) {
                ;
                response.headers.append(
                  "set-cookie",
                  cookie
                );
              }
            } else
              response.headers.append(
                key2,
                set.headers?.get(key2) ?? ""
              );
          }
        else
          for (const key2 in set.headers)
            response.headers.append(
              key2,
              set.headers[key2]
            );
        if (response.status !== set.status)
          set.status = response.status;
        return response;
      case "Error":
        return errorToResponse(response, set);
      case "Promise":
        return response.then(
          (x2) => mapResponse(x2, set)
        );
      case "Function":
        return mapResponse(response(), set);
      case "Number":
      case "Boolean":
        return new Response(
          response.toString(),
          set
        );
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set);
        return new Response(response?.toString(), set);
      case "FormData":
        return new Response(response, set);
      default:
        if (response instanceof Response) {
          let isCookieSet2 = false;
          if (set.headers instanceof Headers)
            for (const key2 of set.headers.keys()) {
              if (key2 === "set-cookie") {
                if (isCookieSet2)
                  continue;
                isCookieSet2 = true;
                for (const cookie of set.headers.getSetCookie()) {
                  ;
                  response.headers.append(
                    "set-cookie",
                    cookie
                  );
                }
              } else
                response.headers.append(
                  key2,
                  set.headers?.get(key2) ?? ""
                );
            }
          else
            for (const key2 in set.headers)
              response.headers.append(
                key2,
                set.headers[key2]
              );
          if (hasHeaderShorthand)
            set.headers = response.headers.toJSON();
          else
            for (const [key2, value] of response.headers.entries())
              if (key2 in set.headers)
                set.headers[key2] = value;
          return response;
        }
        if (response instanceof Promise)
          return response.then((x2) => mapResponse(x2, set));
        if (response instanceof Error)
          return errorToResponse(response, set);
        if (typeof response?.next === "function")
          return handleStream(response, set, request);
        if ("toResponse" in response)
          return mapResponse(response.toResponse(), set);
        if ("charCodeAt" in response) {
          const code4 = response.charCodeAt(0);
          if (code4 === 123 || code4 === 91) {
            if (!set.headers["Content-Type"])
              set.headers["Content-Type"] = "application/json";
            return new Response(
              JSON.stringify(response),
              set
            );
          }
        }
        return new Response(response, set);
    }
  } else
    switch (response?.constructor?.name) {
      case "String":
        return new Response(response);
      case "Blob":
        return handleFile(response, set);
      case "Array":
        return Response.json(response);
      case "Object":
        const status = response[ELYSIA_RESPONSE];
        if (status) {
          set.status = status;
          return mapResponse(response.response, set, request);
        }
        for (const value in Object.values(response)) {
          switch (value?.constructor?.name) {
            case "Blob":
            case "File":
            case "ArrayBuffer":
            case "FileRef":
              return new Response(
                form(response),
                set
              );
            default:
              break;
          }
        }
        return Response.json(response, set);
      case "ReadableStream":
        request?.signal.addEventListener(
          "abort",
          {
            handleEvent() {
              if (!request?.signal.aborted)
                response.cancel(request);
            }
          },
          {
            once: true
          }
        );
        return new Response(response, {
          headers: {
            "Content-Type": "text/event-stream; charset=utf-8"
          }
        });
      case void 0:
        if (!response)
          return new Response("");
        return new Response(JSON.stringify(response), {
          headers: {
            "content-type": "application/json"
          }
        });
      case "Response":
        return response;
      case "Error":
        return errorToResponse(response, set);
      case "Promise":
        return response.then((x2) => {
          const r2 = mapCompactResponse(x2, request);
          if (r2 !== void 0)
            return r2;
          return new Response("");
        });
      case "Function":
        return mapCompactResponse(response(), request);
      case "Number":
      case "Boolean":
        return new Response(response.toString());
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set);
        return new Response(response?.toString(), set);
      case "FormData":
        return new Response(response, set);
      default:
        if (response instanceof Response)
          return new Response(response.body, {
            headers: {
              "Content-Type": "application/json"
            }
          });
        if (response instanceof Promise)
          return response.then((x2) => mapResponse(x2, set));
        if (response instanceof Error)
          return errorToResponse(response, set);
        if (typeof response?.next === "function")
          return handleStream(response, set, request);
        if ("toResponse" in response)
          return mapResponse(response.toResponse(), set);
        if ("charCodeAt" in response) {
          const code4 = response.charCodeAt(0);
          if (code4 === 123 || code4 === 91) {
            if (!set.headers["Content-Type"])
              set.headers["Content-Type"] = "application/json";
            return new Response(
              JSON.stringify(response),
              set
            );
          }
        }
        return new Response(response);
    }
};
var mapEarlyResponse = (response, set, request) => {
  if (response === void 0 || response === null)
    return;
  if (isNotEmpty(set.headers) || set.status !== 200 || set.redirect || set.cookie) {
    if (typeof set.status === "string")
      set.status = StatusMap[set.status];
    if (set.redirect) {
      set.headers.Location = set.redirect;
      if (!set.status || set.status < 300 || set.status >= 400)
        set.status = 302;
    }
    if (set.cookie && isNotEmpty(set.cookie)) {
      const cookie = serializeCookie(set.cookie);
      if (cookie)
        set.headers["set-cookie"] = cookie;
    }
    if (set.headers["set-cookie"] && Array.isArray(set.headers["set-cookie"]))
      set.headers = parseSetCookies(
        new Headers(set.headers),
        set.headers["set-cookie"]
      );
    switch (response?.constructor?.name) {
      case "String":
        return new Response(response, set);
      case "Blob":
        return handleFile(response, set);
      case "Array":
        return Response.json(response, set);
      case "Object":
        const status = response[ELYSIA_RESPONSE];
        if (status) {
          set.status = status;
          return mapEarlyResponse(response.response, set, request);
        }
        for (const value in Object.values(response)) {
          switch (value?.constructor?.name) {
            case "Blob":
            case "File":
            case "ArrayBuffer":
            case "FileRef":
              return new Response(
                form(response),
                set
              );
            default:
              break;
          }
        }
        return Response.json(response, set);
      case "ReadableStream":
        if (!set.headers["content-type"]?.startsWith(
          "text/event-stream"
        ))
          set.headers["content-type"] = "text/event-stream; charset=utf-8";
        request?.signal.addEventListener(
          "abort",
          {
            handleEvent() {
              if (!request?.signal.aborted)
                response.cancel(request);
            }
          },
          {
            once: true
          }
        );
        return new Response(
          response,
          set
        );
      case void 0:
        if (!response)
          return;
        return Response.json(response, set);
      case "Response":
        let isCookieSet = false;
        if (set.headers instanceof Headers)
          for (const key2 of set.headers.keys()) {
            if (key2 === "set-cookie") {
              if (isCookieSet)
                continue;
              isCookieSet = true;
              for (const cookie of set.headers.getSetCookie()) {
                ;
                response.headers.append(
                  "set-cookie",
                  cookie
                );
              }
            } else
              response.headers.append(
                key2,
                set.headers?.get(key2) ?? ""
              );
          }
        else
          for (const key2 in set.headers)
            response.headers.append(
              key2,
              set.headers[key2]
            );
        if (response.status !== set.status)
          set.status = response.status;
        return response;
      case "Promise":
        return response.then((x2) => {
          const r2 = mapEarlyResponse(x2, set);
          if (r2 !== void 0)
            return r2;
        });
      case "Error":
        return errorToResponse(response, set);
      case "Function":
        return mapEarlyResponse(response(), set);
      case "Number":
      case "Boolean":
        return new Response(
          response.toString(),
          set
        );
      case "FormData":
        return new Response(response);
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set);
        return new Response(response?.toString(), set);
      default:
        if (response instanceof Response) {
          let isCookieSet2 = false;
          if (set.headers instanceof Headers)
            for (const key2 of set.headers.keys()) {
              if (key2 === "set-cookie") {
                if (isCookieSet2)
                  continue;
                isCookieSet2 = true;
                for (const cookie of set.headers.getSetCookie()) {
                  ;
                  response.headers.append(
                    "set-cookie",
                    cookie
                  );
                }
              } else
                response.headers.append(
                  key2,
                  set.headers?.get(key2) ?? ""
                );
            }
          else
            for (const key2 in set.headers)
              response.headers.append(
                key2,
                set.headers[key2]
              );
          if (response.status !== set.status)
            set.status = response.status;
          return response;
        }
        if (response instanceof Promise)
          return response.then((x2) => mapEarlyResponse(x2, set));
        if (response instanceof Error)
          return errorToResponse(response, set);
        if (typeof response?.next === "function")
          return handleStream(response, set, request);
        if ("toResponse" in response)
          return mapEarlyResponse(response.toResponse(), set);
        if ("charCodeAt" in response) {
          const code4 = response.charCodeAt(0);
          if (code4 === 123 || code4 === 91) {
            if (!set.headers["Content-Type"])
              set.headers["Content-Type"] = "application/json";
            return new Response(
              JSON.stringify(response),
              set
            );
          }
        }
        return new Response(response, set);
    }
  } else
    switch (response?.constructor?.name) {
      case "String":
        return new Response(response);
      case "Blob":
        return handleFile(response, set);
      case "Array":
        return Response.json(response);
      case "Object":
        const status = response[ELYSIA_RESPONSE];
        if (status) {
          set.status = status;
          return mapEarlyResponse(response.response, set, request);
        }
        for (const value in Object.values(response)) {
          switch (value?.constructor?.name) {
            case "Blob":
            case "File":
            case "ArrayBuffer":
            case "FileRef":
              return new Response(
                form(response),
                set
              );
            default:
              break;
          }
        }
        return Response.json(response, set);
      case "ReadableStream":
        request?.signal.addEventListener(
          "abort",
          {
            handleEvent() {
              if (!request?.signal.aborted)
                response.cancel(request);
            }
          },
          {
            once: true
          }
        );
        return new Response(response, {
          headers: {
            "Content-Type": "text/event-stream; charset=utf-8"
          }
        });
      case void 0:
        if (!response)
          return new Response("");
        return new Response(JSON.stringify(response), {
          headers: {
            "content-type": "application/json"
          }
        });
      case "Response":
        return response;
      case "Promise":
        return response.then((x2) => {
          const r2 = mapEarlyResponse(x2, set);
          if (r2 !== void 0)
            return r2;
        });
      case "Error":
        return errorToResponse(response, set);
      case "Function":
        return mapCompactResponse(response(), request);
      case "Number":
      case "Boolean":
        return new Response(response.toString());
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set);
        return new Response(response?.toString(), set);
      case "FormData":
        return new Response(response);
      default:
        if (response instanceof Response)
          return new Response(response.body, {
            headers: {
              "Content-Type": "application/json"
            }
          });
        if (response instanceof Promise)
          return response.then((x2) => mapEarlyResponse(x2, set));
        if (response instanceof Error)
          return errorToResponse(response, set);
        if (typeof response?.next === "function")
          return handleStream(response, set, request);
        if ("toResponse" in response)
          return mapEarlyResponse(response.toResponse(), set);
        if ("charCodeAt" in response) {
          const code4 = response.charCodeAt(0);
          if (code4 === 123 || code4 === 91) {
            if (!set.headers["Content-Type"])
              set.headers["Content-Type"] = "application/json";
            return new Response(
              JSON.stringify(response),
              set
            );
          }
        }
        return new Response(response);
    }
};
var mapCompactResponse = (response, request) => {
  switch (response?.constructor?.name) {
    case "String":
      return new Response(response);
    case "Blob":
      return handleFile(response);
    case "Array":
      return Response.json(response);
    case "Object":
      if (response[ELYSIA_RESPONSE])
        return mapResponse(response.response, {
          // @ts-ignore
          status: response[ELYSIA_RESPONSE],
          headers: {}
        });
      form:
        for (const value of Object.values(response))
          switch (value?.constructor?.name) {
            case "Blob":
            case "File":
            case "ArrayBuffer":
            case "FileRef":
              return new Response(form(response));
            case "Object":
              break form;
            default:
              break;
          }
      return Response.json(response);
    case "ReadableStream":
      request?.signal.addEventListener(
        "abort",
        {
          handleEvent() {
            if (!request?.signal.aborted)
              response.cancel(request);
          }
        },
        {
          once: true
        }
      );
      return new Response(response, {
        headers: {
          "Content-Type": "text/event-stream; charset=utf-8"
        }
      });
    case void 0:
      if (!response)
        return new Response("");
      return new Response(JSON.stringify(response), {
        headers: {
          "content-type": "application/json"
        }
      });
    case "Response":
      return response;
    case "Error":
      return errorToResponse(response);
    case "Promise":
      return response.then(
        (x2) => mapCompactResponse(x2, request)
      );
    case "Function":
      return mapCompactResponse(response(), request);
    case "Number":
    case "Boolean":
      return new Response(response.toString());
    case "FormData":
      return new Response(response);
    default:
      if (response instanceof Response)
        return new Response(response.body, {
          headers: {
            "Content-Type": "application/json"
          }
        });
      if (response instanceof Promise)
        return response.then(
          (x2) => mapCompactResponse(x2, request)
        );
      if (response instanceof Error)
        return errorToResponse(response);
      if (typeof response?.next === "function")
        return handleStream(response, void 0, request);
      if ("toResponse" in response)
        return mapCompactResponse(response.toResponse());
      if ("charCodeAt" in response) {
        const code4 = response.charCodeAt(0);
        if (code4 === 123 || code4 === 91) {
          return new Response(JSON.stringify(response), {
            headers: {
              "Content-Type": "application/json"
            }
          });
        }
      }
      return new Response(response);
  }
};
var errorToResponse = (error22, set) => new Response(
  JSON.stringify({
    name: error22?.name,
    message: error22?.message,
    cause: error22?.cause
  }),
  {
    status: set?.status !== 200 ? set?.status ?? 500 : 500,
    headers: set?.headers
  }
);
var replaceUrlPath = (url, pathname) => {
  const urlObject = new URL(url);
  urlObject.pathname = pathname;
  return urlObject.toString();
};
var isClass = (v2) => typeof v2 === "function" && /^\s*class\s+/.test(v2.toString()) || // Handle import * as Sentry from '@sentry/bun'
// This also handle [object Date], [object Array]
// and FFI value like [object Prisma]
v2.toString().startsWith("[object ") && v2.toString() !== "[object Object]" || // If object prototype is not pure, then probably a class-like object
isNotEmpty(Object.getPrototypeOf(v2));
var isObject = (item) => item && typeof item === "object" && !Array.isArray(item);
var mergeDeep = (target, source, {
  skipKeys,
  override = true
} = {}) => {
  if (!isObject(target) || !isObject(source))
    return target;
  for (const [key2, value] of Object.entries(source)) {
    if (skipKeys?.includes(key2))
      continue;
    if (!isObject(value) || !(key2 in target) || isClass(value)) {
      if (override || !(key2 in target))
        target[key2] = value;
      continue;
    }
    target[key2] = mergeDeep(
      target[key2],
      value,
      { skipKeys, override }
    );
  }
  return target;
};
var mergeCookie = (a2, b2) => {
  const { properties: _, ...target } = a2 ?? {};
  const { properties: __, ...source } = b2 ?? {};
  return mergeDeep(target, source);
};
var mergeObjectArray = (a2 = [], b2 = []) => {
  if (!a2)
    return [];
  if (!b2)
    return a2;
  const array = [];
  const checksums = [];
  if (!Array.isArray(a2))
    a2 = [a2];
  if (!Array.isArray(b2))
    b2 = [b2];
  for (const item of a2) {
    array.push(item);
    if (item.checksum)
      checksums.push(item.checksum);
  }
  for (const item of b2)
    if (!checksums.includes(item.checksum))
      array.push(item);
  return array;
};
var primitiveHooks = [
  "start",
  "request",
  "parse",
  "transform",
  "resolve",
  "beforeHandle",
  "afterHandle",
  "mapResponse",
  "afterResponse",
  "trace",
  "error",
  "stop",
  "body",
  "headers",
  "params",
  "query",
  "response",
  "type",
  "detail"
];
var primitiveHookMap = primitiveHooks.reduce(
  (acc, x2) => (acc[x2] = true, acc),
  {}
);
var mergeResponse = (a2, b2) => {
  const isRecordNumber = (x2) => typeof x2 === "object" && Object.keys(x2).every(isNumericString);
  if (isRecordNumber(a2) && isRecordNumber(b2))
    return { ...a2, ...b2 };
  return b2 ?? a2;
};
var mergeSchemaValidator = (a2, b2) => {
  return {
    body: b2?.body ?? a2?.body,
    headers: b2?.headers ?? a2?.headers,
    params: b2?.params ?? a2?.params,
    query: b2?.query ?? a2?.query,
    cookie: b2?.cookie ?? a2?.cookie,
    // @ts-ignore ? This order is correct - SaltyAom
    response: mergeResponse(
      // @ts-ignore
      a2?.response,
      // @ts-ignore
      b2?.response
    )
  };
};
var mergeHook = (a2, b2) => {
  return {
    ...a2,
    ...b2,
    // Merge local hook first
    // @ts-ignore
    body: b2?.body ?? a2?.body,
    // @ts-ignore
    headers: b2?.headers ?? a2?.headers,
    // @ts-ignore
    params: b2?.params ?? a2?.params,
    // @ts-ignore
    query: b2?.query ?? a2?.query,
    // @ts-ignore
    cookie: b2?.cookie ?? a2?.cookie,
    // ? This order is correct - SaltyAom
    response: mergeResponse(
      // @ts-ignore
      a2?.response,
      // @ts-ignore
      b2?.response
    ),
    type: a2?.type || b2?.type,
    detail: mergeDeep(
      // @ts-ignore
      b2?.detail ?? {},
      // @ts-ignore
      a2?.detail ?? {}
    ),
    parse: mergeObjectArray(a2?.parse, b2?.parse),
    transform: mergeObjectArray(a2?.transform, b2?.transform),
    beforeHandle: mergeObjectArray(a2?.beforeHandle, b2?.beforeHandle),
    afterHandle: mergeObjectArray(a2?.afterHandle, b2?.afterHandle),
    mapResponse: mergeObjectArray(a2?.mapResponse, b2?.mapResponse),
    afterResponse: mergeObjectArray(
      a2?.afterResponse,
      b2?.afterResponse
    ),
    trace: mergeObjectArray(a2?.trace, b2?.trace),
    error: mergeObjectArray(a2?.error, b2?.error)
  };
};
var replaceSchemaType = (schema, options, root4 = true) => {
  if (!Array.isArray(options))
    return _replaceSchemaType(schema, options, root4);
  for (const option2 of options)
    schema = _replaceSchemaType(schema, option2, root4);
  return schema;
};
var _replaceSchemaType = (schema, options, root4 = true) => {
  if (!schema)
    return schema;
  if (options.untilObjectFound && !root4 && schema.type === "object")
    return schema;
  const fromSymbol = options.from[Kind];
  if (schema.oneOf) {
    for (let i2 = 0; i2 < schema.oneOf.length; i2++)
      schema.oneOf[i2] = _replaceSchemaType(schema.oneOf[i2], options, root4);
    return schema;
  }
  if (schema.anyOf) {
    for (let i2 = 0; i2 < schema.anyOf.length; i2++)
      schema.anyOf[i2] = _replaceSchemaType(schema.anyOf[i2], options, root4);
    return schema;
  }
  if (schema.allOf) {
    for (let i2 = 0; i2 < schema.allOf.length; i2++)
      schema.allOf[i2] = _replaceSchemaType(schema.allOf[i2], options, root4);
    return schema;
  }
  if (schema.not) {
    for (let i2 = 0; i2 < schema.not.length; i2++)
      schema.not[i2] = _replaceSchemaType(schema.not[i2], options, root4);
    return schema;
  }
  const isRoot = root4 && !!options.excludeRoot;
  if (schema[Kind] === fromSymbol) {
    const { anyOf, oneOf, allOf, not: not3, properties: properties2, items, ...rest } = schema;
    const to = options.to();
    let transform;
    const composeProperties = (v2) => {
      if (properties2 && v2.type === "object") {
        const newProperties = {};
        for (const [key2, value2] of Object.entries(properties2))
          newProperties[key2] = _replaceSchemaType(
            value2,
            options,
            false
          );
        return {
          ...rest,
          ...v2,
          properties: newProperties
        };
      }
      if (items && v2.type === "array")
        return {
          ...rest,
          ...v2,
          items: _replaceSchemaType(items, options, false)
        };
      const value = {
        ...rest,
        ...v2
      };
      delete value["required"];
      if (properties2 && v2.type === "string" && v2.format === "ObjectString" && v2.default === "{}") {
        transform = t.ObjectString(properties2, rest);
        value.default = JSON.stringify(
          value_exports2.Create(t.Object(properties2))
        );
        value.properties = properties2;
      }
      if (items && v2.type === "string" && v2.format === "ArrayString" && v2.default === "[]") {
        transform = t.ArrayString(items, rest);
        value.default = JSON.stringify(value_exports2.Create(t.Array(items)));
        value.items = items;
      }
      return value;
    };
    if (isRoot) {
      if (properties2) {
        const newProperties = {};
        for (const [key2, value] of Object.entries(properties2))
          newProperties[key2] = _replaceSchemaType(
            value,
            options,
            false
          );
        return {
          ...rest,
          properties: newProperties
        };
      } else if (items?.map)
        return {
          ...rest,
          items: items.map(
            (v2) => _replaceSchemaType(v2, options, false)
          )
        };
      return rest;
    }
    if (to.anyOf)
      for (let i2 = 0; i2 < to.anyOf.length; i2++)
        to.anyOf[i2] = composeProperties(to.anyOf[i2]);
    else if (to.oneOf)
      for (let i2 = 0; i2 < to.oneOf.length; i2++)
        to.oneOf[i2] = composeProperties(to.oneOf[i2]);
    else if (to.allOf)
      for (let i2 = 0; i2 < to.allOf.length; i2++)
        to.allOf[i2] = composeProperties(to.allOf[i2]);
    else if (to.not)
      for (let i2 = 0; i2 < to.not.length; i2++)
        to.not[i2] = composeProperties(to.not[i2]);
    if (transform)
      to[TransformKind] = transform[TransformKind];
    if (to.anyOf || to.oneOf || to.allOf || to.not)
      return to;
    if (properties2) {
      const newProperties = {};
      for (const [key2, value] of Object.entries(properties2))
        newProperties[key2] = _replaceSchemaType(
          value,
          options,
          false
        );
      return {
        ...rest,
        ...to,
        properties: newProperties
      };
    } else if (items?.map)
      return {
        ...rest,
        ...to,
        items: items.map(
          (v2) => _replaceSchemaType(v2, options, false)
        )
      };
    return {
      ...rest,
      ...to
    };
  }
  const properties = schema?.properties;
  if (properties)
    for (const [key2, value] of Object.entries(properties)) {
      switch (value[Kind]) {
        case fromSymbol:
          const { anyOf, oneOf, allOf, not: not3, type, ...rest } = value;
          const to = options.to();
          if (to.anyOf)
            for (let i2 = 0; i2 < to.anyOf.length; i2++)
              to.anyOf[i2] = { ...rest, ...to.anyOf[i2] };
          else if (to.oneOf)
            for (let i2 = 0; i2 < to.oneOf.length; i2++)
              to.oneOf[i2] = { ...rest, ...to.oneOf[i2] };
          else if (to.allOf)
            for (let i2 = 0; i2 < to.allOf.length; i2++)
              to.allOf[i2] = { ...rest, ...to.allOf[i2] };
          else if (to.not)
            for (let i2 = 0; i2 < to.not.length; i2++)
              to.not[i2] = { ...rest, ...to.not[i2] };
          properties[key2] = {
            ...rest,
            ..._replaceSchemaType(rest, options, false)
          };
          break;
        case "Object":
        case "Union":
          properties[key2] = _replaceSchemaType(value, options, false);
          break;
        default:
          if (value.items)
            for (let i2 = 0; i2 < value.items.length; i2++) {
              value.items[i2] = _replaceSchemaType(
                value.items[i2],
                options,
                false
              );
            }
          else if (value.anyOf || value.oneOf || value.allOf || value.not)
            properties[key2] = _replaceSchemaType(
              value,
              options,
              false
            );
          break;
      }
    }
  return schema;
};
var getSchemaValidator = (s2, {
  models = {},
  dynamic = false,
  normalize: normalize4 = false,
  additionalProperties = false,
  coerce = false,
  additionalCoerce = []
} = {}) => {
  if (!s2)
    return void 0;
  if (typeof s2 === "string" && !(s2 in models))
    return void 0;
  let schema = typeof s2 === "string" ? models[s2] : s2;
  if (coerce)
    schema = replaceSchemaType(schema, [
      {
        from: t.Number(),
        to: () => t.Numeric(),
        untilObjectFound: true
      },
      {
        from: t.Boolean(),
        to: () => t.BooleanString(),
        untilObjectFound: true
      },
      ...Array.isArray(additionalCoerce) ? additionalCoerce : [additionalCoerce]
    ]);
  if (schema.type === "object" && "additionalProperties" in schema === false)
    schema.additionalProperties = additionalProperties;
  const cleaner = (value) => value_exports2.Clean(schema, value);
  if (dynamic) {
    const validator = {
      schema,
      references: "",
      checkFunc: () => {
      },
      code: "",
      Check: (value) => value_exports2.Check(schema, value),
      Errors: (value) => value_exports2.Errors(schema, value),
      Code: () => "",
      Clean: cleaner
    };
    if (normalize4 && schema.additionalProperties === false)
      validator.Clean = cleaner;
    if (schema.config) {
      validator.config = schema.config;
      if (validator?.schema?.config)
        delete validator.schema.config;
    }
    validator.parse = (v2) => {
      try {
        return validator.Decode(v2);
      } catch (error22) {
        throw [...validator.Errors(v2)].map(mapValueError);
      }
    };
    validator.safeParse = (v2) => {
      try {
        return { success: true, data: validator.Decode(v2), error: null };
      } catch (error22) {
        const errors2 = [...compiled.Errors(v2)].map(mapValueError);
        return {
          success: false,
          data: null,
          error: errors2[0]?.summary,
          errors: errors2
        };
      }
    };
    return validator;
  }
  const compiled = TypeCompiler.Compile(schema, Object.values(models));
  compiled.Clean = cleaner;
  if (schema.config) {
    compiled.config = schema.config;
    if (compiled?.schema?.config)
      delete compiled.schema.config;
  }
  compiled.parse = (v2) => {
    try {
      return compiled.Decode(v2);
    } catch (error22) {
      throw [...compiled.Errors(v2)].map(mapValueError);
    }
  };
  compiled.safeParse = (v2) => {
    try {
      return { success: true, data: compiled.Decode(v2), error: null };
    } catch (error22) {
      const errors2 = [...compiled.Errors(v2)].map(mapValueError);
      return {
        success: false,
        data: null,
        error: errors2[0]?.summary,
        errors: errors2
      };
    }
  };
  return compiled;
};
var getResponseSchemaValidator = (s2, {
  models = {},
  dynamic = false,
  normalize: normalize4 = false,
  additionalProperties = false
}) => {
  if (!s2)
    return;
  if (typeof s2 === "string" && !(s2 in models))
    return;
  const maybeSchemaOrRecord = typeof s2 === "string" ? models[s2] : s2;
  const compile = (schema, references) => {
    const cleaner = (value) => {
      if (!value || typeof value !== "object") {
        return value_exports2.Clean(schema, value);
      }
      let touched = false;
      const visited2 = /* @__PURE__ */ new Set();
      const retrieveAllFieldsOfObjectOrArray = (value2) => {
        if (visited2.has(value2)) {
          return value2;
        }
        visited2.add(value2);
        if (Array.isArray(value2)) {
          return value2.map((x2) => retrieveAllFieldsOfObjectOrArray(x2));
        }
        const retrievedArrayFields = {};
        for (const [key2, val2] of Object.entries(value2)) {
          if (Array.isArray(val2)) {
            retrievedArrayFields[key2] = retrieveAllFieldsOfObjectOrArray(val2);
            delete value2[key2];
          }
        }
        Object.assign(value2, retrievedArrayFields);
        const retrievedFields = {};
        let currentObj = value2;
        while (currentObj !== null) {
          for (const name of Object.getOwnPropertyNames(currentObj)) {
            const descriptor = Object.getOwnPropertyDescriptor(
              currentObj,
              name
            );
            if (descriptor && typeof descriptor.get === "function" && name !== "__proto__") {
              retrievedFields[name] = value2[name];
              delete currentObj[name];
              touched = true;
            }
          }
          currentObj = Object.getPrototypeOf(currentObj);
        }
        Object.assign(value2, retrievedFields);
        return value2;
      };
      value = retrieveAllFieldsOfObjectOrArray(value);
      if (!touched) {
        return value_exports2.Clean(schema, value);
      }
      if (Array.isArray(value)) {
        value = value_exports2.Clean(schema, value);
      } else {
        value = { ...value_exports2.Clean(schema, value) };
      }
      return value;
    };
    if (dynamic)
      return {
        schema,
        references: "",
        checkFunc: () => {
        },
        code: "",
        Check: (value) => value_exports2.Check(schema, value),
        Errors: (value) => value_exports2.Errors(schema, value),
        Code: () => ""
      };
    const compiledValidator = TypeCompiler.Compile(schema, references);
    if (normalize4 && schema.additionalProperties === false)
      compiledValidator.Clean = cleaner;
    return compiledValidator;
  };
  if (Kind in maybeSchemaOrRecord) {
    if ("additionalProperties" in maybeSchemaOrRecord === false)
      maybeSchemaOrRecord.additionalProperties = additionalProperties;
    return {
      200: compile(maybeSchemaOrRecord, Object.values(models))
    };
  }
  const record = {};
  Object.keys(maybeSchemaOrRecord).forEach((status) => {
    const maybeNameOrSchema = maybeSchemaOrRecord[+status];
    if (typeof maybeNameOrSchema === "string") {
      if (maybeNameOrSchema in models) {
        const schema = models[maybeNameOrSchema];
        schema.type === "object" && "additionalProperties" in schema === false;
        record[+status] = Kind in schema ? compile(schema, Object.values(models)) : schema;
      }
      return void 0;
    }
    if (maybeNameOrSchema.type === "object" && "additionalProperties" in maybeNameOrSchema === false)
      maybeNameOrSchema.additionalProperties = additionalProperties;
    record[+status] = Kind in maybeNameOrSchema ? compile(maybeNameOrSchema, Object.values(models)) : maybeNameOrSchema;
  });
  return record;
};
var isBun = typeof Bun !== "undefined";
var hasHash = isBun && typeof Bun.hash === "function";
var checksum = (s2) => {
  if (hasHash)
    return Bun.hash(s2);
  let h2 = 9;
  for (let i2 = 0; i2 < s2.length; )
    h2 = Math.imul(h2 ^ s2.charCodeAt(i2++), 9 ** 9);
  return h2 = h2 ^ h2 >>> 9;
};
var _stringToStructureCoercions;
var stringToStructureCoercions = () => {
  if (!_stringToStructureCoercions) {
    _stringToStructureCoercions = [
      {
        from: t.Object({}),
        to: () => t.ObjectString({}),
        excludeRoot: true
      },
      {
        from: t.Array(t.Any()),
        to: () => t.ArrayString(t.Any())
      }
    ];
  }
  return _stringToStructureCoercions;
};
var getCookieValidator = ({
  validator,
  defaultConfig = {},
  config: config3,
  dynamic,
  models
}) => {
  let cookieValidator = getSchemaValidator(validator, {
    dynamic,
    models,
    additionalProperties: true,
    coerce: true,
    additionalCoerce: stringToStructureCoercions()
  });
  if (isNotEmpty(defaultConfig)) {
    if (cookieValidator) {
      cookieValidator.config = mergeCookie(
        // @ts-expect-error private
        cookieValidator.config,
        config3
      );
    } else {
      cookieValidator = getSchemaValidator(t.Cookie({}), {
        dynamic,
        models,
        additionalProperties: true
      });
      cookieValidator.config = defaultConfig;
    }
  }
  return cookieValidator;
};
var injectChecksum = (checksum2, x2) => {
  if (!x2)
    return;
  if (!Array.isArray(x2)) {
    const fn = x2;
    if (checksum2 && !fn.checksum)
      fn.checksum = checksum2;
    if (fn.scope === "scoped")
      fn.scope = "local";
    return fn;
  }
  const fns = [...x2];
  for (const fn of fns) {
    if (checksum2 && !fn.checksum)
      fn.checksum = checksum2;
    if (fn.scope === "scoped")
      fn.scope = "local";
  }
  return fns;
};
var mergeLifeCycle = (a2, b2, checksum2) => {
  return {
    // ...a,
    // ...b,
    start: mergeObjectArray(
      a2.start,
      injectChecksum(checksum2, b2?.start)
    ),
    request: mergeObjectArray(
      a2.request,
      injectChecksum(checksum2, b2?.request)
    ),
    parse: mergeObjectArray(
      a2.parse,
      injectChecksum(checksum2, b2?.parse)
    ),
    transform: mergeObjectArray(
      a2.transform,
      injectChecksum(checksum2, b2?.transform)
    ),
    beforeHandle: mergeObjectArray(
      a2.beforeHandle,
      injectChecksum(checksum2, b2?.beforeHandle)
    ),
    afterHandle: mergeObjectArray(
      a2.afterHandle,
      injectChecksum(checksum2, b2?.afterHandle)
    ),
    mapResponse: mergeObjectArray(
      a2.mapResponse,
      injectChecksum(checksum2, b2?.mapResponse)
    ),
    afterResponse: mergeObjectArray(
      a2.afterResponse,
      injectChecksum(checksum2, b2?.afterResponse)
    ),
    // Already merged on Elysia._use, also logic is more complicated, can't directly merge
    trace: mergeObjectArray(
      a2.trace,
      injectChecksum(checksum2, b2?.trace)
    ),
    error: mergeObjectArray(
      a2.error,
      injectChecksum(checksum2, b2?.error)
    ),
    stop: mergeObjectArray(
      a2.stop,
      injectChecksum(checksum2, b2?.stop)
    )
  };
};
var asHookType = (fn, inject, { skipIfHasType = false } = {}) => {
  if (!fn)
    return fn;
  if (!Array.isArray(fn)) {
    if (skipIfHasType)
      fn.scope ??= inject;
    else
      fn.scope = inject;
    return fn;
  }
  for (const x2 of fn)
    if (skipIfHasType)
      x2.scope ??= inject;
    else
      x2.scope = inject;
  return fn;
};
var filterGlobal = (fn) => {
  if (!fn)
    return fn;
  if (!Array.isArray(fn))
    switch (fn.scope) {
      case "global":
      case "scoped":
        return { ...fn };
      default:
        return { fn };
    }
  const array = [];
  for (const x2 of fn)
    switch (x2.scope) {
      case "global":
      case "scoped":
        array.push({
          ...x2
        });
        break;
    }
  return array;
};
var filterGlobalHook = (hook) => {
  return {
    // rest is validator
    ...hook,
    type: hook?.type,
    detail: hook?.detail,
    parse: filterGlobal(hook?.parse),
    transform: filterGlobal(hook?.transform),
    beforeHandle: filterGlobal(hook?.beforeHandle),
    afterHandle: filterGlobal(hook?.afterHandle),
    mapResponse: filterGlobal(hook?.mapResponse),
    afterResponse: filterGlobal(hook?.afterResponse),
    error: filterGlobal(hook?.error),
    trace: filterGlobal(hook?.trace)
  };
};
var StatusMap = {
  Continue: 100,
  "Switching Protocols": 101,
  Processing: 102,
  "Early Hints": 103,
  OK: 200,
  Created: 201,
  Accepted: 202,
  "Non-Authoritative Information": 203,
  "No Content": 204,
  "Reset Content": 205,
  "Partial Content": 206,
  "Multi-Status": 207,
  "Already Reported": 208,
  "Multiple Choices": 300,
  "Moved Permanently": 301,
  Found: 302,
  "See Other": 303,
  "Not Modified": 304,
  "Temporary Redirect": 307,
  "Permanent Redirect": 308,
  "Bad Request": 400,
  Unauthorized: 401,
  "Payment Required": 402,
  Forbidden: 403,
  "Not Found": 404,
  "Method Not Allowed": 405,
  "Not Acceptable": 406,
  "Proxy Authentication Required": 407,
  "Request Timeout": 408,
  Conflict: 409,
  Gone: 410,
  "Length Required": 411,
  "Precondition Failed": 412,
  "Payload Too Large": 413,
  "URI Too Long": 414,
  "Unsupported Media Type": 415,
  "Range Not Satisfiable": 416,
  "Expectation Failed": 417,
  "I'm a teapot": 418,
  "Misdirected Request": 421,
  "Unprocessable Content": 422,
  Locked: 423,
  "Failed Dependency": 424,
  "Too Early": 425,
  "Upgrade Required": 426,
  "Precondition Required": 428,
  "Too Many Requests": 429,
  "Request Header Fields Too Large": 431,
  "Unavailable For Legal Reasons": 451,
  "Internal Server Error": 500,
  "Not Implemented": 501,
  "Bad Gateway": 502,
  "Service Unavailable": 503,
  "Gateway Timeout": 504,
  "HTTP Version Not Supported": 505,
  "Variant Also Negotiates": 506,
  "Insufficient Storage": 507,
  "Loop Detected": 508,
  "Not Extended": 510,
  "Network Authentication Required": 511
};
var InvertedStatusMap = Object.fromEntries(
  Object.entries(StatusMap).map(([k2, v2]) => [v2, k2])
);
function removeTrailingEquals(digest) {
  let trimmedDigest = digest;
  while (trimmedDigest.endsWith("=")) {
    trimmedDigest = trimmedDigest.slice(0, -1);
  }
  return trimmedDigest;
}
var encoder = new TextEncoder();
var signCookie = async (val2, secret) => {
  if (typeof val2 !== "string")
    throw new TypeError("Cookie value must be provided as a string.");
  if (secret === null)
    throw new TypeError("Secret key must be provided.");
  const secretKey = await crypto.subtle.importKey(
    "raw",
    encoder.encode(secret),
    { name: "HMAC", hash: "SHA-256" },
    false,
    ["sign"]
  );
  const hmacBuffer = await crypto.subtle.sign(
    "HMAC",
    secretKey,
    encoder.encode(val2)
  );
  return val2 + "." + removeTrailingEquals(Buffer2.from(hmacBuffer).toString("base64"));
};
var unsignCookie = async (input, secret) => {
  if (typeof input !== "string")
    throw new TypeError("Signed cookie string must be provided.");
  if (null === secret)
    throw new TypeError("Secret key must be provided.");
  const tentativeValue = input.slice(0, input.lastIndexOf("."));
  const expectedInput = await signCookie(tentativeValue, secret);
  return expectedInput === input ? tentativeValue : false;
};
var traceBackMacro = (extension2, property) => {
  if (!extension2 || typeof extension2 !== "object" || !property)
    return;
  for (const [key2, value] of Object.entries(property)) {
    if (key2 in primitiveHookMap || !(key2 in extension2))
      continue;
    const v2 = extension2[key2];
    if (typeof v2 === "function") {
      v2(value);
      delete property[key2];
    }
  }
};
var createMacroManager = ({
  globalHook,
  localHook
}) => (stackName) => (type, fn) => {
  if (typeof type === "function")
    type = {
      fn: type
    };
  if ("fn" in type || Array.isArray(type)) {
    if (!localHook[stackName])
      localHook[stackName] = [];
    if (typeof localHook[stackName] === "function")
      localHook[stackName] = [localHook[stackName]];
    if (Array.isArray(type))
      localHook[stackName] = localHook[stackName].concat(type);
    else
      localHook[stackName].push(type);
    return;
  }
  const { insert = "after", stack = "local" } = type;
  if (typeof fn === "function")
    fn = { fn };
  if (stack === "global") {
    if (!Array.isArray(fn)) {
      if (insert === "before") {
        ;
        globalHook[stackName].unshift(fn);
      } else {
        ;
        globalHook[stackName].push(fn);
      }
    } else {
      if (insert === "before") {
        globalHook[stackName] = fn.concat(
          globalHook[stackName]
        );
      } else {
        globalHook[stackName] = globalHook[stackName].concat(fn);
      }
    }
  } else {
    if (!localHook[stackName])
      localHook[stackName] = [];
    if (typeof localHook[stackName] === "function")
      localHook[stackName] = [localHook[stackName]];
    if (!Array.isArray(fn)) {
      if (insert === "before") {
        ;
        localHook[stackName].unshift(fn);
      } else {
        ;
        localHook[stackName].push(fn);
      }
    } else {
      if (insert === "before") {
        localHook[stackName] = fn.concat(localHook[stackName]);
      } else {
        localHook[stackName] = localHook[stackName].concat(fn);
      }
    }
  }
};
var parseNumericString = (message2) => {
  if (typeof message2 === "number")
    return message2;
  if (message2.length < 16) {
    if (message2.trim().length === 0)
      return null;
    const length = Number(message2);
    if (Number.isNaN(length))
      return null;
    return length;
  }
  if (message2.length === 16) {
    if (message2.trim().length === 0)
      return null;
    const number2 = Number(message2);
    if (Number.isNaN(number2) || number2.toString() !== message2)
      return null;
    return number2;
  }
  return null;
};
var isNumericString = (message2) => parseNumericString(message2) !== null;
var PromiseGroup = class {
  constructor(onError = console.error) {
    this.onError = onError;
    this.root = null;
    this.promises = [];
  }
  /**
   * The number of promises still being awaited.
   */
  get size() {
    return this.promises.length;
  }
  /**
   * Add a promise to the group.
   * @returns The promise that was added.
   */
  add(promise) {
    this.promises.push(promise);
    this.root ||= this.drain();
    return promise;
  }
  async drain() {
    while (this.promises.length > 0) {
      try {
        await this.promises[0];
      } catch (error22) {
        this.onError(error22);
      }
      this.promises.shift();
    }
    this.root = null;
  }
  // Allow the group to be awaited.
  then(onfulfilled, onrejected) {
    return (this.root ?? Promise.resolve()).then(onfulfilled, onrejected);
  }
};
var fnToContainer = (fn) => {
  if (!fn)
    return fn;
  if (!Array.isArray(fn)) {
    if (typeof fn === "function")
      return { fn };
    else if ("fn" in fn)
      return fn;
  }
  const fns = [];
  for (const x2 of fn) {
    if (typeof x2 === "function")
      fns.push({ fn: x2 });
    else if ("fn" in x2)
      fns.push(x2);
  }
  return fns;
};
var localHookToLifeCycleStore = (a2) => {
  return {
    ...a2,
    start: fnToContainer(a2?.start),
    request: fnToContainer(a2?.request),
    parse: fnToContainer(a2?.parse),
    transform: fnToContainer(a2?.transform),
    beforeHandle: fnToContainer(a2?.beforeHandle),
    afterHandle: fnToContainer(a2?.afterHandle),
    mapResponse: fnToContainer(a2?.mapResponse),
    afterResponse: fnToContainer(a2?.afterResponse),
    trace: fnToContainer(a2?.trace),
    error: fnToContainer(a2?.error),
    stop: fnToContainer(a2?.stop)
  };
};
var lifeCycleToFn = (a2) => {
  return {
    ...a2,
    start: a2.start?.map((x2) => x2.fn),
    request: a2.request?.map((x2) => x2.fn),
    parse: a2.parse?.map((x2) => x2.fn),
    transform: a2.transform?.map((x2) => x2.fn),
    beforeHandle: a2.beforeHandle?.map((x2) => x2.fn),
    afterHandle: a2.afterHandle?.map((x2) => x2.fn),
    afterResponse: a2.afterResponse?.map((x2) => x2.fn),
    mapResponse: a2.mapResponse?.map((x2) => x2.fn),
    trace: a2.trace?.map((x2) => x2.fn),
    error: a2.error?.map((x2) => x2.fn),
    stop: a2.stop?.map((x2) => x2.fn)
  };
};
var cloneInference = (inference) => ({
  body: inference.body,
  cookie: inference.cookie,
  headers: inference.headers,
  query: inference.query,
  set: inference.set,
  server: inference.server
});
var redirect = (url, status = 302) => Response.redirect(url, status);
var ELYSIA_FORM_DATA = Symbol("ElysiaFormData");
var ELYSIA_REQUEST_ID = Symbol("ElysiaRequestId");
var form = (items) => {
  const formData = new FormData();
  for (const [key2, value] of Object.entries(items)) {
    if (Array.isArray(value)) {
      for (const v2 of value) {
        if (value instanceof File)
          formData.append(key2, value, value.name);
        formData.append(key2, v2);
      }
      continue;
    }
    if (value instanceof File)
      formData.append(key2, value, value.name);
    formData.append(key2, value);
  }
  return formData;
};
var randomId = () => crypto.getRandomValues(new Uint32Array(1))[0];
var deduplicateChecksum = (array) => {
  const hashes = [];
  for (let i2 = 0; i2 < array.length; i2++) {
    const item = array[i2];
    if (item.checksum) {
      if (hashes.includes(item.checksum)) {
        array.splice(i2, 1);
        i2--;
      }
      hashes.push(item.checksum);
    }
  }
  return array;
};
var promoteEvent = (events, as2 = "scoped") => {
  if (as2 === "scoped") {
    for (const event of events)
      if ("scope" in event && event.scope === "local")
        event.scope = "scoped";
    return;
  }
  for (const event of events)
    if ("scope" in event)
      event.scope = "global";
};
var env2 = typeof Bun !== "undefined" ? Bun.env : typeof process !== "undefined" ? process?.env : void 0;
var ERROR_CODE = Symbol("ElysiaErrorCode");
var ELYSIA_RESPONSE = Symbol("ElysiaResponse");
var isProduction = (env2?.NODE_ENV ?? env2?.ENV) === "production";
var error = (code4, response) => {
  const res = response ?? (code4 in InvertedStatusMap ? (
    // @ts-expect-error Always correct
    InvertedStatusMap[code4]
  ) : code4);
  return {
    // @ts-expect-error trust me bro
    [ELYSIA_RESPONSE]: StatusMap[code4] ?? code4,
    response: res,
    _type: void 0,
    error: new Error(res)
  };
};
var InternalServerError = class extends Error {
  constructor(message2) {
    super(message2 ?? "INTERNAL_SERVER_ERROR");
    this.code = "INTERNAL_SERVER_ERROR";
    this.status = 500;
  }
};
var NotFoundError = class extends Error {
  constructor(message2) {
    super(message2 ?? "NOT_FOUND");
    this.code = "NOT_FOUND";
    this.status = 404;
  }
};
var ParseError = class extends Error {
  constructor() {
    super("Failed to parse body");
    this.code = "PARSE";
    this.status = 400;
  }
};
var InvalidCookieSignature = class extends Error {
  constructor(key2, message2) {
    super(message2 ?? `"${key2}" has invalid cookie signature`);
    this.key = key2;
    this.code = "INVALID_COOKIE_SIGNATURE";
    this.status = 400;
  }
};
var mapValueError = (error22) => {
  const { message: message2, path: path2, value, type } = error22;
  const property = path2.slice(1).replaceAll("/", ".");
  const isRoot = path2 === "";
  switch (type) {
    case 42:
      return {
        ...error22,
        summary: isRoot ? `Value should not be provided` : `Property '${property}' should not be provided`
      };
    case 45:
      return {
        ...error22,
        summary: isRoot ? `Value is missing` : `Property '${property}' is missing`
      };
    case 50:
      const quoteIndex = message2.indexOf("'");
      const format3 = message2.slice(
        quoteIndex + 1,
        message2.indexOf("'", quoteIndex + 1)
      );
      return {
        ...error22,
        summary: isRoot ? `Value should be an email` : `Property '${property}' should be ${format3}`
      };
    case 54:
      return {
        ...error22,
        summary: `${message2.slice(
          0,
          9
        )} property '${property}' to be ${message2.slice(
          8
        )} but found: ${value}`
      };
    case 62:
      const union2 = error22.schema.anyOf.map((x2) => `'${x2?.format ?? x2.type}'`).join(", ");
      return {
        ...error22,
        summary: isRoot ? `Value should be one of ${union2}` : `Property '${property}' should be one of: ${union2}`
      };
    default:
      return { summary: message2, ...error22 };
  }
};
var ValidationError = class _ValidationError extends Error {
  constructor(type, validator, value) {
    if (value && typeof value === "object" && ELYSIA_RESPONSE in value)
      value = value.response;
    const error22 = isProduction ? void 0 : "Errors" in validator ? validator.Errors(value).First() : value_exports2.Errors(validator, value).First();
    const customError = error22?.schema.error !== void 0 ? typeof error22.schema.error === "function" ? error22.schema.error({
      type,
      validator,
      value,
      get errors() {
        return [...validator.Errors(value)].map(
          mapValueError
        );
      }
    }) : error22.schema.error : void 0;
    const accessor = error22?.path || "root";
    let message2 = "";
    if (customError !== void 0) {
      message2 = typeof customError === "object" ? JSON.stringify(customError) : customError + "";
    } else if (isProduction) {
      message2 = JSON.stringify({
        type: "validation",
        on: type,
        summary: mapValueError(error22).summary,
        message: error22?.message,
        found: value
      });
    } else {
      const schema = validator?.schema ?? validator;
      const errors2 = "Errors" in validator ? [...validator.Errors(value)].map(mapValueError) : [...value_exports2.Errors(validator, value)].map(mapValueError);
      let expected;
      try {
        expected = value_exports2.Create(schema);
      } catch (error3) {
        expected = {
          type: "Could not create expected value",
          // @ts-expect-error
          message: error3?.message,
          error: error3
        };
      }
      message2 = JSON.stringify(
        {
          type: "validation",
          on: type,
          summary: errors2[0]?.summary,
          property: accessor,
          message: error22?.message,
          expected,
          found: value,
          errors: errors2
        },
        null,
        2
      );
    }
    super(message2);
    this.type = type;
    this.validator = validator;
    this.value = value;
    this.code = "VALIDATION";
    this.status = 422;
    Object.setPrototypeOf(this, _ValidationError.prototype);
  }
  get all() {
    return "Errors" in this.validator ? [...this.validator.Errors(this.value)].map(mapValueError) : (
      // @ts-ignore
      [...value_exports2.Errors(this.validator, this.value)].map(mapValueError)
    );
  }
  static simplifyModel(validator) {
    const model = "schema" in validator ? validator.schema : validator;
    try {
      return value_exports2.Create(model);
    } catch {
      return model;
    }
  }
  get model() {
    return _ValidationError.simplifyModel(this.validator);
  }
  toResponse(headers) {
    return new Response(this.message, {
      status: 400,
      headers: {
        ...headers,
        "content-type": "application/json"
      }
    });
  }
};
var websocket = {
  open(ws) {
    ws.data.open?.(ws);
  },
  message(ws, message2) {
    ws.data.message?.(ws, message2);
  },
  drain(ws) {
    ws.data.drain?.(ws);
  },
  close(ws, code4, reason) {
    ws.data.close?.(ws, code4, reason);
  }
};
var ElysiaWS = class {
  constructor(raw2, data) {
    this.raw = raw2;
    this.data = data;
    this.validator = raw2.data.validator;
    if (raw2.data.id) {
      this.id = raw2.data.id;
    } else {
      this.id = randomId().toString();
    }
  }
  get id() {
    return this.raw.data.id;
  }
  set id(newID) {
    this.raw.data.id = newID;
  }
  get publish() {
    return (topic, data = void 0, compress) => {
      if (this.validator?.Check(data) === false)
        throw new ValidationError("message", this.validator, data);
      if (typeof data === "object")
        data = JSON.stringify(data);
      this.raw.publish(topic, data, compress);
      return this;
    };
  }
  get send() {
    return (data) => {
      if (this.validator?.Check(data) === false)
        throw new ValidationError("message", this.validator, data);
      if (Buffer2.isBuffer(data)) {
        this.raw.send(data);
        return this;
      }
      if (typeof data === "object")
        data = JSON.stringify(data);
      this.raw.send(data);
      return this;
    };
  }
  get subscribe() {
    return (room) => {
      this.raw.subscribe(room);
      return this;
    };
  }
  get unsubscribe() {
    return (room) => {
      this.raw.unsubscribe(room);
      return this;
    };
  }
  get cork() {
    return (callback) => {
      this.raw.cork(callback);
      return this;
    };
  }
  get close() {
    return () => {
      this.raw.close();
      return this;
    };
  }
  get terminate() {
    return this.raw.terminate.bind(this.raw);
  }
  get isSubscribed() {
    return this.raw.isSubscribed.bind(this.raw);
  }
  get remoteAddress() {
    return this.raw.remoteAddress;
  }
};
var version3 = "1.1.5";
var plusRegex = /\+/g;
function parseQuery(input) {
  const result = {};
  if (typeof input !== "string")
    return result;
  let key2 = "";
  let value = "";
  let startingIndex = -1;
  let equalityIndex = -1;
  let flags = 0;
  const l2 = input.length;
  for (let i2 = 0; i2 < l2; i2++) {
    switch (input.charCodeAt(i2)) {
      case 38:
        const hasBothKeyValuePair = equalityIndex > startingIndex;
        if (!hasBothKeyValuePair)
          equalityIndex = i2;
        key2 = input.slice(startingIndex + 1, equalityIndex);
        if (hasBothKeyValuePair || key2.length > 0) {
          if (flags & 1)
            key2 = key2.replace(plusRegex, " ");
          if (flags & 2)
            key2 = (0, import_fast_decode_uri_component2.default)(key2) || key2;
          if (!result[key2]) {
            if (hasBothKeyValuePair) {
              value = input.slice(equalityIndex + 1, i2);
              if (flags & 4)
                value = value.replace(plusRegex, " ");
              if (flags & 8)
                value = (0, import_fast_decode_uri_component2.default)(value) || value;
            }
            result[key2] = value;
          }
        }
        key2 = "";
        value = "";
        startingIndex = i2;
        equalityIndex = i2;
        flags = 0;
        break;
      case 61:
        if (equalityIndex <= startingIndex)
          equalityIndex = i2;
        else
          flags |= 8;
        break;
      case 43:
        if (equalityIndex > startingIndex)
          flags |= 4;
        else
          flags |= 1;
        break;
      case 37:
        if (equalityIndex > startingIndex)
          flags |= 8;
        else
          flags |= 2;
        break;
    }
  }
  if (startingIndex < l2) {
    const hasBothKeyValuePair = equalityIndex > startingIndex;
    key2 = input.slice(
      startingIndex + 1,
      hasBothKeyValuePair ? equalityIndex : l2
    );
    if (hasBothKeyValuePair || key2.length > 0) {
      if (flags & 1)
        key2 = key2.replace(plusRegex, " ");
      if (flags & 2)
        key2 = (0, import_fast_decode_uri_component2.default)(key2) || key2;
      if (!result[key2]) {
        if (hasBothKeyValuePair) {
          value = input.slice(equalityIndex + 1, l2);
          if (flags & 4)
            value = value.replace(plusRegex, " ");
          if (flags & 8)
            value = (0, import_fast_decode_uri_component2.default)(value) || value;
        }
        result[key2] = value;
      }
    }
  }
  return result;
}
var ELYSIA_TRACE = Symbol("ElysiaTrace");
var createProcess = () => {
  const { promise, resolve: resolve2 } = Promise.withResolvers();
  const { promise: end, resolve: resolveEnd } = Promise.withResolvers();
  const { promise: error22, resolve: resolveError } = Promise.withResolvers();
  const callbacks = [];
  const callbacksEnd = [];
  return [
    (callback) => {
      if (callback)
        callbacks.push(callback);
      return promise;
    },
    (process2) => {
      const processes = [];
      const resolvers = [];
      let groupError = null;
      for (let i2 = 0; i2 < (process2.total ?? 0); i2++) {
        const { promise: promise2, resolve: resolve22 } = Promise.withResolvers();
        const { promise: end2, resolve: resolveEnd2 } = Promise.withResolvers();
        const { promise: error3, resolve: resolveError2 } = Promise.withResolvers();
        const callbacks2 = [];
        const callbacksEnd2 = [];
        processes.push((callback) => {
          if (callback)
            callbacks2.push(callback);
          return promise2;
        });
        resolvers.push((process3) => {
          const result2 = {
            ...process3,
            end: end2,
            error: error3,
            index: i2,
            onStop(callback) {
              if (callback)
                callbacksEnd2.push(callback);
              return end2;
            }
          };
          resolve22(result2);
          for (let i22 = 0; i22 < callbacks2.length; i22++)
            callbacks2[i22](result2);
          return (error4 = null) => {
            const end3 = performance.now();
            if (error4)
              groupError = error4;
            const detail = {
              end: end3,
              error: error4,
              get elapsed() {
                return end3 - process3.begin;
              }
            };
            for (let i22 = 0; i22 < callbacksEnd2.length; i22++)
              callbacksEnd2[i22](detail);
            resolveEnd2(end3);
            resolveError2(error4);
          };
        });
      }
      const result = {
        ...process2,
        end,
        error: error22,
        onEvent(callback) {
          for (let i2 = 0; i2 < processes.length; i2++)
            processes[i2](callback);
        },
        onStop(callback) {
          if (callback)
            callbacksEnd.push(callback);
          return end;
        }
      };
      resolve2(result);
      for (let i2 = 0; i2 < callbacks.length; i2++)
        callbacks[i2](result);
      return {
        resolveChild: resolvers,
        resolve(error3 = null) {
          const end2 = performance.now();
          if (!error3 && groupError)
            error3 = groupError;
          const detail = {
            end: end2,
            error: error3,
            get elapsed() {
              return end2 - process2.begin;
            }
          };
          for (let i2 = 0; i2 < callbacksEnd.length; i2++)
            callbacksEnd[i2](detail);
          resolveEnd(end2);
          resolveError(error3);
        }
      };
    }
  ];
};
var createTracer = (traceListener) => {
  return (context) => {
    const [onRequest, resolveRequest] = createProcess();
    const [onParse, resolveParse] = createProcess();
    const [onTransform, resolveTransform] = createProcess();
    const [onBeforeHandle, resolveBeforeHandle] = createProcess();
    const [onHandle, resolveHandle] = createProcess();
    const [onAfterHandle, resolveAfterHandle] = createProcess();
    const [onError, resolveError] = createProcess();
    const [onMapResponse, resolveMapResponse] = createProcess();
    const [onAfterResponse, resolveAfterResponse] = createProcess();
    traceListener({
      // @ts-ignore
      id: context[ELYSIA_REQUEST_ID],
      context,
      set: context.set,
      // @ts-ignore
      onRequest,
      // @ts-ignore
      onParse,
      // @ts-ignore
      onTransform,
      // @ts-ignore
      onBeforeHandle,
      // @ts-ignore
      onHandle,
      // @ts-ignore
      onAfterHandle,
      // @ts-ignore
      onMapResponse,
      // @ts-ignore
      onAfterResponse,
      // @ts-ignore
      onError
    });
    return {
      request: resolveRequest,
      parse: resolveParse,
      transform: resolveTransform,
      beforeHandle: resolveBeforeHandle,
      handle: resolveHandle,
      afterHandle: resolveAfterHandle,
      error: resolveError,
      mapResponse: resolveMapResponse,
      afterResponse: resolveAfterResponse
    };
  };
};
var headersHasToJSON = new Headers().toJSON;
var TypeBoxSymbol = {
  optional: Symbol.for("TypeBox.Optional"),
  kind: Symbol.for("TypeBox.Kind")
};
var isOptional = (validator) => {
  if (!validator)
    return false;
  const schema = validator?.schema;
  return !!schema && TypeBoxSymbol.optional in schema;
};
var hasAdditionalProperties = (_schema) => {
  if (!_schema)
    return false;
  const schema = _schema?.schema ?? _schema;
  if (schema.anyOf)
    return schema.anyOf.some(hasAdditionalProperties);
  if (schema.someOf)
    return schema.someOf.some(hasAdditionalProperties);
  if (schema.allOf)
    return schema.allOf.some(hasAdditionalProperties);
  if (schema.not)
    return schema.not.some(hasAdditionalProperties);
  if (schema.type === "object") {
    const properties = schema.properties;
    if ("additionalProperties" in schema)
      return schema.additionalProperties;
    for (const key2 of Object.keys(properties)) {
      const property = properties[key2];
      if (property.type === "object") {
        if (hasAdditionalProperties(property))
          return true;
      } else if (property.anyOf) {
        for (let i2 = 0; i2 < property.anyOf.length; i2++)
          if (hasAdditionalProperties(property.anyOf[i2]))
            return true;
      }
      return property.additionalProperties;
    }
    return false;
  }
  return false;
};
var createReport = ({
  context = "c",
  trace,
  addFn
}) => {
  if (!trace.length)
    return () => {
      return {
        resolveChild() {
          return () => {
          };
        },
        resolve() {
        }
      };
    };
  for (let i2 = 0; i2 < trace.length; i2++)
    addFn(
      `let report${i2}, reportChild${i2}, reportErr${i2}, reportErrChild${i2}; let trace${i2} = ${context}[ELYSIA_TRACE]?.[${i2}] ?? trace[${i2}](${context});
`
    );
  return (event, {
    name,
    total = 0
  } = {}) => {
    if (!name)
      name = "anonymous";
    const reporter = event === "error" ? "reportErr" : "report";
    for (let i2 = 0; i2 < trace.length; i2++)
      addFn(
        `
${reporter}${i2} = trace${i2}.${event}({id,event: '${event}',name: '${name}',begin: performance.now(),total: ${total}})
`
      );
    return {
      resolve() {
        for (let i2 = 0; i2 < trace.length; i2++)
          addFn(`
${reporter}${i2}.resolve()
`);
      },
      resolveChild(name2) {
        for (let i2 = 0; i2 < trace.length; i2++)
          addFn(
            `${reporter}Child${i2} = ${reporter}${i2}.resolveChild?.shift()?.({id,event: '${event}',name: '${name2}',begin: performance.now()})
`
          );
        return (binding3) => {
          for (let i2 = 0; i2 < trace.length; i2++) {
            if (binding3)
              addFn(`
                             	if (${binding3} instanceof Error)
                    				${reporter}Child${i2}?.(${binding3})
                           		else
                             		${reporter}Child${i2}?.()
`);
            else
              addFn(`${reporter}Child${i2}?.()
`);
          }
        };
      }
    };
  };
};
var composeValidationFactory = ({
  injectResponse = "",
  normalize: normalize4 = false,
  validator
}) => ({
  composeValidation: (type, value = `c.${type}`) => `c.set.status = 422; throw new ValidationError('${type}', validator.${type}, ${value})`,
  composeResponseValidation: (name = "r") => {
    let code4 = "\n" + injectResponse + "\n";
    code4 += `if(typeof ${name} === "object" && ${name} && ELYSIA_RESPONSE in ${name}) {
			c.set.status = ${name}[ELYSIA_RESPONSE]
			${name} = ${name}.response
		}

		const isResponse = ${name} instanceof Response

`;
    code4 += `switch(c.set.status) {
`;
    for (const [status, value] of Object.entries(
      validator.response
    )) {
      code4 += `	case ${status}:
				if (!isResponse) {
`;
      if (normalize4 && "Clean" in value && !hasAdditionalProperties(value))
        code4 += `${name} = validator.response['${status}'].Clean(${name})
`;
      code4 += `if(validator.response['${status}'].Check(${name}) === false) {
					c.set.status = 422

					throw new ValidationError('response', validator.response['${status}'], ${name})
				}

				c.set.status = ${status}
			}

			break

`;
    }
    code4 += "\n}\n";
    return code4;
  }
});
var KindSymbol = Symbol.for("TypeBox.Kind");
var hasProperty = (expectedProperty, schema) => {
  if (!schema)
    return;
  if (schema.type === "object") {
    const properties = schema.properties;
    if (!properties)
      return false;
    for (const key2 of Object.keys(properties)) {
      const property = properties[key2];
      if (expectedProperty in property)
        return true;
      if (property.type === "object") {
        if (hasProperty(expectedProperty, property))
          return true;
      } else if (property.anyOf) {
        for (let i2 = 0; i2 < property.anyOf.length; i2++) {
          if (hasProperty(expectedProperty, property.anyOf[i2]))
            return true;
        }
      }
    }
    return false;
  }
  return expectedProperty in schema;
};
var TransformSymbol = Symbol.for("TypeBox.Transform");
var hasTransform = (schema) => {
  if (!schema)
    return;
  if (schema.type === "object" && schema.properties) {
    const properties = schema.properties;
    for (const key2 of Object.keys(properties)) {
      const property = properties[key2];
      if (property.type === "object") {
        if (hasTransform(property))
          return true;
      } else if (property.anyOf) {
        for (let i2 = 0; i2 < property.anyOf.length; i2++)
          if (hasTransform(property.anyOf[i2]))
            return true;
      }
      const hasTransformSymbol = TransformSymbol in property;
      if (hasTransformSymbol)
        return true;
    }
    return false;
  }
  return TransformSymbol in schema || schema.properties && TransformSymbol in schema.properties;
};
var matchFnReturn = /(?:return|=>) \S+\(/g;
var isAsyncName = (v2) => {
  const fn = v2?.fn ?? v2;
  return fn.constructor.name === "AsyncFunction";
};
var isAsync = (v2) => {
  const fn = v2?.fn ?? v2;
  if (fn.constructor.name === "AsyncFunction")
    return true;
  const literal = fn.toString();
  if (literal.includes("=> response.clone("))
    return false;
  if (literal.includes("await"))
    return true;
  if (literal.includes("async"))
    return true;
  return !!literal.match(matchFnReturn);
};
var isGenerator = (v2) => {
  const fn = v2?.fn ?? v2;
  return fn.constructor.name === "AsyncGeneratorFunction" || fn.constructor.name === "GeneratorFunction";
};
var composeHandler = ({
  app: app2,
  path: path2,
  method,
  localHook,
  hooks,
  validator,
  handler,
  allowMeta = false,
  inference
}) => {
  const isHandleFn = typeof handler === "function";
  if (!isHandleFn)
    handler = mapResponse(handler, {
      // @ts-expect-error private property
      headers: app2.setHeaders ?? {}
    });
  const handle3 = isHandleFn ? `handler(c)` : `handler`;
  const hasAfterResponse = hooks.afterResponse.length > 0;
  const hasTrace = hooks.trace.length > 0;
  let fnLiteral = "";
  inference = sucrose(
    Object.assign(localHook, {
      handler
    }),
    inference
  );
  if (inference.server)
    fnLiteral += `
Object.defineProperty(c, 'server', {
			get: function() { return getServer() }
		})
`;
  if (inference.body)
    fnLiteral += `let isParsing = false
`;
  validator.createBody?.();
  validator.createQuery?.();
  validator.createHeaders?.();
  validator.createParams?.();
  validator.createCookie?.();
  validator.createResponse?.();
  const hasQuery = inference.query || !!validator.query;
  const hasBody = method !== "$INTERNALWS" && method !== "GET" && method !== "HEAD" && (inference.body || !!validator.body || hooks.parse.length);
  const defaultHeaders = app2.setHeaders;
  const hasDefaultHeaders = defaultHeaders && !!Object.keys(defaultHeaders).length;
  const hasHeaders = inference.headers || validator.headers;
  const hasCookie = inference.cookie || !!validator.cookie;
  const cookieValidator = hasCookie ? getCookieValidator({
    validator: validator.cookie,
    defaultConfig: app2.config.cookie,
    dynamic: !!app2.config.aot,
    // @ts-expect-error
    config: validator.cookie?.config ?? {},
    // @ts-expect-error
    models: app2.definitions.type
  }) : void 0;
  const cookieMeta = cookieValidator?.config;
  let encodeCookie = "";
  if (cookieMeta?.sign) {
    if (!cookieMeta.secrets)
      throw new Error(
        `t.Cookie required secret which is not set in (${method}) ${path2}.`
      );
    const secret = !cookieMeta.secrets ? void 0 : typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets[0];
    encodeCookie += `const _setCookie = c.set.cookie
		if(_setCookie) {`;
    if (cookieMeta.sign === true) {
      encodeCookie += `for(const [key, cookie] of Object.entries(_setCookie)) {
				c.set.cookie[key].value = await signCookie(cookie.value, '${secret}')
			}`;
    } else
      for (const name of cookieMeta.sign) {
        encodeCookie += `if(_setCookie['${name}']?.value) { c.set.cookie['${name}'].value = await signCookie(_setCookie['${name}'].value, '${secret}') }
`;
      }
    encodeCookie += "}\n";
  }
  const normalize4 = app2.config.normalize;
  const { composeValidation, composeResponseValidation } = composeValidationFactory({
    normalize: normalize4,
    validator
  });
  if (hasHeaders) {
    fnLiteral += headersHasToJSON ? `c.headers = c.request.headers.toJSON()
` : `c.headers = {}
                for (const [key, value] of c.request.headers.entries())
					c.headers[key] = value
				`;
  }
  if (hasCookie) {
    const get = (name, defaultValue) => {
      const value = cookieMeta?.[name] ?? defaultValue;
      if (!value)
        return typeof defaultValue === "string" ? `${name}: "${defaultValue}",` : `${name}: ${defaultValue},`;
      if (typeof value === "string")
        return `${name}: '${value}',`;
      if (value instanceof Date)
        return `${name}: new Date(${value.getTime()}),`;
      return `${name}: ${value},`;
    };
    const options = cookieMeta ? `{
			secrets: ${cookieMeta.secrets !== void 0 ? typeof cookieMeta.secrets === "string" ? `'${cookieMeta.secrets}'` : "[" + cookieMeta.secrets.reduce(
      (a2, b2) => a2 + `'${b2}',`,
      ""
    ) + "]" : "undefined"},
			sign: ${cookieMeta.sign === true ? true : cookieMeta.sign !== void 0 ? "[" + cookieMeta.sign.reduce(
      (a2, b2) => a2 + `'${b2}',`,
      ""
    ) + "]" : "undefined"},
			${get("domain")}
			${get("expires")}
			${get("httpOnly")}
			${get("maxAge")}
			${get("path", "/")}
			${get("priority")}
			${get("sameSite")}
			${get("secure")}
		}` : "undefined";
    if (hasHeaders)
      fnLiteral += `
c.cookie = await parseCookie(c.set, c.headers.cookie, ${options})
`;
    else
      fnLiteral += `
c.cookie = await parseCookie(c.set, c.request.headers.get('cookie'), ${options})
`;
  }
  if (hasQuery) {
    const destructured = [];
    if (validator.query && validator.query.schema.type === "object") {
      const properties = validator.query.schema.properties;
      if (!hasAdditionalProperties(validator.query))
        for (let [key2, _value] of Object.entries(properties)) {
          let value = _value;
          if (value && TypeBoxSymbol.optional in value && value.type === "array" && value.items)
            value = value.items;
          const { type, anyOf } = value;
          const isArray4 = type === "array" || anyOf?.some(
            (v2) => v2.type === "string" && v2.format === "ArrayString"
          );
          destructured.push({
            key: key2,
            isArray: isArray4,
            isNestedObjectArray: isArray4 && value.items?.type === "object" || !!value.items?.anyOf?.some(
              // @ts-expect-error
              (x2) => x2.type === "object" || x2.type === "array"
            ),
            isObject: type === "object" || anyOf?.some(
              (v2) => v2.type === "string" && v2.format === "ArrayString"
            ),
            anyOf: !!anyOf
          });
        }
    }
    if (!destructured.length) {
      fnLiteral += `if(c.qi === -1) {
				c.query = {}
			} else {
				c.query = parseQuery(c.url.slice(c.qi + 1))
			}`;
    } else {
      fnLiteral += `if(c.qi !== -1) {
				let url = '&' + c.url.slice(c.qi + 1)

				${destructured.map(
        ({
          key: key2,
          isArray: isArray4,
          isObject: isObject22,
          isNestedObjectArray,
          anyOf
        }, index3) => {
          const init3 = `${index3 === 0 ? "let" : ""} memory = url.indexOf('&${key2}=')
							let a${index3}
`;
          if (isArray4)
            return init3 + (isNestedObjectArray ? `while (memory !== -1) {
											const start = memory + ${key2.length + 2}
											memory = url.indexOf('&', start)

											if(a${index3} === undefined)
												a${index3} = ''
											else
												a${index3} += ','

											let temp

											if(memory === -1) temp = decodeURIComponent(url.slice(start))
											else temp = decodeURIComponent(url.slice(start, memory))

											const charCode = temp.charCodeAt(0)
											if(charCode !== 91 && charCode !== 123)
												temp = '"' + temp + '"'

											a${index3} += temp

											if(memory === -1) break

											memory = url.indexOf('&${key2}=', memory)
											if(memory === -1) break
										}

										try {
										    if(a${index3}.charCodeAt(0) === 91)
												a${index3} = JSON.parse(a${index3})
											else
												a${index3} = JSON.parse('[' + a${index3} + ']')
										} catch {}
` : `while (memory !== -1) {
											const start = memory + ${key2.length + 2}
											memory = url.indexOf('&', start)

											if(a${index3} === undefined)
												a${index3} = []

											if(memory === -1) {
												a${index3}.push(decodeURIComponent(url.slice(start)))
												break
											}
											else a${index3}.push(decodeURIComponent(url.slice(start, memory)))

											memory = url.indexOf('&${key2}=', memory)
											if(memory === -1) break
										}
`);
          if (isObject22)
            return init3 + `if (memory !== -1) {
										const start = memory + ${key2.length + 2}
										memory = url.indexOf('&', start)

										if(memory === -1) a${index3} = decodeURIComponent(url.slice(start))
										else a${index3} = decodeURIComponent(url.slice(start, memory))

										if (a${index3} !== undefined) {
											try {
												a${index3} = JSON.parse(a${index3})
											} catch {}
										}
									}`;
          return init3 + `if (memory !== -1) {
										const start = memory + ${key2.length + 2}
										memory = url.indexOf('&', start)

										if(memory === -1) a${index3} = decodeURIComponent(url.slice(start))
										else {
											a${index3} = decodeURIComponent(url.slice(start, memory))

											${anyOf ? `
											let deepMemory = url.indexOf('&${key2}=', memory)

											if(deepMemory !== -1) {
												a${index3} = [a${index3}]
												let first = true

												while(true) {
													const start = deepMemory + ${key2.length + 2}
													if(first)
														first = false
													else
														deepMemory = url.indexOf('&', start)

													let value
													if(deepMemory === -1) value = decodeURIComponent(url.slice(start))
													else value = decodeURIComponent(url.slice(start, deepMemory))

													const vStart = value.charCodeAt(0)
													const vEnd = value.charCodeAt(value.length - 1)

													if((vStart === 91 && vEnd === 93) || (vStart === 123 && vEnd === 125))
														try {
															a${index3}.push(JSON.parse(value))
														} catch {
														 	a${index3}.push(value)
														}

													if(deepMemory === -1) break
												}
											}
												` : ""}
										}
									}`;
        }
      ).join("\n")}

				c.query = {
					${destructured.map(({ key: key2 }, index3) => `'${key2}': a${index3}`).join(", ")}
				}
			} else {
				c.query = {}
			}`;
    }
  }
  if (hasTrace)
    fnLiteral += "\nconst id = c[ELYSIA_REQUEST_ID]\n";
  const report = createReport({
    trace: hooks.trace,
    addFn: (word) => {
      fnLiteral += word;
    }
  });
  fnLiteral += "\ntry {\n";
  const isAsyncHandler = typeof handler === "function" && isAsync(handler);
  const saveResponse = hasTrace || hooks.afterResponse.length > 0 ? "c.response = " : "";
  const maybeAsync = hasCookie || hasBody || isAsyncHandler || hooks.parse.length > 0 || hooks.afterHandle.some(isAsync) || hooks.beforeHandle.some(isAsync) || hooks.transform.some(isAsync) || hooks.mapResponse.some(isAsync);
  const maybeStream = (typeof handler === "function" ? isGenerator(handler) : false) || hooks.beforeHandle.some(isGenerator) || hooks.afterHandle.some(isGenerator) || hooks.transform.some(isGenerator);
  const hasSet = inference.cookie || inference.set || hasHeaders || hasTrace || validator.response || isHandleFn && hasDefaultHeaders || maybeStream;
  const requestMapper = `, c.request`;
  fnLiteral += `c.route = \`${path2}\`
`;
  const parseReporter = report("parse", {
    total: hooks.parse.length
  });
  if (hasBody) {
    const hasBodyInference = hooks.parse.length || inference.body || validator.body;
    fnLiteral += "isParsing = true\n";
    if (hooks.type && !hooks.parse.length) {
      switch (hooks.type) {
        case "json":
        case "application/json":
          fnLiteral += `c.body = await c.request.json()`;
          break;
        case "text":
        case "text/plain":
          fnLiteral += `c.body = await c.request.text()
`;
          break;
        case "urlencoded":
        case "application/x-www-form-urlencoded":
          fnLiteral += `c.body = parseQuery(await c.request.text())
`;
          break;
        case "arrayBuffer":
        case "application/octet-stream":
          fnLiteral += `c.body = await c.request.arrayBuffer()
`;
          break;
        case "formdata":
        case "multipart/form-data":
          fnLiteral += `c.body = {}

						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue

							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}
`;
          break;
      }
    } else if (hasBodyInference) {
      fnLiteral += "\n";
      fnLiteral += hasHeaders ? `let contentType = c.headers['content-type']` : `let contentType = c.request.headers.get('content-type')`;
      fnLiteral += `
				if (contentType) {
					const index = contentType.indexOf(';')
					if (index !== -1) contentType = contentType.substring(0, index)

					c.contentType = contentType
`;
      if (hooks.parse.length) {
        fnLiteral += `let used = false
`;
        const reporter = report("parse", {
          total: hooks.parse.length
        });
        for (let i2 = 0; i2 < hooks.parse.length; i2++) {
          const endUnit = reporter.resolveChild(
            hooks.parse[i2].fn.name
          );
          const name = `bo${i2}`;
          if (i2 !== 0)
            fnLiteral += `if(!used) {
`;
          fnLiteral += `let ${name} = parse[${i2}](c, contentType)
`;
          fnLiteral += `if(${name} instanceof Promise) ${name} = await ${name}
`;
          fnLiteral += `if(${name} !== undefined) { c.body = ${name}; used = true }
`;
          endUnit();
          if (i2 !== 0)
            fnLiteral += `}`;
        }
        reporter.resolve();
      }
      fnLiteral += "\ndelete c.contentType\n";
      if (hooks.parse.length)
        fnLiteral += `if (!used) {`;
      if (hooks.type && !Array.isArray(hooks.type)) {
        switch (hooks.type) {
          case "json":
          case "application/json":
            fnLiteral += `c.body = await c.request.json()`;
            break;
          case "text":
          case "text/plain":
            fnLiteral += `c.body = await c.request.text()
`;
            break;
          case "urlencoded":
          case "application/x-www-form-urlencoded":
            fnLiteral += `c.body = parseQuery(await c.request.text())
`;
            break;
          case "arrayBuffer":
          case "application/octet-stream":
            fnLiteral += `c.body = await c.request.arrayBuffer()
`;
            break;
          case "formdata":
          case "multipart/form-data":
            fnLiteral += `c.body = {}

							const form = await c.request.formData()
							for (const key of form.keys()) {
								if (c.body[key])
									continue

								const value = form.getAll(key)
								if (value.length === 1)
									c.body[key] = value[0]
								else c.body[key] = value
							}
`;
            break;
        }
      } else {
        fnLiteral += `
					switch (contentType) {
						case 'application/json':
							c.body = await c.request.json()
							break

						case 'text/plain':
							c.body = await c.request.text()
							break

						case 'application/x-www-form-urlencoded':
							c.body = parseQuery(await c.request.text())
							break

						case 'application/octet-stream':
							c.body = await c.request.arrayBuffer();
							break

						case 'multipart/form-data':
							c.body = {}

							const form = await c.request.formData()
							for (const key of form.keys()) {
								if (c.body[key])
									continue

								const value = form.getAll(key)
								if (value.length === 1)
									c.body[key] = value[0]
								else c.body[key] = value
							}

							break
					}`;
      }
      if (hooks.parse.length)
        fnLiteral += `}`;
      fnLiteral += "}\n";
    }
    fnLiteral += "\nisParsing = false\n";
  }
  parseReporter.resolve();
  if (hooks?.transform) {
    const reporter = report("transform", {
      total: hooks.transform.length
    });
    if (hooks.transform.length)
      fnLiteral += "\nlet transformed\n";
    for (let i2 = 0; i2 < hooks.transform.length; i2++) {
      const transform = hooks.transform[i2];
      const endUnit = reporter.resolveChild(transform.fn.name);
      fnLiteral += isAsync(transform) ? `transformed = await transform[${i2}](c)
` : `transformed = transform[${i2}](c)
`;
      if (transform.subType === "mapDerive")
        fnLiteral += `if(transformed?.[ELYSIA_RESPONSE])
					throw transformed
				else {
					transformed.request = c.request
					transformed.store = c.store
					transformed.qi = c.qi
					transformed.path = c.path
					transformed.url = c.url
					transformed.redirect = c.redirect
					transformed.set = c.set
					transformed.error = c.error

					c = transformed
			}`;
      else
        fnLiteral += `if(transformed?.[ELYSIA_RESPONSE])
					throw transformed
				else
					Object.assign(c, transformed)
`;
      endUnit();
    }
    reporter.resolve();
  }
  if (validator) {
    fnLiteral += "\n";
    if (validator.headers) {
      if (normalize4 && "Clean" in validator.headers && !hasAdditionalProperties(validator.headers))
        fnLiteral += "c.headers = validator.headers.Clean(c.headers);\n";
      if (hasProperty("default", validator.headers.schema))
        for (const [key2, value] of Object.entries(
          value_exports2.Default(
            // @ts-ignore
            validator.headers.schema,
            {}
          )
        )) {
          const parsed = typeof value === "object" ? JSON.stringify(value) : typeof value === "string" ? `'${value}'` : value;
          if (parsed !== void 0)
            fnLiteral += `c.headers['${key2}'] ??= ${parsed}
`;
        }
      if (isOptional(validator.headers))
        fnLiteral += `if(isNotEmpty(c.headers)) {`;
      fnLiteral += `if(validator.headers.Check(c.headers) === false) {
				${composeValidation("headers")}
			}`;
      if (hasTransform(validator.headers.schema))
        fnLiteral += `c.headers = validator.headers.Decode(c.headers)
`;
      if (isOptional(validator.headers))
        fnLiteral += "}";
    }
    if (validator.params) {
      if (hasProperty("default", validator.params.schema))
        for (const [key2, value] of Object.entries(
          value_exports2.Default(
            // @ts-ignore
            validator.params.schema,
            {}
          )
        )) {
          const parsed = typeof value === "object" ? JSON.stringify(value) : typeof value === "string" ? `'${value}'` : value;
          if (parsed !== void 0)
            fnLiteral += `c.params['${key2}'] ??= ${parsed}
`;
        }
      fnLiteral += `if(validator.params.Check(c.params) === false) {
				${composeValidation("params")}
			}`;
      if (hasTransform(validator.params.schema))
        fnLiteral += `
c.params = validator.params.Decode(c.params)
`;
    }
    if (validator.query) {
      if (normalize4 && "Clean" in validator.query && !hasAdditionalProperties(validator.query))
        fnLiteral += "c.query = validator.query.Clean(c.query);\n";
      if (hasProperty("default", validator.query.schema))
        for (const [key2, value] of Object.entries(
          value_exports2.Default(
            // @ts-ignore
            validator.query.schema,
            {}
          )
        )) {
          const parsed = typeof value === "object" ? JSON.stringify(value) : typeof value === "string" ? `'${value}'` : value;
          if (parsed !== void 0)
            fnLiteral += `if(c.query['${key2}'] === undefined) c.query['${key2}'] = ${parsed}
`;
        }
      if (isOptional(validator.query))
        fnLiteral += `if(isNotEmpty(c.query)) {`;
      fnLiteral += `if(validator.query.Check(c.query) === false) {
          		${composeValidation("query")}
			}`;
      if (hasTransform(validator.query.schema))
        fnLiteral += `
c.query = validator.query.Decode(Object.assign({}, c.query))
`;
      if (isOptional(validator.query))
        fnLiteral += `}`;
    }
    if (validator.body) {
      if (normalize4 && "Clean" in validator.body && !hasAdditionalProperties(validator.body))
        fnLiteral += "c.body = validator.body.Clean(c.body);\n";
      const doesHaveTransform = hasTransform(validator.body.schema);
      if (doesHaveTransform || isOptional(validator.body))
        fnLiteral += `
const isNotEmptyObject = c.body && (typeof c.body === "object" && isNotEmpty(c.body))
`;
      if (hasProperty("default", validator.body.schema)) {
        const value = value_exports2.Default(
          // @ts-expect-error private property
          validator.body.schema,
          // @ts-expect-error private property
          validator.body.schema.type === "object" ? {} : void 0
        );
        const parsed = typeof value === "object" ? JSON.stringify(value) : typeof value === "string" ? `'${value}'` : value;
        fnLiteral += `if(validator.body.Check(c.body) === false) {
					if (typeof c.body === 'object') {
						c.body = Object.assign(${parsed}, c.body)
					} else { c.body = ${parsed} }`;
        if (isOptional(validator.body))
          fnLiteral += `
					    if(isNotEmptyObject && validator.body.Check(c.body) === false) {
            				${composeValidation("body")}
             			}
                    }`;
        else
          fnLiteral += `
    				if(validator.body.Check(c.body) === false) {
        				${composeValidation("body")}
         			}
                }`;
      } else {
        if (isOptional(validator.body))
          fnLiteral += `if(isNotEmptyObject && validator.body.Check(c.body) === false) {
         			${composeValidation("body")}
          		}`;
        else
          fnLiteral += `if(validator.body.Check(c.body) === false) {
         			${composeValidation("body")}
          		}`;
      }
      if (doesHaveTransform)
        fnLiteral += `
if(isNotEmptyObject) c.body = validator.body.Decode(c.body)
`;
    }
    if (isNotEmpty(
      // @ts-ignore
      cookieValidator?.schema?.properties ?? // @ts-ignore
      cookieValidator?.schema?.schema ?? {}
    )) {
      fnLiteral += `const cookieValue = {}
    			for(const [key, value] of Object.entries(c.cookie))
    				cookieValue[key] = value.value
`;
      if (hasProperty("default", cookieValidator.schema))
        for (const [key2, value] of Object.entries(
          value_exports2.Default(
            // @ts-ignore
            cookieValidator.schema,
            {}
          )
        )) {
          fnLiteral += `cookieValue['${key2}'] = ${typeof value === "object" ? JSON.stringify(value) : value}
`;
        }
      if (isOptional(validator.cookie))
        fnLiteral += `if(isNotEmpty(c.cookie)) {`;
      fnLiteral += `if(validator.cookie.Check(cookieValue) === false) {
				${composeValidation("cookie", "cookieValue")}
			}`;
      if (hasTransform(validator.cookie.schema))
        fnLiteral += `
for(const [key, value] of Object.entries(validator.cookie.Decode(cookieValue)))
					c.cookie[key].value = value
`;
      if (isOptional(validator.cookie))
        fnLiteral += `}`;
    }
  }
  if (hooks?.beforeHandle) {
    const reporter = report("beforeHandle", {
      total: hooks.beforeHandle.length
    });
    let hasResolve = false;
    for (let i2 = 0; i2 < hooks.beforeHandle.length; i2++) {
      const beforeHandle = hooks.beforeHandle[i2];
      const endUnit = reporter.resolveChild(beforeHandle.fn.name);
      const returning = hasReturn(beforeHandle);
      const isResolver = beforeHandle.subType === "resolve" || beforeHandle.subType === "mapResolve";
      if (isResolver) {
        if (!hasResolve) {
          hasResolve = true;
          fnLiteral += "\nlet resolved\n";
        }
        fnLiteral += isAsync(beforeHandle) ? `resolved = await beforeHandle[${i2}](c);
` : `resolved = beforeHandle[${i2}](c);
`;
        if (beforeHandle.subType === "mapResolve")
          fnLiteral += `if(resolved[ELYSIA_RESPONSE])
						throw resolved
					else {
						resolved.request = c.request
						resolved.store = c.store
						resolved.qi = c.qi
						resolved.path = c.path
						resolved.url = c.url
						resolved.redirect = c.redirect
						resolved.set = c.set
						resolved.error = c.error

						c = resolved
					}`;
        else
          fnLiteral += `if(resolved[ELYSIA_RESPONSE])
						throw resolved
					else
						Object.assign(c, resolved)
`;
      } else if (!returning) {
        fnLiteral += isAsync(beforeHandle) ? `await beforeHandle[${i2}](c);
` : `beforeHandle[${i2}](c);
`;
        endUnit();
      } else {
        fnLiteral += isAsync(beforeHandle) ? `be = await beforeHandle[${i2}](c);
` : `be = beforeHandle[${i2}](c);
`;
        endUnit("be");
        fnLiteral += `if(be !== undefined) {
`;
        reporter.resolve();
        if (hooks.afterHandle?.length) {
          report("handle", {
            name: isHandleFn ? handler.name : void 0
          }).resolve();
          const reporter2 = report("afterHandle", {
            total: hooks.afterHandle.length
          });
          for (let i22 = 0; i22 < hooks.afterHandle.length; i22++) {
            const hook = hooks.afterHandle[i22];
            const returning2 = hasReturn(hook);
            const endUnit2 = reporter2.resolveChild(hook.fn.name);
            fnLiteral += `c.response = be
`;
            if (!returning2) {
              fnLiteral += isAsync(hook.fn) ? `await afterHandle[${i22}](c, be)
` : `afterHandle[${i22}](c, be)
`;
            } else {
              fnLiteral += isAsync(hook.fn) ? `af = await afterHandle[${i22}](c)
` : `af = afterHandle[${i22}](c)
`;
              fnLiteral += `if(af !== undefined) { c.response = be = af }
`;
            }
            endUnit2("af");
          }
          reporter2.resolve();
        }
        if (validator.response)
          fnLiteral += composeResponseValidation("be");
        const mapResponseReporter = report("mapResponse", {
          total: hooks.mapResponse.length
        });
        if (hooks.mapResponse.length) {
          fnLiteral += `
c.response = be
`;
          for (let i22 = 0; i22 < hooks.mapResponse.length; i22++) {
            const mapResponse2 = hooks.mapResponse[i22];
            const endUnit2 = mapResponseReporter.resolveChild(
              mapResponse2.fn.name
            );
            fnLiteral += `
if(mr === undefined) {
							mr = ${isAsyncName(mapResponse2) ? "await" : ""} onMapResponse[${i22}](c)
							if(mr !== undefined) be = c.response = mr
						}
`;
            endUnit2();
          }
        }
        mapResponseReporter.resolve();
        fnLiteral += encodeCookie;
        fnLiteral += `return mapEarlyResponse(${saveResponse} be, c.set ${requestMapper})}
`;
      }
    }
    reporter.resolve();
  }
  if (hooks?.afterHandle.length) {
    const handleReporter = report("handle", {
      name: isHandleFn ? handler.name : void 0
    });
    if (hooks.afterHandle.length)
      fnLiteral += isAsyncHandler ? `let r = c.response = await ${handle3};
` : `let r = c.response = ${handle3};
`;
    else
      fnLiteral += isAsyncHandler ? `let r = await ${handle3};
` : `let r = ${handle3};
`;
    handleReporter.resolve();
    const reporter = report("afterHandle", {
      total: hooks.afterHandle.length
    });
    for (let i2 = 0; i2 < hooks.afterHandle.length; i2++) {
      const hook = hooks.afterHandle[i2];
      const returning = hasReturn(hook);
      const endUnit = reporter.resolveChild(hook.fn.name);
      if (!returning) {
        fnLiteral += isAsync(hook.fn) ? `await afterHandle[${i2}](c)
` : `afterHandle[${i2}](c)
`;
        endUnit();
      } else {
        fnLiteral += isAsync(hook.fn) ? `af = await afterHandle[${i2}](c)
` : `af = afterHandle[${i2}](c)
`;
        endUnit("af");
        if (validator.response) {
          fnLiteral += `if(af !== undefined) {`;
          reporter.resolve();
          fnLiteral += composeResponseValidation("af");
          fnLiteral += `c.response = af }`;
        } else {
          fnLiteral += `if(af !== undefined) {`;
          reporter.resolve();
          fnLiteral += `c.response = af}
`;
        }
      }
    }
    reporter.resolve();
    fnLiteral += `r = c.response
`;
    if (validator.response)
      fnLiteral += composeResponseValidation();
    fnLiteral += encodeCookie;
    const mapResponseReporter = report("mapResponse", {
      total: hooks.mapResponse.length
    });
    if (hooks.mapResponse.length) {
      for (let i2 = 0; i2 < hooks.mapResponse.length; i2++) {
        const mapResponse2 = hooks.mapResponse[i2];
        const endUnit = mapResponseReporter.resolveChild(
          mapResponse2.fn.name
        );
        fnLiteral += `
mr = ${isAsyncName(mapResponse2) ? "await" : ""} onMapResponse[${i2}](c)
				if(mr !== undefined) r = c.response = mr
`;
        endUnit();
      }
    }
    mapResponseReporter.resolve();
    if (hasSet)
      fnLiteral += `return mapResponse(${saveResponse} r, c.set ${requestMapper})
`;
    else
      fnLiteral += `return mapCompactResponse(${saveResponse} r ${requestMapper})
`;
  } else {
    const handleReporter = report("handle", {
      name: isHandleFn ? handler.name : void 0
    });
    if (validator.response || hooks.mapResponse.length) {
      fnLiteral += isAsyncHandler ? `let r = await ${handle3};
` : `let r = ${handle3};
`;
      handleReporter.resolve();
      if (validator.response)
        fnLiteral += composeResponseValidation();
      report("afterHandle").resolve();
      const mapResponseReporter = report("mapResponse", {
        total: hooks.mapResponse.length
      });
      if (hooks.mapResponse.length) {
        fnLiteral += "\nc.response = r\n";
        for (let i2 = 0; i2 < hooks.mapResponse.length; i2++) {
          const mapResponse2 = hooks.mapResponse[i2];
          const endUnit = mapResponseReporter.resolveChild(
            mapResponse2.fn.name
          );
          fnLiteral += `
if(mr === undefined) {
						mr = ${isAsyncName(mapResponse2) ? "await" : ""} onMapResponse[${i2}](c)
    					if(mr !== undefined) r = c.response = mr
					}
`;
          endUnit();
        }
      }
      mapResponseReporter.resolve();
      fnLiteral += encodeCookie;
      if (handler instanceof Response) {
        fnLiteral += inference.set ? `if(
					isNotEmpty(c.set.headers) ||
					c.set.status !== 200 ||
					c.set.redirect ||
					c.set.cookie
				)
					return mapResponse(${saveResponse} ${handle3}.clone(), c.set ${requestMapper})
				else
					return ${handle3}.clone()` : `return ${handle3}.clone()`;
        fnLiteral += "\n";
      } else if (hasSet)
        fnLiteral += `return mapResponse(${saveResponse} r, c.set ${requestMapper})
`;
      else
        fnLiteral += `return mapCompactResponse(${saveResponse} r ${requestMapper})
`;
    } else if (hasCookie || hasTrace) {
      fnLiteral += isAsyncHandler ? `let r = await ${handle3};
` : `let r = ${handle3};
`;
      handleReporter.resolve();
      report("afterHandle").resolve();
      const mapResponseReporter = report("mapResponse", {
        total: hooks.mapResponse.length
      });
      if (hooks.mapResponse.length) {
        fnLiteral += "\nc.response = r\n";
        for (let i2 = 0; i2 < hooks.mapResponse.length; i2++) {
          const mapResponse2 = hooks.mapResponse[i2];
          const endUnit = mapResponseReporter.resolveChild(
            mapResponse2.fn.name
          );
          fnLiteral += `
if(mr === undefined) {
							mr = ${isAsyncName(mapResponse2) ? "await" : ""} onMapResponse[${i2}](c)
    						if(mr !== undefined) r = c.response = mr
						}
`;
          endUnit();
        }
      }
      mapResponseReporter.resolve();
      fnLiteral += encodeCookie;
      if (hasSet)
        fnLiteral += `return mapResponse(${saveResponse} r, c.set ${requestMapper})
`;
      else
        fnLiteral += `return mapCompactResponse(${saveResponse} r ${requestMapper})
`;
    } else {
      handleReporter.resolve();
      const handled = isAsyncHandler ? `await ${handle3}` : handle3;
      report("afterHandle").resolve();
      if (handler instanceof Response) {
        fnLiteral += inference.set ? `if(
					isNotEmpty(c.set.headers) ||
					c.set.status !== 200 ||
					c.set.redirect ||
					c.set.cookie
				)
					return mapResponse(${saveResponse} ${handle3}.clone(), c.set ${requestMapper})
				else
					return ${handle3}.clone()` : `return ${handle3}.clone()`;
        fnLiteral += "\n";
      } else if (hasSet)
        fnLiteral += `return mapResponse(${saveResponse} ${handled}, c.set ${requestMapper})
`;
      else
        fnLiteral += `return mapCompactResponse(${saveResponse} ${handled} ${requestMapper})
`;
    }
  }
  fnLiteral += `
} catch(error) {`;
  if (hasBody)
    fnLiteral += `
if(isParsing) error = new ParseError()
`;
  if (!maybeAsync)
    fnLiteral += `
return (async () => {
`;
  fnLiteral += `
const set = c.set
if (!set.status || set.status < 300) set.status = error?.status || 500
`;
  if (hasTrace)
    for (let i2 = 0; i2 < hooks.trace.length; i2++)
      fnLiteral += `report${i2}?.resolve(error);reportChild${i2}?.(error);
`;
  const errorReporter = report("error", {
    total: hooks.error.length
  });
  if (hooks.error.length) {
    fnLiteral += `
				c.error = error
				c.code = error.code ?? error[ERROR_CODE] ?? "UNKNOWN"
				let er
			`;
    for (let i2 = 0; i2 < hooks.error.length; i2++) {
      const endUnit = errorReporter.resolveChild(hooks.error[i2].fn.name);
      if (isAsync(hooks.error[i2]))
        fnLiteral += `
er = await handleErrors[${i2}](c)
`;
      else
        fnLiteral += `
er = handleErrors[${i2}](c)
if (er instanceof Promise) er = await er
`;
      endUnit();
      const mapResponseReporter = report("mapResponse", {
        total: hooks.mapResponse.length
      });
      if (hooks.mapResponse.length) {
        for (let i22 = 0; i22 < hooks.mapResponse.length; i22++) {
          const mapResponse2 = hooks.mapResponse[i22];
          const endUnit2 = mapResponseReporter.resolveChild(
            mapResponse2.fn.name
          );
          fnLiteral += `
c.response = er

							er = ${isAsyncName(mapResponse2) ? "await" : ""} onMapResponse[${i22}](c)
							if(er instanceof Promise) er = await er
`;
          endUnit2();
        }
      }
      mapResponseReporter.resolve();
      fnLiteral += `er = mapEarlyResponse(er, set ${requestMapper})
`;
      fnLiteral += `if (er) {`;
      if (hasTrace) {
        for (let i22 = 0; i22 < hooks.trace.length; i22++)
          fnLiteral += `
report${i22}.resolve()
`;
        errorReporter.resolve();
      }
      fnLiteral += `return er
}
`;
    }
  }
  errorReporter.resolve();
  fnLiteral += `return handleError(c, error, true)
`;
  if (!maybeAsync)
    fnLiteral += "})()";
  fnLiteral += "}";
  if (hasAfterResponse || hasTrace) {
    fnLiteral += ` finally { `;
    if (!maybeAsync)
      fnLiteral += ";(async () => {";
    const reporter = report("afterResponse", {
      total: hooks.afterResponse.length
    });
    if (hasAfterResponse) {
      for (let i2 = 0; i2 < hooks.afterResponse.length; i2++) {
        const endUnit = reporter.resolveChild(
          hooks.afterResponse[i2].fn.name
        );
        fnLiteral += `
await afterResponse[${i2}](c);
`;
        endUnit();
      }
    }
    reporter.resolve();
    if (!maybeAsync)
      fnLiteral += "})();";
    fnLiteral += `}`;
  }
  fnLiteral = `const {
		handler,
		handleError,
		hooks: {
			transform,
			resolve,
			beforeHandle,
			afterHandle,
			mapResponse: onMapResponse,
			parse,
			error: handleErrors,
			afterResponse,
			trace: _trace
		},
		validator,
		utils: {
			mapResponse,
			mapCompactResponse,
			mapEarlyResponse,
			parseQuery,
			isNotEmpty
		},
		error: {
			NotFoundError,
			ValidationError,
			InternalServerError,
			ParseError
		},
		schema,
		definitions,
		ERROR_CODE,
		parseCookie,
		signCookie,
		decodeURIComponent,
		ELYSIA_RESPONSE,
		ELYSIA_TRACE,
		ELYSIA_REQUEST_ID,
		getServer
	} = hooks

	const trace = _trace.map(x => typeof x === 'function' ? x : x.fn)

	return ${maybeAsync ? "async" : ""} function handle(c) {
		${hooks.beforeHandle.length ? "let be" : ""}
		${hooks.afterHandle.length ? "let af" : ""}
		${hooks.mapResponse.length ? "let mr" : ""}

		${allowMeta ? "c.schema = schema; c.defs = definitions" : ""}
		${fnLiteral}
	}`;
  try {
    return Function(
      "hooks",
      fnLiteral
    )({
      handler,
      hooks: lifeCycleToFn(hooks),
      validator,
      // @ts-expect-error
      handleError: app2.handleError,
      utils: {
        mapResponse,
        mapCompactResponse,
        mapEarlyResponse,
        parseQuery,
        isNotEmpty
      },
      error: {
        NotFoundError,
        ValidationError,
        InternalServerError,
        ParseError
      },
      schema: app2.router.history,
      // @ts-expect-error
      definitions: app2.definitions.type,
      ERROR_CODE,
      parseCookie,
      signCookie,
      decodeURIComponent: import_fast_decode_uri_component3.default,
      ELYSIA_RESPONSE,
      ELYSIA_TRACE,
      ELYSIA_REQUEST_ID,
      // @ts-expect-error private property
      getServer: () => app2.getServer()
    });
  } catch {
    const debugHooks = lifeCycleToFn(hooks);
    console.log("[Composer] failed to generate optimized handler");
    console.log(
      "Please report the following to SaltyAom privately as it may include sensitive information about your codebase:"
    );
    console.log("---");
    console.log({
      handler: typeof handler === "function" ? handler.toString() : handler,
      hooks: {
        ...debugHooks,
        // @ts-expect-error
        transform: debugHooks?.transform?.map?.((x2) => x2.toString()),
        // @ts-expect-error
        resolve: debugHooks?.resolve?.map?.((x2) => x2.toString()),
        // @ts-expect-error
        beforeHandle: debugHooks?.beforeHandle?.map?.(
          (x2) => x2.toString()
        ),
        // @ts-expect-error
        afterHandle: debugHooks?.afterHandle?.map?.(
          (x2) => x2.toString()
        ),
        // @ts-expect-error
        mapResponse: debugHooks?.mapResponse?.map?.(
          (x2) => x2.toString()
        ),
        // @ts-expect-error
        parse: debugHooks?.parse?.map?.((x2) => x2.toString()),
        // @ts-expect-error
        error: debugHooks?.error?.map?.((x2) => x2.toString()),
        // @ts-expect-error
        afterResponse: debugHooks?.afterResponse?.map?.(
          (x2) => x2.toString()
        ),
        // @ts-expect-error
        stop: debugHooks?.stop?.map?.((x2) => x2.toString())
      },
      validator,
      // @ts-expect-error
      definitions: app2.definitions.type
    });
    console.log("---");
    process.exit(1);
  }
};
var composeGeneralHandler = (app2) => {
  let decoratorsLiteral = "";
  let fnLiteral = "";
  const defaultHeaders = app2.setHeaders;
  for (const key2 of Object.keys(app2.singleton.decorator))
    decoratorsLiteral += `,${key2}: app.singleton.decorator.${key2}`;
  const router = app2.router;
  const hasTrace = app2.event.trace.length > 0;
  let findDynamicRoute = `
	const route = router.find(request.method, path) ${router.http.root.ALL ? '?? router.find("ALL", path)' : ""}

	if (route === null)
		return ${app2.event.error.length ? `app.handleError(ctx, notFound)` : app2.event.request.length ? `new Response(error404Message, {
					status: ctx.set.status === 200 ? 404 : ctx.set.status,
					headers: ctx.set.headers
				})` : `error404.clone()`}

	ctx.params = route.params
`;
  findDynamicRoute += `if(route.store.handler) return route.store.handler(ctx)
	return (route.store.handler = route.store.compile())(ctx)
`;
  let switchMap = ``;
  for (const [path2, { code: code4, all: all4 }] of Object.entries(router.static.http.map))
    switchMap += `case '${path2}':
switch(request.method) {
${code4}
${all4 ?? `default: break map`}}

`;
  const maybeAsync = app2.event.request.some(isAsync);
  fnLiteral += `const {
		app,
		mapEarlyResponse,
		NotFoundError,
		randomId,
		handleError,
		error,
		redirect,
		ELYSIA_TRACE,
		ELYSIA_REQUEST_ID,
		getServer
	} = data

	const store = app.singleton.store
	const staticRouter = app.router.static.http
	const st = staticRouter.handlers
	const wsRouter = app.router.ws
	const router = app.router.http
	const trace = app.event.trace.map(x => typeof x === 'function' ? x : x.fn)

	const notFound = new NotFoundError()
	const hoc = app.extender.higherOrderFunctions.map(x => x.fn)

	${app2.event.request.length ? `const onRequest = app.event.request.map(x => x.fn)` : ""}
	${app2.event.error.length ? "" : `
const error404Message = notFound.message.toString()
	const error404 = new Response(error404Message, { status: 404 });
`}

	${app2.event.trace.length ? `const ${app2.event.trace.map((_, i2) => `tr${i2} = app.event.trace[${i2}].fn`).join(",")}` : ""}

	${maybeAsync ? "async" : ""} function map(request) {
`;
  if (app2.event.request.length)
    fnLiteral += `let re`;
  fnLiteral += `
const url = request.url
		const s = url.indexOf('/', 11)
		const qi = url.indexOf('?', s + 1)
		let path
		if(qi === -1)
			path = url.substring(s)
		else
			path = url.substring(s, qi)
`;
  fnLiteral += `${hasTrace ? "const id = randomId()" : ""}
		const ctx = {
			request,
			store,
			qi,
			path,
			url,
			redirect,
			set: {
				headers: ${Object.keys(defaultHeaders ?? {}).length ? "Object.assign({}, app.setHeaders)" : "{}"},
				status: 200
			},
			error
			${// @ts-expect-error private property
  app2.inference.server ? `, get server() {
							return getServer()
						}` : ""}
			${hasTrace ? ",[ELYSIA_REQUEST_ID]: id" : ""}
			${decoratorsLiteral}
		}
`;
  if (app2.event.trace.length)
    fnLiteral += `
ctx[ELYSIA_TRACE] = [${app2.event.trace.map((_, i2) => `tr${i2}(ctx)`).join(",")}]
`;
  const report = createReport({
    context: "ctx",
    trace: app2.event.trace,
    addFn: (word) => {
      fnLiteral += word;
    }
  });
  const reporter = report("request", {
    attribute: "ctx",
    total: app2.event.request.length
  });
  if (app2.event.request.length) {
    fnLiteral += `
 try {
`;
    for (let i2 = 0; i2 < app2.event.request.length; i2++) {
      const hook = app2.event.request[i2];
      const withReturn = hasReturn(hook);
      const maybeAsync2 = isAsync(hook);
      const endUnit = reporter.resolveChild(app2.event.request[i2].fn.name);
      if (withReturn) {
        fnLiteral += `re = mapEarlyResponse(
					${maybeAsync2 ? "await" : ""} onRequest[${i2}](ctx),
					ctx.set,
					request
				)
`;
        endUnit("re");
        fnLiteral += `if(re !== undefined) return re
`;
      } else {
        fnLiteral += `${maybeAsync2 ? "await" : ""} onRequest[${i2}](ctx)
`;
        endUnit();
      }
    }
    fnLiteral += `} catch (error) {
			return app.handleError(ctx, error)
		}`;
  }
  reporter.resolve();
  const wsPaths = app2.router.static.ws;
  const wsRouter = app2.router.ws;
  if (Object.keys(wsPaths).length || wsRouter.history.length) {
    fnLiteral += `
			if(request.method === 'GET') {
				switch(path) {`;
    for (const [path2, index3] of Object.entries(wsPaths)) {
      fnLiteral += `
					case '${path2}':
						if(request.headers.get('upgrade') === 'websocket')
							return st[${index3}](ctx)

						break`;
    }
    fnLiteral += `
				default:
					if(request.headers.get('upgrade') === 'websocket') {
						const route = wsRouter.find('ws', path)

						if(route) {
							ctx.params = route.params

							if(route.store.handler)
							    return route.store.handler(ctx)

							return (route.store.handler = route.store.compile())(ctx)
						}
					}

					break
			}
		}
`;
  }
  fnLiteral += `
		map: switch(path) {
			${switchMap}

			default:
				break
		}

		${findDynamicRoute}
	}
`;
  if (app2.extender.higherOrderFunctions.length) {
    let handler = "map";
    for (let i2 = 0; i2 < app2.extender.higherOrderFunctions.length; i2++)
      handler = `hoc[${i2}](${handler}, request)`;
    fnLiteral += `return function hocMap(request) { return ${handler}(request) }`;
  } else
    fnLiteral += `return map`;
  const handleError = composeErrorHandler(app2);
  app2.handleError = handleError;
  return Function(
    "data",
    fnLiteral
  )({
    app: app2,
    mapEarlyResponse,
    NotFoundError,
    randomId,
    handleError,
    error,
    redirect,
    ELYSIA_TRACE,
    ELYSIA_REQUEST_ID,
    // @ts-expect-error private property
    getServer: () => app2.getServer()
  });
};
var composeErrorHandler = (app2) => {
  const hooks = app2.event;
  let fnLiteral = "";
  fnLiteral += `const {
		app: { event: { error: onErrorContainer, afterResponse: resContainer, mapResponse: _onMapResponse, trace: _trace } },
		mapResponse,
		ERROR_CODE,
		ELYSIA_RESPONSE,
		ELYSIA_TRACE,
		ELYSIA_REQUEST_ID
	} = inject

	const trace = _trace.map(x => typeof x === 'function' ? x : x.fn)
	const onMapResponse = []

	for(let i = 0; i < _onMapResponse.length; i++)
		onMapResponse.push(_onMapResponse[i].fn ?? _onMapResponse[i])

	delete _onMapResponse

	const onError = onErrorContainer.map(x => x.fn)
	const res = resContainer.map(x => x.fn)

	return ${app2.event.error.find(isAsync) || app2.event.mapResponse.find(isAsync) ? "async" : ""} function(context, error, skipGlobal) {`;
  const hasTrace = app2.event.trace.length > 0;
  if (hasTrace)
    fnLiteral += "\nconst id = context[ELYSIA_REQUEST_ID]\n";
  const report = createReport({
    context: "context",
    trace: hooks.trace,
    addFn: (word) => {
      fnLiteral += word;
    }
  });
  fnLiteral += `
		const set = context.set
		let r

		context.code = error.code
		context.error = error

		if(typeof error === "object" && error && ELYSIA_RESPONSE in error) {
			error.status = error[ELYSIA_RESPONSE]
			error.message = error.response
		}
`;
  const saveResponse = hasTrace || hooks.afterResponse.length > 0 || hooks.afterResponse.length > 0 ? "context.response = " : "";
  for (let i2 = 0; i2 < app2.event.error.length; i2++) {
    const handler = app2.event.error[i2];
    const response = `${isAsync(handler) ? "await " : ""}onError[${i2}](context)`;
    fnLiteral += "\nif(skipGlobal !== true) {\n";
    if (hasReturn(handler)) {
      fnLiteral += `r = ${response}; if(r !== undefined) {
				if(r instanceof Response) return r

				if(r[ELYSIA_RESPONSE]) {
					error.status = error[ELYSIA_RESPONSE]
					error.message = error.response
				}

				if(set.status === 200) set.status = error.status
`;
      const mapResponseReporter2 = report("mapResponse", {
        total: hooks.mapResponse.length,
        name: "context"
      });
      if (hooks.mapResponse.length) {
        for (let i22 = 0; i22 < hooks.mapResponse.length; i22++) {
          const mapResponse2 = hooks.mapResponse[i22];
          const endUnit = mapResponseReporter2.resolveChild(
            mapResponse2.fn.name
          );
          fnLiteral += `
context.response = r
						r = ${isAsyncName(mapResponse2) ? "await" : ""} onMapResponse[${i22}](context)
`;
          endUnit();
        }
      }
      mapResponseReporter2.resolve();
      fnLiteral += `return mapResponse(${saveResponse} r, set, context.request)}
`;
    } else
      fnLiteral += response + "\n";
    fnLiteral += "\n}\n";
  }
  fnLiteral += `if(error.constructor.name === "ValidationError" || error.constructor.name === "TransformDecodeError") {
		set.status = error.status ?? 422
		return new Response(
			error.message,
			{
				headers: Object.assign(
					{ 'content-type': 'application/json'},
					set.headers
				),
				status: set.status
			}
		)
	} else {
		if(error.code && typeof error.status === "number")
			return new Response(
				error.message,
				{ headers: set.headers, status: error.status }
			)
`;
  const mapResponseReporter = report("mapResponse", {
    total: hooks.mapResponse.length,
    name: "context"
  });
  if (hooks.mapResponse.length) {
    for (let i2 = 0; i2 < hooks.mapResponse.length; i2++) {
      const mapResponse2 = hooks.mapResponse[i2];
      const endUnit = mapResponseReporter.resolveChild(
        mapResponse2.fn.name
      );
      fnLiteral += `
context.response = error
			error = ${isAsyncName(mapResponse2) ? "await" : ""} onMapResponse[${i2}](context)
`;
      endUnit();
    }
  }
  mapResponseReporter.resolve();
  fnLiteral += `
return mapResponse(${saveResponse} error, set, context.request)
}
}`;
  return Function(
    "inject",
    fnLiteral
  )({
    app: app2,
    mapResponse,
    ERROR_CODE,
    ELYSIA_RESPONSE,
    ELYSIA_TRACE,
    ELYSIA_REQUEST_ID
  });
};
var createDynamicHandler = (app2) => async (request) => {
  const url = request.url, s2 = url.indexOf("/", 11), qi = url.indexOf("?", s2 + 1), path2 = qi === -1 ? url.substring(s2) : url.substring(s2, qi);
  const set = {
    cookie: {},
    status: 200,
    headers: {}
  };
  const context = Object.assign(
    {},
    // @ts-expect-error
    app2.singleton.decorator,
    {
      set,
      // @ts-expect-error
      store: app2.singleton.store,
      request,
      path: path2,
      qi,
      redirect
    }
  );
  try {
    for (let i2 = 0; i2 < app2.event.request.length; i2++) {
      const onRequest = app2.event.request[i2].fn;
      let response2 = onRequest(context);
      if (response2 instanceof Promise)
        response2 = await response2;
      response2 = mapEarlyResponse(response2, set);
      if (response2)
        return context.response = response2;
    }
    const handler = app2.router.dynamic.find(request.method, path2) ?? app2.router.dynamic.find("ALL", path2);
    if (!handler)
      throw new NotFoundError();
    const { handle: handle3, hooks, validator, content: content3 } = handler.store;
    let body3;
    if (request.method !== "GET" && request.method !== "HEAD") {
      if (content3) {
        switch (content3) {
          case "application/json":
            body3 = await request.json();
            break;
          case "text/plain":
            body3 = await request.text();
            break;
          case "application/x-www-form-urlencoded":
            body3 = parseQuery(await request.text());
            break;
          case "application/octet-stream":
            body3 = await request.arrayBuffer();
            break;
          case "multipart/form-data":
            body3 = {};
            const form2 = await request.formData();
            for (const key2 of form2.keys()) {
              if (body3[key2])
                continue;
              const value = form2.getAll(key2);
              if (value.length === 1)
                body3[key2] = value[0];
              else
                body3[key2] = value;
            }
            break;
        }
      } else {
        let contentType = request.headers.get("content-type");
        if (contentType) {
          const index3 = contentType.indexOf(";");
          if (index3 !== -1)
            contentType = contentType.slice(0, index3);
          context.contentType = contentType;
          for (let i2 = 0; i2 < hooks.parse.length; i2++) {
            const hook = hooks.parse[i2].fn;
            let temp = hook(context, contentType);
            if (temp instanceof Promise)
              temp = await temp;
            if (temp) {
              body3 = temp;
              break;
            }
          }
          delete context.contentType;
          if (body3 === void 0) {
            switch (contentType) {
              case "application/json":
                body3 = await request.json();
                break;
              case "text/plain":
                body3 = await request.text();
                break;
              case "application/x-www-form-urlencoded":
                body3 = parseQuery(await request.text());
                break;
              case "application/octet-stream":
                body3 = await request.arrayBuffer();
                break;
              case "multipart/form-data":
                body3 = {};
                const form2 = await request.formData();
                for (const key2 of form2.keys()) {
                  if (body3[key2])
                    continue;
                  const value = form2.getAll(key2);
                  if (value.length === 1)
                    body3[key2] = value[0];
                  else
                    body3[key2] = value;
                }
                break;
            }
          }
        }
      }
    }
    context.body = body3;
    context.params = handler?.params || void 0;
    context.query = qi === -1 ? {} : parseQuery(url.substring(qi + 1));
    context.headers = {};
    for (const [key2, value] of request.headers.entries())
      context.headers[key2] = value;
    const cookieMeta = Object.assign(
      {},
      app2.config?.cookie,
      // @ts-expect-error
      validator?.cookie?.config
    );
    const cookieHeaderValue = request.headers.get("cookie");
    context.cookie = await parseCookie(
      context.set,
      cookieHeaderValue,
      cookieMeta ? {
        secrets: cookieMeta.secrets !== void 0 ? typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets.join(",") : void 0,
        sign: cookieMeta.sign === true ? true : cookieMeta.sign !== void 0 ? typeof cookieMeta.sign === "string" ? cookieMeta.sign : cookieMeta.sign.join(",") : void 0
      } : void 0
    );
    for (let i2 = 0; i2 < hooks.transform.length; i2++) {
      const hook = hooks.transform[i2];
      const operation = hook.fn(context);
      if (hook.subType === "derive") {
        if (operation instanceof Promise)
          Object.assign(context, await operation);
        else
          Object.assign(context, operation);
      } else if (operation instanceof Promise)
        await operation;
    }
    if (validator) {
      if (validator.createHeaders?.()) {
        const _header = {};
        for (const key2 in request.headers)
          _header[key2] = request.headers.get(key2);
        if (validator.headers.Check(_header) === false)
          throw new ValidationError(
            "header",
            validator.headers,
            _header
          );
      }
      if (validator.createParams?.()?.Check(context.params) === false)
        throw new ValidationError(
          "params",
          validator.params,
          context.params
        );
      if (validator.createQuery?.()?.Check(context.query) === false)
        throw new ValidationError(
          "query",
          validator.query,
          context.query
        );
      if (validator.createCookie?.()) {
        const cookieValue = {};
        for (const [key2, value] of Object.entries(context.cookie))
          cookieValue[key2] = value.value;
        if (validator.cookie.Check(cookieValue) === false)
          throw new ValidationError(
            "cookie",
            validator.cookie,
            cookieValue
          );
      }
      if (validator.createBody?.()?.Check(body3) === false)
        throw new ValidationError("body", validator.body, body3);
    }
    for (let i2 = 0; i2 < hooks.beforeHandle.length; i2++) {
      let response2 = hooks.beforeHandle[i2].fn(context);
      if (response2 instanceof Promise)
        response2 = await response2;
      if (response2 !== void 0) {
        ;
        context.response = response2;
        for (let i22 = 0; i22 < hooks.afterHandle.length; i22++) {
          let newResponse = hooks.afterHandle[i22].fn(
            context
          );
          if (newResponse instanceof Promise)
            newResponse = await newResponse;
          if (newResponse)
            response2 = newResponse;
        }
        const result = mapEarlyResponse(response2, context.set);
        if (result)
          return context.response = result;
      }
    }
    let response = handle3(context);
    if (response instanceof Promise)
      response = await response;
    if (!hooks.afterHandle.length) {
      const status = response?.[ELYSIA_RESPONSE] ?? (set.status ? typeof set.status === "string" ? StatusMap[set.status] : set.status : 200);
      const responseValidator = validator?.createResponse?.()?.[status];
      if (responseValidator?.Check(response) === false)
        throw new ValidationError(
          "response",
          responseValidator,
          response
        );
    } else {
      ;
      context.response = response;
      for (let i2 = 0; i2 < hooks.afterHandle.length; i2++) {
        let newResponse = hooks.afterHandle[i2].fn(
          context
        );
        if (newResponse instanceof Promise)
          newResponse = await newResponse;
        const result = mapEarlyResponse(newResponse, context.set);
        if (result !== void 0) {
          const responseValidator = validator?.response?.[result.status];
          if (responseValidator?.Check(result) === false)
            throw new ValidationError(
              "response",
              responseValidator,
              result
            );
          return context.response = result;
        }
      }
    }
    if (context.set.cookie && cookieMeta?.sign) {
      const secret = !cookieMeta.secrets ? void 0 : typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets[0];
      if (cookieMeta.sign === true)
        for (const [key2, cookie] of Object.entries(
          context.set.cookie
        ))
          context.set.cookie[key2].value = await signCookie(
            cookie.value,
            "${secret}"
          );
      else {
        const properties = validator?.cookie?.schema?.properties;
        for (const name of cookieMeta.sign) {
          if (!(name in properties))
            continue;
          if (context.set.cookie[name]?.value) {
            context.set.cookie[name].value = await signCookie(
              context.set.cookie[name].value,
              secret
            );
          }
        }
      }
    }
    return context.response = mapResponse(response, context.set);
  } catch (error22) {
    if (error22.status)
      set.status = error22.status;
    return app2.handleError(context, error22);
  } finally {
    for (const afterResponse of app2.event.afterResponse)
      await afterResponse.fn(context);
  }
};
var createDynamicErrorHandler = (app2) => async (context, error22) => {
  const errorContext = Object.assign(context, { error: error22, code: error22.code });
  errorContext.set = context.set;
  for (let i2 = 0; i2 < app2.event.error.length; i2++) {
    const hook = app2.event.error[i2];
    let response = hook.fn(errorContext);
    if (response instanceof Promise)
      response = await response;
    if (response !== void 0 && response !== null)
      return context.response = mapResponse(response, context.set);
  }
  return new Response(
    typeof error22.cause === "string" ? error22.cause : error22.message,
    {
      headers: context.set.headers,
      status: error22.status ?? 500
    }
  );
};
var Elysia = class _Elysia {
  constructor(config3) {
    this.server = null;
    this.dependencies = {};
    this._routes = {};
    this._types = {
      Prefix: "",
      Scoped: false,
      Singleton: {},
      Definitions: {},
      Metadata: {}
    };
    this._ephemeral = {};
    this._volatile = {};
    this.version = version3;
    this.singleton = {
      decorator: {},
      store: {},
      derive: {},
      resolve: {}
    };
    this.definitions = {
      type: {},
      error: {}
    };
    this.extender = {
      macros: [],
      higherOrderFunctions: []
    };
    this.validator = {
      global: null,
      scoped: null,
      local: null,
      getCandidate() {
        return mergeSchemaValidator(
          mergeSchemaValidator(this.global, this.scoped),
          this.local
        );
      }
    };
    this.event = {
      start: [],
      request: [],
      parse: [],
      transform: [],
      beforeHandle: [],
      afterHandle: [],
      mapResponse: [],
      afterResponse: [],
      trace: [],
      error: [],
      stop: []
    };
    this.telemetry = {
      stack: void 0
    };
    this.router = {
      http: new Memoirist(),
      ws: new Memoirist(),
      // Use in non-AOT mode
      dynamic: new Memoirist(),
      static: {
        http: {
          handlers: [],
          map: {},
          all: ""
        },
        // Static WS Router is consists of pathname and websocket handler index to compose
        ws: {}
      },
      history: []
    };
    this.routeTree = /* @__PURE__ */ new Map();
    this.inference = {
      body: false,
      cookie: false,
      headers: false,
      query: false,
      set: false,
      server: false
    };
    this.handle = async (request) => this.fetch(request);
    this.fetch = (request) => {
      return (this.fetch = this.config.aot ? composeGeneralHandler(this) : createDynamicHandler(this))(request);
    };
    this.handleError = async (context, error22) => (this.handleError = this.config.aot ? composeErrorHandler(this) : createDynamicErrorHandler(this))(context, error22);
    this.outerErrorHandler = (error22) => new Response(error22.message || error22.name || "Error", {
      // @ts-ignore
      status: error22?.status ?? 500
    });
    this.listen = (options, callback) => {
      if (typeof Bun === "undefined")
        throw new Error(
          ".listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch"
        );
      this.compile();
      if (typeof options === "string") {
        if (!isNumericString(options))
          throw new Error("Port must be a numeric value");
        options = parseInt(options);
      }
      const fetch2 = this.fetch;
      const serve = typeof options === "object" ? {
        development: !isProduction,
        reusePort: true,
        ...this.config.serve || {},
        ...options || {},
        websocket: {
          ...this.config.websocket || {},
          ...websocket || {}
        },
        fetch: fetch2,
        error: this.outerErrorHandler
      } : {
        development: !isProduction,
        reusePort: true,
        ...this.config.serve || {},
        websocket: {
          ...this.config.websocket || {},
          ...websocket || {}
        },
        port: options,
        fetch: fetch2,
        error: this.outerErrorHandler
      };
      this.server = Bun?.serve(serve);
      for (let i2 = 0; i2 < this.event.start.length; i2++)
        this.event.start[i2].fn(this);
      if (callback)
        callback(this.server);
      process.on("beforeExit", () => {
        if (this.server) {
          this.server.stop();
          this.server = null;
          for (let i2 = 0; i2 < this.event.stop.length; i2++)
            this.event.stop[i2].fn(this);
        }
      });
      this.promisedModules.then(() => {
        Bun?.gc(false);
      });
      return this;
    };
    this.stop = async () => {
      if (!this.server)
        throw new Error(
          "Elysia isn't running. Call `app.listen` to start the server."
        );
      if (this.server) {
        this.server.stop();
        this.server = null;
        if (this.event.stop.length)
          for (let i2 = 0; i2 < this.event.stop.length; i2++)
            this.event.stop[i2].fn(this);
      }
    };
    if (config3?.tags) {
      if (!config3.detail)
        config3.detail = {
          tags: config3.tags
        };
      else
        config3.detail.tags = config3.tags;
    }
    this.config = {};
    this.applyConfig(config3 ?? {});
    if (config3?.analytic && (config3?.name || config3?.seed !== void 0))
      this.telemetry.stack = new Error().stack;
  }
  static {
    this.version = version3;
  }
  get store() {
    return this.singleton.store;
  }
  get decorator() {
    return this.singleton.decorator;
  }
  get _scoped() {
    return this.config.scoped;
  }
  get routes() {
    return this.router.history;
  }
  getGlobalRoutes() {
    return this.router.history;
  }
  getServer() {
    return this.server;
  }
  get promisedModules() {
    if (!this._promisedModules)
      this._promisedModules = new PromiseGroup();
    return this._promisedModules;
  }
  env(model, env22 = Bun?.env ?? process.env) {
    const validator = getSchemaValidator(model, {
      dynamic: true,
      additionalProperties: true,
      coerce: true
    });
    if (validator.Check(env22) === false) {
      const error22 = new ValidationError("env", model, env22);
      throw new Error(error22.all.map((x2) => x2.summary).join("\n"));
    }
    return this;
  }
  /**
   * @private DO_NOT_USE_OR_YOU_WILL_BE_FIRE
   *
   * ! Do not use unless you now exactly what you are doing
   * ? Add Higher order function to Elysia.fetch
   */
  wrap(fn) {
    this.extender.higherOrderFunctions.push({
      checksum: checksum(
        JSON.stringify({
          name: this.config.name,
          seed: this.config.seed,
          content: fn.toString()
        })
      ),
      fn
    });
    return this;
  }
  applyMacro(localHook) {
    if (this.extender.macros.length) {
      const manage = createMacroManager({
        globalHook: this.event,
        localHook
      });
      const manager = {
        events: {
          global: this.event,
          local: localHook
        },
        onParse: manage("parse"),
        onTransform: manage("transform"),
        onBeforeHandle: manage("beforeHandle"),
        onAfterHandle: manage("afterHandle"),
        mapResponse: manage("mapResponse"),
        onAfterResponse: manage("afterResponse"),
        onError: manage("error")
      };
      for (const macro of this.extender.macros)
        traceBackMacro(macro.fn(manager), localHook);
    }
  }
  applyConfig(config3) {
    this.config = {
      prefix: "",
      aot: true,
      strictPath: false,
      global: false,
      analytic: false,
      normalize: true,
      ...config3,
      cookie: {
        path: "/",
        ...config3?.cookie
      },
      experimental: config3?.experimental ?? {},
      seed: config3?.seed === void 0 ? "" : config3?.seed
    };
    return this;
  }
  get models() {
    const models = {};
    for (const [name, schema] of Object.entries(this.definitions.type))
      models[name] = getSchemaValidator(
        schema
      );
    return models;
  }
  add(method, path2, handle3, localHook, { allowMeta = false, skipPrefix = false } = {
    allowMeta: false,
    skipPrefix: false
  }) {
    localHook = localHookToLifeCycleStore(localHook);
    if (path2 !== "" && path2.charCodeAt(0) !== 47)
      path2 = "/" + path2;
    if (this.config.prefix && !skipPrefix && !this.config.scoped)
      path2 = this.config.prefix + path2;
    if (localHook?.type)
      switch (localHook.type) {
        case "text":
          localHook.type = "text/plain";
          break;
        case "json":
          localHook.type = "application/json";
          break;
        case "formdata":
          localHook.type = "multipart/form-data";
          break;
        case "urlencoded":
          localHook.type = "application/x-www-form-urlencoded";
          break;
        case "arrayBuffer":
          localHook.type = "application/octet-stream";
          break;
        default:
          break;
      }
    const models = this.definitions.type;
    const dynamic = !this.config.aot;
    const instanceValidator = { ...this.validator.getCandidate() };
    const cloned = {
      body: localHook?.body ?? instanceValidator?.body,
      headers: localHook?.headers ?? instanceValidator?.headers,
      params: localHook?.params ?? instanceValidator?.params,
      query: localHook?.query ?? instanceValidator?.query,
      cookie: localHook?.cookie ?? instanceValidator?.cookie,
      response: localHook?.response ?? instanceValidator?.response
    };
    const cookieValidator = () => cloned.cookie ? getCookieValidator({
      validator: cloned.cookie,
      defaultConfig: this.config.cookie,
      config: cloned.cookie?.config ?? {},
      dynamic,
      models
    }) : void 0;
    const normalize4 = this.config.normalize;
    const validator = this.config.precompile === true || typeof this.config.precompile === "object" && this.config.precompile.schema === true ? {
      body: getSchemaValidator(cloned.body, {
        dynamic,
        models,
        normalize: normalize4
      }),
      headers: getSchemaValidator(cloned.headers, {
        dynamic,
        models,
        additionalProperties: !this.config.normalize,
        coerce: true,
        additionalCoerce: stringToStructureCoercions()
      }),
      params: getSchemaValidator(cloned.params, {
        dynamic,
        models,
        coerce: true,
        additionalCoerce: stringToStructureCoercions()
      }),
      query: getSchemaValidator(cloned.query, {
        dynamic,
        models,
        normalize: normalize4,
        coerce: true,
        additionalCoerce: stringToStructureCoercions()
      }),
      cookie: cookieValidator(),
      response: getResponseSchemaValidator(cloned.response, {
        dynamic,
        models,
        normalize: normalize4
      })
    } : {
      createBody() {
        if (this.body)
          return this.body;
        return this.body = getSchemaValidator(
          cloned.body,
          {
            dynamic,
            models,
            normalize: normalize4
          }
        );
      },
      createHeaders() {
        if (this.headers)
          return this.headers;
        return this.headers = getSchemaValidator(
          cloned.headers,
          {
            dynamic,
            models,
            additionalProperties: !normalize4,
            coerce: true,
            additionalCoerce: stringToStructureCoercions()
          }
        );
      },
      createParams() {
        if (this.params)
          return this.params;
        return this.params = getSchemaValidator(
          cloned.params,
          {
            dynamic,
            models,
            coerce: true,
            additionalCoerce: stringToStructureCoercions()
          }
        );
      },
      createQuery() {
        if (this.query)
          return this.query;
        return this.query = getSchemaValidator(
          cloned.query,
          {
            dynamic,
            models,
            coerce: true,
            additionalCoerce: stringToStructureCoercions()
          }
        );
      },
      createCookie() {
        if (this.cookie)
          return this.cookie;
        return this.cookie = cookieValidator();
      },
      createResponse() {
        if (this.response)
          return this.response;
        return this.response = getResponseSchemaValidator(
          cloned.response,
          {
            dynamic,
            models,
            normalize: normalize4
          }
        );
      }
    };
    const loosePath = path2.endsWith("/") ? path2.slice(0, path2.length - 1) : path2 + "/";
    localHook = mergeHook(localHook, instanceValidator);
    if (localHook.tags) {
      if (!localHook.detail)
        localHook.detail = {
          tags: localHook.tags
        };
      else
        localHook.detail.tags = localHook.tags;
    }
    if (isNotEmpty(this.config.detail))
      localHook.detail = mergeDeep(
        Object.assign({}, this.config.detail),
        localHook.detail
      );
    this.applyMacro(localHook);
    const hooks = mergeHook(this.event, localHook);
    if (this.config.aot === false) {
      this.router.dynamic.add(method, path2, {
        validator,
        hooks,
        content: localHook?.type,
        handle: handle3
      });
      if (this.config.strictPath === false) {
        this.router.dynamic.add(method, loosePath, {
          validator,
          hooks,
          content: localHook?.type,
          handle: handle3
        });
      }
      this.router.history.push({
        method,
        path: path2,
        composed: null,
        handler: handle3,
        hooks
      });
      return;
    }
    const shouldPrecompile = this.config.precompile === true || typeof this.config.precompile === "object" && this.config.precompile.compose === true;
    const inference = cloneInference(this.inference);
    const compile = () => composeHandler({
      app: this,
      path: path2,
      method,
      localHook: mergeHook(localHook),
      hooks,
      validator,
      handler: handle3,
      allowMeta,
      inference
    });
    const mainHandler = shouldPrecompile ? compile() : (context) => {
      return compile()(context);
    };
    const routeIndex = this.router.history.length;
    if (this.routeTree.has(method + path2))
      for (let i2 = 0; i2 < this.router.history.length; i2++) {
        const route = this.router.history[i2];
        if (route.path === path2 && route.method === method) {
          const removed = this.router.history.splice(i2, 1)[0];
          if (removed && this.routeTree.has(removed?.method + removed?.path))
            this.routeTree.delete(removed.method + removed.path);
        }
      }
    else
      this.routeTree.set(method + path2, routeIndex);
    this.router.history.push({
      method,
      path: path2,
      composed: mainHandler,
      handler: handle3,
      hooks
    });
    const staticRouter = this.router.static.http;
    const handler = {
      handler: shouldPrecompile ? mainHandler : void 0,
      compile
    };
    if (method === "$INTERNALWS") {
      const loose = this.config.strictPath ? void 0 : path2.endsWith("/") ? path2.slice(0, path2.length - 1) : path2 + "/";
      if (path2.indexOf(":") === -1 && path2.indexOf("*") === -1) {
        const index3 = staticRouter.handlers.length;
        staticRouter.handlers.push(
          (ctx) => (staticRouter.handlers[index3] = compile())(ctx)
        );
        this.router.static.ws[path2] = index3;
        if (loose)
          this.router.static.ws[loose] = index3;
      } else {
        this.router.ws.add("ws", path2, handler);
        if (loose)
          this.router.ws.add("ws", loose, handler);
      }
      return;
    }
    if (path2.indexOf(":") === -1 && path2.indexOf("*") === -1) {
      const index3 = staticRouter.handlers.length;
      staticRouter.handlers.push(
        (ctx) => (staticRouter.handlers[index3] = compile())(
          ctx
        )
      );
      if (!staticRouter.map[path2])
        staticRouter.map[path2] = {
          code: ""
        };
      if (method === "ALL")
        staticRouter.map[path2].all = `default: return st[${index3}](ctx)
`;
      else
        staticRouter.map[path2].code = `case '${method}': return st[${index3}](ctx)
${staticRouter.map[path2].code}`;
      if (!this.config.strictPath) {
        if (!staticRouter.map[loosePath])
          staticRouter.map[loosePath] = {
            code: ""
          };
        if (method === "ALL")
          staticRouter.map[loosePath].all = `default: return st[${index3}](ctx)
`;
        else
          staticRouter.map[loosePath].code = `case '${method}': return st[${index3}](ctx)
${staticRouter.map[loosePath].code}`;
      }
    } else {
      this.router.http.add(method, path2, handler);
      if (!this.config.strictPath)
        this.router.http.add(
          method,
          path2.endsWith("/") ? path2.slice(0, path2.length - 1) : path2 + "/",
          handler
        );
    }
  }
  headers(header) {
    if (!header)
      return this;
    if (!this.setHeaders)
      this.setHeaders = {};
    this.setHeaders = mergeDeep(this.setHeaders, header);
    return this;
  }
  /**
   * ### start | Life cycle event
   * Called after server is ready for serving
   *
   * ---
   * @example
   * ```typescript
   * new Elysia()
   *     .onStart(({ url, port }) => {
   *         console.log("Running at ${url}:${port}")
   *     })
   *     .listen(3000)
   * ```
   */
  onStart(handler) {
    this.on("start", handler);
    return this;
  }
  /**
   * ### request | Life cycle event
   * Called on every new request is accepted
   *
   * ---
   * @example
   * ```typescript
   * new Elysia()
   *     .onRequest(({ method, url }) => {
   *         saveToAnalytic({ method, url })
   *     })
   * ```
   */
  onRequest(handler) {
    this.on("request", handler);
    return this;
  }
  onParse(options, handler) {
    if (!handler)
      return this.on("parse", options);
    return this.on(
      options,
      "parse",
      handler
    );
  }
  onTransform(options, handler) {
    if (!handler)
      return this.on("transform", options);
    return this.on(
      options,
      "transform",
      handler
    );
  }
  resolve(optionsOrResolve, resolve2) {
    if (!resolve2) {
      resolve2 = optionsOrResolve;
      optionsOrResolve = { as: "local" };
    }
    const hook = {
      subType: "resolve",
      fn: resolve2
    };
    return this.onBeforeHandle(optionsOrResolve, hook);
  }
  mapResolve(optionsOrResolve, mapper) {
    if (!mapper) {
      mapper = optionsOrResolve;
      optionsOrResolve = { as: "local" };
    }
    const hook = {
      subType: "mapResolve",
      fn: mapper
    };
    return this.onBeforeHandle(optionsOrResolve, hook);
  }
  onBeforeHandle(options, handler) {
    if (!handler)
      return this.on("beforeHandle", options);
    return this.on(
      options,
      "beforeHandle",
      handler
    );
  }
  onAfterHandle(options, handler) {
    if (!handler)
      return this.on("afterHandle", options);
    return this.on(
      options,
      "afterHandle",
      handler
    );
  }
  mapResponse(options, handler) {
    if (!handler)
      return this.on("mapResponse", options);
    return this.on(
      options,
      "mapResponse",
      handler
    );
  }
  onAfterResponse(options, handler) {
    if (!handler)
      return this.on("afterResponse", options);
    return this.on(
      options,
      "afterResponse",
      handler
    );
  }
  /**
   * ### After Handle | Life cycle event
   * Intercept request **after** main handler is called.
   *
   * If truthy value is returned, will be assigned as `Response`
   *
   * ---
   * @example
   * ```typescript
   * new Elysia()
   *     .onAfterHandle((context, response) => {
   *         if(typeof response === "object")
   *             return JSON.stringify(response)
   *     })
   * ```
   */
  trace(options, handler) {
    if (!handler) {
      handler = options;
      options = { as: "local" };
    }
    if (!Array.isArray(handler))
      handler = [handler];
    for (const fn of handler)
      this.on(
        options,
        "trace",
        createTracer(fn)
      );
    return this;
  }
  error(name, error22) {
    switch (typeof name) {
      case "string":
        error22.prototype[ERROR_CODE] = name;
        this.definitions.error[name] = error22;
        return this;
      case "function":
        this.definitions.error = name(this.definitions.error);
        return this;
    }
    for (const [code4, error3] of Object.entries(name)) {
      error3.prototype[ERROR_CODE] = code4;
      this.definitions.error[code4] = error3;
    }
    return this;
  }
  /**
   * ### Error | Life cycle event
   * Called when error is thrown during processing request
   *
   * ---
   * @example
   * ```typescript
   * new Elysia()
   *     .onError(({ code }) => {
   *         if(code === "NOT_FOUND")
   *             return "Path not found :("
   *     })
   * ```
   */
  onError(options, handler) {
    if (!handler)
      return this.on("error", options);
    return this.on(
      options,
      "error",
      handler
    );
  }
  /**
   * ### stop | Life cycle event
   * Called after server stop serving request
   *
   * ---
   * @example
   * ```typescript
   * new Elysia()
   *     .onStop((app) => {
   *         cleanup()
   *     })
   * ```
   */
  onStop(handler) {
    this.on("stop", handler);
    return this;
  }
  on(optionsOrType, typeOrHandlers, handlers2) {
    let type;
    switch (typeof optionsOrType) {
      case "string":
        type = optionsOrType;
        handlers2 = typeOrHandlers;
        break;
      case "object":
        type = typeOrHandlers;
        if (!Array.isArray(typeOrHandlers) && typeof typeOrHandlers === "object")
          handlers2 = typeOrHandlers;
        break;
    }
    if (Array.isArray(handlers2))
      handlers2 = fnToContainer(handlers2);
    else {
      if (typeof handlers2 === "function")
        handlers2 = [
          {
            fn: handlers2
          }
        ];
      else
        handlers2 = [handlers2];
    }
    const handles = handlers2;
    for (const handle3 of handles)
      handle3.scope = typeof optionsOrType === "string" ? "local" : optionsOrType?.as ?? "local";
    if (type !== "trace")
      sucrose(
        {
          [type]: handles.map((x2) => x2.fn)
        },
        this.inference
      );
    for (const handle3 of handles) {
      const fn = asHookType(handle3, "global", { skipIfHasType: true });
      switch (type) {
        case "start":
          this.event.start.push(fn);
          break;
        case "request":
          this.event.request.push(fn);
          break;
        case "parse":
          this.event.parse.push(fn);
          break;
        case "transform":
          this.event.transform.push(fn);
          break;
        case "beforeHandle":
          this.event.beforeHandle.push(fn);
          break;
        case "afterHandle":
          this.event.afterHandle.push(fn);
          break;
        case "mapResponse":
          this.event.mapResponse.push(fn);
          break;
        case "afterResponse":
          this.event.afterResponse.push(fn);
          break;
        case "trace":
          this.event.trace.push(fn);
          break;
        case "error":
          this.event.error.push(fn);
          break;
        case "stop":
          this.event.stop.push(fn);
          break;
      }
    }
    return this;
  }
  /**
   * @deprecated use `Elysia.as` instead
   *
   * Will be removed in Elysia 1.2
   */
  propagate() {
    promoteEvent(this.event.parse);
    promoteEvent(this.event.transform);
    promoteEvent(this.event.beforeHandle);
    promoteEvent(this.event.afterHandle);
    promoteEvent(this.event.mapResponse);
    promoteEvent(this.event.afterResponse);
    promoteEvent(this.event.trace);
    promoteEvent(this.event.error);
    return this;
  }
  as(type) {
    const castType = { plugin: "scoped", global: "global" }[type];
    promoteEvent(this.event.parse, castType);
    promoteEvent(this.event.transform, castType);
    promoteEvent(this.event.beforeHandle, castType);
    promoteEvent(this.event.afterHandle, castType);
    promoteEvent(this.event.mapResponse, castType);
    promoteEvent(this.event.afterResponse, castType);
    promoteEvent(this.event.trace, castType);
    promoteEvent(this.event.error, castType);
    if (type === "plugin") {
      this.validator.scoped = mergeSchemaValidator(
        this.validator.scoped,
        this.validator.local
      );
      this.validator.local = null;
    } else if (type === "global") {
      this.validator.global = mergeSchemaValidator(
        this.validator.global,
        mergeSchemaValidator(
          this.validator.scoped,
          this.validator.local
        )
      );
      this.validator.scoped = null;
      this.validator.local = null;
    }
    return this;
  }
  /**
   * ### group
   * Encapsulate and group path with prefix
   *
   * ---
   * @example
   * ```typescript
   * new Elysia()
   *     .group('/v1', app => app
   *         .get('/', () => 'Hi')
   *         .get('/name', () => 'Elysia')
   *     })
   * ```
   */
  group(prefix, schemaOrRun, run) {
    const instance = new _Elysia({
      ...this.config,
      prefix: ""
    });
    instance.singleton = { ...this.singleton };
    instance.definitions = { ...this.definitions };
    instance.getServer = () => this.getServer();
    instance.inference = cloneInference(this.inference);
    instance.extender = { ...this.extender };
    const isSchema = typeof schemaOrRun === "object";
    const sandbox = (isSchema ? run : schemaOrRun)(instance);
    this.singleton = mergeDeep(this.singleton, instance.singleton);
    this.definitions = mergeDeep(this.definitions, instance.definitions);
    if (sandbox.event.request.length)
      this.event.request = [
        ...this.event.request || [],
        ...sandbox.event.request || []
      ];
    if (sandbox.event.mapResponse.length)
      this.event.mapResponse = [
        ...this.event.mapResponse || [],
        ...sandbox.event.mapResponse || []
      ];
    this.model(sandbox.definitions.type);
    Object.values(instance.router.history).forEach(
      ({ method, path: path2, handler, hooks }) => {
        path2 = (isSchema ? "" : this.config.prefix) + prefix + path2;
        if (isSchema) {
          const hook = schemaOrRun;
          const localHook = hooks;
          this.add(
            method,
            path2,
            handler,
            mergeHook(hook, {
              ...localHook || {},
              error: !localHook.error ? sandbox.event.error : Array.isArray(localHook.error) ? [
                ...localHook.error || {},
                ...sandbox.event.error || {}
              ] : [
                localHook.error,
                ...sandbox.event.error || {}
              ]
            })
          );
        } else {
          this.add(
            method,
            path2,
            handler,
            mergeHook(
              hooks,
              {
                error: sandbox.event.error
              }
            ),
            {
              skipPrefix: true
            }
          );
        }
      }
    );
    return this;
  }
  /**
   * ### guard
   * Encapsulate and pass hook into all child handler
   *
   * ---
   * @example
   * ```typescript
   * import { t } from 'elysia'
   *
   * new Elysia()
   *     .guard({
   *          schema: {
   *              body: t.Object({
   *                  username: t.String(),
   *                  password: t.String()
   *              })
   *          }
   *     }, app => app
   *         .get("/", () => 'Hi')
   *         .get("/name", () => 'Elysia')
   *     })
   * ```
   */
  guard(hook, run) {
    if (!run) {
      if (typeof hook === "object") {
        this.applyMacro(hook);
        const type = hook.as ?? "local";
        this.validator[type] = {
          body: hook.body ?? this.validator[type]?.body,
          headers: hook.headers ?? this.validator[type]?.headers,
          params: hook.params ?? this.validator[type]?.params,
          query: hook.query ?? this.validator[type]?.query,
          response: hook.response ?? this.validator[type]?.response,
          cookie: hook.cookie ?? this.validator[type]?.cookie
        };
        if (hook.parse)
          this.on({ as: type }, "parse", hook.parse);
        if (hook.transform)
          this.on({ as: type }, "transform", hook.transform);
        if (hook.beforeHandle)
          this.on({ as: type }, "beforeHandle", hook.beforeHandle);
        if (hook.afterHandle)
          this.on({ as: type }, "afterHandle", hook.afterHandle);
        if (hook.mapResponse)
          this.on({ as: type }, "mapResponse", hook.mapResponse);
        if (hook.afterResponse)
          this.on({ as: type }, "afterResponse", hook.afterResponse);
        if (hook.error)
          this.on({ as: type }, "error", hook.error);
        if (hook.detail) {
          if (this.config.detail)
            this.config.detail = mergeDeep(
              Object.assign({}, this.config.detail),
              hook.detail
            );
          else
            this.config.detail = hook.detail;
        }
        if (hook?.tags) {
          if (!this.config.detail)
            this.config.detail = {
              tags: hook.tags
            };
          else
            this.config.detail.tags = hook.tags;
        }
        return this;
      }
      return this.guard({}, hook);
    }
    const instance = new _Elysia({
      ...this.config,
      prefix: ""
    });
    instance.singleton = { ...this.singleton };
    instance.definitions = { ...this.definitions };
    instance.inference = cloneInference(this.inference);
    instance.extender = { ...this.extender };
    const sandbox = run(instance);
    this.singleton = mergeDeep(this.singleton, instance.singleton);
    this.definitions = mergeDeep(this.definitions, instance.definitions);
    sandbox.getServer = () => this.server;
    if (sandbox.event.request.length)
      this.event.request = [
        ...this.event.request || [],
        ...sandbox.event.request || []
      ];
    if (sandbox.event.mapResponse.length)
      this.event.mapResponse = [
        ...this.event.mapResponse || [],
        ...sandbox.event.mapResponse || []
      ];
    this.model(sandbox.definitions.type);
    Object.values(instance.router.history).forEach(
      ({ method, path: path2, handler, hooks: localHook }) => {
        this.add(
          method,
          path2,
          handler,
          mergeHook(hook, {
            ...localHook || {},
            error: !localHook.error ? sandbox.event.error : Array.isArray(localHook.error) ? [
              ...localHook.error || {},
              ...sandbox.event.error || []
            ] : [
              localHook.error,
              ...sandbox.event.error || []
            ]
          })
        );
      }
    );
    return this;
  }
  /**
   * ### use
   * Merge separate logic of Elysia with current
   *
   * ---
   * @example
   * ```typescript
   * const plugin = (app: Elysia) => app
   *     .get('/plugin', () => 'hi')
   *
   * new Elysia()
   *     .use(plugin)
   * ```
   */
  use(plugin, options) {
    if (options?.scoped)
      return this.guard({}, (app2) => app2.use(plugin));
    if (Array.isArray(plugin)) {
      let current = this;
      for (const p3 of plugin)
        current = this.use(p3);
      return current;
    }
    if (plugin instanceof Promise) {
      this.promisedModules.add(
        plugin.then((plugin2) => {
          if (typeof plugin2 === "function")
            return plugin2(this);
          if (plugin2 instanceof _Elysia)
            return this._use(plugin2);
          if (typeof plugin2.default === "function")
            return plugin2.default(this);
          if (plugin2.default instanceof _Elysia)
            return this._use(plugin2.default);
          throw new Error(
            'Invalid plugin type. Expected Elysia instance, function, or module with "default" as Elysia instance or function that returns Elysia instance.'
          );
        }).then((x2) => x2.compile())
      );
      return this;
    }
    return this._use(plugin);
  }
  _use(plugin) {
    if (typeof plugin === "function") {
      const instance = plugin(this);
      if (instance instanceof Promise) {
        this.promisedModules.add(
          instance.then((plugin2) => {
            if (plugin2 instanceof _Elysia) {
              this.compile();
              for (const {
                method,
                path: path2,
                handler,
                hooks
              } of Object.values(plugin2.router.history)) {
                this.add(
                  method,
                  path2,
                  handler,
                  mergeHook(
                    hooks,
                    {
                      error: plugin2.event.error
                    }
                  )
                );
              }
              return plugin2;
            }
            if (typeof plugin2 === "function")
              return plugin2(
                this
              );
            if (typeof plugin2.default === "function")
              return plugin2.default(
                this
              );
            return this._use(plugin2);
          }).then((x2) => x2.compile())
        );
        return this;
      }
      return instance;
    }
    if (plugin.promisedModules.size) {
      this.promisedModules.add(
        plugin.modules.then(() => this._use(plugin)).then((x2) => x2.compile())
      );
      return this;
    }
    const { name, seed } = plugin.config;
    plugin.getServer = () => this.getServer();
    plugin.getGlobalRoutes = () => this.getGlobalRoutes();
    plugin.model(this.definitions.type);
    plugin.error(this.definitions.error);
    const isScoped = plugin.config.scoped;
    if (isScoped) {
      if (name) {
        if (!(name in this.dependencies))
          this.dependencies[name] = [];
        const current = seed !== void 0 ? checksum(name + JSON.stringify(seed)) : 0;
        if (this.dependencies[name].some(
          ({ checksum: checksum2 }) => current === checksum2
        ))
          return this;
        this.dependencies[name].push(
          !this.config?.analytic ? {
            name: plugin.config.name,
            seed: plugin.config.seed,
            checksum: current,
            dependencies: plugin.dependencies
          } : {
            name: plugin.config.name,
            seed: plugin.config.seed,
            checksum: current,
            dependencies: plugin.dependencies,
            stack: plugin.telemetry.stack,
            routes: plugin.router.history,
            decorators: plugin.singleton.decorator,
            store: plugin.singleton.store,
            type: plugin.definitions.type,
            error: plugin.definitions.error,
            derive: plugin.event.transform.filter((x2) => x2.subType === "derive").map((x2) => ({
              fn: x2.fn.toString(),
              stack: new Error().stack ?? ""
            })),
            resolve: plugin.event.transform.filter((x2) => x2.subType === "derive").map((x2) => ({
              fn: x2.fn.toString(),
              stack: new Error().stack ?? ""
            }))
          }
        );
      }
      plugin.extender.macros = this.extender.macros.concat(
        plugin.extender.macros
      );
      const macroHashes = [];
      for (let i2 = 0; i2 < plugin.extender.macros.length; i2++) {
        const macro = this.extender.macros[i2];
        if (macroHashes.includes(macro.checksum)) {
          plugin.extender.macros.splice(i2, 1);
          i2--;
        }
        macroHashes.push(macro.checksum);
      }
      plugin.onRequest((context) => {
        Object.assign(context, this.singleton.decorator);
        Object.assign(context.store, this.singleton.store);
      });
      if (plugin.event.trace.length)
        plugin.event.trace.push(...plugin.event.trace);
      if (!plugin.config.prefix)
        console.warn(
          "It's recommended to use scoped instance with a prefix to prevent collision routing with other instance."
        );
      if (plugin.event.error.length)
        plugin.event.error.push(...this.event.error);
      if (plugin.config.aot)
        plugin.compile();
      if (isScoped === true && plugin.config.prefix) {
        this.mount(plugin.config.prefix + "/", plugin.fetch);
        for (const route of plugin.router.history) {
          this.routeTree.set(
            route.method + `${plugin.config.prefix}${route.path}`,
            this.router.history.length
          );
          this.router.history.push({
            ...route,
            path: `${plugin.config.prefix}${route.path}`,
            hooks: mergeHook(route.hooks, {
              error: this.event.error
            })
          });
        }
      } else {
        this.mount(plugin.fetch);
        for (const route of plugin.router.history) {
          this.routeTree.set(
            route.method + `${plugin.config.prefix}${route.path}`,
            this.router.history.length
          );
          this.router.history.push({
            ...route,
            path: `${plugin.config.prefix}${route.path}`,
            hooks: mergeHook(route.hooks, {
              error: this.event.error
            })
          });
        }
      }
      return this;
    } else {
      this.headers(plugin.setHeaders);
      if (name) {
        if (!(name in this.dependencies))
          this.dependencies[name] = [];
        const current = seed !== void 0 ? checksum(name + JSON.stringify(seed)) : 0;
        if (!this.dependencies[name].some(
          ({ checksum: checksum2 }) => current === checksum2
        )) {
          this.extender.macros = this.extender.macros.concat(
            plugin.extender.macros
          );
          this.extender.higherOrderFunctions = this.extender.higherOrderFunctions.concat(
            plugin.extender.higherOrderFunctions
          );
        }
      } else {
        this.extender.macros = this.extender.macros.concat(
          plugin.extender.macros
        );
        this.extender.higherOrderFunctions = this.extender.higherOrderFunctions.concat(
          plugin.extender.higherOrderFunctions
        );
      }
      deduplicateChecksum(this.extender.macros);
      deduplicateChecksum(this.extender.higherOrderFunctions);
      const hofHashes = [];
      for (let i2 = 0; i2 < this.extender.higherOrderFunctions.length; i2++) {
        const hof = this.extender.higherOrderFunctions[i2];
        if (hof.checksum) {
          if (hofHashes.includes(hof.checksum)) {
            this.extender.higherOrderFunctions.splice(i2, 1);
            i2--;
          }
          hofHashes.push(hof.checksum);
        }
      }
      this.inference = {
        body: this.inference.body || plugin.inference.body,
        cookie: this.inference.cookie || plugin.inference.cookie,
        headers: this.inference.headers || plugin.inference.headers,
        query: this.inference.query || plugin.inference.query,
        set: this.inference.set || plugin.inference.set,
        server: this.inference.server || plugin.inference.server
      };
    }
    this.decorate(plugin.singleton.decorator);
    this.state(plugin.singleton.store);
    this.model(plugin.definitions.type);
    this.error(plugin.definitions.error);
    plugin.extender.macros = this.extender.macros.concat(
      plugin.extender.macros
    );
    for (const { method, path: path2, handler, hooks } of Object.values(
      plugin.router.history
    )) {
      this.add(
        method,
        path2,
        handler,
        mergeHook(
          hooks,
          {
            error: plugin.event.error
          }
        )
      );
    }
    if (!isScoped)
      if (name) {
        if (!(name in this.dependencies))
          this.dependencies[name] = [];
        const current = seed !== void 0 ? checksum(name + JSON.stringify(seed)) : 0;
        if (this.dependencies[name].some(
          ({ checksum: checksum2 }) => current === checksum2
        ))
          return this;
        this.dependencies[name].push(
          !this.config?.analytic ? {
            name: plugin.config.name,
            seed: plugin.config.seed,
            checksum: current,
            dependencies: plugin.dependencies
          } : {
            name: plugin.config.name,
            seed: plugin.config.seed,
            checksum: current,
            dependencies: plugin.dependencies,
            stack: plugin.telemetry.stack,
            routes: plugin.router.history,
            decorators: plugin.singleton,
            store: plugin.singleton.store,
            type: plugin.definitions.type,
            error: plugin.definitions.error,
            derive: plugin.event.transform.filter((x2) => x2?.subType === "derive").map((x2) => ({
              fn: x2.toString(),
              stack: new Error().stack ?? ""
            })),
            resolve: plugin.event.transform.filter((x2) => x2?.subType === "resolve").map((x2) => ({
              fn: x2.toString(),
              stack: new Error().stack ?? ""
            }))
          }
        );
        this.event = mergeLifeCycle(
          this.event,
          filterGlobalHook(plugin.event),
          current
        );
      } else {
        this.event = mergeLifeCycle(
          this.event,
          filterGlobalHook(plugin.event)
        );
      }
    this.validator.global = mergeHook(this.validator.global, {
      ...plugin.validator.global
    });
    this.validator.local = mergeHook(this.validator.local, {
      ...plugin.validator.scoped
    });
    return this;
  }
  macro(macro) {
    const hook = {
      checksum: checksum(
        JSON.stringify({
          name: this.config.name,
          seed: this.config.seed,
          content: macro.toString()
        })
      ),
      fn: macro
    };
    this.extender.macros.push(hook);
    return this;
  }
  mount(path2, handle3) {
    if (path2 instanceof _Elysia || typeof path2 === "function" || path2.length === 0 || path2 === "/") {
      const run = typeof path2 === "function" ? path2 : path2 instanceof _Elysia ? path2.compile().fetch : handle3 instanceof _Elysia ? handle3.compile().fetch : handle3;
      const handler2 = async ({ request, path: path22 }) => run(
        new Request(
          replaceUrlPath(request.url, path22 || "/"),
          request
        )
      );
      this.all(
        "/*",
        handler2,
        {
          type: "none"
        }
      );
      return this;
    }
    const length = path2.length;
    if (handle3 instanceof _Elysia)
      handle3 = handle3.compile().fetch;
    const handler = async ({ request, path: path22 }) => handle3(
      new Request(
        replaceUrlPath(request.url, path22.slice(length) || "/"),
        request
      )
    );
    this.all(
      path2,
      handler,
      {
        type: "none"
      }
    );
    this.all(
      path2 + (path2.endsWith("/") ? "*" : "/*"),
      handler,
      {
        type: "none"
      }
    );
    return this;
  }
  /**
   * ### get
   * Register handler for path with method [GET]
   *
   * ---
   * @example
   * ```typescript
   * import { Elysia, t } from 'elysia'
   *
   * new Elysia()
   *     .get('/', () => 'hi')
   *     .get('/with-hook', () => 'hi', {
   *         response: t.String()
   *     })
   * ```
   */
  get(path2, handler, hook) {
    this.add("GET", path2, handler, hook);
    return this;
  }
  /**
   * ### post
   * Register handler for path with method [POST]
   *
   * ---
   * @example
   * ```typescript
   * import { Elysia, t } from 'elysia'
   *
   * new Elysia()
   *     .post('/', () => 'hi')
   *     .post('/with-hook', () => 'hi', {
   *         response: t.String()
   *     })
   * ```
   */
  post(path2, handler, hook) {
    this.add("POST", path2, handler, hook);
    return this;
  }
  /**
   * ### put
   * Register handler for path with method [PUT]
   *
   * ---
   * @example
   * ```typescript
   * import { Elysia, t } from 'elysia'
   *
   * new Elysia()
   *     .put('/', () => 'hi')
   *     .put('/with-hook', () => 'hi', {
   *         response: t.String()
   *     })
   * ```
   */
  put(path2, handler, hook) {
    this.add("PUT", path2, handler, hook);
    return this;
  }
  /**
   * ### patch
   * Register handler for path with method [PATCH]
   *
   * ---
   * @example
   * ```typescript
   * import { Elysia, t } from 'elysia'
   *
   * new Elysia()
   *     .patch('/', () => 'hi')
   *     .patch('/with-hook', () => 'hi', {
   *         response: t.String()
   *     })
   * ```
   */
  patch(path2, handler, hook) {
    this.add("PATCH", path2, handler, hook);
    return this;
  }
  /**
   * ### delete
   * Register handler for path with method [DELETE]
   *
   * ---
   * @example
   * ```typescript
   * import { Elysia, t } from 'elysia'
   *
   * new Elysia()
   *     .delete('/', () => 'hi')
   *     .delete('/with-hook', () => 'hi', {
   *         response: t.String()
   *     })
   * ```
   */
  delete(path2, handler, hook) {
    this.add("DELETE", path2, handler, hook);
    return this;
  }
  /**
   * ### options
   * Register handler for path with method [POST]
   *
   * ---
   * @example
   * ```typescript
   * import { Elysia, t } from 'elysia'
   *
   * new Elysia()
   *     .options('/', () => 'hi')
   *     .options('/with-hook', () => 'hi', {
   *         response: t.String()
   *     })
   * ```
   */
  options(path2, handler, hook) {
    this.add("OPTIONS", path2, handler, hook);
    return this;
  }
  /**
   * ### all
   * Register handler for path with method [ALL]
   *
   * ---
   * @example
   * ```typescript
   * import { Elysia, t } from 'elysia'
   *
   * new Elysia()
   *     .all('/', () => 'hi')
   *     .all('/with-hook', () => 'hi', {
   *         response: t.String()
   *     })
   * ```
   */
  all(path2, handler, hook) {
    this.add("ALL", path2, handler, hook);
    return this;
  }
  /**
   * ### head
   * Register handler for path with method [HEAD]
   *
   * ---
   * @example
   * ```typescript
   * import { Elysia, t } from 'elysia'
   *
   * new Elysia()
   *     .head('/', () => 'hi')
   *     .head('/with-hook', () => 'hi', {
   *         response: t.String()
   *     })
   * ```
   */
  head(path2, handler, hook) {
    this.add("HEAD", path2, handler, hook);
    return this;
  }
  /**
   * ### connect
   * Register handler for path with method [CONNECT]
   *
   * ---
   * @example
   * ```typescript
   * import { Elysia, t } from 'elysia'
   *
   * new Elysia()
   *     .connect('/', () => 'hi')
   *     .connect('/with-hook', () => 'hi', {
   *         response: t.String()
   *     })
   * ```
   */
  connect(path2, handler, hook) {
    this.add("CONNECT", path2, handler, hook);
    return this;
  }
  /**
   * ### route
   * Register handler for path with method [ROUTE]
   *
   * ---
   * @example
   * ```typescript
   * import { Elysia, t } from 'elysia'
   *
   * new Elysia()
   *     .route('/', () => 'hi')
   *     .route('/with-hook', () => 'hi', {
   *         response: t.String()
   *     })
   * ```
   */
  route(method, path2, handler, hook) {
    this.add(method.toUpperCase(), path2, handler, hook, hook?.config);
    return this;
  }
  /**
   * ### ws
   * Register handler for path with method [ws]
   *
   * ---
   * @example
   * ```typescript
   * import { Elysia, t } from 'elysia'
   *
   * new Elysia()
   *     .ws('/', {
   *         message(ws, message) {
   *             ws.send(message)
   *         }
   *     })
   * ```
   */
  ws(path2, options) {
    const transform = options.transformMessage ? Array.isArray(options.transformMessage) ? options.transformMessage : [options.transformMessage] : void 0;
    let server = null;
    const validateMessage = getSchemaValidator(options?.body, {
      models: this.definitions.type,
      normalize: this.config.normalize
    });
    const validateResponse = getSchemaValidator(options?.response, {
      models: this.definitions.type,
      normalize: this.config.normalize
    });
    const parseMessage = (message2) => {
      if (typeof message2 === "string") {
        const start = message2?.charCodeAt(0);
        if (start === 47 || start === 123)
          try {
            message2 = JSON.parse(message2);
          } catch {
          }
        else if (isNumericString(message2))
          message2 = +message2;
      }
      if (transform?.length)
        for (let i2 = 0; i2 < transform.length; i2++) {
          const temp = transform[i2](message2);
          if (temp !== void 0)
            message2 = temp;
        }
      return message2;
    };
    this.route(
      "$INTERNALWS",
      path2,
      // @ts-expect-error
      (context) => {
        const { set, path: path22, qi, headers, query, params } = context;
        if (server === null)
          server = this.getServer();
        if (server?.upgrade(context.request, {
          headers: typeof options.upgrade === "function" ? options.upgrade(context) : options.upgrade,
          data: {
            validator: validateResponse,
            open(ws) {
              options.open?.(new ElysiaWS(ws, context));
            },
            message: (ws, msg) => {
              const message2 = parseMessage(msg);
              if (validateMessage?.Check(message2) === false)
                return void ws.send(
                  new ValidationError(
                    "message",
                    validateMessage,
                    message2
                  ).message
                );
              options.message?.(
                new ElysiaWS(ws, context),
                message2
              );
            },
            drain(ws) {
              options.drain?.(
                new ElysiaWS(ws, context)
              );
            },
            close(ws, code4, reason) {
              options.close?.(
                new ElysiaWS(ws, context),
                code4,
                reason
              );
            }
          }
        }))
          return;
        set.status = 400;
        return "Expected a websocket connection";
      },
      {
        beforeHandle: options.beforeHandle,
        transform: options.transform,
        headers: options.headers,
        params: options.params,
        query: options.query
      }
    );
    return this;
  }
  /**
   * ### state
   * Assign global mutatable state accessible for all handler
   *
   * ---
   * @example
   * ```typescript
   * new Elysia()
   *     .state('counter', 0)
   *     .get('/', (({ counter }) => ++counter)
   * ```
   */
  state(options, name, value) {
    if (name === void 0) {
      value = options;
      options = { as: "append" };
      name = "";
    } else if (value === void 0) {
      if (typeof options === "string") {
        value = name;
        name = options;
        options = { as: "append" };
      } else if (typeof options === "object") {
        value = name;
        name = "";
      }
    }
    const { as: as2 } = options;
    if (typeof name !== "string")
      return this;
    switch (typeof value) {
      case "object":
        if (name) {
          if (name in this.singleton.store)
            this.singleton.store[name] = mergeDeep(
              this.singleton.store[name],
              value,
              {
                override: as2 === "override"
              }
            );
          else
            this.singleton.store[name] = value;
          return this;
        }
        if (value === null)
          return this;
        this.singleton.store = mergeDeep(this.singleton.store, value, {
          override: as2 === "override"
        });
        return this;
      case "function":
        if (name) {
          if (as2 === "override" || !(name in this.singleton.store))
            this.singleton.store[name] = value;
        } else
          this.singleton.store = value(this.singleton.store);
        return this;
      default:
        if (as2 === "override" || !(name in this.singleton.store))
          this.singleton.store[name] = value;
        return this;
    }
  }
  /**
   * ### decorate
   * Define custom method to `Context` accessible for all handler
   *
   * ---
   * @example
   * ```typescript
   * new Elysia()
   *     .decorate('getDate', () => Date.now())
   *     .get('/', (({ getDate }) => getDate())
   * ```
   */
  decorate(options, name, value) {
    if (name === void 0) {
      value = options;
      options = { as: "append" };
      name = "";
    } else if (value === void 0) {
      if (typeof options === "string") {
        value = name;
        name = options;
        options = { as: "append" };
      } else if (typeof options === "object") {
        value = name;
        name = "";
      }
    }
    const { as: as2 } = options;
    if (typeof name !== "string")
      return this;
    switch (typeof value) {
      case "object":
        if (name) {
          if (name in this.singleton.decorator)
            this.singleton.decorator[name] = mergeDeep(
              this.singleton.decorator[name],
              value,
              {
                override: as2 === "override"
              }
            );
          else
            this.singleton.decorator[name] = value;
          return this;
        }
        if (value === null)
          return this;
        this.singleton.decorator = mergeDeep(
          this.singleton.decorator,
          value,
          {
            override: as2 === "override"
          }
        );
        return this;
      case "function":
        if (name) {
          if (as2 === "override" || !(name in this.singleton.decorator))
            this.singleton.decorator[name] = value;
        } else
          this.singleton.decorator = value(this.singleton.decorator);
        return this;
      default:
        if (as2 === "override" || !(name in this.singleton.decorator))
          this.singleton.decorator[name] = value;
        return this;
    }
  }
  derive(optionsOrTransform, transform) {
    if (!transform) {
      transform = optionsOrTransform;
      optionsOrTransform = { as: "local" };
    }
    const hook = {
      subType: "derive",
      fn: transform
    };
    return this.onTransform(optionsOrTransform, hook);
  }
  model(name, model) {
    switch (typeof name) {
      case "object":
        Object.entries(name).forEach(([key2, value]) => {
          if (!(key2 in this.definitions.type))
            this.definitions.type[key2] = value;
        });
        return this;
      case "function":
        this.definitions.type = name(this.definitions.type);
        return this;
    }
    ;
    this.definitions.type[name] = model;
    return this;
  }
  mapDerive(optionsOrDerive, mapper) {
    if (!mapper) {
      mapper = optionsOrDerive;
      optionsOrDerive = { as: "local" };
    }
    const hook = {
      subType: "mapDerive",
      fn: mapper
    };
    return this.onTransform(optionsOrDerive, hook);
  }
  affix(base2, type, word) {
    if (word === "")
      return this;
    const delimieter = ["_", "-", " "];
    const capitalize = (word2) => word2[0].toUpperCase() + word2.slice(1);
    const joinKey = base2 === "prefix" ? (prefix, word2) => delimieter.includes(prefix.at(-1) ?? "") ? prefix + word2 : prefix + capitalize(word2) : delimieter.includes(word.at(-1) ?? "") ? (suffix, word2) => word2 + suffix : (suffix, word2) => word2 + capitalize(suffix);
    const remap = (type2) => {
      const store = {};
      switch (type2) {
        case "decorator":
          for (const key2 in this.singleton.decorator) {
            store[joinKey(word, key2)] = this.singleton.decorator[key2];
          }
          this.singleton.decorator = store;
          break;
        case "state":
          for (const key2 in this.singleton.store)
            store[joinKey(word, key2)] = this.singleton.store[key2];
          this.singleton.store = store;
          break;
        case "model":
          for (const key2 in this.definitions.type)
            store[joinKey(word, key2)] = this.definitions.type[key2];
          this.definitions.type = store;
          break;
        case "error":
          for (const key2 in this.definitions.error)
            store[joinKey(word, key2)] = this.definitions.error[key2];
          this.definitions.error = store;
          break;
      }
    };
    const types2 = Array.isArray(type) ? type : [type];
    for (const type2 of types2.some((x2) => x2 === "all") ? ["decorator", "state", "model", "error"] : types2)
      remap(type2);
    return this;
  }
  prefix(type, word) {
    return this.affix("prefix", type, word);
  }
  suffix(type, word) {
    return this.affix("suffix", type, word);
  }
  compile() {
    this.fetch = this.config.aot ? composeGeneralHandler(this) : createDynamicHandler(this);
    if (typeof this.server?.reload === "function")
      this.server.reload({
        ...this.server || {},
        fetch: this.fetch
      });
    return this;
  }
  /**
   * Wait until all lazy loaded modules all load is fully
   */
  get modules() {
    return Promise.all(this.promisedModules.promises);
  }
};

// server/src/_worker.ts
var import_reflect_metadata = __toESM(require_Reflect(), 1);

// node_modules/typedi/esm5/index.js
init_process();
init_buffer();

// node_modules/typedi/esm5/container.class.js
init_process();
init_buffer();

// node_modules/typedi/esm5/container-instance.class.js
init_process();
init_buffer();

// node_modules/typedi/esm5/error/service-not-found.error.js
init_process();
init_buffer();

// node_modules/typedi/esm5/token.class.js
init_process();
init_buffer();
var Token = (
  /** @class */
  function() {
    function Token2(name) {
      this.name = name;
    }
    return Token2;
  }()
);

// node_modules/typedi/esm5/error/service-not-found.error.js
var __extends = function() {
  var extendStatics = function(d2, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p3 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p3))
          d3[p3] = b3[p3];
    };
    return extendStatics(d2, b2);
  };
  return function(d2, b2) {
    extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var ServiceNotFoundError = (
  /** @class */
  function(_super) {
    __extends(ServiceNotFoundError2, _super);
    function ServiceNotFoundError2(identifier) {
      var _a89, _b;
      var _this = _super.call(this) || this;
      _this.name = "ServiceNotFoundError";
      _this.normalizedIdentifier = "<UNKNOWN_IDENTIFIER>";
      if (typeof identifier === "string") {
        _this.normalizedIdentifier = identifier;
      } else if (identifier instanceof Token) {
        _this.normalizedIdentifier = "Token<" + (identifier.name || "UNSET_NAME") + ">";
      } else if (identifier && (identifier.name || ((_a89 = identifier.prototype) === null || _a89 === void 0 ? void 0 : _a89.name))) {
        _this.normalizedIdentifier = "MaybeConstructable<" + identifier.name + ">" || "MaybeConstructable<" + ((_b = identifier.prototype) === null || _b === void 0 ? void 0 : _b.name) + ">";
      }
      return _this;
    }
    Object.defineProperty(ServiceNotFoundError2.prototype, "message", {
      get: function() {
        return 'Service with "' + this.normalizedIdentifier + '" identifier was not found in the container. Register it before usage via explicitly calling the "Container.set" function or using the "@Service()" decorator.';
      },
      enumerable: false,
      configurable: true
    });
    return ServiceNotFoundError2;
  }(Error)
);

// node_modules/typedi/esm5/error/cannot-instantiate-value.error.js
init_process();
init_buffer();
var __extends2 = function() {
  var extendStatics = function(d2, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p3 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p3))
          d3[p3] = b3[p3];
    };
    return extendStatics(d2, b2);
  };
  return function(d2, b2) {
    extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var CannotInstantiateValueError = (
  /** @class */
  function(_super) {
    __extends2(CannotInstantiateValueError2, _super);
    function CannotInstantiateValueError2(identifier) {
      var _a89, _b;
      var _this = _super.call(this) || this;
      _this.name = "CannotInstantiateValueError";
      _this.normalizedIdentifier = "<UNKNOWN_IDENTIFIER>";
      if (typeof identifier === "string") {
        _this.normalizedIdentifier = identifier;
      } else if (identifier instanceof Token) {
        _this.normalizedIdentifier = "Token<" + (identifier.name || "UNSET_NAME") + ">";
      } else if (identifier && (identifier.name || ((_a89 = identifier.prototype) === null || _a89 === void 0 ? void 0 : _a89.name))) {
        _this.normalizedIdentifier = "MaybeConstructable<" + identifier.name + ">" || "MaybeConstructable<" + ((_b = identifier.prototype) === null || _b === void 0 ? void 0 : _b.name) + ">";
      }
      return _this;
    }
    Object.defineProperty(CannotInstantiateValueError2.prototype, "message", {
      get: function() {
        return 'Cannot instantiate the requested value for the "' + this.normalizedIdentifier + `" identifier. The related metadata doesn't contain a factory or a type to instantiate.`;
      },
      enumerable: false,
      configurable: true
    });
    return CannotInstantiateValueError2;
  }(Error)
);

// node_modules/typedi/esm5/empty.const.js
init_process();
init_buffer();
var EMPTY_VALUE = Symbol("EMPTY_VALUE");

// node_modules/typedi/esm5/container-instance.class.js
var __assign = function() {
  __assign = Object.assign || function(t3) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p3 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p3))
          t3[p3] = s2[p3];
    }
    return t3;
  };
  return __assign.apply(this, arguments);
};
var __spreadArrays = function() {
  for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
    s2 += arguments[i2].length;
  for (var r2 = Array(s2), k2 = 0, i2 = 0; i2 < il; i2++)
    for (var a2 = arguments[i2], j2 = 0, jl = a2.length; j2 < jl; j2++, k2++)
      r2[k2] = a2[j2];
  return r2;
};
var ContainerInstance = (
  /** @class */
  function() {
    function ContainerInstance2(id) {
      this.services = [];
      this.id = id;
    }
    ContainerInstance2.prototype.has = function(identifier) {
      return !!this.findService(identifier);
    };
    ContainerInstance2.prototype.get = function(identifier) {
      var globalContainer = Container.of(void 0);
      var globalService = globalContainer.findService(identifier);
      var scopedService = this.findService(identifier);
      if (globalService && globalService.global === true)
        return this.getServiceValue(globalService);
      if (scopedService)
        return this.getServiceValue(scopedService);
      if (globalService && this !== globalContainer) {
        var clonedService = __assign({}, globalService);
        clonedService.value = EMPTY_VALUE;
        this.set(clonedService);
        var value = this.getServiceValue(clonedService);
        this.set(__assign(__assign({}, clonedService), { value }));
        return value;
      }
      if (globalService)
        return this.getServiceValue(globalService);
      throw new ServiceNotFoundError(identifier);
    };
    ContainerInstance2.prototype.getMany = function(identifier) {
      var _this = this;
      return this.findAllServices(identifier).map(function(service) {
        return _this.getServiceValue(service);
      });
    };
    ContainerInstance2.prototype.set = function(identifierOrServiceMetadata, value) {
      var _this = this;
      if (identifierOrServiceMetadata instanceof Array) {
        identifierOrServiceMetadata.forEach(function(data) {
          return _this.set(data);
        });
        return this;
      }
      if (typeof identifierOrServiceMetadata === "string" || identifierOrServiceMetadata instanceof Token) {
        return this.set({
          id: identifierOrServiceMetadata,
          type: null,
          value,
          factory: void 0,
          global: false,
          multiple: false,
          eager: false,
          transient: false
        });
      }
      if (typeof identifierOrServiceMetadata === "function") {
        return this.set({
          id: identifierOrServiceMetadata,
          // TODO: remove explicit casting
          type: identifierOrServiceMetadata,
          value,
          factory: void 0,
          global: false,
          multiple: false,
          eager: false,
          transient: false
        });
      }
      var newService = __assign({ id: new Token("UNREACHABLE"), type: null, factory: void 0, value: EMPTY_VALUE, global: false, multiple: false, eager: false, transient: false }, identifierOrServiceMetadata);
      var service = this.findService(newService.id);
      if (service && service.multiple !== true) {
        Object.assign(service, newService);
      } else {
        this.services.push(newService);
      }
      if (newService.eager) {
        this.get(newService.id);
      }
      return this;
    };
    ContainerInstance2.prototype.remove = function(identifierOrIdentifierArray) {
      var _this = this;
      if (Array.isArray(identifierOrIdentifierArray)) {
        identifierOrIdentifierArray.forEach(function(id) {
          return _this.remove(id);
        });
      } else {
        this.services = this.services.filter(function(service) {
          if (service.id === identifierOrIdentifierArray) {
            _this.destroyServiceInstance(service);
            return false;
          }
          return true;
        });
      }
      return this;
    };
    ContainerInstance2.prototype.reset = function(options) {
      var _this = this;
      if (options === void 0) {
        options = { strategy: "resetValue" };
      }
      switch (options.strategy) {
        case "resetValue":
          this.services.forEach(function(service) {
            return _this.destroyServiceInstance(service);
          });
          break;
        case "resetServices":
          this.services.forEach(function(service) {
            return _this.destroyServiceInstance(service);
          });
          this.services = [];
          break;
        default:
          throw new Error("Received invalid reset strategy.");
      }
      return this;
    };
    ContainerInstance2.prototype.findAllServices = function(identifier) {
      return this.services.filter(function(service) {
        return service.id === identifier;
      });
    };
    ContainerInstance2.prototype.findService = function(identifier) {
      return this.services.find(function(service) {
        return service.id === identifier;
      });
    };
    ContainerInstance2.prototype.getServiceValue = function(serviceMetadata) {
      var _a89;
      var value = EMPTY_VALUE;
      if (serviceMetadata.value !== EMPTY_VALUE) {
        return serviceMetadata.value;
      }
      if (!serviceMetadata.factory && !serviceMetadata.type) {
        throw new CannotInstantiateValueError(serviceMetadata.id);
      }
      if (serviceMetadata.factory) {
        if (serviceMetadata.factory instanceof Array) {
          var factoryInstance = void 0;
          try {
            factoryInstance = this.get(serviceMetadata.factory[0]);
          } catch (error3) {
            if (error3 instanceof ServiceNotFoundError) {
              factoryInstance = new serviceMetadata.factory[0]();
            } else {
              throw error3;
            }
          }
          value = factoryInstance[serviceMetadata.factory[1]](this, serviceMetadata.id);
        } else {
          value = serviceMetadata.factory(this, serviceMetadata.id);
        }
      }
      if (!serviceMetadata.factory && serviceMetadata.type) {
        var constructableTargetType = serviceMetadata.type;
        var paramTypes = ((_a89 = Reflect) === null || _a89 === void 0 ? void 0 : _a89.getMetadata("design:paramtypes", constructableTargetType)) || [];
        var params = this.initializeParams(constructableTargetType, paramTypes);
        params.push(this);
        value = new (constructableTargetType.bind.apply(constructableTargetType, __spreadArrays([void 0], params)))();
      }
      if (!serviceMetadata.transient && value !== EMPTY_VALUE) {
        serviceMetadata.value = value;
      }
      if (value === EMPTY_VALUE) {
        throw new CannotInstantiateValueError(serviceMetadata.id);
      }
      if (serviceMetadata.type) {
        this.applyPropertyHandlers(serviceMetadata.type, value);
      }
      return value;
    };
    ContainerInstance2.prototype.initializeParams = function(target, paramTypes) {
      var _this = this;
      return paramTypes.map(function(paramType, index3) {
        var paramHandler = Container.handlers.find(function(handler) {
          return (handler.object === target || handler.object === Object.getPrototypeOf(target)) && handler.index === index3;
        });
        if (paramHandler)
          return paramHandler.value(_this);
        if (paramType && paramType.name && !_this.isPrimitiveParamType(paramType.name)) {
          return _this.get(paramType);
        }
        return void 0;
      });
    };
    ContainerInstance2.prototype.isPrimitiveParamType = function(paramTypeName) {
      return ["string", "boolean", "number", "object"].includes(paramTypeName.toLowerCase());
    };
    ContainerInstance2.prototype.applyPropertyHandlers = function(target, instance) {
      var _this = this;
      Container.handlers.forEach(function(handler) {
        if (typeof handler.index === "number")
          return;
        if (handler.object.constructor !== target && !(target.prototype instanceof handler.object.constructor))
          return;
        if (handler.propertyName) {
          instance[handler.propertyName] = handler.value(_this);
        }
      });
    };
    ContainerInstance2.prototype.destroyServiceInstance = function(serviceMetadata, force) {
      if (force === void 0) {
        force = false;
      }
      var shouldResetValue = force || !!serviceMetadata.type || !!serviceMetadata.factory;
      if (shouldResetValue) {
        if (typeof (serviceMetadata === null || serviceMetadata === void 0 ? void 0 : serviceMetadata.value)["destroy"] === "function") {
          try {
            serviceMetadata.value.destroy();
          } catch (error3) {
          }
        }
        serviceMetadata.value = EMPTY_VALUE;
      }
    };
    return ContainerInstance2;
  }()
);

// node_modules/typedi/esm5/container.class.js
var Container = (
  /** @class */
  function() {
    function Container2() {
    }
    Container2.of = function(containerId) {
      if (containerId === void 0) {
        containerId = "default";
      }
      if (containerId === "default")
        return this.globalInstance;
      var container = this.instances.find(function(instance) {
        return instance.id === containerId;
      });
      if (!container) {
        container = new ContainerInstance(containerId);
        this.instances.push(container);
      }
      return container;
    };
    Container2.has = function(identifier) {
      return this.globalInstance.has(identifier);
    };
    Container2.get = function(identifier) {
      return this.globalInstance.get(identifier);
    };
    Container2.getMany = function(id) {
      return this.globalInstance.getMany(id);
    };
    Container2.set = function(identifierOrServiceMetadata, value) {
      this.globalInstance.set(identifierOrServiceMetadata, value);
      return this;
    };
    Container2.remove = function(identifierOrIdentifierArray) {
      this.globalInstance.remove(identifierOrIdentifierArray);
      return this;
    };
    Container2.reset = function(containerId) {
      if (containerId === void 0) {
        containerId = "default";
      }
      if (containerId == "default") {
        this.globalInstance.reset();
        this.instances.forEach(function(instance2) {
          return instance2.reset();
        });
      } else {
        var instance = this.instances.find(function(instance2) {
          return instance2.id === containerId;
        });
        if (instance) {
          instance.reset();
          this.instances.splice(this.instances.indexOf(instance), 1);
        }
      }
      return this;
    };
    Container2.registerHandler = function(handler) {
      this.handlers.push(handler);
      return this;
    };
    Container2.import = function(services) {
      return this;
    };
    Container2.handlers = [];
    Container2.globalInstance = new ContainerInstance("default");
    Container2.instances = [];
    return Container2;
  }()
);

// node_modules/typedi/esm5/decorators/service.decorator.js
init_process();
init_buffer();
function Service(optionsOrServiceIdentifier) {
  return function(targetConstructor) {
    var serviceMetadata = {
      id: targetConstructor,
      // TODO: Let's investigate why we receive Function type instead of a constructable.
      type: targetConstructor,
      factory: void 0,
      multiple: false,
      global: false,
      eager: false,
      transient: false,
      value: EMPTY_VALUE
    };
    if (optionsOrServiceIdentifier instanceof Token || typeof optionsOrServiceIdentifier === "string") {
      serviceMetadata.id = optionsOrServiceIdentifier;
    } else if (optionsOrServiceIdentifier) {
      serviceMetadata.id = optionsOrServiceIdentifier.id || targetConstructor;
      serviceMetadata.factory = optionsOrServiceIdentifier.factory || void 0;
      serviceMetadata.multiple = optionsOrServiceIdentifier.multiple || false;
      serviceMetadata.global = optionsOrServiceIdentifier.global || false;
      serviceMetadata.eager = optionsOrServiceIdentifier.eager || false;
      serviceMetadata.transient = optionsOrServiceIdentifier.transient || false;
    }
    Container.set(serviceMetadata);
  };
}

// node_modules/typedi/esm5/index.js
var esm5_default = Container;

// server/src/db/schema.ts
var schema_exports = {};
__export(schema_exports, {
  comments: () => comments,
  commentsRelations: () => commentsRelations,
  feedHashtags: () => feedHashtags,
  feedHashtagsRelations: () => feedHashtagsRelations,
  feeds: () => feeds,
  feedsRelations: () => feedsRelations,
  friends: () => friends,
  hashtags: () => hashtags,
  hashtagsRelations: () => hashtagsRelations,
  info: () => info,
  users: () => users,
  visits: () => visits
});
init_process();
init_buffer();
var created_at = integer("created_at", { mode: "timestamp" }).default(sql`(unixepoch())`).notNull();
var updated_at = integer("updated_at", { mode: "timestamp" }).default(sql`(unixepoch())`).notNull();
var feeds = sqliteTable("feeds", {
  id: integer("id").primaryKey(),
  alias: text("alias"),
  title: text("title"),
  summary: text("summary").default("").notNull(),
  content: text("content").notNull(),
  listed: integer("listed").default(1).notNull(),
  draft: integer("draft").default(1).notNull(),
  top: integer("top").default(0).notNull(),
  uid: integer("uid").references(() => users.id).notNull(),
  createdAt: created_at,
  updatedAt: updated_at
});
var visits = sqliteTable("visits", {
  id: integer("id").primaryKey(),
  feedId: integer("feed_id").references(() => feeds.id, { onDelete: "cascade" }).notNull(),
  ip: text("ip").notNull(),
  createdAt: created_at
});
var info = sqliteTable("info", {
  key: text("key").notNull().unique(),
  value: text("value").notNull()
});
var friends = sqliteTable("friends", {
  id: integer("id").primaryKey(),
  name: text("name").notNull(),
  desc: text("desc"),
  avatar: text("avatar").notNull(),
  url: text("url").notNull(),
  uid: integer("uid").references(() => users.id, { onDelete: "cascade" }).notNull(),
  accepted: integer("accepted").default(0).notNull(),
  health: text("health").default("").notNull(),
  createdAt: created_at,
  updatedAt: updated_at
});
var users = sqliteTable("users", {
  id: integer("id").primaryKey(),
  username: text("username").notNull(),
  openid: text("openid").notNull(),
  avatar: text("avatar"),
  permission: integer("permission").default(0),
  createdAt: created_at,
  updatedAt: updated_at
});
var comments = sqliteTable("comments", {
  id: integer("id").primaryKey(),
  feedId: integer("feed_id").references(() => feeds.id, { onDelete: "cascade" }).notNull(),
  userId: integer("user_id").references(() => users.id, { onDelete: "cascade" }).notNull(),
  content: text("content").notNull(),
  createdAt: created_at,
  updatedAt: updated_at
});
var hashtags = sqliteTable("hashtags", {
  id: integer("id").primaryKey(),
  name: text("name").notNull(),
  createdAt: created_at,
  updatedAt: updated_at
});
var feedHashtags = sqliteTable("feed_hashtags", {
  feedId: integer("feed_id").references(() => feeds.id, { onDelete: "cascade" }).notNull(),
  hashtagId: integer("hashtag_id").references(() => hashtags.id, { onDelete: "cascade" }).notNull(),
  createdAt: created_at,
  updatedAt: updated_at
});
var feedsRelations = relations(feeds, ({ many, one: one4 }) => ({
  hashtags: many(feedHashtags),
  user: one4(users, {
    fields: [feeds.uid],
    references: [users.id]
  }),
  comments: many(comments)
}));
var commentsRelations = relations(comments, ({ one: one4 }) => ({
  feed: one4(feeds, {
    fields: [comments.feedId],
    references: [feeds.id]
  }),
  user: one4(users, {
    fields: [comments.userId],
    references: [users.id]
  })
}));
var hashtagsRelations = relations(hashtags, ({ many }) => ({
  feeds: many(feedHashtags)
}));
var feedHashtagsRelations = relations(feedHashtags, ({ one: one4 }) => ({
  feed: one4(feeds, {
    fields: [feedHashtags.feedId],
    references: [feeds.id]
  }),
  hashtag: one4(hashtags, {
    fields: [feedHashtags.hashtagId],
    references: [hashtags.id]
  })
}));

// server/src/server.ts
init_process();
init_buffer();

// node_modules/@elysiajs/cors/dist/index.js
init_process();
init_buffer();
var processOrigin = (origin, request, from3) => {
  if (Array.isArray(origin))
    return origin.some((o2) => processOrigin(o2, request, from3));
  switch (typeof origin) {
    case "string":
      const protocolStart = from3.indexOf("://");
      if (protocolStart !== -1)
        from3 = from3.slice(protocolStart + 3);
      const trailingSlash = from3.indexOf("/", 0);
      if (trailingSlash !== -1)
        from3 = from3.slice(trailingSlash);
      return origin === from3;
    case "function":
      return origin(request) === true;
    case "object":
      if (origin instanceof RegExp)
        return origin.test(from3);
  }
  return false;
};
var cors = (config3) => {
  let { aot = true, origin = "*", methods = "*", allowedHeaders = "*", exposedHeaders = "*", credentials = true, maxAge = 5, preflight = true } = config3 ?? {};
  if (Array.isArray(allowedHeaders))
    allowedHeaders = allowedHeaders.join(", ");
  if (Array.isArray(exposedHeaders))
    exposedHeaders = exposedHeaders.join(", ");
  const origins = typeof origin === "boolean" ? void 0 : Array.isArray(origin) ? origin : [origin];
  const app2 = new Elysia({
    name: "@elysiajs/cors",
    seed: config3,
    aot
  });
  const anyOrigin = origins?.some((o2) => o2 === "*");
  const handleOrigin = (set, request) => {
    if (origin === true) {
      set.headers["Vary"] = "*";
      set.headers["Access-Control-Allow-Origin"] = request.headers.get("Origin") || "*";
      return;
    }
    if (anyOrigin) {
      set.headers["Vary"] = "*";
      set.headers["Access-Control-Allow-Origin"] = "*";
      return;
    }
    if (!origins?.length)
      return;
    const headers = [];
    if (origins.length) {
      const from3 = request.headers.get("Origin") ?? "";
      for (let i2 = 0; i2 < origins.length; i2++) {
        const value = processOrigin(origins[i2], request, from3);
        if (value === true) {
          set.headers["Vary"] = origin ? "Origin" : "*";
          set.headers["Access-Control-Allow-Origin"] = from3 || "*";
          return;
        }
        if (value)
          headers.push(value);
      }
    }
    set.headers["Vary"] = "Origin";
    set.headers["Access-Control-Allow-Origin"] = headers.join(", ");
  };
  const handleMethod = (set, method) => {
    if (methods === true)
      return set.headers["Access-Control-Allow-Methods"] = method ?? "*";
    if (methods === false || !methods?.length)
      return;
    if (methods === "*")
      return set.headers["Access-Control-Allow-Methods"] = "*";
    if (!Array.isArray(methods))
      return set.headers["Access-Control-Allow-Methods"] = methods;
    set.headers["Access-Control-Allow-Methods"] = methods.join(", ");
  };
  if (preflight)
    app2.options("/", ({ set, request }) => {
      handleOrigin(set, request);
      handleMethod(set, request.method);
      if (allowedHeaders.length)
        set.headers["Access-Control-Allow-Headers"] = allowedHeaders;
      if (exposedHeaders.length)
        set.headers["Access-Control-Expose-Headers"] = exposedHeaders;
      if (maxAge)
        set.headers["Access-Control-Max-Age"] = maxAge.toString();
      return new Response(null, {
        status: 204
      });
    }).options("/*", ({ set, request }) => {
      handleOrigin(set, request);
      handleMethod(set, request.method);
      if (allowedHeaders.length)
        set.headers["Access-Control-Allow-Headers"] = allowedHeaders;
      if (exposedHeaders.length)
        set.headers["Access-Control-Expose-Headers"] = exposedHeaders;
      if (maxAge)
        set.headers["Access-Control-Max-Age"] = maxAge.toString();
      return new Response(null, {
        status: 204
      });
    });
  const defaultHeaders = {
    "Access-Control-Allow-Headers": allowedHeaders,
    "Access-Control-Exposed-Headers": exposedHeaders
  };
  if (credentials === true)
    defaultHeaders["Access-Control-Allow-Credentials"] = "true";
  return app2.headers(defaultHeaders).onRequest(({ set, request }) => {
    handleOrigin(set, request);
    handleMethod(set, request.method);
    if (allowedHeaders.length)
      set.headers["Access-Control-Allow-Headers"] = allowedHeaders;
    if (exposedHeaders.length)
      set.headers["Access-Control-Expose-Headers"] = exposedHeaders;
  });
};
var dist_default = cors;

// node_modules/@elysiajs/server-timing/dist/index.mjs
init_process();
init_buffer();
var getLabel = (event, listener, write4) => {
  listener(async ({ onStop, onEvent, total }) => {
    let label = "";
    if (total === 0)
      return;
    onEvent(({ name, index: index3, onStop: onStop2 }) => {
      onStop2(({ elapsed }) => {
        label += `${event}.${index3}.${name || "anon"};dur=${elapsed},`;
      });
    });
    onStop(({ elapsed }) => {
      label += `${event};dur=${elapsed},`;
      write4(label);
    });
  });
};
var serverTiming = ({
  allow,
  enabled = true,
  trace: {
    request: traceRequest = true,
    parse: traceParse = true,
    transform: traceTransform = true,
    beforeHandle: traceBeforeHandle = true,
    handle: traceHandle = true,
    afterHandle: traceAfterHandle = true,
    error: traceError = true,
    mapResponse: traceMapResponse = true,
    total: traceTotal = true
  } = {}
} = {}) => {
  const app2 = new Elysia();
  if (enabled) {
    app2.trace(
      { as: "global" },
      async ({
        onRequest,
        onParse,
        onTransform,
        onBeforeHandle,
        onHandle,
        onAfterHandle,
        onMapResponse,
        onError,
        set,
        context,
        context: {
          request: { method }
        }
      }) => {
        let label = "";
        const write4 = (nextValue) => {
          label += nextValue;
        };
        let start;
        onRequest(({ begin }) => {
          start = begin;
        });
        if (traceRequest)
          getLabel("request", onRequest, write4);
        if (traceParse)
          getLabel("parse", onParse, write4);
        if (traceTransform)
          getLabel("transform", onTransform, write4);
        if (traceBeforeHandle)
          getLabel("beforeHandle", onBeforeHandle, write4);
        if (traceAfterHandle)
          getLabel("afterHandle", onAfterHandle, write4);
        if (traceError)
          getLabel("error", onError, write4);
        if (traceMapResponse)
          getLabel("mapResponse", onMapResponse, write4);
        if (traceHandle)
          onHandle(({ name, onStop }) => {
            onStop(({ elapsed }) => {
              label += `handle.${name};dur=${elapsed}`;
            });
          });
        onMapResponse(({ onStop }) => {
          onStop(async ({ end }) => {
            let allowed = allow;
            if (allowed instanceof Promise)
              allowed = await allowed;
            if (traceTotal)
              label += `total;dur=${end - start}`;
            switch (typeof allowed) {
              case "boolean":
                if (allowed === false)
                  delete set.headers["Server-Timing"];
                set.headers["Server-Timing"] = label;
                break;
              case "function":
                if (await allowed(context) === false)
                  delete set.headers["Server-Timing"];
                set.headers["Server-Timing"] = label;
                break;
              default:
                set.headers["Server-Timing"] = label;
            }
          });
        });
      }
    );
  }
  return app2;
};

// server/src/services/comments.ts
init_process();
init_buffer();

// server/src/setup.ts
init_process();
init_buffer();
var import_elysia_oauth2 = __toESM(require_dist(), 1);

// server/src/utils/di.ts
init_process();
init_buffer();
var envToken = "env";
var dbToken = "db";
var getEnv = () => esm5_default.get(envToken);
var getDB = () => esm5_default.get(dbToken);

// server/src/utils/jwt.ts
init_process();
init_buffer();

// node_modules/jose/dist/browser/index.js
init_process();
init_buffer();

// node_modules/jose/dist/browser/runtime/base64url.js
init_process();
init_buffer();

// node_modules/jose/dist/browser/lib/buffer_utils.js
init_process();
init_buffer();

// node_modules/jose/dist/browser/runtime/webcrypto.js
init_process();
init_buffer();
var webcrypto_default = crypto;
var isCryptoKey = (key2) => key2 instanceof CryptoKey;

// node_modules/jose/dist/browser/lib/buffer_utils.js
var encoder2 = new TextEncoder();
var decoder = new TextDecoder();
var MAX_INT322 = 2 ** 32;
function concat2(...buffers) {
  const size = buffers.reduce((acc, { length }) => acc + length, 0);
  const buf = new Uint8Array(size);
  let i2 = 0;
  for (const buffer of buffers) {
    buf.set(buffer, i2);
    i2 += buffer.length;
  }
  return buf;
}

// node_modules/jose/dist/browser/runtime/base64url.js
var encodeBase642 = (input) => {
  let unencoded = input;
  if (typeof unencoded === "string") {
    unencoded = encoder2.encode(unencoded);
  }
  const CHUNK_SIZE = 32768;
  const arr = [];
  for (let i2 = 0; i2 < unencoded.length; i2 += CHUNK_SIZE) {
    arr.push(String.fromCharCode.apply(null, unencoded.subarray(i2, i2 + CHUNK_SIZE)));
  }
  return btoa(arr.join(""));
};
var encode = (input) => {
  return encodeBase642(input).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
};
var decodeBase642 = (encoded) => {
  const binary = atob(encoded);
  const bytes = new Uint8Array(binary.length);
  for (let i2 = 0; i2 < binary.length; i2++) {
    bytes[i2] = binary.charCodeAt(i2);
  }
  return bytes;
};
var decode = (input) => {
  let encoded = input;
  if (encoded instanceof Uint8Array) {
    encoded = decoder.decode(encoded);
  }
  encoded = encoded.replace(/-/g, "+").replace(/_/g, "/").replace(/\s/g, "");
  try {
    return decodeBase642(encoded);
  } catch {
    throw new TypeError("The input to be decoded is not correctly encoded.");
  }
};

// node_modules/jose/dist/browser/util/errors.js
init_process();
init_buffer();
var JOSEError = class extends Error {
  static get code() {
    return "ERR_JOSE_GENERIC";
  }
  constructor(message2) {
    super(message2);
    this.code = "ERR_JOSE_GENERIC";
    this.name = this.constructor.name;
    Error.captureStackTrace?.(this, this.constructor);
  }
};
var JWTClaimValidationFailed = class extends JOSEError {
  static get code() {
    return "ERR_JWT_CLAIM_VALIDATION_FAILED";
  }
  constructor(message2, payload, claim = "unspecified", reason = "unspecified") {
    super(message2);
    this.code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
    this.claim = claim;
    this.reason = reason;
    this.payload = payload;
  }
};
var JWTExpired = class extends JOSEError {
  static get code() {
    return "ERR_JWT_EXPIRED";
  }
  constructor(message2, payload, claim = "unspecified", reason = "unspecified") {
    super(message2);
    this.code = "ERR_JWT_EXPIRED";
    this.claim = claim;
    this.reason = reason;
    this.payload = payload;
  }
};
var JOSEAlgNotAllowed = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JOSE_ALG_NOT_ALLOWED";
  }
  static get code() {
    return "ERR_JOSE_ALG_NOT_ALLOWED";
  }
};
var JOSENotSupported = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JOSE_NOT_SUPPORTED";
  }
  static get code() {
    return "ERR_JOSE_NOT_SUPPORTED";
  }
};
var JWSInvalid = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWS_INVALID";
  }
  static get code() {
    return "ERR_JWS_INVALID";
  }
};
var JWTInvalid = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWT_INVALID";
  }
  static get code() {
    return "ERR_JWT_INVALID";
  }
};
var JWSSignatureVerificationFailed = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
    this.message = "signature verification failed";
  }
  static get code() {
    return "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
  }
};

// node_modules/jose/dist/browser/lib/crypto_key.js
init_process();
init_buffer();
function unusable(name, prop = "algorithm.name") {
  return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);
}
function isAlgorithm(algorithm, name) {
  return algorithm.name === name;
}
function getHashLength(hash) {
  return parseInt(hash.name.slice(4), 10);
}
function getNamedCurve(alg) {
  switch (alg) {
    case "ES256":
      return "P-256";
    case "ES384":
      return "P-384";
    case "ES512":
      return "P-521";
    default:
      throw new Error("unreachable");
  }
}
function checkUsage(key2, usages) {
  if (usages.length && !usages.some((expected) => key2.usages.includes(expected))) {
    let msg = "CryptoKey does not support this operation, its usages must include ";
    if (usages.length > 2) {
      const last = usages.pop();
      msg += `one of ${usages.join(", ")}, or ${last}.`;
    } else if (usages.length === 2) {
      msg += `one of ${usages[0]} or ${usages[1]}.`;
    } else {
      msg += `${usages[0]}.`;
    }
    throw new TypeError(msg);
  }
}
function checkSigCryptoKey(key2, alg, ...usages) {
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512": {
      if (!isAlgorithm(key2.algorithm, "HMAC"))
        throw unusable("HMAC");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key2.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "RS256":
    case "RS384":
    case "RS512": {
      if (!isAlgorithm(key2.algorithm, "RSASSA-PKCS1-v1_5"))
        throw unusable("RSASSA-PKCS1-v1_5");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key2.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "PS256":
    case "PS384":
    case "PS512": {
      if (!isAlgorithm(key2.algorithm, "RSA-PSS"))
        throw unusable("RSA-PSS");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key2.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "EdDSA": {
      if (key2.algorithm.name !== "Ed25519" && key2.algorithm.name !== "Ed448") {
        throw unusable("Ed25519 or Ed448");
      }
      break;
    }
    case "ES256":
    case "ES384":
    case "ES512": {
      if (!isAlgorithm(key2.algorithm, "ECDSA"))
        throw unusable("ECDSA");
      const expected = getNamedCurve(alg);
      const actual = key2.algorithm.namedCurve;
      if (actual !== expected)
        throw unusable(expected, "algorithm.namedCurve");
      break;
    }
    default:
      throw new TypeError("CryptoKey does not support this operation");
  }
  checkUsage(key2, usages);
}

// node_modules/jose/dist/browser/lib/invalid_key_input.js
init_process();
init_buffer();
function message(msg, actual, ...types2) {
  if (types2.length > 2) {
    const last = types2.pop();
    msg += `one of type ${types2.join(", ")}, or ${last}.`;
  } else if (types2.length === 2) {
    msg += `one of type ${types2[0]} or ${types2[1]}.`;
  } else {
    msg += `of type ${types2[0]}.`;
  }
  if (actual == null) {
    msg += ` Received ${actual}`;
  } else if (typeof actual === "function" && actual.name) {
    msg += ` Received function ${actual.name}`;
  } else if (typeof actual === "object" && actual != null) {
    if (actual.constructor?.name) {
      msg += ` Received an instance of ${actual.constructor.name}`;
    }
  }
  return msg;
}
var invalid_key_input_default = (actual, ...types2) => {
  return message("Key must be ", actual, ...types2);
};
function withAlg(alg, actual, ...types2) {
  return message(`Key for the ${alg} algorithm must be `, actual, ...types2);
}

// node_modules/jose/dist/browser/runtime/is_key_like.js
init_process();
init_buffer();
var is_key_like_default = (key2) => {
  if (isCryptoKey(key2)) {
    return true;
  }
  return key2?.[Symbol.toStringTag] === "KeyObject";
};
var types = ["CryptoKey"];

// node_modules/jose/dist/browser/lib/is_disjoint.js
init_process();
init_buffer();
var isDisjoint = (...headers) => {
  const sources = headers.filter(Boolean);
  if (sources.length === 0 || sources.length === 1) {
    return true;
  }
  let acc;
  for (const header of sources) {
    const parameters = Object.keys(header);
    if (!acc || acc.size === 0) {
      acc = new Set(parameters);
      continue;
    }
    for (const parameter of parameters) {
      if (acc.has(parameter)) {
        return false;
      }
      acc.add(parameter);
    }
  }
  return true;
};
var is_disjoint_default = isDisjoint;

// node_modules/jose/dist/browser/lib/is_object.js
init_process();
init_buffer();
function isObjectLike(value) {
  return typeof value === "object" && value !== null;
}
function isObject2(input) {
  if (!isObjectLike(input) || Object.prototype.toString.call(input) !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(input) === null) {
    return true;
  }
  let proto = input;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(input) === proto;
}

// node_modules/jose/dist/browser/runtime/check_key_length.js
init_process();
init_buffer();
var check_key_length_default = (alg, key2) => {
  if (alg.startsWith("RS") || alg.startsWith("PS")) {
    const { modulusLength } = key2.algorithm;
    if (typeof modulusLength !== "number" || modulusLength < 2048) {
      throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
    }
  }
};

// node_modules/jose/dist/browser/runtime/normalize_key.js
init_process();
init_buffer();

// node_modules/jose/dist/browser/runtime/jwk_to_key.js
init_process();
init_buffer();
function subtleMapping(jwk) {
  let algorithm;
  let keyUsages;
  switch (jwk.kty) {
    case "RSA": {
      switch (jwk.alg) {
        case "PS256":
        case "PS384":
        case "PS512":
          algorithm = { name: "RSA-PSS", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "RS256":
        case "RS384":
        case "RS512":
          algorithm = { name: "RSASSA-PKCS1-v1_5", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "RSA-OAEP":
        case "RSA-OAEP-256":
        case "RSA-OAEP-384":
        case "RSA-OAEP-512":
          algorithm = {
            name: "RSA-OAEP",
            hash: `SHA-${parseInt(jwk.alg.slice(-3), 10) || 1}`
          };
          keyUsages = jwk.d ? ["decrypt", "unwrapKey"] : ["encrypt", "wrapKey"];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "EC": {
      switch (jwk.alg) {
        case "ES256":
          algorithm = { name: "ECDSA", namedCurve: "P-256" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ES384":
          algorithm = { name: "ECDSA", namedCurve: "P-384" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ES512":
          algorithm = { name: "ECDSA", namedCurve: "P-521" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          algorithm = { name: "ECDH", namedCurve: jwk.crv };
          keyUsages = jwk.d ? ["deriveBits"] : [];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "OKP": {
      switch (jwk.alg) {
        case "EdDSA":
          algorithm = { name: jwk.crv };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          algorithm = { name: jwk.crv };
          keyUsages = jwk.d ? ["deriveBits"] : [];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    default:
      throw new JOSENotSupported('Invalid or unsupported JWK "kty" (Key Type) Parameter value');
  }
  return { algorithm, keyUsages };
}
var parse2 = async (jwk) => {
  if (!jwk.alg) {
    throw new TypeError('"alg" argument is required when "jwk.alg" is not present');
  }
  const { algorithm, keyUsages } = subtleMapping(jwk);
  const rest = [
    algorithm,
    jwk.ext ?? false,
    jwk.key_ops ?? keyUsages
  ];
  const keyData = { ...jwk };
  delete keyData.alg;
  delete keyData.use;
  return webcrypto_default.subtle.importKey("jwk", keyData, ...rest);
};
var jwk_to_key_default = parse2;

// node_modules/jose/dist/browser/runtime/normalize_key.js
var normalizeSecretKey = (k2) => decode(k2);
var privCache;
var pubCache;
var isKeyObject = (key2) => {
  return key2?.[Symbol.toStringTag] === "KeyObject";
};
var importAndCache = async (cache, key2, jwk, alg) => {
  let cached = cache.get(key2);
  if (cached?.[alg]) {
    return cached[alg];
  }
  const cryptoKey = await jwk_to_key_default({ ...jwk, alg });
  if (!cached) {
    cache.set(key2, { [alg]: cryptoKey });
  } else {
    cached[alg] = cryptoKey;
  }
  return cryptoKey;
};
var normalizePublicKey = (key2, alg) => {
  if (isKeyObject(key2)) {
    let jwk = key2.export({ format: "jwk" });
    delete jwk.d;
    delete jwk.dp;
    delete jwk.dq;
    delete jwk.p;
    delete jwk.q;
    delete jwk.qi;
    if (jwk.k) {
      return normalizeSecretKey(jwk.k);
    }
    pubCache || (pubCache = /* @__PURE__ */ new WeakMap());
    return importAndCache(pubCache, key2, jwk, alg);
  }
  return key2;
};
var normalizePrivateKey = (key2, alg) => {
  if (isKeyObject(key2)) {
    let jwk = key2.export({ format: "jwk" });
    if (jwk.k) {
      return normalizeSecretKey(jwk.k);
    }
    privCache || (privCache = /* @__PURE__ */ new WeakMap());
    return importAndCache(privCache, key2, jwk, alg);
  }
  return key2;
};
var normalize_key_default = { normalizePublicKey, normalizePrivateKey };

// node_modules/jose/dist/browser/lib/check_key_type.js
init_process();
init_buffer();
var tag = (key2) => key2?.[Symbol.toStringTag];
var symmetricTypeCheck = (alg, key2) => {
  if (key2 instanceof Uint8Array)
    return;
  if (!is_key_like_default(key2)) {
    throw new TypeError(withAlg(alg, key2, ...types, "Uint8Array"));
  }
  if (key2.type !== "secret") {
    throw new TypeError(`${tag(key2)} instances for symmetric algorithms must be of type "secret"`);
  }
};
var asymmetricTypeCheck = (alg, key2, usage) => {
  if (!is_key_like_default(key2)) {
    throw new TypeError(withAlg(alg, key2, ...types));
  }
  if (key2.type === "secret") {
    throw new TypeError(`${tag(key2)} instances for asymmetric algorithms must not be of type "secret"`);
  }
  if (usage === "sign" && key2.type === "public") {
    throw new TypeError(`${tag(key2)} instances for asymmetric algorithm signing must be of type "private"`);
  }
  if (usage === "decrypt" && key2.type === "public") {
    throw new TypeError(`${tag(key2)} instances for asymmetric algorithm decryption must be of type "private"`);
  }
  if (key2.algorithm && usage === "verify" && key2.type === "private") {
    throw new TypeError(`${tag(key2)} instances for asymmetric algorithm verifying must be of type "public"`);
  }
  if (key2.algorithm && usage === "encrypt" && key2.type === "private") {
    throw new TypeError(`${tag(key2)} instances for asymmetric algorithm encryption must be of type "public"`);
  }
};
var checkKeyType = (alg, key2, usage) => {
  const symmetric = alg.startsWith("HS") || alg === "dir" || alg.startsWith("PBES2") || /^A\d{3}(?:GCM)?KW$/.test(alg);
  if (symmetric) {
    symmetricTypeCheck(alg, key2);
  } else {
    asymmetricTypeCheck(alg, key2, usage);
  }
};
var check_key_type_default = checkKeyType;

// node_modules/jose/dist/browser/lib/validate_crit.js
init_process();
init_buffer();
function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
  if (joseHeader.crit !== void 0 && protectedHeader?.crit === void 0) {
    throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
  }
  if (!protectedHeader || protectedHeader.crit === void 0) {
    return /* @__PURE__ */ new Set();
  }
  if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input) => typeof input !== "string" || input.length === 0)) {
    throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
  }
  let recognized;
  if (recognizedOption !== void 0) {
    recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
  } else {
    recognized = recognizedDefault;
  }
  for (const parameter of protectedHeader.crit) {
    if (!recognized.has(parameter)) {
      throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
    }
    if (joseHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" is missing`);
    }
    if (recognized.get(parameter) && protectedHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
    }
  }
  return new Set(protectedHeader.crit);
}
var validate_crit_default = validateCrit;

// node_modules/jose/dist/browser/lib/validate_algorithms.js
init_process();
init_buffer();
var validateAlgorithms = (option2, algorithms) => {
  if (algorithms !== void 0 && (!Array.isArray(algorithms) || algorithms.some((s2) => typeof s2 !== "string"))) {
    throw new TypeError(`"${option2}" option must be an array of strings`);
  }
  if (!algorithms) {
    return void 0;
  }
  return new Set(algorithms);
};
var validate_algorithms_default = validateAlgorithms;

// node_modules/jose/dist/browser/jws/compact/verify.js
init_process();
init_buffer();

// node_modules/jose/dist/browser/jws/flattened/verify.js
init_process();
init_buffer();

// node_modules/jose/dist/browser/runtime/verify.js
init_process();
init_buffer();

// node_modules/jose/dist/browser/runtime/subtle_dsa.js
init_process();
init_buffer();
function subtleDsa(alg, algorithm) {
  const hash = `SHA-${alg.slice(-3)}`;
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512":
      return { hash, name: "HMAC" };
    case "PS256":
    case "PS384":
    case "PS512":
      return { hash, name: "RSA-PSS", saltLength: alg.slice(-3) >> 3 };
    case "RS256":
    case "RS384":
    case "RS512":
      return { hash, name: "RSASSA-PKCS1-v1_5" };
    case "ES256":
    case "ES384":
    case "ES512":
      return { hash, name: "ECDSA", namedCurve: algorithm.namedCurve };
    case "EdDSA":
      return { name: algorithm.name };
    default:
      throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
  }
}

// node_modules/jose/dist/browser/runtime/get_sign_verify_key.js
init_process();
init_buffer();
async function getCryptoKey(alg, key2, usage) {
  if (usage === "sign") {
    key2 = await normalize_key_default.normalizePrivateKey(key2, alg);
  }
  if (usage === "verify") {
    key2 = await normalize_key_default.normalizePublicKey(key2, alg);
  }
  if (isCryptoKey(key2)) {
    checkSigCryptoKey(key2, alg, usage);
    return key2;
  }
  if (key2 instanceof Uint8Array) {
    if (!alg.startsWith("HS")) {
      throw new TypeError(invalid_key_input_default(key2, ...types));
    }
    return webcrypto_default.subtle.importKey("raw", key2, { hash: `SHA-${alg.slice(-3)}`, name: "HMAC" }, false, [usage]);
  }
  throw new TypeError(invalid_key_input_default(key2, ...types, "Uint8Array"));
}

// node_modules/jose/dist/browser/runtime/verify.js
var verify = async (alg, key2, signature, data) => {
  const cryptoKey = await getCryptoKey(alg, key2, "verify");
  check_key_length_default(alg, cryptoKey);
  const algorithm = subtleDsa(alg, cryptoKey.algorithm);
  try {
    return await webcrypto_default.subtle.verify(algorithm, cryptoKey, signature, data);
  } catch {
    return false;
  }
};
var verify_default = verify;

// node_modules/jose/dist/browser/jws/flattened/verify.js
async function flattenedVerify(jws, key2, options) {
  if (!isObject2(jws)) {
    throw new JWSInvalid("Flattened JWS must be an object");
  }
  if (jws.protected === void 0 && jws.header === void 0) {
    throw new JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');
  }
  if (jws.protected !== void 0 && typeof jws.protected !== "string") {
    throw new JWSInvalid("JWS Protected Header incorrect type");
  }
  if (jws.payload === void 0) {
    throw new JWSInvalid("JWS Payload missing");
  }
  if (typeof jws.signature !== "string") {
    throw new JWSInvalid("JWS Signature missing or incorrect type");
  }
  if (jws.header !== void 0 && !isObject2(jws.header)) {
    throw new JWSInvalid("JWS Unprotected Header incorrect type");
  }
  let parsedProt = {};
  if (jws.protected) {
    try {
      const protectedHeader = decode(jws.protected);
      parsedProt = JSON.parse(decoder.decode(protectedHeader));
    } catch {
      throw new JWSInvalid("JWS Protected Header is invalid");
    }
  }
  if (!is_disjoint_default(parsedProt, jws.header)) {
    throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
  }
  const joseHeader = {
    ...parsedProt,
    ...jws.header
  };
  const extensions = validate_crit_default(JWSInvalid, /* @__PURE__ */ new Map([["b64", true]]), options?.crit, parsedProt, joseHeader);
  let b64 = true;
  if (extensions.has("b64")) {
    b64 = parsedProt.b64;
    if (typeof b64 !== "boolean") {
      throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
    }
  }
  const { alg } = joseHeader;
  if (typeof alg !== "string" || !alg) {
    throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
  }
  const algorithms = options && validate_algorithms_default("algorithms", options.algorithms);
  if (algorithms && !algorithms.has(alg)) {
    throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter value not allowed');
  }
  if (b64) {
    if (typeof jws.payload !== "string") {
      throw new JWSInvalid("JWS Payload must be a string");
    }
  } else if (typeof jws.payload !== "string" && !(jws.payload instanceof Uint8Array)) {
    throw new JWSInvalid("JWS Payload must be a string or an Uint8Array instance");
  }
  let resolvedKey = false;
  if (typeof key2 === "function") {
    key2 = await key2(parsedProt, jws);
    resolvedKey = true;
  }
  check_key_type_default(alg, key2, "verify");
  const data = concat2(encoder2.encode(jws.protected ?? ""), encoder2.encode("."), typeof jws.payload === "string" ? encoder2.encode(jws.payload) : jws.payload);
  let signature;
  try {
    signature = decode(jws.signature);
  } catch {
    throw new JWSInvalid("Failed to base64url decode the signature");
  }
  const verified = await verify_default(alg, key2, signature, data);
  if (!verified) {
    throw new JWSSignatureVerificationFailed();
  }
  let payload;
  if (b64) {
    try {
      payload = decode(jws.payload);
    } catch {
      throw new JWSInvalid("Failed to base64url decode the payload");
    }
  } else if (typeof jws.payload === "string") {
    payload = encoder2.encode(jws.payload);
  } else {
    payload = jws.payload;
  }
  const result = { payload };
  if (jws.protected !== void 0) {
    result.protectedHeader = parsedProt;
  }
  if (jws.header !== void 0) {
    result.unprotectedHeader = jws.header;
  }
  if (resolvedKey) {
    return { ...result, key: key2 };
  }
  return result;
}

// node_modules/jose/dist/browser/jws/compact/verify.js
async function compactVerify(jws, key2, options) {
  if (jws instanceof Uint8Array) {
    jws = decoder.decode(jws);
  }
  if (typeof jws !== "string") {
    throw new JWSInvalid("Compact JWS must be a string or Uint8Array");
  }
  const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split(".");
  if (length !== 3) {
    throw new JWSInvalid("Invalid Compact JWS");
  }
  const verified = await flattenedVerify({ payload, protected: protectedHeader, signature }, key2, options);
  const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };
  if (typeof key2 === "function") {
    return { ...result, key: verified.key };
  }
  return result;
}

// node_modules/jose/dist/browser/jwt/verify.js
init_process();
init_buffer();

// node_modules/jose/dist/browser/lib/jwt_claims_set.js
init_process();
init_buffer();

// node_modules/jose/dist/browser/lib/epoch.js
init_process();
init_buffer();
var epoch_default = (date2) => Math.floor(date2.getTime() / 1e3);

// node_modules/jose/dist/browser/lib/secs.js
init_process();
init_buffer();
var minute = 60;
var hour = minute * 60;
var day = hour * 24;
var week = day * 7;
var year = day * 365.25;
var REGEX = /^(\+|\-)? ?(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i;
var secs_default = (str) => {
  const matched = REGEX.exec(str);
  if (!matched || matched[4] && matched[1]) {
    throw new TypeError("Invalid time period format");
  }
  const value = parseFloat(matched[2]);
  const unit = matched[3].toLowerCase();
  let numericDate;
  switch (unit) {
    case "sec":
    case "secs":
    case "second":
    case "seconds":
    case "s":
      numericDate = Math.round(value);
      break;
    case "minute":
    case "minutes":
    case "min":
    case "mins":
    case "m":
      numericDate = Math.round(value * minute);
      break;
    case "hour":
    case "hours":
    case "hr":
    case "hrs":
    case "h":
      numericDate = Math.round(value * hour);
      break;
    case "day":
    case "days":
    case "d":
      numericDate = Math.round(value * day);
      break;
    case "week":
    case "weeks":
    case "w":
      numericDate = Math.round(value * week);
      break;
    default:
      numericDate = Math.round(value * year);
      break;
  }
  if (matched[1] === "-" || matched[4] === "ago") {
    return -numericDate;
  }
  return numericDate;
};

// node_modules/jose/dist/browser/lib/jwt_claims_set.js
var normalizeTyp = (value) => value.toLowerCase().replace(/^application\//, "");
var checkAudiencePresence = (audPayload, audOption) => {
  if (typeof audPayload === "string") {
    return audOption.includes(audPayload);
  }
  if (Array.isArray(audPayload)) {
    return audOption.some(Set.prototype.has.bind(new Set(audPayload)));
  }
  return false;
};
var jwt_claims_set_default = (protectedHeader, encodedPayload, options = {}) => {
  let payload;
  try {
    payload = JSON.parse(decoder.decode(encodedPayload));
  } catch {
  }
  if (!isObject2(payload)) {
    throw new JWTInvalid("JWT Claims Set must be a top-level JSON object");
  }
  const { typ } = options;
  if (typ && (typeof protectedHeader.typ !== "string" || normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {
    throw new JWTClaimValidationFailed('unexpected "typ" JWT header value', payload, "typ", "check_failed");
  }
  const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options;
  const presenceCheck = [...requiredClaims];
  if (maxTokenAge !== void 0)
    presenceCheck.push("iat");
  if (audience !== void 0)
    presenceCheck.push("aud");
  if (subject !== void 0)
    presenceCheck.push("sub");
  if (issuer !== void 0)
    presenceCheck.push("iss");
  for (const claim of new Set(presenceCheck.reverse())) {
    if (!(claim in payload)) {
      throw new JWTClaimValidationFailed(`missing required "${claim}" claim`, payload, claim, "missing");
    }
  }
  if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {
    throw new JWTClaimValidationFailed('unexpected "iss" claim value', payload, "iss", "check_failed");
  }
  if (subject && payload.sub !== subject) {
    throw new JWTClaimValidationFailed('unexpected "sub" claim value', payload, "sub", "check_failed");
  }
  if (audience && !checkAudiencePresence(payload.aud, typeof audience === "string" ? [audience] : audience)) {
    throw new JWTClaimValidationFailed('unexpected "aud" claim value', payload, "aud", "check_failed");
  }
  let tolerance;
  switch (typeof options.clockTolerance) {
    case "string":
      tolerance = secs_default(options.clockTolerance);
      break;
    case "number":
      tolerance = options.clockTolerance;
      break;
    case "undefined":
      tolerance = 0;
      break;
    default:
      throw new TypeError("Invalid clockTolerance option type");
  }
  const { currentDate } = options;
  const now = epoch_default(currentDate || /* @__PURE__ */ new Date());
  if ((payload.iat !== void 0 || maxTokenAge) && typeof payload.iat !== "number") {
    throw new JWTClaimValidationFailed('"iat" claim must be a number', payload, "iat", "invalid");
  }
  if (payload.nbf !== void 0) {
    if (typeof payload.nbf !== "number") {
      throw new JWTClaimValidationFailed('"nbf" claim must be a number', payload, "nbf", "invalid");
    }
    if (payload.nbf > now + tolerance) {
      throw new JWTClaimValidationFailed('"nbf" claim timestamp check failed', payload, "nbf", "check_failed");
    }
  }
  if (payload.exp !== void 0) {
    if (typeof payload.exp !== "number") {
      throw new JWTClaimValidationFailed('"exp" claim must be a number', payload, "exp", "invalid");
    }
    if (payload.exp <= now - tolerance) {
      throw new JWTExpired('"exp" claim timestamp check failed', payload, "exp", "check_failed");
    }
  }
  if (maxTokenAge) {
    const age = now - payload.iat;
    const max = typeof maxTokenAge === "number" ? maxTokenAge : secs_default(maxTokenAge);
    if (age - tolerance > max) {
      throw new JWTExpired('"iat" claim timestamp check failed (too far in the past)', payload, "iat", "check_failed");
    }
    if (age < 0 - tolerance) {
      throw new JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', payload, "iat", "check_failed");
    }
  }
  return payload;
};

// node_modules/jose/dist/browser/jwt/verify.js
async function jwtVerify(jwt2, key2, options) {
  const verified = await compactVerify(jwt2, key2, options);
  if (verified.protectedHeader.crit?.includes("b64") && verified.protectedHeader.b64 === false) {
    throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
  }
  const payload = jwt_claims_set_default(verified.protectedHeader, verified.payload, options);
  const result = { payload, protectedHeader: verified.protectedHeader };
  if (typeof key2 === "function") {
    return { ...result, key: verified.key };
  }
  return result;
}

// node_modules/jose/dist/browser/jws/compact/sign.js
init_process();
init_buffer();

// node_modules/jose/dist/browser/jws/flattened/sign.js
init_process();
init_buffer();

// node_modules/jose/dist/browser/runtime/sign.js
init_process();
init_buffer();
var sign = async (alg, key2, data) => {
  const cryptoKey = await getCryptoKey(alg, key2, "sign");
  check_key_length_default(alg, cryptoKey);
  const signature = await webcrypto_default.subtle.sign(subtleDsa(alg, cryptoKey.algorithm), cryptoKey, data);
  return new Uint8Array(signature);
};
var sign_default = sign;

// node_modules/jose/dist/browser/jws/flattened/sign.js
var FlattenedSign = class {
  constructor(payload) {
    if (!(payload instanceof Uint8Array)) {
      throw new TypeError("payload must be an instance of Uint8Array");
    }
    this._payload = payload;
  }
  setProtectedHeader(protectedHeader) {
    if (this._protectedHeader) {
      throw new TypeError("setProtectedHeader can only be called once");
    }
    this._protectedHeader = protectedHeader;
    return this;
  }
  setUnprotectedHeader(unprotectedHeader) {
    if (this._unprotectedHeader) {
      throw new TypeError("setUnprotectedHeader can only be called once");
    }
    this._unprotectedHeader = unprotectedHeader;
    return this;
  }
  async sign(key2, options) {
    if (!this._protectedHeader && !this._unprotectedHeader) {
      throw new JWSInvalid("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");
    }
    if (!is_disjoint_default(this._protectedHeader, this._unprotectedHeader)) {
      throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
    }
    const joseHeader = {
      ...this._protectedHeader,
      ...this._unprotectedHeader
    };
    const extensions = validate_crit_default(JWSInvalid, /* @__PURE__ */ new Map([["b64", true]]), options?.crit, this._protectedHeader, joseHeader);
    let b64 = true;
    if (extensions.has("b64")) {
      b64 = this._protectedHeader.b64;
      if (typeof b64 !== "boolean") {
        throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
      }
    }
    const { alg } = joseHeader;
    if (typeof alg !== "string" || !alg) {
      throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
    }
    check_key_type_default(alg, key2, "sign");
    let payload = this._payload;
    if (b64) {
      payload = encoder2.encode(encode(payload));
    }
    let protectedHeader;
    if (this._protectedHeader) {
      protectedHeader = encoder2.encode(encode(JSON.stringify(this._protectedHeader)));
    } else {
      protectedHeader = encoder2.encode("");
    }
    const data = concat2(protectedHeader, encoder2.encode("."), payload);
    const signature = await sign_default(alg, key2, data);
    const jws = {
      signature: encode(signature),
      payload: ""
    };
    if (b64) {
      jws.payload = decoder.decode(payload);
    }
    if (this._unprotectedHeader) {
      jws.header = this._unprotectedHeader;
    }
    if (this._protectedHeader) {
      jws.protected = decoder.decode(protectedHeader);
    }
    return jws;
  }
};

// node_modules/jose/dist/browser/jws/compact/sign.js
var CompactSign = class {
  constructor(payload) {
    this._flattened = new FlattenedSign(payload);
  }
  setProtectedHeader(protectedHeader) {
    this._flattened.setProtectedHeader(protectedHeader);
    return this;
  }
  async sign(key2, options) {
    const jws = await this._flattened.sign(key2, options);
    if (jws.payload === void 0) {
      throw new TypeError("use the flattened module for creating JWS with b64: false");
    }
    return `${jws.protected}.${jws.payload}.${jws.signature}`;
  }
};

// node_modules/jose/dist/browser/jwt/sign.js
init_process();
init_buffer();

// node_modules/jose/dist/browser/jwt/produce.js
init_process();
init_buffer();
function validateInput(label, input) {
  if (!Number.isFinite(input)) {
    throw new TypeError(`Invalid ${label} input`);
  }
  return input;
}
var ProduceJWT = class {
  constructor(payload = {}) {
    if (!isObject2(payload)) {
      throw new TypeError("JWT Claims Set MUST be an object");
    }
    this._payload = payload;
  }
  setIssuer(issuer) {
    this._payload = { ...this._payload, iss: issuer };
    return this;
  }
  setSubject(subject) {
    this._payload = { ...this._payload, sub: subject };
    return this;
  }
  setAudience(audience) {
    this._payload = { ...this._payload, aud: audience };
    return this;
  }
  setJti(jwtId) {
    this._payload = { ...this._payload, jti: jwtId };
    return this;
  }
  setNotBefore(input) {
    if (typeof input === "number") {
      this._payload = { ...this._payload, nbf: validateInput("setNotBefore", input) };
    } else if (input instanceof Date) {
      this._payload = { ...this._payload, nbf: validateInput("setNotBefore", epoch_default(input)) };
    } else {
      this._payload = { ...this._payload, nbf: epoch_default(/* @__PURE__ */ new Date()) + secs_default(input) };
    }
    return this;
  }
  setExpirationTime(input) {
    if (typeof input === "number") {
      this._payload = { ...this._payload, exp: validateInput("setExpirationTime", input) };
    } else if (input instanceof Date) {
      this._payload = { ...this._payload, exp: validateInput("setExpirationTime", epoch_default(input)) };
    } else {
      this._payload = { ...this._payload, exp: epoch_default(/* @__PURE__ */ new Date()) + secs_default(input) };
    }
    return this;
  }
  setIssuedAt(input) {
    if (typeof input === "undefined") {
      this._payload = { ...this._payload, iat: epoch_default(/* @__PURE__ */ new Date()) };
    } else if (input instanceof Date) {
      this._payload = { ...this._payload, iat: validateInput("setIssuedAt", epoch_default(input)) };
    } else if (typeof input === "string") {
      this._payload = {
        ...this._payload,
        iat: validateInput("setIssuedAt", epoch_default(/* @__PURE__ */ new Date()) + secs_default(input))
      };
    } else {
      this._payload = { ...this._payload, iat: validateInput("setIssuedAt", input) };
    }
    return this;
  }
};

// node_modules/jose/dist/browser/jwt/sign.js
var SignJWT = class extends ProduceJWT {
  setProtectedHeader(protectedHeader) {
    this._protectedHeader = protectedHeader;
    return this;
  }
  async sign(key2, options) {
    const sig = new CompactSign(encoder2.encode(JSON.stringify(this._payload)));
    sig.setProtectedHeader(this._protectedHeader);
    if (Array.isArray(this._protectedHeader?.crit) && this._protectedHeader.crit.includes("b64") && this._protectedHeader.b64 === false) {
      throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
    }
    return sig.sign(key2, options);
  }
};

// server/src/utils/jwt.ts
var jwt = ({
  name = "jwt",
  secret,
  // Start JWT Header
  alg = "HS256",
  crit,
  schema,
  // End JWT Header
  // Start JWT Payload
  nbf,
  exp,
  aot = true,
  ...payload
}) => {
  if (!secret)
    throw new Error("Secret can't be empty");
  const key2 = typeof secret === "string" ? new TextEncoder().encode(secret) : secret;
  const dynamic = !aot;
  const validator = schema ? getSchemaValidator(
    Type.Intersect([
      schema,
      Type.Object({
        iss: Type.Optional(Type.String()),
        sub: Type.Optional(Type.String()),
        aud: Type.Optional(
          Type.Union([Type.String(), Type.Array(Type.String())])
        ),
        jti: Type.Optional(Type.String()),
        nbf: Type.Optional(Type.Union([Type.String(), Type.Number()])),
        exp: Type.Optional(Type.Union([Type.String(), Type.Number()])),
        iat: Type.Optional(Type.String())
      })
    ]),
    { dynamic }
  ) : void 0;
  return new Elysia({
    name: "@elysiajs/jwt",
    seed: {
      name,
      secret,
      alg,
      crit,
      schema,
      nbf,
      exp,
      ...payload
    }
  }).decorate(name, {
    sign: (morePayload) => {
      let jwt2 = new SignJWT({
        ...payload,
        ...morePayload,
        nbf: void 0,
        exp: void 0
      }).setProtectedHeader({
        alg,
        crit
      });
      if (nbf)
        jwt2 = jwt2.setNotBefore(nbf);
      if (exp)
        jwt2 = jwt2.setExpirationTime(exp);
      return jwt2.sign(key2);
    },
    verify: async (jwt2) => {
      if (!jwt2)
        return false;
      try {
        const data = (await jwtVerify(jwt2, key2)).payload;
        if (validator && !validator.Check(data))
          throw new ValidationError("JWT", validator, data);
        return data;
      } catch (_) {
        return false;
      }
    }
  });
};
var jwt_default = jwt;

// server/src/setup.ts
var anyUser = async (db) => (await db.query.users.findMany())?.length > 0;
function setup() {
  const db = getDB();
  const env5 = getEnv();
  let gh_client_id = env5.RIN_GITHUB_CLIENT_ID || env5.GITHUB_CLIENT_ID;
  let gh_client_secret = env5.RIN_GITHUB_CLIENT_SECRET || env5.GITHUB_CLIENT_SECRET;
  let jwt_secret = env5.JWT_SECRET;
  if (!gh_client_id || !gh_client_secret) {
    throw new Error("Please set RIN_GITHUB_CLIENT_ID and RIN_GITHUB_CLIENT_SECRET");
  }
  if (!jwt_secret) {
    throw new Error("Please set JWT_SECRET");
  }
  const oauth = (0, import_elysia_oauth2.oauth2)({
    GitHub: [
      gh_client_id,
      gh_client_secret
    ]
  });
  return new Elysia({ aot: false, name: "setup" }).state("anyUser", anyUser).use(oauth).use(
    jwt_default({
      aot: false,
      name: "jwt",
      secret: jwt_secret,
      schema: t.Object({
        id: t.Integer()
      })
    })
  ).derive({ as: "global" }, async ({ headers, jwt: jwt2 }) => {
    const authorization = headers["authorization"];
    if (!authorization) {
      return {};
    }
    const token = authorization.split(" ")[1];
    if ("undefined"?.toLowerCase() === "test") {
      console.warn("Now in test mode, skip jwt verification.");
      try {
        return JSON.parse(token);
      } catch (e2) {
        return {};
      }
    }
    const profile = await jwt2.verify(token);
    if (!profile) {
      return {};
    }
    const user = await db.query.users.findFirst({ where: eq(users.id, profile.id) });
    if (!user) {
      return {};
    }
    return {
      uid: user.id,
      username: user.username,
      admin: user.permission === 1
    };
  });
}

// server/src/utils/cache.ts
init_process();
init_buffer();

// node_modules/@aws-sdk/client-s3/dist-es/S3Client.js
init_process();
init_buffer();

// node_modules/@aws-sdk/middleware-expect-continue/dist-es/index.js
init_process();
init_buffer();

// node_modules/@smithy/protocol-http/dist-es/index.js
init_process();
init_buffer();

// node_modules/@smithy/protocol-http/dist-es/extensions/index.js
init_process();
init_buffer();

// node_modules/@smithy/protocol-http/dist-es/extensions/httpExtensionConfiguration.js
init_process();
init_buffer();
var getHttpHandlerExtensionConfiguration = (runtimeConfig) => {
  let httpHandler = runtimeConfig.httpHandler;
  return {
    setHttpHandler(handler) {
      httpHandler = handler;
    },
    httpHandler() {
      return httpHandler;
    },
    updateHttpClientConfig(key2, value) {
      httpHandler.updateHttpClientConfig(key2, value);
    },
    httpHandlerConfigs() {
      return httpHandler.httpHandlerConfigs();
    }
  };
};
var resolveHttpHandlerRuntimeConfig = (httpHandlerExtensionConfiguration) => {
  return {
    httpHandler: httpHandlerExtensionConfiguration.httpHandler()
  };
};

// node_modules/@smithy/protocol-http/dist-es/Field.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/index.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/abort.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/auth/index.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/auth/auth.js
init_process();
init_buffer();
var HttpAuthLocation;
(function(HttpAuthLocation2) {
  HttpAuthLocation2["HEADER"] = "header";
  HttpAuthLocation2["QUERY"] = "query";
})(HttpAuthLocation || (HttpAuthLocation = {}));

// node_modules/@smithy/types/dist-es/auth/HttpApiKeyAuth.js
init_process();
init_buffer();
var HttpApiKeyAuthLocation;
(function(HttpApiKeyAuthLocation2) {
  HttpApiKeyAuthLocation2["HEADER"] = "header";
  HttpApiKeyAuthLocation2["QUERY"] = "query";
})(HttpApiKeyAuthLocation || (HttpApiKeyAuthLocation = {}));

// node_modules/@smithy/types/dist-es/auth/HttpAuthScheme.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/auth/HttpAuthSchemeProvider.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/auth/HttpSigner.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/auth/IdentityProviderConfig.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/blob/blob-payload-input-types.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/checksum.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/client.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/command.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/connection/index.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/connection/config.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/connection/manager.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/connection/pool.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/crypto.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/encode.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/endpoint.js
init_process();
init_buffer();
var EndpointURLScheme;
(function(EndpointURLScheme2) {
  EndpointURLScheme2["HTTP"] = "http";
  EndpointURLScheme2["HTTPS"] = "https";
})(EndpointURLScheme || (EndpointURLScheme = {}));

// node_modules/@smithy/types/dist-es/endpoints/index.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/endpoints/EndpointRuleObject.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/endpoints/ErrorRuleObject.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/endpoints/RuleSetObject.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/endpoints/shared.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/endpoints/TreeRuleObject.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/eventStream.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/extensions/index.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/extensions/defaultClientConfiguration.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/extensions/checksum.js
init_process();
init_buffer();
var AlgorithmId;
(function(AlgorithmId2) {
  AlgorithmId2["MD5"] = "md5";
  AlgorithmId2["CRC32"] = "crc32";
  AlgorithmId2["CRC32C"] = "crc32c";
  AlgorithmId2["SHA1"] = "sha1";
  AlgorithmId2["SHA256"] = "sha256";
})(AlgorithmId || (AlgorithmId = {}));

// node_modules/@smithy/types/dist-es/extensions/defaultExtensionConfiguration.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/http.js
init_process();
init_buffer();
var FieldPosition;
(function(FieldPosition2) {
  FieldPosition2[FieldPosition2["HEADER"] = 0] = "HEADER";
  FieldPosition2[FieldPosition2["TRAILER"] = 1] = "TRAILER";
})(FieldPosition || (FieldPosition = {}));

// node_modules/@smithy/types/dist-es/http/httpHandlerInitialization.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/identity/index.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/identity/apiKeyIdentity.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/identity/awsCredentialIdentity.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/identity/identity.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/identity/tokenIdentity.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/logger.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/middleware.js
init_process();
init_buffer();
var SMITHY_CONTEXT_KEY = "__smithy_context";

// node_modules/@smithy/types/dist-es/pagination.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/profile.js
init_process();
init_buffer();
var IniSectionType;
(function(IniSectionType2) {
  IniSectionType2["PROFILE"] = "profile";
  IniSectionType2["SSO_SESSION"] = "sso-session";
  IniSectionType2["SERVICES"] = "services";
})(IniSectionType || (IniSectionType = {}));

// node_modules/@smithy/types/dist-es/response.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/retry.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/serde.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/shapes.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/signature.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/stream.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/streaming-payload/streaming-blob-common-types.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/streaming-payload/streaming-blob-payload-input-types.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/streaming-payload/streaming-blob-payload-output-types.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/transfer.js
init_process();
init_buffer();
var RequestHandlerProtocol;
(function(RequestHandlerProtocol2) {
  RequestHandlerProtocol2["HTTP_0_9"] = "http/0.9";
  RequestHandlerProtocol2["HTTP_1_0"] = "http/1.0";
  RequestHandlerProtocol2["TDS_8_0"] = "tds/8.0";
})(RequestHandlerProtocol || (RequestHandlerProtocol = {}));

// node_modules/@smithy/types/dist-es/transform/client-payload-blob-type-narrow.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/transform/no-undefined.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/transform/type-transform.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/uri.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/util.js
init_process();
init_buffer();

// node_modules/@smithy/types/dist-es/waiter.js
init_process();
init_buffer();

// node_modules/@smithy/protocol-http/dist-es/Fields.js
init_process();
init_buffer();

// node_modules/@smithy/protocol-http/dist-es/httpHandler.js
init_process();
init_buffer();

// node_modules/@smithy/protocol-http/dist-es/httpRequest.js
init_process();
init_buffer();
var HttpRequest = class {
  constructor(options) {
    this.method = options.method || "GET";
    this.hostname = options.hostname || "localhost";
    this.port = options.port;
    this.query = options.query || {};
    this.headers = options.headers || {};
    this.body = options.body;
    this.protocol = options.protocol ? options.protocol.slice(-1) !== ":" ? `${options.protocol}:` : options.protocol : "https:";
    this.path = options.path ? options.path.charAt(0) !== "/" ? `/${options.path}` : options.path : "/";
    this.username = options.username;
    this.password = options.password;
    this.fragment = options.fragment;
  }
  static clone(request) {
    const cloned = new HttpRequest({
      ...request,
      headers: { ...request.headers }
    });
    if (cloned.query) {
      cloned.query = cloneQuery(cloned.query);
    }
    return cloned;
  }
  static isInstance(request) {
    if (!request) {
      return false;
    }
    const req = request;
    return "method" in req && "protocol" in req && "hostname" in req && "path" in req && typeof req["query"] === "object" && typeof req["headers"] === "object";
  }
  clone() {
    return HttpRequest.clone(this);
  }
};
function cloneQuery(query) {
  return Object.keys(query).reduce((carry, paramName) => {
    const param = query[paramName];
    return {
      ...carry,
      [paramName]: Array.isArray(param) ? [...param] : param
    };
  }, {});
}

// node_modules/@smithy/protocol-http/dist-es/httpResponse.js
init_process();
init_buffer();
var HttpResponse = class {
  constructor(options) {
    this.statusCode = options.statusCode;
    this.reason = options.reason;
    this.headers = options.headers || {};
    this.body = options.body;
  }
  static isInstance(response) {
    if (!response)
      return false;
    const resp = response;
    return typeof resp.statusCode === "number" && typeof resp.headers === "object";
  }
};

// node_modules/@smithy/protocol-http/dist-es/isValidHostname.js
init_process();
init_buffer();

// node_modules/@smithy/protocol-http/dist-es/types.js
init_process();
init_buffer();

// node_modules/@aws-sdk/middleware-expect-continue/dist-es/index.js
function addExpectContinueMiddleware(options) {
  return (next) => async (args) => {
    const { request } = args;
    if (HttpRequest.isInstance(request) && request.body && options.runtime === "node") {
      if (options.requestHandler?.constructor?.name !== "FetchHttpHandler") {
        request.headers = {
          ...request.headers,
          Expect: "100-continue"
        };
      }
    }
    return next({
      ...args,
      request
    });
  };
}
var addExpectContinueMiddlewareOptions = {
  step: "build",
  tags: ["SET_EXPECT_HEADER", "EXPECT_HEADER"],
  name: "addExpectContinueMiddleware",
  override: true
};
var getAddExpectContinuePlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(addExpectContinueMiddleware(options), addExpectContinueMiddlewareOptions);
  }
});

// node_modules/@aws-sdk/middleware-host-header/dist-es/index.js
init_process();
init_buffer();
function resolveHostHeaderConfig(input) {
  return input;
}
var hostHeaderMiddleware = (options) => (next) => async (args) => {
  if (!HttpRequest.isInstance(args.request))
    return next(args);
  const { request } = args;
  const { handlerProtocol = "" } = options.requestHandler.metadata || {};
  if (handlerProtocol.indexOf("h2") >= 0 && !request.headers[":authority"]) {
    delete request.headers["host"];
    request.headers[":authority"] = request.hostname + (request.port ? ":" + request.port : "");
  } else if (!request.headers["host"]) {
    let host = request.hostname;
    if (request.port != null)
      host += `:${request.port}`;
    request.headers["host"] = host;
  }
  return next(args);
};
var hostHeaderMiddlewareOptions = {
  name: "hostHeaderMiddleware",
  step: "build",
  priority: "low",
  tags: ["HOST"],
  override: true
};
var getHostHeaderPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(hostHeaderMiddleware(options), hostHeaderMiddlewareOptions);
  }
});

// node_modules/@aws-sdk/middleware-logger/dist-es/index.js
init_process();
init_buffer();

// node_modules/@aws-sdk/middleware-logger/dist-es/loggerMiddleware.js
init_process();
init_buffer();
var loggerMiddleware = () => (next, context) => async (args) => {
  try {
    const response = await next(args);
    const { clientName, commandName, logger: logger2, dynamoDbDocumentClientOptions = {} } = context;
    const { overrideInputFilterSensitiveLog, overrideOutputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
    const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context.inputFilterSensitiveLog;
    const outputFilterSensitiveLog = overrideOutputFilterSensitiveLog ?? context.outputFilterSensitiveLog;
    const { $metadata, ...outputWithoutMetadata } = response.output;
    logger2?.info?.({
      clientName,
      commandName,
      input: inputFilterSensitiveLog(args.input),
      output: outputFilterSensitiveLog(outputWithoutMetadata),
      metadata: $metadata
    });
    return response;
  } catch (error3) {
    const { clientName, commandName, logger: logger2, dynamoDbDocumentClientOptions = {} } = context;
    const { overrideInputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
    const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context.inputFilterSensitiveLog;
    logger2?.error?.({
      clientName,
      commandName,
      input: inputFilterSensitiveLog(args.input),
      error: error3,
      metadata: error3.$metadata
    });
    throw error3;
  }
};
var loggerMiddlewareOptions = {
  name: "loggerMiddleware",
  tags: ["LOGGER"],
  step: "initialize",
  override: true
};
var getLoggerPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(loggerMiddleware(), loggerMiddlewareOptions);
  }
});

// node_modules/@aws-sdk/middleware-recursion-detection/dist-es/index.js
init_process();
init_buffer();
var TRACE_ID_HEADER_NAME = "X-Amzn-Trace-Id";
var ENV_LAMBDA_FUNCTION_NAME = "AWS_LAMBDA_FUNCTION_NAME";
var ENV_TRACE_ID = "_X_AMZN_TRACE_ID";
var recursionDetectionMiddleware = (options) => (next) => async (args) => {
  const { request } = args;
  if (!HttpRequest.isInstance(request) || options.runtime !== "node" || request.headers.hasOwnProperty(TRACE_ID_HEADER_NAME)) {
    return next(args);
  }
  const functionName = process.env[ENV_LAMBDA_FUNCTION_NAME];
  const traceId = process.env[ENV_TRACE_ID];
  const nonEmptyString = (str) => typeof str === "string" && str.length > 0;
  if (nonEmptyString(functionName) && nonEmptyString(traceId)) {
    request.headers[TRACE_ID_HEADER_NAME] = traceId;
  }
  return next({
    ...args,
    request
  });
};
var addRecursionDetectionMiddlewareOptions = {
  step: "build",
  tags: ["RECURSION_DETECTION"],
  name: "recursionDetectionMiddleware",
  override: true,
  priority: "low"
};
var getRecursionDetectionPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(recursionDetectionMiddleware(options), addRecursionDetectionMiddlewareOptions);
  }
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/index.js
init_process();
init_buffer();

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/check-content-length-header.js
init_process();
init_buffer();

// node_modules/@smithy/smithy-client/dist-es/index.js
init_process();
init_buffer();

// node_modules/@smithy/smithy-client/dist-es/NoOpLogger.js
init_process();
init_buffer();
var NoOpLogger = class {
  trace() {
  }
  debug() {
  }
  info() {
  }
  warn() {
  }
  error() {
  }
};

// node_modules/@smithy/smithy-client/dist-es/client.js
init_process();
init_buffer();

// node_modules/@smithy/middleware-stack/dist-es/index.js
init_process();
init_buffer();

// node_modules/@smithy/middleware-stack/dist-es/MiddlewareStack.js
init_process();
init_buffer();
var getAllAliases = (name, aliases) => {
  const _aliases = [];
  if (name) {
    _aliases.push(name);
  }
  if (aliases) {
    for (const alias of aliases) {
      _aliases.push(alias);
    }
  }
  return _aliases;
};
var getMiddlewareNameWithAliases = (name, aliases) => {
  return `${name || "anonymous"}${aliases && aliases.length > 0 ? ` (a.k.a. ${aliases.join(",")})` : ""}`;
};
var constructStack = () => {
  let absoluteEntries = [];
  let relativeEntries = [];
  let identifyOnResolve = false;
  const entriesNameSet = /* @__PURE__ */ new Set();
  const sort = (entries) => entries.sort((a2, b2) => stepWeights[b2.step] - stepWeights[a2.step] || priorityWeights[b2.priority || "normal"] - priorityWeights[a2.priority || "normal"]);
  const removeByName = (toRemove) => {
    let isRemoved = false;
    const filterCb = (entry) => {
      const aliases = getAllAliases(entry.name, entry.aliases);
      if (aliases.includes(toRemove)) {
        isRemoved = true;
        for (const alias of aliases) {
          entriesNameSet.delete(alias);
        }
        return false;
      }
      return true;
    };
    absoluteEntries = absoluteEntries.filter(filterCb);
    relativeEntries = relativeEntries.filter(filterCb);
    return isRemoved;
  };
  const removeByReference = (toRemove) => {
    let isRemoved = false;
    const filterCb = (entry) => {
      if (entry.middleware === toRemove) {
        isRemoved = true;
        for (const alias of getAllAliases(entry.name, entry.aliases)) {
          entriesNameSet.delete(alias);
        }
        return false;
      }
      return true;
    };
    absoluteEntries = absoluteEntries.filter(filterCb);
    relativeEntries = relativeEntries.filter(filterCb);
    return isRemoved;
  };
  const cloneTo = (toStack) => {
    absoluteEntries.forEach((entry) => {
      toStack.add(entry.middleware, { ...entry });
    });
    relativeEntries.forEach((entry) => {
      toStack.addRelativeTo(entry.middleware, { ...entry });
    });
    toStack.identifyOnResolve?.(stack.identifyOnResolve());
    return toStack;
  };
  const expandRelativeMiddlewareList = (from3) => {
    const expandedMiddlewareList = [];
    from3.before.forEach((entry) => {
      if (entry.before.length === 0 && entry.after.length === 0) {
        expandedMiddlewareList.push(entry);
      } else {
        expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
      }
    });
    expandedMiddlewareList.push(from3);
    from3.after.reverse().forEach((entry) => {
      if (entry.before.length === 0 && entry.after.length === 0) {
        expandedMiddlewareList.push(entry);
      } else {
        expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
      }
    });
    return expandedMiddlewareList;
  };
  const getMiddlewareList = (debug2 = false) => {
    const normalizedAbsoluteEntries = [];
    const normalizedRelativeEntries = [];
    const normalizedEntriesNameMap = {};
    absoluteEntries.forEach((entry) => {
      const normalizedEntry = {
        ...entry,
        before: [],
        after: []
      };
      for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
        normalizedEntriesNameMap[alias] = normalizedEntry;
      }
      normalizedAbsoluteEntries.push(normalizedEntry);
    });
    relativeEntries.forEach((entry) => {
      const normalizedEntry = {
        ...entry,
        before: [],
        after: []
      };
      for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
        normalizedEntriesNameMap[alias] = normalizedEntry;
      }
      normalizedRelativeEntries.push(normalizedEntry);
    });
    normalizedRelativeEntries.forEach((entry) => {
      if (entry.toMiddleware) {
        const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
        if (toMiddleware === void 0) {
          if (debug2) {
            return;
          }
          throw new Error(`${entry.toMiddleware} is not found when adding ${getMiddlewareNameWithAliases(entry.name, entry.aliases)} middleware ${entry.relation} ${entry.toMiddleware}`);
        }
        if (entry.relation === "after") {
          toMiddleware.after.push(entry);
        }
        if (entry.relation === "before") {
          toMiddleware.before.push(entry);
        }
      }
    });
    const mainChain = sort(normalizedAbsoluteEntries).map(expandRelativeMiddlewareList).reduce((wholeList, expandedMiddlewareList) => {
      wholeList.push(...expandedMiddlewareList);
      return wholeList;
    }, []);
    return mainChain;
  };
  const stack = {
    add: (middleware, options = {}) => {
      const { name, override, aliases: _aliases } = options;
      const entry = {
        step: "initialize",
        priority: "normal",
        middleware,
        ...options
      };
      const aliases = getAllAliases(name, _aliases);
      if (aliases.length > 0) {
        if (aliases.some((alias) => entriesNameSet.has(alias))) {
          if (!override)
            throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
          for (const alias of aliases) {
            const toOverrideIndex = absoluteEntries.findIndex((entry2) => entry2.name === alias || entry2.aliases?.some((a2) => a2 === alias));
            if (toOverrideIndex === -1) {
              continue;
            }
            const toOverride = absoluteEntries[toOverrideIndex];
            if (toOverride.step !== entry.step || entry.priority !== toOverride.priority) {
              throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware with ${toOverride.priority} priority in ${toOverride.step} step cannot be overridden by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware with ${entry.priority} priority in ${entry.step} step.`);
            }
            absoluteEntries.splice(toOverrideIndex, 1);
          }
        }
        for (const alias of aliases) {
          entriesNameSet.add(alias);
        }
      }
      absoluteEntries.push(entry);
    },
    addRelativeTo: (middleware, options) => {
      const { name, override, aliases: _aliases } = options;
      const entry = {
        middleware,
        ...options
      };
      const aliases = getAllAliases(name, _aliases);
      if (aliases.length > 0) {
        if (aliases.some((alias) => entriesNameSet.has(alias))) {
          if (!override)
            throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
          for (const alias of aliases) {
            const toOverrideIndex = relativeEntries.findIndex((entry2) => entry2.name === alias || entry2.aliases?.some((a2) => a2 === alias));
            if (toOverrideIndex === -1) {
              continue;
            }
            const toOverride = relativeEntries[toOverrideIndex];
            if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {
              throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware ${toOverride.relation} "${toOverride.toMiddleware}" middleware cannot be overridden by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware ${entry.relation} "${entry.toMiddleware}" middleware.`);
            }
            relativeEntries.splice(toOverrideIndex, 1);
          }
        }
        for (const alias of aliases) {
          entriesNameSet.add(alias);
        }
      }
      relativeEntries.push(entry);
    },
    clone: () => cloneTo(constructStack()),
    use: (plugin) => {
      plugin.applyToStack(stack);
    },
    remove: (toRemove) => {
      if (typeof toRemove === "string")
        return removeByName(toRemove);
      else
        return removeByReference(toRemove);
    },
    removeByTag: (toRemove) => {
      let isRemoved = false;
      const filterCb = (entry) => {
        const { tags, name, aliases: _aliases } = entry;
        if (tags && tags.includes(toRemove)) {
          const aliases = getAllAliases(name, _aliases);
          for (const alias of aliases) {
            entriesNameSet.delete(alias);
          }
          isRemoved = true;
          return false;
        }
        return true;
      };
      absoluteEntries = absoluteEntries.filter(filterCb);
      relativeEntries = relativeEntries.filter(filterCb);
      return isRemoved;
    },
    concat: (from3) => {
      const cloned = cloneTo(constructStack());
      cloned.use(from3);
      cloned.identifyOnResolve(identifyOnResolve || cloned.identifyOnResolve() || (from3.identifyOnResolve?.() ?? false));
      return cloned;
    },
    applyToStack: cloneTo,
    identify: () => {
      return getMiddlewareList(true).map((mw) => {
        const step = mw.step ?? mw.relation + " " + mw.toMiddleware;
        return getMiddlewareNameWithAliases(mw.name, mw.aliases) + " - " + step;
      });
    },
    identifyOnResolve(toggle) {
      if (typeof toggle === "boolean")
        identifyOnResolve = toggle;
      return identifyOnResolve;
    },
    resolve: (handler, context) => {
      for (const middleware of getMiddlewareList().map((entry) => entry.middleware).reverse()) {
        handler = middleware(handler, context);
      }
      if (identifyOnResolve) {
        console.log(stack.identify());
      }
      return handler;
    }
  };
  return stack;
};
var stepWeights = {
  initialize: 5,
  serialize: 4,
  build: 3,
  finalizeRequest: 2,
  deserialize: 1
};
var priorityWeights = {
  high: 3,
  normal: 2,
  low: 1
};

// node_modules/@smithy/smithy-client/dist-es/client.js
var Client = class {
  constructor(config3) {
    this.middlewareStack = constructStack();
    this.config = config3;
  }
  send(command, optionsOrCb, cb2) {
    const options = typeof optionsOrCb !== "function" ? optionsOrCb : void 0;
    const callback = typeof optionsOrCb === "function" ? optionsOrCb : cb2;
    const handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
    if (callback) {
      handler(command).then((result) => callback(null, result.output), (err) => callback(err)).catch(() => {
      });
    } else {
      return handler(command).then((result) => result.output);
    }
  }
  destroy() {
    if (this.config.requestHandler.destroy)
      this.config.requestHandler.destroy();
  }
};

// node_modules/@smithy/smithy-client/dist-es/collect-stream-body.js
init_process();
init_buffer();

// node_modules/@smithy/util-stream/dist-es/index.js
init_process();
init_buffer();

// node_modules/@smithy/util-stream/dist-es/blob/Uint8ArrayBlobAdapter.js
init_process();
init_buffer();

// node_modules/@smithy/util-stream/dist-es/blob/transforms.js
init_process();
init_buffer();

// node_modules/@smithy/util-base64/dist-es/index.js
init_process();
init_buffer();

// node_modules/@smithy/util-base64/dist-es/fromBase64.browser.js
init_process();
init_buffer();

// node_modules/@smithy/util-base64/dist-es/constants.browser.js
init_process();
init_buffer();
var alphabetByEncoding = {};
var alphabetByValue = new Array(64);
for (let i2 = 0, start = "A".charCodeAt(0), limit = "Z".charCodeAt(0); i2 + start <= limit; i2++) {
  const char = String.fromCharCode(i2 + start);
  alphabetByEncoding[char] = i2;
  alphabetByValue[i2] = char;
}
for (let i2 = 0, start = "a".charCodeAt(0), limit = "z".charCodeAt(0); i2 + start <= limit; i2++) {
  const char = String.fromCharCode(i2 + start);
  const index3 = i2 + 26;
  alphabetByEncoding[char] = index3;
  alphabetByValue[index3] = char;
}
for (let i2 = 0; i2 < 10; i2++) {
  alphabetByEncoding[i2.toString(10)] = i2 + 52;
  const char = i2.toString(10);
  const index3 = i2 + 52;
  alphabetByEncoding[char] = index3;
  alphabetByValue[index3] = char;
}
alphabetByEncoding["+"] = 62;
alphabetByValue[62] = "+";
alphabetByEncoding["/"] = 63;
alphabetByValue[63] = "/";
var bitsPerLetter = 6;
var bitsPerByte = 8;
var maxLetterValue = 63;

// node_modules/@smithy/util-base64/dist-es/fromBase64.browser.js
var fromBase64 = (input) => {
  let totalByteLength = input.length / 4 * 3;
  if (input.slice(-2) === "==") {
    totalByteLength -= 2;
  } else if (input.slice(-1) === "=") {
    totalByteLength--;
  }
  const out = new ArrayBuffer(totalByteLength);
  const dataView = new DataView(out);
  for (let i2 = 0; i2 < input.length; i2 += 4) {
    let bits = 0;
    let bitLength = 0;
    for (let j2 = i2, limit = i2 + 3; j2 <= limit; j2++) {
      if (input[j2] !== "=") {
        if (!(input[j2] in alphabetByEncoding)) {
          throw new TypeError(`Invalid character ${input[j2]} in base64 string.`);
        }
        bits |= alphabetByEncoding[input[j2]] << (limit - j2) * bitsPerLetter;
        bitLength += bitsPerLetter;
      } else {
        bits >>= bitsPerLetter;
      }
    }
    const chunkOffset = i2 / 4 * 3;
    bits >>= bitLength % bitsPerByte;
    const byteLength3 = Math.floor(bitLength / bitsPerByte);
    for (let k2 = 0; k2 < byteLength3; k2++) {
      const offset = (byteLength3 - k2 - 1) * bitsPerByte;
      dataView.setUint8(chunkOffset + k2, (bits & 255 << offset) >> offset);
    }
  }
  return new Uint8Array(out);
};

// node_modules/@smithy/util-base64/dist-es/toBase64.browser.js
init_process();
init_buffer();

// node_modules/@smithy/util-utf8/dist-es/index.js
init_process();
init_buffer();

// node_modules/@smithy/util-utf8/dist-es/fromUtf8.browser.js
init_process();
init_buffer();
var fromUtf8 = (input) => new TextEncoder().encode(input);

// node_modules/@smithy/util-utf8/dist-es/toUint8Array.js
init_process();
init_buffer();
var toUint8Array = (data) => {
  if (typeof data === "string") {
    return fromUtf8(data);
  }
  if (ArrayBuffer.isView(data)) {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
  }
  return new Uint8Array(data);
};

// node_modules/@smithy/util-utf8/dist-es/toUtf8.browser.js
init_process();
init_buffer();
var toUtf8 = (input) => {
  if (typeof input === "string") {
    return input;
  }
  if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
    throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
  }
  return new TextDecoder("utf-8").decode(input);
};

// node_modules/@smithy/util-base64/dist-es/toBase64.browser.js
function toBase64(_input) {
  let input;
  if (typeof _input === "string") {
    input = fromUtf8(_input);
  } else {
    input = _input;
  }
  const isArrayLike = typeof input === "object" && typeof input.length === "number";
  const isUint8Array3 = typeof input === "object" && typeof input.byteOffset === "number" && typeof input.byteLength === "number";
  if (!isArrayLike && !isUint8Array3) {
    throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
  }
  let str = "";
  for (let i2 = 0; i2 < input.length; i2 += 3) {
    let bits = 0;
    let bitLength = 0;
    for (let j2 = i2, limit = Math.min(i2 + 3, input.length); j2 < limit; j2++) {
      bits |= input[j2] << (limit - j2 - 1) * bitsPerByte;
      bitLength += bitsPerByte;
    }
    const bitClusterCount = Math.ceil(bitLength / bitsPerLetter);
    bits <<= bitClusterCount * bitsPerLetter - bitLength;
    for (let k2 = 1; k2 <= bitClusterCount; k2++) {
      const offset = (bitClusterCount - k2) * bitsPerLetter;
      str += alphabetByValue[(bits & maxLetterValue << offset) >> offset];
    }
    str += "==".slice(0, 4 - bitClusterCount);
  }
  return str;
}

// node_modules/@smithy/util-stream/dist-es/blob/transforms.js
function transformToString(payload, encoding = "utf-8") {
  if (encoding === "base64") {
    return toBase64(payload);
  }
  return toUtf8(payload);
}
function transformFromString(str, encoding) {
  if (encoding === "base64") {
    return Uint8ArrayBlobAdapter.mutate(fromBase64(str));
  }
  return Uint8ArrayBlobAdapter.mutate(fromUtf8(str));
}

// node_modules/@smithy/util-stream/dist-es/blob/Uint8ArrayBlobAdapter.js
var Uint8ArrayBlobAdapter = class extends Uint8Array {
  static fromString(source, encoding = "utf-8") {
    switch (typeof source) {
      case "string":
        return transformFromString(source, encoding);
      default:
        throw new Error(`Unsupported conversion from ${typeof source} to Uint8ArrayBlobAdapter.`);
    }
  }
  static mutate(source) {
    Object.setPrototypeOf(source, Uint8ArrayBlobAdapter.prototype);
    return source;
  }
  transformToString(encoding = "utf-8") {
    return transformToString(this, encoding);
  }
};

// node_modules/@smithy/util-stream/dist-es/getAwsChunkedEncodingStream.browser.js
init_process();
init_buffer();
var getAwsChunkedEncodingStream = (readableStream, options) => {
  const { base64Encoder, bodyLengthChecker, checksumAlgorithmFn, checksumLocationName, streamHasher } = options;
  const checksumRequired = base64Encoder !== void 0 && bodyLengthChecker !== void 0 && checksumAlgorithmFn !== void 0 && checksumLocationName !== void 0 && streamHasher !== void 0;
  const digest = checksumRequired ? streamHasher(checksumAlgorithmFn, readableStream) : void 0;
  const reader = readableStream.getReader();
  return new ReadableStream({
    async pull(controller) {
      const { value, done: done2 } = await reader.read();
      if (done2) {
        controller.enqueue(`0\r
`);
        if (checksumRequired) {
          const checksum2 = base64Encoder(await digest);
          controller.enqueue(`${checksumLocationName}:${checksum2}\r
`);
          controller.enqueue(`\r
`);
        }
        controller.close();
      } else {
        controller.enqueue(`${(bodyLengthChecker(value) || 0).toString(16)}\r
${value}\r
`);
      }
    }
  });
};

// node_modules/@smithy/util-stream/dist-es/sdk-stream-mixin.browser.js
init_process();
init_buffer();

// node_modules/@smithy/fetch-http-handler/dist-es/index.js
init_process();
init_buffer();

// node_modules/@smithy/fetch-http-handler/dist-es/fetch-http-handler.js
init_process();
init_buffer();

// node_modules/@smithy/querystring-builder/dist-es/index.js
init_process();
init_buffer();

// node_modules/@smithy/util-uri-escape/dist-es/index.js
init_process();
init_buffer();

// node_modules/@smithy/util-uri-escape/dist-es/escape-uri.js
init_process();
init_buffer();
var escapeUri = (uri2) => encodeURIComponent(uri2).replace(/[!'()*]/g, hexEncode);
var hexEncode = (c2) => `%${c2.charCodeAt(0).toString(16).toUpperCase()}`;

// node_modules/@smithy/util-uri-escape/dist-es/escape-uri-path.js
init_process();
init_buffer();

// node_modules/@smithy/querystring-builder/dist-es/index.js
function buildQueryString(query) {
  const parts = [];
  for (let key2 of Object.keys(query).sort()) {
    const value = query[key2];
    key2 = escapeUri(key2);
    if (Array.isArray(value)) {
      for (let i2 = 0, iLen = value.length; i2 < iLen; i2++) {
        parts.push(`${key2}=${escapeUri(value[i2])}`);
      }
    } else {
      let qsEntry = key2;
      if (value || typeof value === "string") {
        qsEntry += `=${escapeUri(value)}`;
      }
      parts.push(qsEntry);
    }
  }
  return parts.join("&");
}

// node_modules/@smithy/fetch-http-handler/dist-es/request-timeout.js
init_process();
init_buffer();
function requestTimeout(timeoutInMs = 0) {
  return new Promise((resolve2, reject) => {
    if (timeoutInMs) {
      setTimeout(() => {
        const timeoutError = new Error(`Request did not complete within ${timeoutInMs} ms`);
        timeoutError.name = "TimeoutError";
        reject(timeoutError);
      }, timeoutInMs);
    }
  });
}

// node_modules/@smithy/fetch-http-handler/dist-es/fetch-http-handler.js
var keepAliveSupport = {
  supported: void 0
};
var FetchHttpHandler = class {
  static create(instanceOrOptions) {
    if (typeof instanceOrOptions?.handle === "function") {
      return instanceOrOptions;
    }
    return new FetchHttpHandler(instanceOrOptions);
  }
  constructor(options) {
    if (typeof options === "function") {
      this.configProvider = options().then((opts) => opts || {});
    } else {
      this.config = options ?? {};
      this.configProvider = Promise.resolve(this.config);
    }
    if (keepAliveSupport.supported === void 0) {
      keepAliveSupport.supported = Boolean(typeof Request !== "undefined" && "keepalive" in new Request("https://[::1]"));
    }
  }
  destroy() {
  }
  async handle(request, { abortSignal } = {}) {
    if (!this.config) {
      this.config = await this.configProvider;
    }
    const requestTimeoutInMs = this.config.requestTimeout;
    const keepAlive = this.config.keepAlive === true;
    const credentials = this.config.credentials;
    if (abortSignal?.aborted) {
      const abortError = new Error("Request aborted");
      abortError.name = "AbortError";
      return Promise.reject(abortError);
    }
    let path2 = request.path;
    const queryString = buildQueryString(request.query || {});
    if (queryString) {
      path2 += `?${queryString}`;
    }
    if (request.fragment) {
      path2 += `#${request.fragment}`;
    }
    let auth = "";
    if (request.username != null || request.password != null) {
      const username = request.username ?? "";
      const password = request.password ?? "";
      auth = `${username}:${password}@`;
    }
    const { port, method } = request;
    const url = `${request.protocol}//${auth}${request.hostname}${port ? `:${port}` : ""}${path2}`;
    const body3 = method === "GET" || method === "HEAD" ? void 0 : request.body;
    const requestOptions = {
      body: body3,
      headers: new Headers(request.headers),
      method,
      credentials
    };
    if (body3) {
      requestOptions.duplex = "half";
    }
    if (typeof AbortController !== "undefined") {
      requestOptions.signal = abortSignal;
    }
    if (keepAliveSupport.supported) {
      requestOptions.keepalive = keepAlive;
    }
    let removeSignalEventListener = () => {
    };
    const fetchRequest = new Request(url, requestOptions);
    const raceOfPromises = [
      fetch(fetchRequest).then((response) => {
        const fetchHeaders = response.headers;
        const transformedHeaders = {};
        for (const pair of fetchHeaders.entries()) {
          transformedHeaders[pair[0]] = pair[1];
        }
        const hasReadableStream = response.body != void 0;
        if (!hasReadableStream) {
          return response.blob().then((body4) => ({
            response: new HttpResponse({
              headers: transformedHeaders,
              reason: response.statusText,
              statusCode: response.status,
              body: body4
            })
          }));
        }
        return {
          response: new HttpResponse({
            headers: transformedHeaders,
            reason: response.statusText,
            statusCode: response.status,
            body: response.body
          })
        };
      }),
      requestTimeout(requestTimeoutInMs)
    ];
    if (abortSignal) {
      raceOfPromises.push(new Promise((resolve2, reject) => {
        const onAbort = () => {
          const abortError = new Error("Request aborted");
          abortError.name = "AbortError";
          reject(abortError);
        };
        if (typeof abortSignal.addEventListener === "function") {
          const signal = abortSignal;
          signal.addEventListener("abort", onAbort, { once: true });
          removeSignalEventListener = () => signal.removeEventListener("abort", onAbort);
        } else {
          abortSignal.onabort = onAbort;
        }
      }));
    }
    return Promise.race(raceOfPromises).finally(removeSignalEventListener);
  }
  updateHttpClientConfig(key2, value) {
    this.config = void 0;
    this.configProvider = this.configProvider.then((config3) => {
      config3[key2] = value;
      return config3;
    });
  }
  httpHandlerConfigs() {
    return this.config ?? {};
  }
};

// node_modules/@smithy/fetch-http-handler/dist-es/stream-collector.js
init_process();
init_buffer();
var streamCollector = (stream) => {
  if (typeof Blob === "function" && stream instanceof Blob) {
    return collectBlob(stream);
  }
  return collectStream(stream);
};
async function collectBlob(blob) {
  const base642 = await readToBase64(blob);
  const arrayBuffer = fromBase64(base642);
  return new Uint8Array(arrayBuffer);
}
async function collectStream(stream) {
  const chunks = [];
  const reader = stream.getReader();
  let isDone = false;
  let length = 0;
  while (!isDone) {
    const { done: done2, value } = await reader.read();
    if (value) {
      chunks.push(value);
      length += value.length;
    }
    isDone = done2;
  }
  const collected = new Uint8Array(length);
  let offset = 0;
  for (const chunk of chunks) {
    collected.set(chunk, offset);
    offset += chunk.length;
  }
  return collected;
}
function readToBase64(blob) {
  return new Promise((resolve2, reject) => {
    const reader = new FileReader();
    reader.onloadend = () => {
      if (reader.readyState !== 2) {
        return reject(new Error("Reader aborted too early"));
      }
      const result = reader.result ?? "";
      const commaIndex = result.indexOf(",");
      const dataOffset = commaIndex > -1 ? commaIndex + 1 : result.length;
      resolve2(result.substring(dataOffset));
    };
    reader.onabort = () => reject(new Error("Read aborted"));
    reader.onerror = () => reject(reader.error);
    reader.readAsDataURL(blob);
  });
}

// node_modules/@smithy/util-hex-encoding/dist-es/index.js
init_process();
init_buffer();
var SHORT_TO_HEX = {};
var HEX_TO_SHORT = {};
for (let i2 = 0; i2 < 256; i2++) {
  let encodedByte = i2.toString(16).toLowerCase();
  if (encodedByte.length === 1) {
    encodedByte = `0${encodedByte}`;
  }
  SHORT_TO_HEX[i2] = encodedByte;
  HEX_TO_SHORT[encodedByte] = i2;
}
function fromHex(encoded) {
  if (encoded.length % 2 !== 0) {
    throw new Error("Hex encoded strings must have an even number length");
  }
  const out = new Uint8Array(encoded.length / 2);
  for (let i2 = 0; i2 < encoded.length; i2 += 2) {
    const encodedByte = encoded.slice(i2, i2 + 2).toLowerCase();
    if (encodedByte in HEX_TO_SHORT) {
      out[i2 / 2] = HEX_TO_SHORT[encodedByte];
    } else {
      throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);
    }
  }
  return out;
}
function toHex2(bytes) {
  let out = "";
  for (let i2 = 0; i2 < bytes.byteLength; i2++) {
    out += SHORT_TO_HEX[bytes[i2]];
  }
  return out;
}

// node_modules/@smithy/util-stream/dist-es/stream-type-check.js
init_process();
init_buffer();
var isReadableStream = (stream) => typeof ReadableStream === "function" && (stream?.constructor?.name === ReadableStream.name || stream instanceof ReadableStream);

// node_modules/@smithy/util-stream/dist-es/sdk-stream-mixin.browser.js
var ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
var sdkStreamMixin = (stream) => {
  if (!isBlobInstance(stream) && !isReadableStream(stream)) {
    const name = stream?.__proto__?.constructor?.name || stream;
    throw new Error(`Unexpected stream implementation, expect Blob or ReadableStream, got ${name}`);
  }
  let transformed = false;
  const transformToByteArray = async () => {
    if (transformed) {
      throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
    }
    transformed = true;
    return await streamCollector(stream);
  };
  const blobToWebStream = (blob) => {
    if (typeof blob.stream !== "function") {
      throw new Error("Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.\nIf you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body");
    }
    return blob.stream();
  };
  return Object.assign(stream, {
    transformToByteArray,
    transformToString: async (encoding) => {
      const buf = await transformToByteArray();
      if (encoding === "base64") {
        return toBase64(buf);
      } else if (encoding === "hex") {
        return toHex2(buf);
      } else if (encoding === void 0 || encoding === "utf8" || encoding === "utf-8") {
        return toUtf8(buf);
      } else if (typeof TextDecoder === "function") {
        return new TextDecoder(encoding).decode(buf);
      } else {
        throw new Error("TextDecoder is not available, please make sure polyfill is provided.");
      }
    },
    transformToWebStream: () => {
      if (transformed) {
        throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
      }
      transformed = true;
      if (isBlobInstance(stream)) {
        return blobToWebStream(stream);
      } else if (isReadableStream(stream)) {
        return stream;
      } else {
        throw new Error(`Cannot transform payload to web stream, got ${stream}`);
      }
    }
  });
};
var isBlobInstance = (stream) => typeof Blob === "function" && stream instanceof Blob;

// node_modules/@smithy/util-stream/dist-es/splitStream.browser.js
init_process();
init_buffer();
async function splitStream(stream) {
  if (typeof stream.stream === "function") {
    stream = stream.stream();
  }
  const readableStream = stream;
  return readableStream.tee();
}

// node_modules/@smithy/util-stream/dist-es/headStream.browser.js
init_process();
init_buffer();
async function headStream(stream, bytes) {
  let byteLengthCounter = 0;
  const chunks = [];
  const reader = stream.getReader();
  let isDone = false;
  while (!isDone) {
    const { done: done2, value } = await reader.read();
    if (value) {
      chunks.push(value);
      byteLengthCounter += value?.byteLength ?? 0;
    }
    if (byteLengthCounter >= bytes) {
      break;
    }
    isDone = done2;
  }
  reader.releaseLock();
  const collected = new Uint8Array(Math.min(bytes, byteLengthCounter));
  let offset = 0;
  for (const chunk of chunks) {
    if (chunk.byteLength > collected.byteLength - offset) {
      collected.set(chunk.subarray(0, collected.byteLength - offset), offset);
      break;
    } else {
      collected.set(chunk, offset);
    }
    offset += chunk.length;
  }
  return collected;
}

// node_modules/@smithy/smithy-client/dist-es/collect-stream-body.js
var collectBody = async (streamBody = new Uint8Array(), context) => {
  if (streamBody instanceof Uint8Array) {
    return Uint8ArrayBlobAdapter.mutate(streamBody);
  }
  if (!streamBody) {
    return Uint8ArrayBlobAdapter.mutate(new Uint8Array());
  }
  const fromContext = context.streamCollector(streamBody);
  return Uint8ArrayBlobAdapter.mutate(await fromContext);
};

// node_modules/@smithy/smithy-client/dist-es/command.js
init_process();
init_buffer();
var Command = class {
  constructor() {
    this.middlewareStack = constructStack();
  }
  static classBuilder() {
    return new ClassBuilder();
  }
  resolveMiddlewareWithContext(clientStack, configuration, options, { middlewareFn, clientName, commandName, inputFilterSensitiveLog, outputFilterSensitiveLog, smithyContext, additionalContext, CommandCtor }) {
    for (const mw of middlewareFn.bind(this)(CommandCtor, clientStack, configuration, options)) {
      this.middlewareStack.use(mw);
    }
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger2 } = configuration;
    const handlerExecutionContext = {
      logger: logger2,
      clientName,
      commandName,
      inputFilterSensitiveLog,
      outputFilterSensitiveLog,
      [SMITHY_CONTEXT_KEY]: {
        commandInstance: this,
        ...smithyContext
      },
      ...additionalContext
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
};
var ClassBuilder = class {
  constructor() {
    this._init = () => {
    };
    this._ep = {};
    this._middlewareFn = () => [];
    this._commandName = "";
    this._clientName = "";
    this._additionalContext = {};
    this._smithyContext = {};
    this._inputFilterSensitiveLog = (_) => _;
    this._outputFilterSensitiveLog = (_) => _;
    this._serializer = null;
    this._deserializer = null;
  }
  init(cb2) {
    this._init = cb2;
  }
  ep(endpointParameterInstructions) {
    this._ep = endpointParameterInstructions;
    return this;
  }
  m(middlewareSupplier) {
    this._middlewareFn = middlewareSupplier;
    return this;
  }
  s(service, operation, smithyContext = {}) {
    this._smithyContext = {
      service,
      operation,
      ...smithyContext
    };
    return this;
  }
  c(additionalContext = {}) {
    this._additionalContext = additionalContext;
    return this;
  }
  n(clientName, commandName) {
    this._clientName = clientName;
    this._commandName = commandName;
    return this;
  }
  f(inputFilter = (_) => _, outputFilter = (_) => _) {
    this._inputFilterSensitiveLog = inputFilter;
    this._outputFilterSensitiveLog = outputFilter;
    return this;
  }
  ser(serializer2) {
    this._serializer = serializer2;
    return this;
  }
  de(deserializer2) {
    this._deserializer = deserializer2;
    return this;
  }
  build() {
    const closure = this;
    let CommandRef;
    return CommandRef = class extends Command {
      static getEndpointParameterInstructions() {
        return closure._ep;
      }
      constructor(...[input]) {
        super();
        this.serialize = closure._serializer;
        this.deserialize = closure._deserializer;
        this.input = input ?? {};
        closure._init(this);
      }
      resolveMiddleware(stack, configuration, options) {
        return this.resolveMiddlewareWithContext(stack, configuration, options, {
          CommandCtor: CommandRef,
          middlewareFn: closure._middlewareFn,
          clientName: closure._clientName,
          commandName: closure._commandName,
          inputFilterSensitiveLog: closure._inputFilterSensitiveLog,
          outputFilterSensitiveLog: closure._outputFilterSensitiveLog,
          smithyContext: closure._smithyContext,
          additionalContext: closure._additionalContext
        });
      }
    };
  }
};

// node_modules/@smithy/smithy-client/dist-es/constants.js
init_process();
init_buffer();
var SENSITIVE_STRING = "***SensitiveInformation***";

// node_modules/@smithy/smithy-client/dist-es/create-aggregated-client.js
init_process();
init_buffer();

// node_modules/@smithy/smithy-client/dist-es/date-utils.js
init_process();
init_buffer();

// node_modules/@smithy/smithy-client/dist-es/parse-utils.js
init_process();
init_buffer();
var parseBoolean = (value) => {
  switch (value) {
    case "true":
      return true;
    case "false":
      return false;
    default:
      throw new Error(`Unable to parse boolean value "${value}"`);
  }
};
var expectNumber = (value) => {
  if (value === null || value === void 0) {
    return void 0;
  }
  if (typeof value === "string") {
    const parsed = parseFloat(value);
    if (!Number.isNaN(parsed)) {
      if (String(parsed) !== String(value)) {
        logger.warn(stackTraceWarning(`Expected number but observed string: ${value}`));
      }
      return parsed;
    }
  }
  if (typeof value === "number") {
    return value;
  }
  throw new TypeError(`Expected number, got ${typeof value}: ${value}`);
};
var MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));
var expectFloat32 = (value) => {
  const expected = expectNumber(value);
  if (expected !== void 0 && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {
    if (Math.abs(expected) > MAX_FLOAT) {
      throw new TypeError(`Expected 32-bit float, got ${value}`);
    }
  }
  return expected;
};
var expectLong = (value) => {
  if (value === null || value === void 0) {
    return void 0;
  }
  if (Number.isInteger(value) && !Number.isNaN(value)) {
    return value;
  }
  throw new TypeError(`Expected integer, got ${typeof value}: ${value}`);
};
var expectShort = (value) => expectSizedInt(value, 16);
var expectByte = (value) => expectSizedInt(value, 8);
var expectSizedInt = (value, size) => {
  const expected = expectLong(value);
  if (expected !== void 0 && castInt(expected, size) !== expected) {
    throw new TypeError(`Expected ${size}-bit integer, got ${value}`);
  }
  return expected;
};
var castInt = (value, size) => {
  switch (size) {
    case 32:
      return Int32Array.of(value)[0];
    case 16:
      return Int16Array.of(value)[0];
    case 8:
      return Int8Array.of(value)[0];
  }
};
var expectNonNull = (value, location) => {
  if (value === null || value === void 0) {
    if (location) {
      throw new TypeError(`Expected a non-null value for ${location}`);
    }
    throw new TypeError("Expected a non-null value");
  }
  return value;
};
var expectObject = (value) => {
  if (value === null || value === void 0) {
    return void 0;
  }
  if (typeof value === "object" && !Array.isArray(value)) {
    return value;
  }
  const receivedType = Array.isArray(value) ? "array" : typeof value;
  throw new TypeError(`Expected object, got ${receivedType}: ${value}`);
};
var expectString = (value) => {
  if (value === null || value === void 0) {
    return void 0;
  }
  if (typeof value === "string") {
    return value;
  }
  if (["boolean", "number", "bigint"].includes(typeof value)) {
    logger.warn(stackTraceWarning(`Expected string, got ${typeof value}: ${value}`));
    return String(value);
  }
  throw new TypeError(`Expected string, got ${typeof value}: ${value}`);
};
var strictParseFloat32 = (value) => {
  if (typeof value == "string") {
    return expectFloat32(parseNumber(value));
  }
  return expectFloat32(value);
};
var NUMBER_REGEX = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g;
var parseNumber = (value) => {
  const matches = value.match(NUMBER_REGEX);
  if (matches === null || matches[0].length !== value.length) {
    throw new TypeError(`Expected real number, got implicit NaN`);
  }
  return parseFloat(value);
};
var strictParseShort = (value) => {
  if (typeof value === "string") {
    return expectShort(parseNumber(value));
  }
  return expectShort(value);
};
var strictParseByte = (value) => {
  if (typeof value === "string") {
    return expectByte(parseNumber(value));
  }
  return expectByte(value);
};
var stackTraceWarning = (message2) => {
  return String(new TypeError(message2).stack || message2).split("\n").slice(0, 5).filter((s2) => !s2.includes("stackTraceWarning")).join("\n");
};
var logger = {
  warn: console.warn
};

// node_modules/@smithy/smithy-client/dist-es/date-utils.js
var DAYS2 = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
var MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
function dateToUtcString(date2) {
  const year2 = date2.getUTCFullYear();
  const month = date2.getUTCMonth();
  const dayOfWeek = date2.getUTCDay();
  const dayOfMonthInt = date2.getUTCDate();
  const hoursInt = date2.getUTCHours();
  const minutesInt = date2.getUTCMinutes();
  const secondsInt = date2.getUTCSeconds();
  const dayOfMonthString = dayOfMonthInt < 10 ? `0${dayOfMonthInt}` : `${dayOfMonthInt}`;
  const hoursString = hoursInt < 10 ? `0${hoursInt}` : `${hoursInt}`;
  const minutesString = minutesInt < 10 ? `0${minutesInt}` : `${minutesInt}`;
  const secondsString = secondsInt < 10 ? `0${secondsInt}` : `${secondsInt}`;
  return `${DAYS2[dayOfWeek]}, ${dayOfMonthString} ${MONTHS[month]} ${year2} ${hoursString}:${minutesString}:${secondsString} GMT`;
}
var RFC3339 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/);
var RFC3339_WITH_OFFSET = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/);
var parseRfc3339DateTimeWithOffset = (value) => {
  if (value === null || value === void 0) {
    return void 0;
  }
  if (typeof value !== "string") {
    throw new TypeError("RFC-3339 date-times must be expressed as strings");
  }
  const match = RFC3339_WITH_OFFSET.exec(value);
  if (!match) {
    throw new TypeError("Invalid RFC-3339 date-time value");
  }
  const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, offsetStr] = match;
  const year2 = strictParseShort(stripLeadingZeroes(yearStr));
  const month = parseDateValue(monthStr, "month", 1, 12);
  const day2 = parseDateValue(dayStr, "day", 1, 31);
  const date2 = buildDate(year2, month, day2, { hours, minutes, seconds, fractionalMilliseconds });
  if (offsetStr.toUpperCase() != "Z") {
    date2.setTime(date2.getTime() - parseOffsetToMilliseconds(offsetStr));
  }
  return date2;
};
var IMF_FIXDATE = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
var RFC_850_DATE = new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
var ASC_TIME = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/);
var buildDate = (year2, month, day2, time) => {
  const adjustedMonth = month - 1;
  validateDayOfMonth(year2, adjustedMonth, day2);
  return new Date(Date.UTC(year2, adjustedMonth, day2, parseDateValue(time.hours, "hour", 0, 23), parseDateValue(time.minutes, "minute", 0, 59), parseDateValue(time.seconds, "seconds", 0, 60), parseMilliseconds(time.fractionalMilliseconds)));
};
var FIFTY_YEARS_IN_MILLIS = 50 * 365 * 24 * 60 * 60 * 1e3;
var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var validateDayOfMonth = (year2, month, day2) => {
  let maxDays = DAYS_IN_MONTH[month];
  if (month === 1 && isLeapYear2(year2)) {
    maxDays = 29;
  }
  if (day2 > maxDays) {
    throw new TypeError(`Invalid day for ${MONTHS[month]} in ${year2}: ${day2}`);
  }
};
var isLeapYear2 = (year2) => {
  return year2 % 4 === 0 && (year2 % 100 !== 0 || year2 % 400 === 0);
};
var parseDateValue = (value, type, lower, upper) => {
  const dateVal = strictParseByte(stripLeadingZeroes(value));
  if (dateVal < lower || dateVal > upper) {
    throw new TypeError(`${type} must be between ${lower} and ${upper}, inclusive`);
  }
  return dateVal;
};
var parseMilliseconds = (value) => {
  if (value === null || value === void 0) {
    return 0;
  }
  return strictParseFloat32("0." + value) * 1e3;
};
var parseOffsetToMilliseconds = (value) => {
  const directionStr = value[0];
  let direction = 1;
  if (directionStr == "+") {
    direction = 1;
  } else if (directionStr == "-") {
    direction = -1;
  } else {
    throw new TypeError(`Offset direction, ${directionStr}, must be "+" or "-"`);
  }
  const hour2 = Number(value.substring(1, 3));
  const minute2 = Number(value.substring(4, 6));
  return direction * (hour2 * 60 + minute2) * 60 * 1e3;
};
var stripLeadingZeroes = (value) => {
  let idx = 0;
  while (idx < value.length - 1 && value.charAt(idx) === "0") {
    idx++;
  }
  if (idx === 0) {
    return value;
  }
  return value.slice(idx);
};

// node_modules/@smithy/smithy-client/dist-es/default-error-handler.js
init_process();
init_buffer();

// node_modules/@smithy/smithy-client/dist-es/exceptions.js
init_process();
init_buffer();
var ServiceException = class extends Error {
  constructor(options) {
    super(options.message);
    Object.setPrototypeOf(this, ServiceException.prototype);
    this.name = options.name;
    this.$fault = options.$fault;
    this.$metadata = options.$metadata;
  }
};
var decorateServiceException = (exception, additions = {}) => {
  Object.entries(additions).filter(([, v2]) => v2 !== void 0).forEach(([k2, v2]) => {
    if (exception[k2] == void 0 || exception[k2] === "") {
      exception[k2] = v2;
    }
  });
  const message2 = exception.message || exception.Message || "UnknownError";
  exception.message = message2;
  delete exception.Message;
  return exception;
};

// node_modules/@smithy/smithy-client/dist-es/default-error-handler.js
var throwDefaultError = ({ output, parsedBody, exceptionCtor, errorCode }) => {
  const $metadata = deserializeMetadata(output);
  const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : void 0;
  const response = new exceptionCtor({
    name: parsedBody?.code || parsedBody?.Code || errorCode || statusCode || "UnknownError",
    $fault: "client",
    $metadata
  });
  throw decorateServiceException(response, parsedBody);
};
var withBaseException = (ExceptionCtor) => {
  return ({ output, parsedBody, errorCode }) => {
    throwDefaultError({ output, parsedBody, exceptionCtor: ExceptionCtor, errorCode });
  };
};
var deserializeMetadata = (output) => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
});

// node_modules/@smithy/smithy-client/dist-es/defaults-mode.js
init_process();
init_buffer();
var loadConfigsForDefaultMode = (mode) => {
  switch (mode) {
    case "standard":
      return {
        retryMode: "standard",
        connectionTimeout: 3100
      };
    case "in-region":
      return {
        retryMode: "standard",
        connectionTimeout: 1100
      };
    case "cross-region":
      return {
        retryMode: "standard",
        connectionTimeout: 3100
      };
    case "mobile":
      return {
        retryMode: "standard",
        connectionTimeout: 3e4
      };
    default:
      return {};
  }
};

// node_modules/@smithy/smithy-client/dist-es/emitWarningIfUnsupportedVersion.js
init_process();
init_buffer();

// node_modules/@smithy/smithy-client/dist-es/extensions/index.js
init_process();
init_buffer();

// node_modules/@smithy/smithy-client/dist-es/extensions/defaultExtensionConfiguration.js
init_process();
init_buffer();

// node_modules/@smithy/smithy-client/dist-es/extensions/checksum.js
init_process();
init_buffer();
var getChecksumConfiguration2 = (runtimeConfig) => {
  const checksumAlgorithms = [];
  for (const id in AlgorithmId) {
    const algorithmId = AlgorithmId[id];
    if (runtimeConfig[algorithmId] === void 0) {
      continue;
    }
    checksumAlgorithms.push({
      algorithmId: () => algorithmId,
      checksumConstructor: () => runtimeConfig[algorithmId]
    });
  }
  return {
    _checksumAlgorithms: checksumAlgorithms,
    addChecksumAlgorithm(algo) {
      this._checksumAlgorithms.push(algo);
    },
    checksumAlgorithms() {
      return this._checksumAlgorithms;
    }
  };
};
var resolveChecksumRuntimeConfig2 = (clientConfig) => {
  const runtimeConfig = {};
  clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
    runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
  });
  return runtimeConfig;
};

// node_modules/@smithy/smithy-client/dist-es/extensions/retry.js
init_process();
init_buffer();
var getRetryConfiguration = (runtimeConfig) => {
  let _retryStrategy = runtimeConfig.retryStrategy;
  return {
    setRetryStrategy(retryStrategy) {
      _retryStrategy = retryStrategy;
    },
    retryStrategy() {
      return _retryStrategy;
    }
  };
};
var resolveRetryRuntimeConfig = (retryStrategyConfiguration) => {
  const runtimeConfig = {};
  runtimeConfig.retryStrategy = retryStrategyConfiguration.retryStrategy();
  return runtimeConfig;
};

// node_modules/@smithy/smithy-client/dist-es/extensions/defaultExtensionConfiguration.js
var getDefaultExtensionConfiguration = (runtimeConfig) => {
  return {
    ...getChecksumConfiguration2(runtimeConfig),
    ...getRetryConfiguration(runtimeConfig)
  };
};
var resolveDefaultRuntimeConfig = (config3) => {
  return {
    ...resolveChecksumRuntimeConfig2(config3),
    ...resolveRetryRuntimeConfig(config3)
  };
};

// node_modules/@smithy/smithy-client/dist-es/extended-encode-uri-component.js
init_process();
init_buffer();
function extendedEncodeURIComponent(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function(c2) {
    return "%" + c2.charCodeAt(0).toString(16).toUpperCase();
  });
}

// node_modules/@smithy/smithy-client/dist-es/get-array-if-single-item.js
init_process();
init_buffer();

// node_modules/@smithy/smithy-client/dist-es/get-value-from-text-node.js
init_process();
init_buffer();
var getValueFromTextNode = (obj) => {
  const textNodeName = "#text";
  for (const key2 in obj) {
    if (obj.hasOwnProperty(key2) && obj[key2][textNodeName] !== void 0) {
      obj[key2] = obj[key2][textNodeName];
    } else if (typeof obj[key2] === "object" && obj[key2] !== null) {
      obj[key2] = getValueFromTextNode(obj[key2]);
    }
  }
  return obj;
};

// node_modules/@smithy/smithy-client/dist-es/lazy-json.js
init_process();
init_buffer();
var StringWrapper = function() {
  const Class = Object.getPrototypeOf(this).constructor;
  const Constructor2 = Function.bind.apply(String, [null, ...arguments]);
  const instance = new Constructor2();
  Object.setPrototypeOf(instance, Class.prototype);
  return instance;
};
StringWrapper.prototype = Object.create(String.prototype, {
  constructor: {
    value: StringWrapper,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
Object.setPrototypeOf(StringWrapper, String);

// node_modules/@smithy/smithy-client/dist-es/object-mapping.js
init_process();
init_buffer();
function map3(arg0, arg1, arg2) {
  let target;
  let filter2;
  let instructions;
  if (typeof arg1 === "undefined" && typeof arg2 === "undefined") {
    target = {};
    instructions = arg0;
  } else {
    target = arg0;
    if (typeof arg1 === "function") {
      filter2 = arg1;
      instructions = arg2;
      return mapWithFilter(target, filter2, instructions);
    } else {
      instructions = arg1;
    }
  }
  for (const key2 of Object.keys(instructions)) {
    if (!Array.isArray(instructions[key2])) {
      target[key2] = instructions[key2];
      continue;
    }
    applyInstruction(target, null, instructions, key2);
  }
  return target;
}
var mapWithFilter = (target, filter2, instructions) => {
  return map3(target, Object.entries(instructions).reduce((_instructions, [key2, value]) => {
    if (Array.isArray(value)) {
      _instructions[key2] = value;
    } else {
      if (typeof value === "function") {
        _instructions[key2] = [filter2, value()];
      } else {
        _instructions[key2] = [filter2, value];
      }
    }
    return _instructions;
  }, {}));
};
var applyInstruction = (target, source, instructions, targetKey) => {
  if (source !== null) {
    let instruction = instructions[targetKey];
    if (typeof instruction === "function") {
      instruction = [, instruction];
    }
    const [filter3 = nonNullish, valueFn = pass, sourceKey = targetKey] = instruction;
    if (typeof filter3 === "function" && filter3(source[sourceKey]) || typeof filter3 !== "function" && !!filter3) {
      target[targetKey] = valueFn(source[sourceKey]);
    }
    return;
  }
  let [filter2, value] = instructions[targetKey];
  if (typeof value === "function") {
    let _value;
    const defaultFilterPassed = filter2 === void 0 && (_value = value()) != null;
    const customFilterPassed = typeof filter2 === "function" && !!filter2(void 0) || typeof filter2 !== "function" && !!filter2;
    if (defaultFilterPassed) {
      target[targetKey] = _value;
    } else if (customFilterPassed) {
      target[targetKey] = value();
    }
  } else {
    const defaultFilterPassed = filter2 === void 0 && value != null;
    const customFilterPassed = typeof filter2 === "function" && !!filter2(value) || typeof filter2 !== "function" && !!filter2;
    if (defaultFilterPassed || customFilterPassed) {
      target[targetKey] = value;
    }
  }
};
var nonNullish = (_) => _ != null;
var pass = (_) => _;

// node_modules/@smithy/smithy-client/dist-es/resolve-path.js
init_process();
init_buffer();
var resolvedPath = (resolvedPath2, input, memberName, labelValueProvider, uriLabel, isGreedyLabel) => {
  if (input != null && input[memberName] !== void 0) {
    const labelValue = labelValueProvider();
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: " + memberName + ".");
    }
    resolvedPath2 = resolvedPath2.replace(uriLabel, isGreedyLabel ? labelValue.split("/").map((segment) => extendedEncodeURIComponent(segment)).join("/") : extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: " + memberName + ".");
  }
  return resolvedPath2;
};

// node_modules/@smithy/smithy-client/dist-es/ser-utils.js
init_process();
init_buffer();
var serializeDateTime = (date2) => date2.toISOString().replace(".000Z", "Z");

// node_modules/@smithy/smithy-client/dist-es/serde-json.js
init_process();
init_buffer();

// node_modules/@smithy/smithy-client/dist-es/split-every.js
init_process();
init_buffer();

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/check-content-length-header.js
var CONTENT_LENGTH_HEADER = "content-length";
function checkContentLengthHeader() {
  return (next, context) => async (args) => {
    const { request } = args;
    if (HttpRequest.isInstance(request)) {
      if (!(CONTENT_LENGTH_HEADER in request.headers)) {
        const message2 = `Are you using a Stream of unknown length as the Body of a PutObject request? Consider using Upload instead from @aws-sdk/lib-storage.`;
        if (typeof context?.logger?.warn === "function" && !(context.logger instanceof NoOpLogger)) {
          context.logger.warn(message2);
        } else {
          console.warn(message2);
        }
      }
    }
    return next({ ...args });
  };
}
var checkContentLengthHeaderMiddlewareOptions = {
  step: "finalizeRequest",
  tags: ["CHECK_CONTENT_LENGTH_HEADER"],
  name: "getCheckContentLengthHeaderPlugin",
  override: true
};
var getCheckContentLengthHeaderPlugin = (unused) => ({
  applyToStack: (clientStack) => {
    clientStack.add(checkContentLengthHeader(), checkContentLengthHeaderMiddlewareOptions);
  }
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/region-redirect-endpoint-middleware.js
init_process();
init_buffer();
var regionRedirectEndpointMiddleware = (config3) => {
  return (next, context) => async (args) => {
    const originalRegion = await config3.region();
    const regionProviderRef = config3.region;
    let unlock = () => {
    };
    if (context.__s3RegionRedirect) {
      Object.defineProperty(config3, "region", {
        writable: false,
        value: async () => {
          return context.__s3RegionRedirect;
        }
      });
      unlock = () => Object.defineProperty(config3, "region", {
        writable: true,
        value: regionProviderRef
      });
    }
    try {
      const result = await next(args);
      if (context.__s3RegionRedirect) {
        unlock();
        const region = await config3.region();
        if (originalRegion !== region) {
          throw new Error("Region was not restored following S3 region redirect.");
        }
      }
      return result;
    } catch (e2) {
      unlock();
      throw e2;
    }
  };
};
var regionRedirectEndpointMiddlewareOptions = {
  tags: ["REGION_REDIRECT", "S3"],
  name: "regionRedirectEndpointMiddleware",
  override: true,
  relation: "before",
  toMiddleware: "endpointV2Middleware"
};

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/region-redirect-middleware.js
init_process();
init_buffer();
function regionRedirectMiddleware(clientConfig) {
  return (next, context) => async (args) => {
    try {
      return await next(args);
    } catch (err) {
      if (clientConfig.followRegionRedirects && err?.$metadata?.httpStatusCode === 301) {
        try {
          const actualRegion = err.$response.headers["x-amz-bucket-region"];
          context.logger?.debug(`Redirecting from ${await clientConfig.region()} to ${actualRegion}`);
          context.__s3RegionRedirect = actualRegion;
        } catch (e2) {
          throw new Error("Region redirect failed: " + e2);
        }
        return next(args);
      } else {
        throw err;
      }
    }
  };
}
var regionRedirectMiddlewareOptions = {
  step: "initialize",
  tags: ["REGION_REDIRECT", "S3"],
  name: "regionRedirectMiddleware",
  override: true
};
var getRegionRedirectMiddlewarePlugin = (clientConfig) => ({
  applyToStack: (clientStack) => {
    clientStack.add(regionRedirectMiddleware(clientConfig), regionRedirectMiddlewareOptions);
    clientStack.addRelativeTo(regionRedirectEndpointMiddleware(clientConfig), regionRedirectEndpointMiddlewareOptions);
  }
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-expires-middleware.js
init_process();
init_buffer();

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/index.js
init_process();
init_buffer();

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/S3ExpressIdentityCache.js
init_process();
init_buffer();
var S3ExpressIdentityCache = class {
  constructor(data = {}) {
    this.data = data;
    this.lastPurgeTime = Date.now();
  }
  get(key2) {
    const entry = this.data[key2];
    if (!entry) {
      return;
    }
    return entry;
  }
  set(key2, entry) {
    this.data[key2] = entry;
    return entry;
  }
  delete(key2) {
    delete this.data[key2];
  }
  async purgeExpired() {
    const now = Date.now();
    if (this.lastPurgeTime + S3ExpressIdentityCache.EXPIRED_CREDENTIAL_PURGE_INTERVAL_MS > now) {
      return;
    }
    for (const key2 in this.data) {
      const entry = this.data[key2];
      if (!entry.isRefreshing) {
        const credential = await entry.identity;
        if (credential.expiration) {
          if (credential.expiration.getTime() < now) {
            delete this.data[key2];
          }
        }
      }
    }
  }
};
S3ExpressIdentityCache.EXPIRED_CREDENTIAL_PURGE_INTERVAL_MS = 3e4;

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/S3ExpressIdentityCacheEntry.js
init_process();
init_buffer();
var S3ExpressIdentityCacheEntry = class {
  constructor(_identity, isRefreshing = false, accessed = Date.now()) {
    this._identity = _identity;
    this.isRefreshing = isRefreshing;
    this.accessed = accessed;
  }
  get identity() {
    this.accessed = Date.now();
    return this._identity;
  }
};

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/S3ExpressIdentityProviderImpl.js
init_process();
init_buffer();
var S3ExpressIdentityProviderImpl = class {
  constructor(createSessionFn, cache = new S3ExpressIdentityCache()) {
    this.createSessionFn = createSessionFn;
    this.cache = cache;
  }
  async getS3ExpressIdentity(awsIdentity, identityProperties) {
    const key2 = identityProperties.Bucket;
    const { cache } = this;
    const entry = cache.get(key2);
    if (entry) {
      return entry.identity.then((identity) => {
        const isExpired = (identity.expiration?.getTime() ?? 0) < Date.now();
        if (isExpired) {
          return cache.set(key2, new S3ExpressIdentityCacheEntry(this.getIdentity(key2))).identity;
        }
        const isExpiringSoon = (identity.expiration?.getTime() ?? 0) < Date.now() + S3ExpressIdentityProviderImpl.REFRESH_WINDOW_MS;
        if (isExpiringSoon && !entry.isRefreshing) {
          entry.isRefreshing = true;
          this.getIdentity(key2).then((id) => {
            cache.set(key2, new S3ExpressIdentityCacheEntry(Promise.resolve(id)));
          });
        }
        return identity;
      });
    }
    return cache.set(key2, new S3ExpressIdentityCacheEntry(this.getIdentity(key2))).identity;
  }
  async getIdentity(key2) {
    await this.cache.purgeExpired().catch((error3) => {
      console.warn("Error while clearing expired entries in S3ExpressIdentityCache: \n" + error3);
    });
    const session = await this.createSessionFn(key2);
    if (!session.Credentials?.AccessKeyId || !session.Credentials?.SecretAccessKey) {
      throw new Error("s3#createSession response credential missing AccessKeyId or SecretAccessKey.");
    }
    const identity = {
      accessKeyId: session.Credentials.AccessKeyId,
      secretAccessKey: session.Credentials.SecretAccessKey,
      sessionToken: session.Credentials.SessionToken,
      expiration: session.Credentials.Expiration ? new Date(session.Credentials.Expiration) : void 0
    };
    return identity;
  }
};
S3ExpressIdentityProviderImpl.REFRESH_WINDOW_MS = 6e4;

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/SignatureV4S3Express.js
init_process();
init_buffer();

// node_modules/@smithy/signature-v4/dist-es/index.js
init_process();
init_buffer();

// node_modules/@smithy/signature-v4/dist-es/SignatureV4.js
init_process();
init_buffer();

// node_modules/@smithy/util-middleware/dist-es/index.js
init_process();
init_buffer();

// node_modules/@smithy/util-middleware/dist-es/getSmithyContext.js
init_process();
init_buffer();
var getSmithyContext = (context) => context[SMITHY_CONTEXT_KEY] || (context[SMITHY_CONTEXT_KEY] = {});

// node_modules/@smithy/util-middleware/dist-es/normalizeProvider.js
init_process();
init_buffer();
var normalizeProvider = (input) => {
  if (typeof input === "function")
    return input;
  const promisified = Promise.resolve(input);
  return () => promisified;
};

// node_modules/@smithy/signature-v4/dist-es/constants.js
init_process();
init_buffer();
var ALGORITHM_QUERY_PARAM = "X-Amz-Algorithm";
var CREDENTIAL_QUERY_PARAM = "X-Amz-Credential";
var AMZ_DATE_QUERY_PARAM = "X-Amz-Date";
var SIGNED_HEADERS_QUERY_PARAM = "X-Amz-SignedHeaders";
var EXPIRES_QUERY_PARAM = "X-Amz-Expires";
var SIGNATURE_QUERY_PARAM = "X-Amz-Signature";
var TOKEN_QUERY_PARAM = "X-Amz-Security-Token";
var AUTH_HEADER = "authorization";
var AMZ_DATE_HEADER = AMZ_DATE_QUERY_PARAM.toLowerCase();
var DATE_HEADER = "date";
var GENERATED_HEADERS = [AUTH_HEADER, AMZ_DATE_HEADER, DATE_HEADER];
var SIGNATURE_HEADER = SIGNATURE_QUERY_PARAM.toLowerCase();
var SHA256_HEADER = "x-amz-content-sha256";
var TOKEN_HEADER = TOKEN_QUERY_PARAM.toLowerCase();
var ALWAYS_UNSIGNABLE_HEADERS = {
  authorization: true,
  "cache-control": true,
  connection: true,
  expect: true,
  from: true,
  "keep-alive": true,
  "max-forwards": true,
  pragma: true,
  referer: true,
  te: true,
  trailer: true,
  "transfer-encoding": true,
  upgrade: true,
  "user-agent": true,
  "x-amzn-trace-id": true
};
var PROXY_HEADER_PATTERN = /^proxy-/;
var SEC_HEADER_PATTERN = /^sec-/;
var ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256";
var EVENT_ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256-PAYLOAD";
var UNSIGNED_PAYLOAD = "UNSIGNED-PAYLOAD";
var MAX_CACHE_SIZE = 50;
var KEY_TYPE_IDENTIFIER = "aws4_request";
var MAX_PRESIGNED_TTL = 60 * 60 * 24 * 7;

// node_modules/@smithy/signature-v4/dist-es/credentialDerivation.js
init_process();
init_buffer();
var signingKeyCache = {};
var cacheQueue = [];
var createScope = (shortDate, region, service) => `${shortDate}/${region}/${service}/${KEY_TYPE_IDENTIFIER}`;
var getSigningKey = async (sha256Constructor, credentials, shortDate, region, service) => {
  const credsHash = await hmac(sha256Constructor, credentials.secretAccessKey, credentials.accessKeyId);
  const cacheKey = `${shortDate}:${region}:${service}:${toHex2(credsHash)}:${credentials.sessionToken}`;
  if (cacheKey in signingKeyCache) {
    return signingKeyCache[cacheKey];
  }
  cacheQueue.push(cacheKey);
  while (cacheQueue.length > MAX_CACHE_SIZE) {
    delete signingKeyCache[cacheQueue.shift()];
  }
  let key2 = `AWS4${credentials.secretAccessKey}`;
  for (const signable of [shortDate, region, service, KEY_TYPE_IDENTIFIER]) {
    key2 = await hmac(sha256Constructor, key2, signable);
  }
  return signingKeyCache[cacheKey] = key2;
};
var hmac = (ctor, secret, data) => {
  const hash = new ctor(secret);
  hash.update(toUint8Array(data));
  return hash.digest();
};

// node_modules/@smithy/signature-v4/dist-es/getCanonicalHeaders.js
init_process();
init_buffer();
var getCanonicalHeaders = ({ headers }, unsignableHeaders, signableHeaders) => {
  const canonical = {};
  for (const headerName of Object.keys(headers).sort()) {
    if (headers[headerName] == void 0) {
      continue;
    }
    const canonicalHeaderName = headerName.toLowerCase();
    if (canonicalHeaderName in ALWAYS_UNSIGNABLE_HEADERS || unsignableHeaders?.has(canonicalHeaderName) || PROXY_HEADER_PATTERN.test(canonicalHeaderName) || SEC_HEADER_PATTERN.test(canonicalHeaderName)) {
      if (!signableHeaders || signableHeaders && !signableHeaders.has(canonicalHeaderName)) {
        continue;
      }
    }
    canonical[canonicalHeaderName] = headers[headerName].trim().replace(/\s+/g, " ");
  }
  return canonical;
};

// node_modules/@smithy/signature-v4/dist-es/getCanonicalQuery.js
init_process();
init_buffer();
var getCanonicalQuery = ({ query = {} }) => {
  const keys3 = [];
  const serialized = {};
  for (const key2 of Object.keys(query).sort()) {
    if (key2.toLowerCase() === SIGNATURE_HEADER) {
      continue;
    }
    keys3.push(key2);
    const value = query[key2];
    if (typeof value === "string") {
      serialized[key2] = `${escapeUri(key2)}=${escapeUri(value)}`;
    } else if (Array.isArray(value)) {
      serialized[key2] = value.slice(0).reduce((encoded, value2) => encoded.concat([`${escapeUri(key2)}=${escapeUri(value2)}`]), []).sort().join("&");
    }
  }
  return keys3.map((key2) => serialized[key2]).filter((serialized2) => serialized2).join("&");
};

// node_modules/@smithy/signature-v4/dist-es/getPayloadHash.js
init_process();
init_buffer();

// node_modules/@smithy/is-array-buffer/dist-es/index.js
init_process();
init_buffer();
var isArrayBuffer = (arg) => typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer || Object.prototype.toString.call(arg) === "[object ArrayBuffer]";

// node_modules/@smithy/signature-v4/dist-es/getPayloadHash.js
var getPayloadHash = async ({ headers, body: body3 }, hashConstructor) => {
  for (const headerName of Object.keys(headers)) {
    if (headerName.toLowerCase() === SHA256_HEADER) {
      return headers[headerName];
    }
  }
  if (body3 == void 0) {
    return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
  } else if (typeof body3 === "string" || ArrayBuffer.isView(body3) || isArrayBuffer(body3)) {
    const hashCtor = new hashConstructor();
    hashCtor.update(toUint8Array(body3));
    return toHex2(await hashCtor.digest());
  }
  return UNSIGNED_PAYLOAD;
};

// node_modules/@smithy/signature-v4/dist-es/HeaderFormatter.js
init_process();
init_buffer();
var HeaderFormatter = class {
  format(headers) {
    const chunks = [];
    for (const headerName of Object.keys(headers)) {
      const bytes = fromUtf8(headerName);
      chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));
    }
    const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));
    let position4 = 0;
    for (const chunk of chunks) {
      out.set(chunk, position4);
      position4 += chunk.byteLength;
    }
    return out;
  }
  formatHeaderValue(header) {
    switch (header.type) {
      case "boolean":
        return Uint8Array.from([header.value ? 0 : 1]);
      case "byte":
        return Uint8Array.from([2, header.value]);
      case "short":
        const shortView = new DataView(new ArrayBuffer(3));
        shortView.setUint8(0, 3);
        shortView.setInt16(1, header.value, false);
        return new Uint8Array(shortView.buffer);
      case "integer":
        const intView = new DataView(new ArrayBuffer(5));
        intView.setUint8(0, 4);
        intView.setInt32(1, header.value, false);
        return new Uint8Array(intView.buffer);
      case "long":
        const longBytes = new Uint8Array(9);
        longBytes[0] = 5;
        longBytes.set(header.value.bytes, 1);
        return longBytes;
      case "binary":
        const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));
        binView.setUint8(0, 6);
        binView.setUint16(1, header.value.byteLength, false);
        const binBytes = new Uint8Array(binView.buffer);
        binBytes.set(header.value, 3);
        return binBytes;
      case "string":
        const utf8Bytes = fromUtf8(header.value);
        const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));
        strView.setUint8(0, 7);
        strView.setUint16(1, utf8Bytes.byteLength, false);
        const strBytes = new Uint8Array(strView.buffer);
        strBytes.set(utf8Bytes, 3);
        return strBytes;
      case "timestamp":
        const tsBytes = new Uint8Array(9);
        tsBytes[0] = 8;
        tsBytes.set(Int64.fromNumber(header.value.valueOf()).bytes, 1);
        return tsBytes;
      case "uuid":
        if (!UUID_PATTERN.test(header.value)) {
          throw new Error(`Invalid UUID received: ${header.value}`);
        }
        const uuidBytes = new Uint8Array(17);
        uuidBytes[0] = 9;
        uuidBytes.set(fromHex(header.value.replace(/\-/g, "")), 1);
        return uuidBytes;
    }
  }
};
var HEADER_VALUE_TYPE;
(function(HEADER_VALUE_TYPE3) {
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["boolTrue"] = 0] = "boolTrue";
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["boolFalse"] = 1] = "boolFalse";
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["byte"] = 2] = "byte";
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["short"] = 3] = "short";
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["integer"] = 4] = "integer";
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["long"] = 5] = "long";
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["byteArray"] = 6] = "byteArray";
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["string"] = 7] = "string";
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["timestamp"] = 8] = "timestamp";
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["uuid"] = 9] = "uuid";
})(HEADER_VALUE_TYPE || (HEADER_VALUE_TYPE = {}));
var UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
var Int64 = class {
  constructor(bytes) {
    this.bytes = bytes;
    if (bytes.byteLength !== 8) {
      throw new Error("Int64 buffers must be exactly 8 bytes");
    }
  }
  static fromNumber(number2) {
    if (number2 > 9223372036854776e3 || number2 < -9223372036854776e3) {
      throw new Error(`${number2} is too large (or, if negative, too small) to represent as an Int64`);
    }
    const bytes = new Uint8Array(8);
    for (let i2 = 7, remaining = Math.abs(Math.round(number2)); i2 > -1 && remaining > 0; i2--, remaining /= 256) {
      bytes[i2] = remaining;
    }
    if (number2 < 0) {
      negate(bytes);
    }
    return new Int64(bytes);
  }
  valueOf() {
    const bytes = this.bytes.slice(0);
    const negative = bytes[0] & 128;
    if (negative) {
      negate(bytes);
    }
    return parseInt(toHex2(bytes), 16) * (negative ? -1 : 1);
  }
  toString() {
    return String(this.valueOf());
  }
};
function negate(bytes) {
  for (let i2 = 0; i2 < 8; i2++) {
    bytes[i2] ^= 255;
  }
  for (let i2 = 7; i2 > -1; i2--) {
    bytes[i2]++;
    if (bytes[i2] !== 0)
      break;
  }
}

// node_modules/@smithy/signature-v4/dist-es/headerUtil.js
init_process();
init_buffer();
var hasHeader = (soughtHeader, headers) => {
  soughtHeader = soughtHeader.toLowerCase();
  for (const headerName of Object.keys(headers)) {
    if (soughtHeader === headerName.toLowerCase()) {
      return true;
    }
  }
  return false;
};

// node_modules/@smithy/signature-v4/dist-es/moveHeadersToQuery.js
init_process();
init_buffer();
var moveHeadersToQuery = (request, options = {}) => {
  const { headers, query = {} } = HttpRequest.clone(request);
  for (const name of Object.keys(headers)) {
    const lname = name.toLowerCase();
    if (lname.slice(0, 6) === "x-amz-" && !options.unhoistableHeaders?.has(lname)) {
      query[name] = headers[name];
      delete headers[name];
    }
  }
  return {
    ...request,
    headers,
    query
  };
};

// node_modules/@smithy/signature-v4/dist-es/prepareRequest.js
init_process();
init_buffer();
var prepareRequest = (request) => {
  request = HttpRequest.clone(request);
  for (const headerName of Object.keys(request.headers)) {
    if (GENERATED_HEADERS.indexOf(headerName.toLowerCase()) > -1) {
      delete request.headers[headerName];
    }
  }
  return request;
};

// node_modules/@smithy/signature-v4/dist-es/utilDate.js
init_process();
init_buffer();
var iso8601 = (time) => toDate(time).toISOString().replace(/\.\d{3}Z$/, "Z");
var toDate = (time) => {
  if (typeof time === "number") {
    return new Date(time * 1e3);
  }
  if (typeof time === "string") {
    if (Number(time)) {
      return new Date(Number(time) * 1e3);
    }
    return new Date(time);
  }
  return time;
};

// node_modules/@smithy/signature-v4/dist-es/SignatureV4.js
var SignatureV4 = class {
  constructor({ applyChecksum, credentials, region, service, sha256: sha2562, uriEscapePath = true }) {
    this.headerFormatter = new HeaderFormatter();
    this.service = service;
    this.sha256 = sha2562;
    this.uriEscapePath = uriEscapePath;
    this.applyChecksum = typeof applyChecksum === "boolean" ? applyChecksum : true;
    this.regionProvider = normalizeProvider(region);
    this.credentialProvider = normalizeProvider(credentials);
  }
  async presign(originalRequest, options = {}) {
    const { signingDate = /* @__PURE__ */ new Date(), expiresIn = 3600, unsignableHeaders, unhoistableHeaders, signableHeaders, signingRegion, signingService } = options;
    const credentials = await this.credentialProvider();
    this.validateResolvedCredentials(credentials);
    const region = signingRegion ?? await this.regionProvider();
    const { longDate, shortDate } = formatDate(signingDate);
    if (expiresIn > MAX_PRESIGNED_TTL) {
      return Promise.reject("Signature version 4 presigned URLs must have an expiration date less than one week in the future");
    }
    const scope = createScope(shortDate, region, signingService ?? this.service);
    const request = moveHeadersToQuery(prepareRequest(originalRequest), { unhoistableHeaders });
    if (credentials.sessionToken) {
      request.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;
    }
    request.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;
    request.query[CREDENTIAL_QUERY_PARAM] = `${credentials.accessKeyId}/${scope}`;
    request.query[AMZ_DATE_QUERY_PARAM] = longDate;
    request.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);
    const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);
    request.query[SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);
    request.query[SIGNATURE_QUERY_PARAM] = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, await getPayloadHash(originalRequest, this.sha256)));
    return request;
  }
  async sign(toSign, options) {
    if (typeof toSign === "string") {
      return this.signString(toSign, options);
    } else if (toSign.headers && toSign.payload) {
      return this.signEvent(toSign, options);
    } else if (toSign.message) {
      return this.signMessage(toSign, options);
    } else {
      return this.signRequest(toSign, options);
    }
  }
  async signEvent({ headers, payload }, { signingDate = /* @__PURE__ */ new Date(), priorSignature, signingRegion, signingService }) {
    const region = signingRegion ?? await this.regionProvider();
    const { shortDate, longDate } = formatDate(signingDate);
    const scope = createScope(shortDate, region, signingService ?? this.service);
    const hashedPayload = await getPayloadHash({ headers: {}, body: payload }, this.sha256);
    const hash = new this.sha256();
    hash.update(headers);
    const hashedHeaders = toHex2(await hash.digest());
    const stringToSign = [
      EVENT_ALGORITHM_IDENTIFIER,
      longDate,
      scope,
      priorSignature,
      hashedHeaders,
      hashedPayload
    ].join("\n");
    return this.signString(stringToSign, { signingDate, signingRegion: region, signingService });
  }
  async signMessage(signableMessage, { signingDate = /* @__PURE__ */ new Date(), signingRegion, signingService }) {
    const promise = this.signEvent({
      headers: this.headerFormatter.format(signableMessage.message.headers),
      payload: signableMessage.message.body
    }, {
      signingDate,
      signingRegion,
      signingService,
      priorSignature: signableMessage.priorSignature
    });
    return promise.then((signature) => {
      return { message: signableMessage.message, signature };
    });
  }
  async signString(stringToSign, { signingDate = /* @__PURE__ */ new Date(), signingRegion, signingService } = {}) {
    const credentials = await this.credentialProvider();
    this.validateResolvedCredentials(credentials);
    const region = signingRegion ?? await this.regionProvider();
    const { shortDate } = formatDate(signingDate);
    const hash = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));
    hash.update(toUint8Array(stringToSign));
    return toHex2(await hash.digest());
  }
  async signRequest(requestToSign, { signingDate = /* @__PURE__ */ new Date(), signableHeaders, unsignableHeaders, signingRegion, signingService } = {}) {
    const credentials = await this.credentialProvider();
    this.validateResolvedCredentials(credentials);
    const region = signingRegion ?? await this.regionProvider();
    const request = prepareRequest(requestToSign);
    const { longDate, shortDate } = formatDate(signingDate);
    const scope = createScope(shortDate, region, signingService ?? this.service);
    request.headers[AMZ_DATE_HEADER] = longDate;
    if (credentials.sessionToken) {
      request.headers[TOKEN_HEADER] = credentials.sessionToken;
    }
    const payloadHash = await getPayloadHash(request, this.sha256);
    if (!hasHeader(SHA256_HEADER, request.headers) && this.applyChecksum) {
      request.headers[SHA256_HEADER] = payloadHash;
    }
    const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);
    const signature = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, payloadHash));
    request.headers[AUTH_HEADER] = `${ALGORITHM_IDENTIFIER} Credential=${credentials.accessKeyId}/${scope}, SignedHeaders=${getCanonicalHeaderList(canonicalHeaders)}, Signature=${signature}`;
    return request;
  }
  createCanonicalRequest(request, canonicalHeaders, payloadHash) {
    const sortedHeaders = Object.keys(canonicalHeaders).sort();
    return `${request.method}
${this.getCanonicalPath(request)}
${getCanonicalQuery(request)}
${sortedHeaders.map((name) => `${name}:${canonicalHeaders[name]}`).join("\n")}

${sortedHeaders.join(";")}
${payloadHash}`;
  }
  async createStringToSign(longDate, credentialScope, canonicalRequest) {
    const hash = new this.sha256();
    hash.update(toUint8Array(canonicalRequest));
    const hashedRequest = await hash.digest();
    return `${ALGORITHM_IDENTIFIER}
${longDate}
${credentialScope}
${toHex2(hashedRequest)}`;
  }
  getCanonicalPath({ path: path2 }) {
    if (this.uriEscapePath) {
      const normalizedPathSegments = [];
      for (const pathSegment of path2.split("/")) {
        if (pathSegment?.length === 0)
          continue;
        if (pathSegment === ".")
          continue;
        if (pathSegment === "..") {
          normalizedPathSegments.pop();
        } else {
          normalizedPathSegments.push(pathSegment);
        }
      }
      const normalizedPath = `${path2?.startsWith("/") ? "/" : ""}${normalizedPathSegments.join("/")}${normalizedPathSegments.length > 0 && path2?.endsWith("/") ? "/" : ""}`;
      const doubleEncoded = escapeUri(normalizedPath);
      return doubleEncoded.replace(/%2F/g, "/");
    }
    return path2;
  }
  async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {
    const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest);
    const hash = new this.sha256(await keyPromise);
    hash.update(toUint8Array(stringToSign));
    return toHex2(await hash.digest());
  }
  getSigningKey(credentials, region, shortDate, service) {
    return getSigningKey(this.sha256, credentials, shortDate, region, service || this.service);
  }
  validateResolvedCredentials(credentials) {
    if (typeof credentials !== "object" || typeof credentials.accessKeyId !== "string" || typeof credentials.secretAccessKey !== "string") {
      throw new Error("Resolved credential object is not valid");
    }
  }
};
var formatDate = (now) => {
  const longDate = iso8601(now).replace(/[\-:]/g, "");
  return {
    longDate,
    shortDate: longDate.slice(0, 8)
  };
};
var getCanonicalHeaderList = (headers) => Object.keys(headers).sort().join(";");

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/constants.js
init_process();
init_buffer();

// node_modules/@smithy/util-config-provider/dist-es/index.js
init_process();
init_buffer();

// node_modules/@smithy/util-config-provider/dist-es/booleanSelector.js
init_process();
init_buffer();

// node_modules/@smithy/util-config-provider/dist-es/numberSelector.js
init_process();
init_buffer();

// node_modules/@smithy/util-config-provider/dist-es/types.js
init_process();
init_buffer();
var SelectorType;
(function(SelectorType2) {
  SelectorType2["ENV"] = "env";
  SelectorType2["CONFIG"] = "shared config entry";
})(SelectorType || (SelectorType = {}));

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/constants.js
var S3_EXPRESS_BUCKET_TYPE = "Directory";
var S3_EXPRESS_BACKEND = "S3Express";
var S3_EXPRESS_AUTH_SCHEME = "sigv4-s3express";
var SESSION_TOKEN_QUERY_PARAM = "X-Amz-S3session-Token";
var SESSION_TOKEN_HEADER = SESSION_TOKEN_QUERY_PARAM.toLowerCase();

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/SignatureV4S3Express.js
var SignatureV4S3Express = class extends SignatureV4 {
  async signWithCredentials(requestToSign, credentials, options) {
    const credentialsWithoutSessionToken = getCredentialsWithoutSessionToken(credentials);
    requestToSign.headers[SESSION_TOKEN_HEADER] = credentials.sessionToken;
    const privateAccess = this;
    setSingleOverride(privateAccess, credentialsWithoutSessionToken);
    return privateAccess.signRequest(requestToSign, options ?? {});
  }
  async presignWithCredentials(requestToSign, credentials, options) {
    const credentialsWithoutSessionToken = getCredentialsWithoutSessionToken(credentials);
    delete requestToSign.headers[SESSION_TOKEN_HEADER];
    requestToSign.headers[SESSION_TOKEN_QUERY_PARAM] = credentials.sessionToken;
    requestToSign.query = requestToSign.query ?? {};
    requestToSign.query[SESSION_TOKEN_QUERY_PARAM] = credentials.sessionToken;
    const privateAccess = this;
    setSingleOverride(privateAccess, credentialsWithoutSessionToken);
    return this.presign(requestToSign, options);
  }
};
function getCredentialsWithoutSessionToken(credentials) {
  const credentialsWithoutSessionToken = {
    accessKeyId: credentials.accessKeyId,
    secretAccessKey: credentials.secretAccessKey,
    expiration: credentials.expiration
  };
  return credentialsWithoutSessionToken;
}
function setSingleOverride(privateAccess, credentialsWithoutSessionToken) {
  const id = setTimeout(() => {
    throw new Error("SignatureV4S3Express credential override was created but not called.");
  }, 10);
  const currentCredentialProvider = privateAccess.credentialProvider;
  const overrideCredentialsProviderOnce = () => {
    clearTimeout(id);
    privateAccess.credentialProvider = currentCredentialProvider;
    return Promise.resolve(credentialsWithoutSessionToken);
  };
  privateAccess.credentialProvider = overrideCredentialsProviderOnce;
}

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/functions/s3ExpressMiddleware.js
init_process();
init_buffer();
var s3ExpressMiddleware = (options) => {
  return (next, context) => async (args) => {
    if (context.endpointV2) {
      const endpoint = context.endpointV2;
      const isS3ExpressAuth = endpoint.properties?.authSchemes?.[0]?.name === S3_EXPRESS_AUTH_SCHEME;
      const isS3ExpressBucket = endpoint.properties?.backend === S3_EXPRESS_BACKEND || endpoint.properties?.bucketType === S3_EXPRESS_BUCKET_TYPE;
      if (isS3ExpressBucket) {
        context.isS3ExpressBucket = true;
      }
      if (isS3ExpressAuth) {
        const requestBucket = args.input.Bucket;
        if (requestBucket) {
          const s3ExpressIdentity = await options.s3ExpressIdentityProvider.getS3ExpressIdentity(await options.credentials(), {
            Bucket: requestBucket
          });
          context.s3ExpressIdentity = s3ExpressIdentity;
          if (HttpRequest.isInstance(args.request) && s3ExpressIdentity.sessionToken) {
            args.request.headers[SESSION_TOKEN_HEADER] = s3ExpressIdentity.sessionToken;
          }
        }
      }
    }
    return next(args);
  };
};
var s3ExpressMiddlewareOptions = {
  name: "s3ExpressMiddleware",
  step: "build",
  tags: ["S3", "S3_EXPRESS"],
  override: true
};
var getS3ExpressPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(s3ExpressMiddleware(options), s3ExpressMiddlewareOptions);
  }
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/functions/s3ExpressHttpSigningMiddleware.js
init_process();
init_buffer();

// node_modules/@smithy/core/dist-es/index.js
init_process();
init_buffer();

// node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/index.js
init_process();
init_buffer();

// node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/httpAuthSchemeMiddleware.js
init_process();
init_buffer();
function convertHttpAuthSchemesToMap(httpAuthSchemes) {
  const map9 = /* @__PURE__ */ new Map();
  for (const scheme of httpAuthSchemes) {
    map9.set(scheme.schemeId, scheme);
  }
  return map9;
}
var httpAuthSchemeMiddleware = (config3, mwOptions) => (next, context) => async (args) => {
  const options = config3.httpAuthSchemeProvider(await mwOptions.httpAuthSchemeParametersProvider(config3, context, args.input));
  const authSchemes = convertHttpAuthSchemesToMap(config3.httpAuthSchemes);
  const smithyContext = getSmithyContext(context);
  const failureReasons = [];
  for (const option2 of options) {
    const scheme = authSchemes.get(option2.schemeId);
    if (!scheme) {
      failureReasons.push(`HttpAuthScheme \`${option2.schemeId}\` was not enabled for this service.`);
      continue;
    }
    const identityProvider = scheme.identityProvider(await mwOptions.identityProviderConfigProvider(config3));
    if (!identityProvider) {
      failureReasons.push(`HttpAuthScheme \`${option2.schemeId}\` did not have an IdentityProvider configured.`);
      continue;
    }
    const { identityProperties = {}, signingProperties = {} } = option2.propertiesExtractor?.(config3, context) || {};
    option2.identityProperties = Object.assign(option2.identityProperties || {}, identityProperties);
    option2.signingProperties = Object.assign(option2.signingProperties || {}, signingProperties);
    smithyContext.selectedHttpAuthScheme = {
      httpAuthOption: option2,
      identity: await identityProvider(option2.identityProperties),
      signer: scheme.signer
    };
    break;
  }
  if (!smithyContext.selectedHttpAuthScheme) {
    throw new Error(failureReasons.join("\n"));
  }
  return next(args);
};

// node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/getHttpAuthSchemeEndpointRuleSetPlugin.js
init_process();
init_buffer();

// node_modules/@smithy/middleware-endpoint/dist-es/index.js
init_process();
init_buffer();

// node_modules/@smithy/middleware-endpoint/dist-es/adaptors/index.js
init_process();
init_buffer();

// node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointFromInstructions.js
init_process();
init_buffer();

// node_modules/@smithy/middleware-endpoint/dist-es/service-customizations/index.js
init_process();
init_buffer();

// node_modules/@smithy/middleware-endpoint/dist-es/service-customizations/s3.js
init_process();
init_buffer();
var resolveParamsForS3 = async (endpointParams) => {
  const bucket = endpointParams?.Bucket || "";
  if (typeof endpointParams.Bucket === "string") {
    endpointParams.Bucket = bucket.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"));
  }
  if (isArnBucketName(bucket)) {
    if (endpointParams.ForcePathStyle === true) {
      throw new Error("Path-style addressing cannot be used with ARN buckets");
    }
  } else if (!isDnsCompatibleBucketName(bucket) || bucket.indexOf(".") !== -1 && !String(endpointParams.Endpoint).startsWith("http:") || bucket.toLowerCase() !== bucket || bucket.length < 3) {
    endpointParams.ForcePathStyle = true;
  }
  if (endpointParams.DisableMultiRegionAccessPoints) {
    endpointParams.disableMultiRegionAccessPoints = true;
    endpointParams.DisableMRAP = true;
  }
  return endpointParams;
};
var DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/;
var IP_ADDRESS_PATTERN = /(\d+\.){3}\d+/;
var DOTS_PATTERN = /\.\./;
var isDnsCompatibleBucketName = (bucketName) => DOMAIN_PATTERN.test(bucketName) && !IP_ADDRESS_PATTERN.test(bucketName) && !DOTS_PATTERN.test(bucketName);
var isArnBucketName = (bucketName) => {
  const [arn, partition2, service, , , bucket] = bucketName.split(":");
  const isArn = arn === "arn" && bucketName.split(":").length >= 6;
  const isValidArn = Boolean(isArn && partition2 && service && bucket);
  if (isArn && !isValidArn) {
    throw new Error(`Invalid ARN: ${bucketName} was an invalid ARN.`);
  }
  return isValidArn;
};

// node_modules/@smithy/middleware-endpoint/dist-es/adaptors/createConfigValueProvider.js
init_process();
init_buffer();
var createConfigValueProvider = (configKey, canonicalEndpointParamKey, config3) => {
  const configProvider = async () => {
    const configValue = config3[configKey] ?? config3[canonicalEndpointParamKey];
    if (typeof configValue === "function") {
      return configValue();
    }
    return configValue;
  };
  if (configKey === "credentialScope" || canonicalEndpointParamKey === "CredentialScope") {
    return async () => {
      const credentials = typeof config3.credentials === "function" ? await config3.credentials() : config3.credentials;
      const configValue = credentials?.credentialScope ?? credentials?.CredentialScope;
      return configValue;
    };
  }
  if (configKey === "accountId" || canonicalEndpointParamKey === "AccountId") {
    return async () => {
      const credentials = typeof config3.credentials === "function" ? await config3.credentials() : config3.credentials;
      const configValue = credentials?.accountId ?? credentials?.AccountId;
      return configValue;
    };
  }
  if (configKey === "endpoint" || canonicalEndpointParamKey === "endpoint") {
    return async () => {
      const endpoint = await configProvider();
      if (endpoint && typeof endpoint === "object") {
        if ("url" in endpoint) {
          return endpoint.url.href;
        }
        if ("hostname" in endpoint) {
          const { protocol, hostname, port, path: path2 } = endpoint;
          return `${protocol}//${hostname}${port ? ":" + port : ""}${path2}`;
        }
      }
      return endpoint;
    };
  }
  return configProvider;
};

// node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointFromConfig.browser.js
init_process();
init_buffer();
var getEndpointFromConfig = async (serviceId) => void 0;

// node_modules/@smithy/middleware-endpoint/dist-es/adaptors/toEndpointV1.js
init_process();
init_buffer();

// node_modules/@smithy/url-parser/dist-es/index.js
init_process();
init_buffer();

// node_modules/@smithy/querystring-parser/dist-es/index.js
init_process();
init_buffer();
function parseQueryString(querystring) {
  const query = {};
  querystring = querystring.replace(/^\?/, "");
  if (querystring) {
    for (const pair of querystring.split("&")) {
      let [key2, value = null] = pair.split("=");
      key2 = decodeURIComponent(key2);
      if (value) {
        value = decodeURIComponent(value);
      }
      if (!(key2 in query)) {
        query[key2] = value;
      } else if (Array.isArray(query[key2])) {
        query[key2].push(value);
      } else {
        query[key2] = [query[key2], value];
      }
    }
  }
  return query;
}

// node_modules/@smithy/url-parser/dist-es/index.js
var parseUrl = (url) => {
  if (typeof url === "string") {
    return parseUrl(new URL(url));
  }
  const { hostname, pathname, port, protocol, search: search2 } = url;
  let query;
  if (search2) {
    query = parseQueryString(search2);
  }
  return {
    hostname,
    port: port ? parseInt(port) : void 0,
    protocol,
    path: pathname,
    query
  };
};

// node_modules/@smithy/middleware-endpoint/dist-es/adaptors/toEndpointV1.js
var toEndpointV1 = (endpoint) => {
  if (typeof endpoint === "object") {
    if ("url" in endpoint) {
      return parseUrl(endpoint.url);
    }
    return endpoint;
  }
  return parseUrl(endpoint);
};

// node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointFromInstructions.js
var getEndpointFromInstructions = async (commandInput, instructionsSupplier, clientConfig, context) => {
  if (!clientConfig.endpoint) {
    const endpointFromConfig = await getEndpointFromConfig(clientConfig.serviceId || "");
    if (endpointFromConfig) {
      clientConfig.endpoint = () => Promise.resolve(toEndpointV1(endpointFromConfig));
    }
  }
  const endpointParams = await resolveParams(commandInput, instructionsSupplier, clientConfig);
  if (typeof clientConfig.endpointProvider !== "function") {
    throw new Error("config.endpointProvider is not set.");
  }
  const endpoint = clientConfig.endpointProvider(endpointParams, context);
  return endpoint;
};
var resolveParams = async (commandInput, instructionsSupplier, clientConfig) => {
  const endpointParams = {};
  const instructions = instructionsSupplier?.getEndpointParameterInstructions?.() || {};
  for (const [name, instruction] of Object.entries(instructions)) {
    switch (instruction.type) {
      case "staticContextParams":
        endpointParams[name] = instruction.value;
        break;
      case "contextParams":
        endpointParams[name] = commandInput[instruction.name];
        break;
      case "clientContextParams":
      case "builtInParams":
        endpointParams[name] = await createConfigValueProvider(instruction.name, name, clientConfig)();
        break;
      default:
        throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(instruction));
    }
  }
  if (Object.keys(instructions).length === 0) {
    Object.assign(endpointParams, clientConfig);
  }
  if (String(clientConfig.serviceId).toLowerCase() === "s3") {
    await resolveParamsForS3(endpointParams);
  }
  return endpointParams;
};

// node_modules/@smithy/middleware-endpoint/dist-es/endpointMiddleware.js
init_process();
init_buffer();
var endpointMiddleware = ({ config: config3, instructions }) => {
  return (next, context) => async (args) => {
    const endpoint = await getEndpointFromInstructions(args.input, {
      getEndpointParameterInstructions() {
        return instructions;
      }
    }, { ...config3 }, context);
    context.endpointV2 = endpoint;
    context.authSchemes = endpoint.properties?.authSchemes;
    const authScheme = context.authSchemes?.[0];
    if (authScheme) {
      context["signing_region"] = authScheme.signingRegion;
      context["signing_service"] = authScheme.signingName;
      const smithyContext = getSmithyContext(context);
      const httpAuthOption = smithyContext?.selectedHttpAuthScheme?.httpAuthOption;
      if (httpAuthOption) {
        httpAuthOption.signingProperties = Object.assign(httpAuthOption.signingProperties || {}, {
          signing_region: authScheme.signingRegion,
          signingRegion: authScheme.signingRegion,
          signing_service: authScheme.signingName,
          signingName: authScheme.signingName,
          signingRegionSet: authScheme.signingRegionSet
        }, authScheme.properties);
      }
    }
    return next({
      ...args
    });
  };
};

// node_modules/@smithy/middleware-endpoint/dist-es/getEndpointPlugin.js
init_process();
init_buffer();

// node_modules/@smithy/middleware-serde/dist-es/index.js
init_process();
init_buffer();

// node_modules/@smithy/middleware-serde/dist-es/deserializerMiddleware.js
init_process();
init_buffer();
var deserializerMiddleware = (options, deserializer2) => (next) => async (args) => {
  const { response } = await next(args);
  try {
    const parsed = await deserializer2(response, options);
    return {
      response,
      output: parsed
    };
  } catch (error3) {
    Object.defineProperty(error3, "$response", {
      value: response
    });
    if (!("$metadata" in error3)) {
      const hint = `Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.`;
      error3.message += "\n  " + hint;
      if (typeof error3.$responseBodyText !== "undefined") {
        if (error3.$response) {
          error3.$response.body = error3.$responseBodyText;
        }
      }
    }
    throw error3;
  }
};

// node_modules/@smithy/middleware-serde/dist-es/serdePlugin.js
init_process();
init_buffer();

// node_modules/@smithy/middleware-serde/dist-es/serializerMiddleware.js
init_process();
init_buffer();
var serializerMiddleware = (options, serializer2) => (next, context) => async (args) => {
  const endpoint = context.endpointV2?.url && options.urlParser ? async () => options.urlParser(context.endpointV2.url) : options.endpoint;
  if (!endpoint) {
    throw new Error("No valid endpoint provider available.");
  }
  const request = await serializer2(args.input, { ...options, endpoint });
  return next({
    ...args,
    request
  });
};

// node_modules/@smithy/middleware-serde/dist-es/serdePlugin.js
var deserializerMiddlewareOption = {
  name: "deserializerMiddleware",
  step: "deserialize",
  tags: ["DESERIALIZER"],
  override: true
};
var serializerMiddlewareOption = {
  name: "serializerMiddleware",
  step: "serialize",
  tags: ["SERIALIZER"],
  override: true
};
function getSerdePlugin(config3, serializer2, deserializer2) {
  return {
    applyToStack: (commandStack) => {
      commandStack.add(deserializerMiddleware(config3, deserializer2), deserializerMiddlewareOption);
      commandStack.add(serializerMiddleware(config3, serializer2), serializerMiddlewareOption);
    }
  };
}

// node_modules/@smithy/middleware-endpoint/dist-es/getEndpointPlugin.js
var endpointMiddlewareOptions = {
  step: "serialize",
  tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
  name: "endpointV2Middleware",
  override: true,
  relation: "before",
  toMiddleware: serializerMiddlewareOption.name
};
var getEndpointPlugin = (config3, instructions) => ({
  applyToStack: (clientStack) => {
    clientStack.addRelativeTo(endpointMiddleware({
      config: config3,
      instructions
    }), endpointMiddlewareOptions);
  }
});

// node_modules/@smithy/middleware-endpoint/dist-es/resolveEndpointConfig.js
init_process();
init_buffer();
var resolveEndpointConfig = (input) => {
  const tls = input.tls ?? true;
  const { endpoint } = input;
  const customEndpointProvider = endpoint != null ? async () => toEndpointV1(await normalizeProvider(endpoint)()) : void 0;
  const isCustomEndpoint = !!endpoint;
  return {
    ...input,
    endpoint: customEndpointProvider,
    tls,
    isCustomEndpoint,
    useDualstackEndpoint: normalizeProvider(input.useDualstackEndpoint ?? false),
    useFipsEndpoint: normalizeProvider(input.useFipsEndpoint ?? false)
  };
};

// node_modules/@smithy/middleware-endpoint/dist-es/types.js
init_process();
init_buffer();

// node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/getHttpAuthSchemeEndpointRuleSetPlugin.js
var httpAuthSchemeEndpointRuleSetMiddlewareOptions = {
  step: "serialize",
  tags: ["HTTP_AUTH_SCHEME"],
  name: "httpAuthSchemeMiddleware",
  override: true,
  relation: "before",
  toMiddleware: endpointMiddlewareOptions.name
};
var getHttpAuthSchemeEndpointRuleSetPlugin = (config3, { httpAuthSchemeParametersProvider, identityProviderConfigProvider }) => ({
  applyToStack: (clientStack) => {
    clientStack.addRelativeTo(httpAuthSchemeMiddleware(config3, {
      httpAuthSchemeParametersProvider,
      identityProviderConfigProvider
    }), httpAuthSchemeEndpointRuleSetMiddlewareOptions);
  }
});

// node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/getHttpAuthSchemePlugin.js
init_process();
init_buffer();
var httpAuthSchemeMiddlewareOptions = {
  step: "serialize",
  tags: ["HTTP_AUTH_SCHEME"],
  name: "httpAuthSchemeMiddleware",
  override: true,
  relation: "before",
  toMiddleware: serializerMiddlewareOption.name
};

// node_modules/@smithy/core/dist-es/middleware-http-signing/index.js
init_process();
init_buffer();

// node_modules/@smithy/core/dist-es/middleware-http-signing/httpSigningMiddleware.js
init_process();
init_buffer();
var defaultErrorHandler = (signingProperties) => (error3) => {
  throw error3;
};
var defaultSuccessHandler = (httpResponse, signingProperties) => {
};
var httpSigningMiddleware = (config3) => (next, context) => async (args) => {
  if (!HttpRequest.isInstance(args.request)) {
    return next(args);
  }
  const smithyContext = getSmithyContext(context);
  const scheme = smithyContext.selectedHttpAuthScheme;
  if (!scheme) {
    throw new Error(`No HttpAuthScheme was selected: unable to sign request`);
  }
  const { httpAuthOption: { signingProperties = {} }, identity, signer } = scheme;
  const output = await next({
    ...args,
    request: await signer.sign(args.request, identity, signingProperties)
  }).catch((signer.errorHandler || defaultErrorHandler)(signingProperties));
  (signer.successHandler || defaultSuccessHandler)(output.response, signingProperties);
  return output;
};

// node_modules/@smithy/core/dist-es/middleware-http-signing/getHttpSigningMiddleware.js
init_process();
init_buffer();

// node_modules/@smithy/middleware-retry/dist-es/index.js
init_process();
init_buffer();

// node_modules/@smithy/middleware-retry/dist-es/AdaptiveRetryStrategy.js
init_process();
init_buffer();

// node_modules/@smithy/util-retry/dist-es/index.js
init_process();
init_buffer();

// node_modules/@smithy/util-retry/dist-es/AdaptiveRetryStrategy.js
init_process();
init_buffer();

// node_modules/@smithy/util-retry/dist-es/config.js
init_process();
init_buffer();
var RETRY_MODES;
(function(RETRY_MODES2) {
  RETRY_MODES2["STANDARD"] = "standard";
  RETRY_MODES2["ADAPTIVE"] = "adaptive";
})(RETRY_MODES || (RETRY_MODES = {}));
var DEFAULT_MAX_ATTEMPTS = 3;
var DEFAULT_RETRY_MODE = RETRY_MODES.STANDARD;

// node_modules/@smithy/util-retry/dist-es/DefaultRateLimiter.js
init_process();
init_buffer();

// node_modules/@smithy/service-error-classification/dist-es/index.js
init_process();
init_buffer();

// node_modules/@smithy/service-error-classification/dist-es/constants.js
init_process();
init_buffer();
var THROTTLING_ERROR_CODES = [
  "BandwidthLimitExceeded",
  "EC2ThrottledException",
  "LimitExceededException",
  "PriorRequestNotComplete",
  "ProvisionedThroughputExceededException",
  "RequestLimitExceeded",
  "RequestThrottled",
  "RequestThrottledException",
  "SlowDown",
  "ThrottledException",
  "Throttling",
  "ThrottlingException",
  "TooManyRequestsException",
  "TransactionInProgressException"
];
var TRANSIENT_ERROR_CODES = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"];
var TRANSIENT_ERROR_STATUS_CODES = [500, 502, 503, 504];
var NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"];

// node_modules/@smithy/service-error-classification/dist-es/index.js
var isClockSkewCorrectedError = (error3) => error3.$metadata?.clockSkewCorrected;
var isThrottlingError = (error3) => error3.$metadata?.httpStatusCode === 429 || THROTTLING_ERROR_CODES.includes(error3.name) || error3.$retryable?.throttling == true;
var isTransientError = (error3) => isClockSkewCorrectedError(error3) || TRANSIENT_ERROR_CODES.includes(error3.name) || NODEJS_TIMEOUT_ERROR_CODES.includes(error3?.code || "") || TRANSIENT_ERROR_STATUS_CODES.includes(error3.$metadata?.httpStatusCode || 0);
var isServerError = (error3) => {
  if (error3.$metadata?.httpStatusCode !== void 0) {
    const statusCode = error3.$metadata.httpStatusCode;
    if (500 <= statusCode && statusCode <= 599 && !isTransientError(error3)) {
      return true;
    }
    return false;
  }
  return false;
};

// node_modules/@smithy/util-retry/dist-es/DefaultRateLimiter.js
var DefaultRateLimiter = class {
  constructor(options) {
    this.currentCapacity = 0;
    this.enabled = false;
    this.lastMaxRate = 0;
    this.measuredTxRate = 0;
    this.requestCount = 0;
    this.lastTimestamp = 0;
    this.timeWindow = 0;
    this.beta = options?.beta ?? 0.7;
    this.minCapacity = options?.minCapacity ?? 1;
    this.minFillRate = options?.minFillRate ?? 0.5;
    this.scaleConstant = options?.scaleConstant ?? 0.4;
    this.smooth = options?.smooth ?? 0.8;
    const currentTimeInSeconds = this.getCurrentTimeInSeconds();
    this.lastThrottleTime = currentTimeInSeconds;
    this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());
    this.fillRate = this.minFillRate;
    this.maxCapacity = this.minCapacity;
  }
  getCurrentTimeInSeconds() {
    return Date.now() / 1e3;
  }
  async getSendToken() {
    return this.acquireTokenBucket(1);
  }
  async acquireTokenBucket(amount) {
    if (!this.enabled) {
      return;
    }
    this.refillTokenBucket();
    if (amount > this.currentCapacity) {
      const delay = (amount - this.currentCapacity) / this.fillRate * 1e3;
      await new Promise((resolve2) => setTimeout(resolve2, delay));
    }
    this.currentCapacity = this.currentCapacity - amount;
  }
  refillTokenBucket() {
    const timestamp = this.getCurrentTimeInSeconds();
    if (!this.lastTimestamp) {
      this.lastTimestamp = timestamp;
      return;
    }
    const fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;
    this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);
    this.lastTimestamp = timestamp;
  }
  updateClientSendingRate(response) {
    let calculatedRate;
    this.updateMeasuredRate();
    if (isThrottlingError(response)) {
      const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);
      this.lastMaxRate = rateToUse;
      this.calculateTimeWindow();
      this.lastThrottleTime = this.getCurrentTimeInSeconds();
      calculatedRate = this.cubicThrottle(rateToUse);
      this.enableTokenBucket();
    } else {
      this.calculateTimeWindow();
      calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());
    }
    const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);
    this.updateTokenBucketRate(newRate);
  }
  calculateTimeWindow() {
    this.timeWindow = this.getPrecise(Math.pow(this.lastMaxRate * (1 - this.beta) / this.scaleConstant, 1 / 3));
  }
  cubicThrottle(rateToUse) {
    return this.getPrecise(rateToUse * this.beta);
  }
  cubicSuccess(timestamp) {
    return this.getPrecise(this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);
  }
  enableTokenBucket() {
    this.enabled = true;
  }
  updateTokenBucketRate(newRate) {
    this.refillTokenBucket();
    this.fillRate = Math.max(newRate, this.minFillRate);
    this.maxCapacity = Math.max(newRate, this.minCapacity);
    this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);
  }
  updateMeasuredRate() {
    const t3 = this.getCurrentTimeInSeconds();
    const timeBucket = Math.floor(t3 * 2) / 2;
    this.requestCount++;
    if (timeBucket > this.lastTxRateBucket) {
      const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);
      this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));
      this.requestCount = 0;
      this.lastTxRateBucket = timeBucket;
    }
  }
  getPrecise(num) {
    return parseFloat(num.toFixed(8));
  }
};

// node_modules/@smithy/util-retry/dist-es/StandardRetryStrategy.js
init_process();
init_buffer();

// node_modules/@smithy/util-retry/dist-es/constants.js
init_process();
init_buffer();
var DEFAULT_RETRY_DELAY_BASE = 100;
var MAXIMUM_RETRY_DELAY = 20 * 1e3;
var THROTTLING_RETRY_DELAY_BASE = 500;
var INITIAL_RETRY_TOKENS = 500;
var RETRY_COST = 5;
var TIMEOUT_RETRY_COST = 10;
var NO_RETRY_INCREMENT = 1;
var INVOCATION_ID_HEADER = "amz-sdk-invocation-id";
var REQUEST_HEADER = "amz-sdk-request";

// node_modules/@smithy/util-retry/dist-es/defaultRetryBackoffStrategy.js
init_process();
init_buffer();
var getDefaultRetryBackoffStrategy = () => {
  let delayBase = DEFAULT_RETRY_DELAY_BASE;
  const computeNextBackoffDelay = (attempts) => {
    return Math.floor(Math.min(MAXIMUM_RETRY_DELAY, Math.random() * 2 ** attempts * delayBase));
  };
  const setDelayBase = (delay) => {
    delayBase = delay;
  };
  return {
    computeNextBackoffDelay,
    setDelayBase
  };
};

// node_modules/@smithy/util-retry/dist-es/defaultRetryToken.js
init_process();
init_buffer();
var createDefaultRetryToken = ({ retryDelay, retryCount, retryCost }) => {
  const getRetryCount = () => retryCount;
  const getRetryDelay = () => Math.min(MAXIMUM_RETRY_DELAY, retryDelay);
  const getRetryCost = () => retryCost;
  return {
    getRetryCount,
    getRetryDelay,
    getRetryCost
  };
};

// node_modules/@smithy/util-retry/dist-es/StandardRetryStrategy.js
var StandardRetryStrategy = class {
  constructor(maxAttempts) {
    this.maxAttempts = maxAttempts;
    this.mode = RETRY_MODES.STANDARD;
    this.capacity = INITIAL_RETRY_TOKENS;
    this.retryBackoffStrategy = getDefaultRetryBackoffStrategy();
    this.maxAttemptsProvider = typeof maxAttempts === "function" ? maxAttempts : async () => maxAttempts;
  }
  async acquireInitialRetryToken(retryTokenScope) {
    return createDefaultRetryToken({
      retryDelay: DEFAULT_RETRY_DELAY_BASE,
      retryCount: 0
    });
  }
  async refreshRetryTokenForRetry(token, errorInfo) {
    const maxAttempts = await this.getMaxAttempts();
    if (this.shouldRetry(token, errorInfo, maxAttempts)) {
      const errorType = errorInfo.errorType;
      this.retryBackoffStrategy.setDelayBase(errorType === "THROTTLING" ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE);
      const delayFromErrorType = this.retryBackoffStrategy.computeNextBackoffDelay(token.getRetryCount());
      const retryDelay = errorInfo.retryAfterHint ? Math.max(errorInfo.retryAfterHint.getTime() - Date.now() || 0, delayFromErrorType) : delayFromErrorType;
      const capacityCost = this.getCapacityCost(errorType);
      this.capacity -= capacityCost;
      return createDefaultRetryToken({
        retryDelay,
        retryCount: token.getRetryCount() + 1,
        retryCost: capacityCost
      });
    }
    throw new Error("No retry token available");
  }
  recordSuccess(token) {
    this.capacity = Math.max(INITIAL_RETRY_TOKENS, this.capacity + (token.getRetryCost() ?? NO_RETRY_INCREMENT));
  }
  getCapacity() {
    return this.capacity;
  }
  async getMaxAttempts() {
    try {
      return await this.maxAttemptsProvider();
    } catch (error3) {
      console.warn(`Max attempts provider could not resolve. Using default of ${DEFAULT_MAX_ATTEMPTS}`);
      return DEFAULT_MAX_ATTEMPTS;
    }
  }
  shouldRetry(tokenToRenew, errorInfo, maxAttempts) {
    const attempts = tokenToRenew.getRetryCount() + 1;
    return attempts < maxAttempts && this.capacity >= this.getCapacityCost(errorInfo.errorType) && this.isRetryableError(errorInfo.errorType);
  }
  getCapacityCost(errorType) {
    return errorType === "TRANSIENT" ? TIMEOUT_RETRY_COST : RETRY_COST;
  }
  isRetryableError(errorType) {
    return errorType === "THROTTLING" || errorType === "TRANSIENT";
  }
};

// node_modules/@smithy/util-retry/dist-es/AdaptiveRetryStrategy.js
var AdaptiveRetryStrategy = class {
  constructor(maxAttemptsProvider, options) {
    this.maxAttemptsProvider = maxAttemptsProvider;
    this.mode = RETRY_MODES.ADAPTIVE;
    const { rateLimiter } = options ?? {};
    this.rateLimiter = rateLimiter ?? new DefaultRateLimiter();
    this.standardRetryStrategy = new StandardRetryStrategy(maxAttemptsProvider);
  }
  async acquireInitialRetryToken(retryTokenScope) {
    await this.rateLimiter.getSendToken();
    return this.standardRetryStrategy.acquireInitialRetryToken(retryTokenScope);
  }
  async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
    this.rateLimiter.updateClientSendingRate(errorInfo);
    return this.standardRetryStrategy.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
  }
  recordSuccess(token) {
    this.rateLimiter.updateClientSendingRate({});
    this.standardRetryStrategy.recordSuccess(token);
  }
};

// node_modules/@smithy/util-retry/dist-es/ConfiguredRetryStrategy.js
init_process();
init_buffer();

// node_modules/@smithy/util-retry/dist-es/types.js
init_process();
init_buffer();

// node_modules/@smithy/middleware-retry/dist-es/StandardRetryStrategy.js
init_process();
init_buffer();

// node_modules/uuid/dist/esm-browser/index.js
init_process();
init_buffer();

// node_modules/uuid/dist/esm-browser/rng.js
init_process();
init_buffer();
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/stringify.js
init_process();
init_buffer();
var byteToHex = [];
for (let i2 = 0; i2 < 256; ++i2) {
  byteToHex.push((i2 + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

// node_modules/uuid/dist/esm-browser/v4.js
init_process();
init_buffer();

// node_modules/uuid/dist/esm-browser/native.js
init_process();
init_buffer();
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i2 = 0; i2 < 16; ++i2) {
      buf[offset + i2] = rnds[i2];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// node_modules/@smithy/middleware-retry/dist-es/defaultRetryQuota.js
init_process();
init_buffer();

// node_modules/@smithy/middleware-retry/dist-es/delayDecider.js
init_process();
init_buffer();

// node_modules/@smithy/middleware-retry/dist-es/retryDecider.js
init_process();
init_buffer();

// node_modules/@smithy/middleware-retry/dist-es/util.js
init_process();
init_buffer();
var asSdkError = (error3) => {
  if (error3 instanceof Error)
    return error3;
  if (error3 instanceof Object)
    return Object.assign(new Error(), error3);
  if (typeof error3 === "string")
    return new Error(error3);
  return new Error(`AWS SDK error wrapper for ${error3}`);
};

// node_modules/@smithy/middleware-retry/dist-es/configurations.js
init_process();
init_buffer();
var resolveRetryConfig = (input) => {
  const { retryStrategy } = input;
  const maxAttempts = normalizeProvider(input.maxAttempts ?? DEFAULT_MAX_ATTEMPTS);
  return {
    ...input,
    maxAttempts,
    retryStrategy: async () => {
      if (retryStrategy) {
        return retryStrategy;
      }
      const retryMode = await normalizeProvider(input.retryMode)();
      if (retryMode === RETRY_MODES.ADAPTIVE) {
        return new AdaptiveRetryStrategy(maxAttempts);
      }
      return new StandardRetryStrategy(maxAttempts);
    }
  };
};

// node_modules/@smithy/middleware-retry/dist-es/omitRetryHeadersMiddleware.js
init_process();
init_buffer();

// node_modules/@smithy/middleware-retry/dist-es/retryMiddleware.js
init_process();
init_buffer();

// node_modules/@smithy/middleware-retry/dist-es/isStreamingPayload/isStreamingPayload.browser.js
init_process();
init_buffer();
var isStreamingPayload = (request) => request?.body instanceof ReadableStream;

// node_modules/@smithy/middleware-retry/dist-es/retryMiddleware.js
var retryMiddleware = (options) => (next, context) => async (args) => {
  let retryStrategy = await options.retryStrategy();
  const maxAttempts = await options.maxAttempts();
  if (isRetryStrategyV2(retryStrategy)) {
    retryStrategy = retryStrategy;
    let retryToken = await retryStrategy.acquireInitialRetryToken(context["partition_id"]);
    let lastError = new Error();
    let attempts = 0;
    let totalRetryDelay = 0;
    const { request } = args;
    const isRequest = HttpRequest.isInstance(request);
    if (isRequest) {
      request.headers[INVOCATION_ID_HEADER] = v4_default();
    }
    while (true) {
      try {
        if (isRequest) {
          request.headers[REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;
        }
        const { response, output } = await next(args);
        retryStrategy.recordSuccess(retryToken);
        output.$metadata.attempts = attempts + 1;
        output.$metadata.totalRetryDelay = totalRetryDelay;
        return { response, output };
      } catch (e2) {
        const retryErrorInfo = getRetryErrorInfo(e2);
        lastError = asSdkError(e2);
        if (isRequest && isStreamingPayload(request)) {
          (context.logger instanceof NoOpLogger ? console : context.logger)?.warn("An error was encountered in a non-retryable streaming request.");
          throw lastError;
        }
        try {
          retryToken = await retryStrategy.refreshRetryTokenForRetry(retryToken, retryErrorInfo);
        } catch (refreshError) {
          if (!lastError.$metadata) {
            lastError.$metadata = {};
          }
          lastError.$metadata.attempts = attempts + 1;
          lastError.$metadata.totalRetryDelay = totalRetryDelay;
          throw lastError;
        }
        attempts = retryToken.getRetryCount();
        const delay = retryToken.getRetryDelay();
        totalRetryDelay += delay;
        await new Promise((resolve2) => setTimeout(resolve2, delay));
      }
    }
  } else {
    retryStrategy = retryStrategy;
    if (retryStrategy?.mode)
      context.userAgent = [...context.userAgent || [], ["cfg/retry-mode", retryStrategy.mode]];
    return retryStrategy.retry(next, args);
  }
};
var isRetryStrategyV2 = (retryStrategy) => typeof retryStrategy.acquireInitialRetryToken !== "undefined" && typeof retryStrategy.refreshRetryTokenForRetry !== "undefined" && typeof retryStrategy.recordSuccess !== "undefined";
var getRetryErrorInfo = (error3) => {
  const errorInfo = {
    error: error3,
    errorType: getRetryErrorType(error3)
  };
  const retryAfterHint = getRetryAfterHint(error3.$response);
  if (retryAfterHint) {
    errorInfo.retryAfterHint = retryAfterHint;
  }
  return errorInfo;
};
var getRetryErrorType = (error3) => {
  if (isThrottlingError(error3))
    return "THROTTLING";
  if (isTransientError(error3))
    return "TRANSIENT";
  if (isServerError(error3))
    return "SERVER_ERROR";
  return "CLIENT_ERROR";
};
var retryMiddlewareOptions = {
  name: "retryMiddleware",
  tags: ["RETRY"],
  step: "finalizeRequest",
  priority: "high",
  override: true
};
var getRetryPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(retryMiddleware(options), retryMiddlewareOptions);
  }
});
var getRetryAfterHint = (response) => {
  if (!HttpResponse.isInstance(response))
    return;
  const retryAfterHeaderName = Object.keys(response.headers).find((key2) => key2.toLowerCase() === "retry-after");
  if (!retryAfterHeaderName)
    return;
  const retryAfter = response.headers[retryAfterHeaderName];
  const retryAfterSeconds = Number(retryAfter);
  if (!Number.isNaN(retryAfterSeconds))
    return new Date(retryAfterSeconds * 1e3);
  const retryAfterDate = new Date(retryAfter);
  return retryAfterDate;
};

// node_modules/@smithy/core/dist-es/middleware-http-signing/getHttpSigningMiddleware.js
var httpSigningMiddlewareOptions = {
  step: "finalizeRequest",
  tags: ["HTTP_SIGNING"],
  name: "httpSigningMiddleware",
  aliases: ["apiKeyMiddleware", "tokenMiddleware", "awsAuthMiddleware"],
  override: true,
  relation: "after",
  toMiddleware: retryMiddlewareOptions.name
};
var getHttpSigningPlugin = (config3) => ({
  applyToStack: (clientStack) => {
    clientStack.addRelativeTo(httpSigningMiddleware(config3), httpSigningMiddlewareOptions);
  }
});

// node_modules/@smithy/core/dist-es/util-identity-and-auth/index.js
init_process();
init_buffer();

// node_modules/@smithy/core/dist-es/util-identity-and-auth/DefaultIdentityProviderConfig.js
init_process();
init_buffer();
var DefaultIdentityProviderConfig = class {
  constructor(config3) {
    this.authSchemes = /* @__PURE__ */ new Map();
    for (const [key2, value] of Object.entries(config3)) {
      if (value !== void 0) {
        this.authSchemes.set(key2, value);
      }
    }
  }
  getIdentityProvider(schemeId) {
    return this.authSchemes.get(schemeId);
  }
};

// node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/index.js
init_process();
init_buffer();

// node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/httpApiKeyAuth.js
init_process();
init_buffer();

// node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/httpBearerAuth.js
init_process();
init_buffer();

// node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/noAuth.js
init_process();
init_buffer();

// node_modules/@smithy/core/dist-es/util-identity-and-auth/memoizeIdentityProvider.js
init_process();
init_buffer();
var createIsIdentityExpiredFunction = (expirationMs) => (identity) => doesIdentityRequireRefresh(identity) && identity.expiration.getTime() - Date.now() < expirationMs;
var EXPIRATION_MS = 3e5;
var isIdentityExpired = createIsIdentityExpiredFunction(EXPIRATION_MS);
var doesIdentityRequireRefresh = (identity) => identity.expiration !== void 0;
var memoizeIdentityProvider = (provider, isExpired, requiresRefresh) => {
  if (provider === void 0) {
    return void 0;
  }
  const normalizedProvider = typeof provider !== "function" ? async () => Promise.resolve(provider) : provider;
  let resolved;
  let pending;
  let hasResult;
  let isConstant = false;
  const coalesceProvider = async (options) => {
    if (!pending) {
      pending = normalizedProvider(options);
    }
    try {
      resolved = await pending;
      hasResult = true;
      isConstant = false;
    } finally {
      pending = void 0;
    }
    return resolved;
  };
  if (isExpired === void 0) {
    return async (options) => {
      if (!hasResult || options?.forceRefresh) {
        resolved = await coalesceProvider(options);
      }
      return resolved;
    };
  }
  return async (options) => {
    if (!hasResult || options?.forceRefresh) {
      resolved = await coalesceProvider(options);
    }
    if (isConstant) {
      return resolved;
    }
    if (!requiresRefresh(resolved)) {
      isConstant = true;
      return resolved;
    }
    if (isExpired(resolved)) {
      await coalesceProvider(options);
      return resolved;
    }
    return resolved;
  };
};

// node_modules/@smithy/core/dist-es/getSmithyContext.js
init_process();
init_buffer();

// node_modules/@smithy/core/dist-es/normalizeProvider.js
init_process();
init_buffer();
var normalizeProvider2 = (input) => {
  if (typeof input === "function")
    return input;
  const promisified = Promise.resolve(input);
  return () => promisified;
};

// node_modules/@smithy/core/dist-es/protocols/requestBuilder.js
init_process();
init_buffer();
function requestBuilder(input, context) {
  return new RequestBuilder(input, context);
}
var RequestBuilder = class {
  constructor(input, context) {
    this.input = input;
    this.context = context;
    this.query = {};
    this.method = "";
    this.headers = {};
    this.path = "";
    this.body = null;
    this.hostname = "";
    this.resolvePathStack = [];
  }
  async build() {
    const { hostname, protocol = "https", port, path: basePath } = await this.context.endpoint();
    this.path = basePath;
    for (const resolvePath of this.resolvePathStack) {
      resolvePath(this.path);
    }
    return new HttpRequest({
      protocol,
      hostname: this.hostname || hostname,
      port,
      method: this.method,
      path: this.path,
      query: this.query,
      body: this.body,
      headers: this.headers
    });
  }
  hn(hostname) {
    this.hostname = hostname;
    return this;
  }
  bp(uriLabel) {
    this.resolvePathStack.push((basePath) => {
      this.path = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + uriLabel;
    });
    return this;
  }
  p(memberName, labelValueProvider, uriLabel, isGreedyLabel) {
    this.resolvePathStack.push((path2) => {
      this.path = resolvedPath(path2, this.input, memberName, labelValueProvider, uriLabel, isGreedyLabel);
    });
    return this;
  }
  h(headers) {
    this.headers = headers;
    return this;
  }
  q(query) {
    this.query = query;
    return this;
  }
  b(body3) {
    this.body = body3;
    return this;
  }
  m(method) {
    this.method = method;
    return this;
  }
};

// node_modules/@smithy/core/dist-es/pagination/createPaginator.js
init_process();
init_buffer();

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/functions/signS3Express.js
init_process();
init_buffer();
var signS3Express = async (s3ExpressIdentity, signingOptions, request, sigV4MultiRegionSigner) => {
  const signedRequest = await sigV4MultiRegionSigner.signWithCredentials(request, s3ExpressIdentity, {});
  if (signedRequest.headers["X-Amz-Security-Token"] || signedRequest.headers["x-amz-security-token"]) {
    throw new Error("X-Amz-Security-Token must not be set for s3-express requests.");
  }
  return signedRequest;
};

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/functions/s3ExpressHttpSigningMiddleware.js
var defaultErrorHandler2 = (signingProperties) => (error3) => {
  throw error3;
};
var defaultSuccessHandler2 = (httpResponse, signingProperties) => {
};
var s3ExpressHttpSigningMiddleware = (config3) => (next, context) => async (args) => {
  if (!HttpRequest.isInstance(args.request)) {
    return next(args);
  }
  const smithyContext = getSmithyContext(context);
  const scheme = smithyContext.selectedHttpAuthScheme;
  if (!scheme) {
    throw new Error(`No HttpAuthScheme was selected: unable to sign request`);
  }
  const { httpAuthOption: { signingProperties = {} }, identity, signer } = scheme;
  let request;
  if (context.s3ExpressIdentity) {
    request = await signS3Express(context.s3ExpressIdentity, signingProperties, args.request, await config3.signer());
  } else {
    request = await signer.sign(args.request, identity, signingProperties);
  }
  const output = await next({
    ...args,
    request
  }).catch((signer.errorHandler || defaultErrorHandler2)(signingProperties));
  (signer.successHandler || defaultSuccessHandler2)(output.response, signingProperties);
  return output;
};
var getS3ExpressHttpSigningPlugin = (config3) => ({
  applyToStack: (clientStack) => {
    clientStack.addRelativeTo(s3ExpressHttpSigningMiddleware(config3), httpSigningMiddlewareOptions);
  }
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3Configuration.js
init_process();
init_buffer();
var resolveS3Config = (input, { session }) => {
  const [s3ClientProvider, CreateSessionCommandCtor] = session;
  return {
    ...input,
    forcePathStyle: input.forcePathStyle ?? false,
    useAccelerateEndpoint: input.useAccelerateEndpoint ?? false,
    disableMultiregionAccessPoints: input.disableMultiregionAccessPoints ?? false,
    followRegionRedirects: input.followRegionRedirects ?? false,
    s3ExpressIdentityProvider: input.s3ExpressIdentityProvider ?? new S3ExpressIdentityProviderImpl(async (key2) => s3ClientProvider().send(new CreateSessionCommandCtor({
      Bucket: key2,
      SessionMode: "ReadWrite"
    }))),
    bucketEndpoint: input.bucketEndpoint ?? false
  };
};

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/throw-200-exceptions.js
init_process();
init_buffer();
var THROW_IF_EMPTY_BODY = {
  CopyObjectCommand: true,
  UploadPartCopyCommand: true,
  CompleteMultipartUploadCommand: true
};
var MAX_BYTES_TO_INSPECT = 3e3;
var throw200ExceptionsMiddleware = (config3) => (next, context) => async (args) => {
  const result = await next(args);
  const { response } = result;
  if (!HttpResponse.isInstance(response)) {
    return result;
  }
  const { statusCode, body: sourceBody } = response;
  if (statusCode < 200 || statusCode >= 300) {
    return result;
  }
  let bodyCopy = sourceBody;
  let body3 = sourceBody;
  if (sourceBody && typeof sourceBody === "object" && !(sourceBody instanceof Uint8Array)) {
    [bodyCopy, body3] = await splitStream(sourceBody);
  }
  response.body = body3;
  const bodyBytes = await collectBody2(bodyCopy, {
    streamCollector: async (stream) => {
      return headStream(stream, MAX_BYTES_TO_INSPECT);
    }
  });
  if (typeof bodyCopy?.destroy === "function") {
    bodyCopy.destroy();
  }
  const bodyStringTail = config3.utf8Encoder(bodyBytes.subarray(bodyBytes.length - 16));
  if (bodyBytes.length === 0 && THROW_IF_EMPTY_BODY[context.commandName]) {
    const err = new Error("S3 aborted request");
    err.name = "InternalError";
    throw err;
  }
  if (bodyStringTail && bodyStringTail.endsWith("</Error>")) {
    response.statusCode = 400;
  }
  return result;
};
var collectBody2 = (streamBody = new Uint8Array(), context) => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};
var throw200ExceptionsMiddlewareOptions = {
  relation: "after",
  toMiddleware: "deserializerMiddleware",
  tags: ["THROW_200_EXCEPTIONS", "S3"],
  name: "throw200ExceptionsMiddleware",
  override: true
};
var getThrow200ExceptionsPlugin = (config3) => ({
  applyToStack: (clientStack) => {
    clientStack.addRelativeTo(throw200ExceptionsMiddleware(config3), throw200ExceptionsMiddlewareOptions);
  }
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/validate-bucket-name.js
init_process();
init_buffer();

// node_modules/@aws-sdk/util-arn-parser/dist-es/index.js
init_process();
init_buffer();
var validate = (str) => typeof str === "string" && str.indexOf("arn:") === 0 && str.split(":").length >= 6;

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/bucket-endpoint-middleware.js
init_process();
init_buffer();
function bucketEndpointMiddleware(options) {
  return (next, context) => async (args) => {
    if (options.bucketEndpoint) {
      const endpoint = context.endpointV2;
      if (endpoint) {
        const bucket = args.input.Bucket;
        if (typeof bucket === "string") {
          try {
            const bucketEndpointUrl = new URL(bucket);
            endpoint.url = bucketEndpointUrl;
          } catch (e2) {
            const warning = `@aws-sdk/middleware-sdk-s3: bucketEndpoint=true was set but Bucket=${bucket} could not be parsed as URL.`;
            if (context.logger?.constructor?.name === "NoOpLogger") {
              console.warn(warning);
            } else {
              context.logger?.warn?.(warning);
            }
            throw e2;
          }
        }
      }
    }
    return next(args);
  };
}
var bucketEndpointMiddlewareOptions = {
  name: "bucketEndpointMiddleware",
  override: true,
  relation: "after",
  toMiddleware: "endpointV2Middleware"
};

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/validate-bucket-name.js
function validateBucketNameMiddleware({ bucketEndpoint }) {
  return (next) => async (args) => {
    const { input: { Bucket } } = args;
    if (!bucketEndpoint && typeof Bucket === "string" && !validate(Bucket) && Bucket.indexOf("/") >= 0) {
      const err = new Error(`Bucket name shouldn't contain '/', received '${Bucket}'`);
      err.name = "InvalidBucketName";
      throw err;
    }
    return next({ ...args });
  };
}
var validateBucketNameMiddlewareOptions = {
  step: "initialize",
  tags: ["VALIDATE_BUCKET_NAME"],
  name: "validateBucketNameMiddleware",
  override: true
};
var getValidateBucketNamePlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(validateBucketNameMiddleware(options), validateBucketNameMiddlewareOptions);
    clientStack.addRelativeTo(bucketEndpointMiddleware(options), bucketEndpointMiddlewareOptions);
  }
});

// node_modules/@aws-sdk/middleware-user-agent/dist-es/index.js
init_process();
init_buffer();

// node_modules/@aws-sdk/middleware-user-agent/dist-es/configurations.js
init_process();
init_buffer();
function resolveUserAgentConfig(input) {
  return {
    ...input,
    customUserAgent: typeof input.customUserAgent === "string" ? [[input.customUserAgent]] : input.customUserAgent
  };
}

// node_modules/@aws-sdk/middleware-user-agent/dist-es/user-agent-middleware.js
init_process();
init_buffer();

// node_modules/@aws-sdk/util-endpoints/dist-es/index.js
init_process();
init_buffer();

// node_modules/@aws-sdk/util-endpoints/dist-es/aws.js
init_process();
init_buffer();

// node_modules/@smithy/util-endpoints/dist-es/index.js
init_process();
init_buffer();

// node_modules/@smithy/util-endpoints/dist-es/lib/isIpAddress.js
init_process();
init_buffer();
var IP_V4_REGEX = new RegExp(`^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$`);
var isIpAddress = (value) => IP_V4_REGEX.test(value) || value.startsWith("[") && value.endsWith("]");

// node_modules/@smithy/util-endpoints/dist-es/lib/isValidHostLabel.js
init_process();
init_buffer();
var VALID_HOST_LABEL_REGEX = new RegExp(`^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$`);
var isValidHostLabel = (value, allowSubDomains = false) => {
  if (!allowSubDomains) {
    return VALID_HOST_LABEL_REGEX.test(value);
  }
  const labels = value.split(".");
  for (const label of labels) {
    if (!isValidHostLabel(label)) {
      return false;
    }
  }
  return true;
};

// node_modules/@smithy/util-endpoints/dist-es/utils/customEndpointFunctions.js
init_process();
init_buffer();
var customEndpointFunctions = {};

// node_modules/@smithy/util-endpoints/dist-es/resolveEndpoint.js
init_process();
init_buffer();

// node_modules/@smithy/util-endpoints/dist-es/debug/index.js
init_process();
init_buffer();

// node_modules/@smithy/util-endpoints/dist-es/debug/debugId.js
init_process();
init_buffer();
var debugId = "endpoints";

// node_modules/@smithy/util-endpoints/dist-es/debug/toDebugString.js
init_process();
init_buffer();
function toDebugString(input) {
  if (typeof input !== "object" || input == null) {
    return input;
  }
  if ("ref" in input) {
    return `$${toDebugString(input.ref)}`;
  }
  if ("fn" in input) {
    return `${input.fn}(${(input.argv || []).map(toDebugString).join(", ")})`;
  }
  return JSON.stringify(input, null, 2);
}

// node_modules/@smithy/util-endpoints/dist-es/types/index.js
init_process();
init_buffer();

// node_modules/@smithy/util-endpoints/dist-es/types/EndpointError.js
init_process();
init_buffer();
var EndpointError = class extends Error {
  constructor(message2) {
    super(message2);
    this.name = "EndpointError";
  }
};

// node_modules/@smithy/util-endpoints/dist-es/types/EndpointFunctions.js
init_process();
init_buffer();

// node_modules/@smithy/util-endpoints/dist-es/types/EndpointRuleObject.js
init_process();
init_buffer();

// node_modules/@smithy/util-endpoints/dist-es/types/ErrorRuleObject.js
init_process();
init_buffer();

// node_modules/@smithy/util-endpoints/dist-es/types/RuleSetObject.js
init_process();
init_buffer();

// node_modules/@smithy/util-endpoints/dist-es/types/TreeRuleObject.js
init_process();
init_buffer();

// node_modules/@smithy/util-endpoints/dist-es/types/shared.js
init_process();
init_buffer();

// node_modules/@smithy/util-endpoints/dist-es/utils/index.js
init_process();
init_buffer();

// node_modules/@smithy/util-endpoints/dist-es/utils/evaluateRules.js
init_process();
init_buffer();

// node_modules/@smithy/util-endpoints/dist-es/utils/evaluateEndpointRule.js
init_process();
init_buffer();

// node_modules/@smithy/util-endpoints/dist-es/utils/evaluateConditions.js
init_process();
init_buffer();

// node_modules/@smithy/util-endpoints/dist-es/utils/evaluateCondition.js
init_process();
init_buffer();

// node_modules/@smithy/util-endpoints/dist-es/utils/callFunction.js
init_process();
init_buffer();

// node_modules/@smithy/util-endpoints/dist-es/utils/endpointFunctions.js
init_process();
init_buffer();

// node_modules/@smithy/util-endpoints/dist-es/lib/index.js
init_process();
init_buffer();

// node_modules/@smithy/util-endpoints/dist-es/lib/booleanEquals.js
init_process();
init_buffer();
var booleanEquals = (value1, value2) => value1 === value2;

// node_modules/@smithy/util-endpoints/dist-es/lib/getAttr.js
init_process();
init_buffer();

// node_modules/@smithy/util-endpoints/dist-es/lib/getAttrPathList.js
init_process();
init_buffer();
var getAttrPathList = (path2) => {
  const parts = path2.split(".");
  const pathList = [];
  for (const part of parts) {
    const squareBracketIndex = part.indexOf("[");
    if (squareBracketIndex !== -1) {
      if (part.indexOf("]") !== part.length - 1) {
        throw new EndpointError(`Path: '${path2}' does not end with ']'`);
      }
      const arrayIndex = part.slice(squareBracketIndex + 1, -1);
      if (Number.isNaN(parseInt(arrayIndex))) {
        throw new EndpointError(`Invalid array index: '${arrayIndex}' in path: '${path2}'`);
      }
      if (squareBracketIndex !== 0) {
        pathList.push(part.slice(0, squareBracketIndex));
      }
      pathList.push(arrayIndex);
    } else {
      pathList.push(part);
    }
  }
  return pathList;
};

// node_modules/@smithy/util-endpoints/dist-es/lib/getAttr.js
var getAttr = (value, path2) => getAttrPathList(path2).reduce((acc, index3) => {
  if (typeof acc !== "object") {
    throw new EndpointError(`Index '${index3}' in '${path2}' not found in '${JSON.stringify(value)}'`);
  } else if (Array.isArray(acc)) {
    return acc[parseInt(index3)];
  }
  return acc[index3];
}, value);

// node_modules/@smithy/util-endpoints/dist-es/lib/isSet.js
init_process();
init_buffer();
var isSet = (value) => value != null;

// node_modules/@smithy/util-endpoints/dist-es/lib/not.js
init_process();
init_buffer();
var not2 = (value) => !value;

// node_modules/@smithy/util-endpoints/dist-es/lib/parseURL.js
init_process();
init_buffer();
var DEFAULT_PORTS = {
  [EndpointURLScheme.HTTP]: 80,
  [EndpointURLScheme.HTTPS]: 443
};
var parseURL = (value) => {
  const whatwgURL = (() => {
    try {
      if (value instanceof URL) {
        return value;
      }
      if (typeof value === "object" && "hostname" in value) {
        const { hostname: hostname2, port, protocol: protocol2 = "", path: path2 = "", query = {} } = value;
        const url = new URL(`${protocol2}//${hostname2}${port ? `:${port}` : ""}${path2}`);
        url.search = Object.entries(query).map(([k2, v2]) => `${k2}=${v2}`).join("&");
        return url;
      }
      return new URL(value);
    } catch (error3) {
      return null;
    }
  })();
  if (!whatwgURL) {
    console.error(`Unable to parse ${JSON.stringify(value)} as a whatwg URL.`);
    return null;
  }
  const urlString = whatwgURL.href;
  const { host, hostname, pathname, protocol, search: search2 } = whatwgURL;
  if (search2) {
    return null;
  }
  const scheme = protocol.slice(0, -1);
  if (!Object.values(EndpointURLScheme).includes(scheme)) {
    return null;
  }
  const isIp = isIpAddress(hostname);
  const inputContainsDefaultPort = urlString.includes(`${host}:${DEFAULT_PORTS[scheme]}`) || typeof value === "string" && value.includes(`${host}:${DEFAULT_PORTS[scheme]}`);
  const authority = `${host}${inputContainsDefaultPort ? `:${DEFAULT_PORTS[scheme]}` : ``}`;
  return {
    scheme,
    authority,
    path: pathname,
    normalizedPath: pathname.endsWith("/") ? pathname : `${pathname}/`,
    isIp
  };
};

// node_modules/@smithy/util-endpoints/dist-es/lib/stringEquals.js
init_process();
init_buffer();
var stringEquals = (value1, value2) => value1 === value2;

// node_modules/@smithy/util-endpoints/dist-es/lib/substring.js
init_process();
init_buffer();
var substring = (input, start, stop, reverse) => {
  if (start >= stop || input.length < stop) {
    return null;
  }
  if (!reverse) {
    return input.substring(start, stop);
  }
  return input.substring(input.length - stop, input.length - start);
};

// node_modules/@smithy/util-endpoints/dist-es/lib/uriEncode.js
init_process();
init_buffer();
var uriEncode = (value) => encodeURIComponent(value).replace(/[!*'()]/g, (c2) => `%${c2.charCodeAt(0).toString(16).toUpperCase()}`);

// node_modules/@smithy/util-endpoints/dist-es/utils/endpointFunctions.js
var endpointFunctions = {
  booleanEquals,
  getAttr,
  isSet,
  isValidHostLabel,
  not: not2,
  parseURL,
  stringEquals,
  substring,
  uriEncode
};

// node_modules/@smithy/util-endpoints/dist-es/utils/evaluateExpression.js
init_process();
init_buffer();

// node_modules/@smithy/util-endpoints/dist-es/utils/evaluateTemplate.js
init_process();
init_buffer();
var evaluateTemplate = (template, options) => {
  const evaluatedTemplateArr = [];
  const templateContext = {
    ...options.endpointParams,
    ...options.referenceRecord
  };
  let currentIndex = 0;
  while (currentIndex < template.length) {
    const openingBraceIndex = template.indexOf("{", currentIndex);
    if (openingBraceIndex === -1) {
      evaluatedTemplateArr.push(template.slice(currentIndex));
      break;
    }
    evaluatedTemplateArr.push(template.slice(currentIndex, openingBraceIndex));
    const closingBraceIndex = template.indexOf("}", openingBraceIndex);
    if (closingBraceIndex === -1) {
      evaluatedTemplateArr.push(template.slice(openingBraceIndex));
      break;
    }
    if (template[openingBraceIndex + 1] === "{" && template[closingBraceIndex + 1] === "}") {
      evaluatedTemplateArr.push(template.slice(openingBraceIndex + 1, closingBraceIndex));
      currentIndex = closingBraceIndex + 2;
    }
    const parameterName = template.substring(openingBraceIndex + 1, closingBraceIndex);
    if (parameterName.includes("#")) {
      const [refName, attrName] = parameterName.split("#");
      evaluatedTemplateArr.push(getAttr(templateContext[refName], attrName));
    } else {
      evaluatedTemplateArr.push(templateContext[parameterName]);
    }
    currentIndex = closingBraceIndex + 1;
  }
  return evaluatedTemplateArr.join("");
};

// node_modules/@smithy/util-endpoints/dist-es/utils/getReferenceValue.js
init_process();
init_buffer();
var getReferenceValue = ({ ref }, options) => {
  const referenceRecord = {
    ...options.endpointParams,
    ...options.referenceRecord
  };
  return referenceRecord[ref];
};

// node_modules/@smithy/util-endpoints/dist-es/utils/evaluateExpression.js
var evaluateExpression = (obj, keyName, options) => {
  if (typeof obj === "string") {
    return evaluateTemplate(obj, options);
  } else if (obj["fn"]) {
    return callFunction(obj, options);
  } else if (obj["ref"]) {
    return getReferenceValue(obj, options);
  }
  throw new EndpointError(`'${keyName}': ${String(obj)} is not a string, function or reference.`);
};

// node_modules/@smithy/util-endpoints/dist-es/utils/callFunction.js
var callFunction = ({ fn, argv: argv3 }, options) => {
  const evaluatedArgs = argv3.map((arg) => ["boolean", "number"].includes(typeof arg) ? arg : evaluateExpression(arg, "arg", options));
  const fnSegments = fn.split(".");
  if (fnSegments[0] in customEndpointFunctions && fnSegments[1] != null) {
    return customEndpointFunctions[fnSegments[0]][fnSegments[1]](...evaluatedArgs);
  }
  return endpointFunctions[fn](...evaluatedArgs);
};

// node_modules/@smithy/util-endpoints/dist-es/utils/evaluateCondition.js
var evaluateCondition = ({ assign, ...fnArgs }, options) => {
  if (assign && assign in options.referenceRecord) {
    throw new EndpointError(`'${assign}' is already defined in Reference Record.`);
  }
  const value = callFunction(fnArgs, options);
  options.logger?.debug?.(`${debugId} evaluateCondition: ${toDebugString(fnArgs)} = ${toDebugString(value)}`);
  return {
    result: value === "" ? true : !!value,
    ...assign != null && { toAssign: { name: assign, value } }
  };
};

// node_modules/@smithy/util-endpoints/dist-es/utils/evaluateConditions.js
var evaluateConditions = (conditions = [], options) => {
  const conditionsReferenceRecord = {};
  for (const condition of conditions) {
    const { result, toAssign } = evaluateCondition(condition, {
      ...options,
      referenceRecord: {
        ...options.referenceRecord,
        ...conditionsReferenceRecord
      }
    });
    if (!result) {
      return { result };
    }
    if (toAssign) {
      conditionsReferenceRecord[toAssign.name] = toAssign.value;
      options.logger?.debug?.(`${debugId} assign: ${toAssign.name} := ${toDebugString(toAssign.value)}`);
    }
  }
  return { result: true, referenceRecord: conditionsReferenceRecord };
};

// node_modules/@smithy/util-endpoints/dist-es/utils/getEndpointHeaders.js
init_process();
init_buffer();
var getEndpointHeaders = (headers, options) => Object.entries(headers).reduce((acc, [headerKey, headerVal]) => ({
  ...acc,
  [headerKey]: headerVal.map((headerValEntry) => {
    const processedExpr = evaluateExpression(headerValEntry, "Header value entry", options);
    if (typeof processedExpr !== "string") {
      throw new EndpointError(`Header '${headerKey}' value '${processedExpr}' is not a string`);
    }
    return processedExpr;
  })
}), {});

// node_modules/@smithy/util-endpoints/dist-es/utils/getEndpointProperties.js
init_process();
init_buffer();

// node_modules/@smithy/util-endpoints/dist-es/utils/getEndpointProperty.js
init_process();
init_buffer();
var getEndpointProperty = (property, options) => {
  if (Array.isArray(property)) {
    return property.map((propertyEntry) => getEndpointProperty(propertyEntry, options));
  }
  switch (typeof property) {
    case "string":
      return evaluateTemplate(property, options);
    case "object":
      if (property === null) {
        throw new EndpointError(`Unexpected endpoint property: ${property}`);
      }
      return getEndpointProperties(property, options);
    case "boolean":
      return property;
    default:
      throw new EndpointError(`Unexpected endpoint property type: ${typeof property}`);
  }
};

// node_modules/@smithy/util-endpoints/dist-es/utils/getEndpointProperties.js
var getEndpointProperties = (properties, options) => Object.entries(properties).reduce((acc, [propertyKey, propertyVal]) => ({
  ...acc,
  [propertyKey]: getEndpointProperty(propertyVal, options)
}), {});

// node_modules/@smithy/util-endpoints/dist-es/utils/getEndpointUrl.js
init_process();
init_buffer();
var getEndpointUrl = (endpointUrl, options) => {
  const expression = evaluateExpression(endpointUrl, "Endpoint URL", options);
  if (typeof expression === "string") {
    try {
      return new URL(expression);
    } catch (error3) {
      console.error(`Failed to construct URL with ${expression}`, error3);
      throw error3;
    }
  }
  throw new EndpointError(`Endpoint URL must be a string, got ${typeof expression}`);
};

// node_modules/@smithy/util-endpoints/dist-es/utils/evaluateEndpointRule.js
var evaluateEndpointRule = (endpointRule, options) => {
  const { conditions, endpoint } = endpointRule;
  const { result, referenceRecord } = evaluateConditions(conditions, options);
  if (!result) {
    return;
  }
  const endpointRuleOptions = {
    ...options,
    referenceRecord: { ...options.referenceRecord, ...referenceRecord }
  };
  const { url, properties, headers } = endpoint;
  options.logger?.debug?.(`${debugId} Resolving endpoint from template: ${toDebugString(endpoint)}`);
  return {
    ...headers != void 0 && {
      headers: getEndpointHeaders(headers, endpointRuleOptions)
    },
    ...properties != void 0 && {
      properties: getEndpointProperties(properties, endpointRuleOptions)
    },
    url: getEndpointUrl(url, endpointRuleOptions)
  };
};

// node_modules/@smithy/util-endpoints/dist-es/utils/evaluateErrorRule.js
init_process();
init_buffer();
var evaluateErrorRule = (errorRule, options) => {
  const { conditions, error: error3 } = errorRule;
  const { result, referenceRecord } = evaluateConditions(conditions, options);
  if (!result) {
    return;
  }
  throw new EndpointError(evaluateExpression(error3, "Error", {
    ...options,
    referenceRecord: { ...options.referenceRecord, ...referenceRecord }
  }));
};

// node_modules/@smithy/util-endpoints/dist-es/utils/evaluateTreeRule.js
init_process();
init_buffer();
var evaluateTreeRule = (treeRule, options) => {
  const { conditions, rules } = treeRule;
  const { result, referenceRecord } = evaluateConditions(conditions, options);
  if (!result) {
    return;
  }
  return evaluateRules(rules, {
    ...options,
    referenceRecord: { ...options.referenceRecord, ...referenceRecord }
  });
};

// node_modules/@smithy/util-endpoints/dist-es/utils/evaluateRules.js
var evaluateRules = (rules, options) => {
  for (const rule of rules) {
    if (rule.type === "endpoint") {
      const endpointOrUndefined = evaluateEndpointRule(rule, options);
      if (endpointOrUndefined) {
        return endpointOrUndefined;
      }
    } else if (rule.type === "error") {
      evaluateErrorRule(rule, options);
    } else if (rule.type === "tree") {
      const endpointOrUndefined = evaluateTreeRule(rule, options);
      if (endpointOrUndefined) {
        return endpointOrUndefined;
      }
    } else {
      throw new EndpointError(`Unknown endpoint rule: ${rule}`);
    }
  }
  throw new EndpointError(`Rules evaluation failed`);
};

// node_modules/@smithy/util-endpoints/dist-es/resolveEndpoint.js
var resolveEndpoint = (ruleSetObject, options) => {
  const { endpointParams, logger: logger2 } = options;
  const { parameters, rules } = ruleSetObject;
  options.logger?.debug?.(`${debugId} Initial EndpointParams: ${toDebugString(endpointParams)}`);
  const paramsWithDefault = Object.entries(parameters).filter(([, v2]) => v2.default != null).map(([k2, v2]) => [k2, v2.default]);
  if (paramsWithDefault.length > 0) {
    for (const [paramKey, paramDefaultValue] of paramsWithDefault) {
      endpointParams[paramKey] = endpointParams[paramKey] ?? paramDefaultValue;
    }
  }
  const requiredParams = Object.entries(parameters).filter(([, v2]) => v2.required).map(([k2]) => k2);
  for (const requiredParam of requiredParams) {
    if (endpointParams[requiredParam] == null) {
      throw new EndpointError(`Missing required parameter: '${requiredParam}'`);
    }
  }
  const endpoint = evaluateRules(rules, { endpointParams, logger: logger2, referenceRecord: {} });
  if (options.endpointParams?.Endpoint) {
    try {
      const givenEndpoint = new URL(options.endpointParams.Endpoint);
      const { protocol, port } = givenEndpoint;
      endpoint.url.protocol = protocol;
      endpoint.url.port = port;
    } catch (e2) {
    }
  }
  options.logger?.debug?.(`${debugId} Resolved endpoint: ${toDebugString(endpoint)}`);
  return endpoint;
};

// node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/isVirtualHostableS3Bucket.js
init_process();
init_buffer();

// node_modules/@aws-sdk/util-endpoints/dist-es/lib/isIpAddress.js
init_process();
init_buffer();

// node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/isVirtualHostableS3Bucket.js
var isVirtualHostableS3Bucket = (value, allowSubDomains = false) => {
  if (allowSubDomains) {
    for (const label of value.split(".")) {
      if (!isVirtualHostableS3Bucket(label)) {
        return false;
      }
    }
    return true;
  }
  if (!isValidHostLabel(value)) {
    return false;
  }
  if (value.length < 3 || value.length > 63) {
    return false;
  }
  if (value !== value.toLowerCase()) {
    return false;
  }
  if (isIpAddress(value)) {
    return false;
  }
  return true;
};

// node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/parseArn.js
init_process();
init_buffer();
var parseArn = (value) => {
  const segments = value.split(":");
  if (segments.length < 6)
    return null;
  const [arn, partition2, service, region, accountId, ...resourceId] = segments;
  if (arn !== "arn" || partition2 === "" || service === "" || resourceId[0] === "")
    return null;
  return {
    partition: partition2,
    service,
    region,
    accountId,
    resourceId: resourceId[0].includes("/") ? resourceId[0].split("/") : resourceId
  };
};

// node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/partition.js
init_process();
init_buffer();

// node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/partitions.json
var partitions_default = {
  partitions: [{
    id: "aws",
    outputs: {
      dnsSuffix: "amazonaws.com",
      dualStackDnsSuffix: "api.aws",
      implicitGlobalRegion: "us-east-1",
      name: "aws",
      supportsDualStack: true,
      supportsFIPS: true
    },
    regionRegex: "^(us|eu|ap|sa|ca|me|af|il)\\-\\w+\\-\\d+$",
    regions: {
      "af-south-1": {
        description: "Africa (Cape Town)"
      },
      "ap-east-1": {
        description: "Asia Pacific (Hong Kong)"
      },
      "ap-northeast-1": {
        description: "Asia Pacific (Tokyo)"
      },
      "ap-northeast-2": {
        description: "Asia Pacific (Seoul)"
      },
      "ap-northeast-3": {
        description: "Asia Pacific (Osaka)"
      },
      "ap-south-1": {
        description: "Asia Pacific (Mumbai)"
      },
      "ap-south-2": {
        description: "Asia Pacific (Hyderabad)"
      },
      "ap-southeast-1": {
        description: "Asia Pacific (Singapore)"
      },
      "ap-southeast-2": {
        description: "Asia Pacific (Sydney)"
      },
      "ap-southeast-3": {
        description: "Asia Pacific (Jakarta)"
      },
      "ap-southeast-4": {
        description: "Asia Pacific (Melbourne)"
      },
      "aws-global": {
        description: "AWS Standard global region"
      },
      "ca-central-1": {
        description: "Canada (Central)"
      },
      "ca-west-1": {
        description: "Canada West (Calgary)"
      },
      "eu-central-1": {
        description: "Europe (Frankfurt)"
      },
      "eu-central-2": {
        description: "Europe (Zurich)"
      },
      "eu-north-1": {
        description: "Europe (Stockholm)"
      },
      "eu-south-1": {
        description: "Europe (Milan)"
      },
      "eu-south-2": {
        description: "Europe (Spain)"
      },
      "eu-west-1": {
        description: "Europe (Ireland)"
      },
      "eu-west-2": {
        description: "Europe (London)"
      },
      "eu-west-3": {
        description: "Europe (Paris)"
      },
      "il-central-1": {
        description: "Israel (Tel Aviv)"
      },
      "me-central-1": {
        description: "Middle East (UAE)"
      },
      "me-south-1": {
        description: "Middle East (Bahrain)"
      },
      "sa-east-1": {
        description: "South America (Sao Paulo)"
      },
      "us-east-1": {
        description: "US East (N. Virginia)"
      },
      "us-east-2": {
        description: "US East (Ohio)"
      },
      "us-west-1": {
        description: "US West (N. California)"
      },
      "us-west-2": {
        description: "US West (Oregon)"
      }
    }
  }, {
    id: "aws-cn",
    outputs: {
      dnsSuffix: "amazonaws.com.cn",
      dualStackDnsSuffix: "api.amazonwebservices.com.cn",
      implicitGlobalRegion: "cn-northwest-1",
      name: "aws-cn",
      supportsDualStack: true,
      supportsFIPS: true
    },
    regionRegex: "^cn\\-\\w+\\-\\d+$",
    regions: {
      "aws-cn-global": {
        description: "AWS China global region"
      },
      "cn-north-1": {
        description: "China (Beijing)"
      },
      "cn-northwest-1": {
        description: "China (Ningxia)"
      }
    }
  }, {
    id: "aws-us-gov",
    outputs: {
      dnsSuffix: "amazonaws.com",
      dualStackDnsSuffix: "api.aws",
      implicitGlobalRegion: "us-gov-west-1",
      name: "aws-us-gov",
      supportsDualStack: true,
      supportsFIPS: true
    },
    regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
    regions: {
      "aws-us-gov-global": {
        description: "AWS GovCloud (US) global region"
      },
      "us-gov-east-1": {
        description: "AWS GovCloud (US-East)"
      },
      "us-gov-west-1": {
        description: "AWS GovCloud (US-West)"
      }
    }
  }, {
    id: "aws-iso",
    outputs: {
      dnsSuffix: "c2s.ic.gov",
      dualStackDnsSuffix: "c2s.ic.gov",
      implicitGlobalRegion: "us-iso-east-1",
      name: "aws-iso",
      supportsDualStack: false,
      supportsFIPS: true
    },
    regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
    regions: {
      "aws-iso-global": {
        description: "AWS ISO (US) global region"
      },
      "us-iso-east-1": {
        description: "US ISO East"
      },
      "us-iso-west-1": {
        description: "US ISO WEST"
      }
    }
  }, {
    id: "aws-iso-b",
    outputs: {
      dnsSuffix: "sc2s.sgov.gov",
      dualStackDnsSuffix: "sc2s.sgov.gov",
      implicitGlobalRegion: "us-isob-east-1",
      name: "aws-iso-b",
      supportsDualStack: false,
      supportsFIPS: true
    },
    regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
    regions: {
      "aws-iso-b-global": {
        description: "AWS ISOB (US) global region"
      },
      "us-isob-east-1": {
        description: "US ISOB East (Ohio)"
      }
    }
  }, {
    id: "aws-iso-e",
    outputs: {
      dnsSuffix: "cloud.adc-e.uk",
      dualStackDnsSuffix: "cloud.adc-e.uk",
      implicitGlobalRegion: "eu-isoe-west-1",
      name: "aws-iso-e",
      supportsDualStack: false,
      supportsFIPS: true
    },
    regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$",
    regions: {
      "eu-isoe-west-1": {
        description: "EU ISOE West"
      }
    }
  }, {
    id: "aws-iso-f",
    outputs: {
      dnsSuffix: "csp.hci.ic.gov",
      dualStackDnsSuffix: "csp.hci.ic.gov",
      implicitGlobalRegion: "us-isof-south-1",
      name: "aws-iso-f",
      supportsDualStack: false,
      supportsFIPS: true
    },
    regionRegex: "^us\\-isof\\-\\w+\\-\\d+$",
    regions: {}
  }],
  version: "1.1"
};

// node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/partition.js
var selectedPartitionsInfo = partitions_default;
var selectedUserAgentPrefix = "";
var partition = (value) => {
  const { partitions } = selectedPartitionsInfo;
  for (const partition2 of partitions) {
    const { regions, outputs } = partition2;
    for (const [region, regionData] of Object.entries(regions)) {
      if (region === value) {
        return {
          ...outputs,
          ...regionData
        };
      }
    }
  }
  for (const partition2 of partitions) {
    const { regionRegex, outputs } = partition2;
    if (new RegExp(regionRegex).test(value)) {
      return {
        ...outputs
      };
    }
  }
  const DEFAULT_PARTITION = partitions.find((partition2) => partition2.id === "aws");
  if (!DEFAULT_PARTITION) {
    throw new Error("Provided region was not found in the partition array or regex, and default partition with id 'aws' doesn't exist.");
  }
  return {
    ...DEFAULT_PARTITION.outputs
  };
};
var getUserAgentPrefix = () => selectedUserAgentPrefix;

// node_modules/@aws-sdk/util-endpoints/dist-es/aws.js
var awsEndpointFunctions = {
  isVirtualHostableS3Bucket,
  parseArn,
  partition
};
customEndpointFunctions.aws = awsEndpointFunctions;

// node_modules/@aws-sdk/util-endpoints/dist-es/resolveEndpoint.js
init_process();
init_buffer();

// node_modules/@aws-sdk/util-endpoints/dist-es/types/index.js
init_process();
init_buffer();

// node_modules/@aws-sdk/util-endpoints/dist-es/types/EndpointError.js
init_process();
init_buffer();

// node_modules/@aws-sdk/util-endpoints/dist-es/types/EndpointRuleObject.js
init_process();
init_buffer();

// node_modules/@aws-sdk/util-endpoints/dist-es/types/ErrorRuleObject.js
init_process();
init_buffer();

// node_modules/@aws-sdk/util-endpoints/dist-es/types/RuleSetObject.js
init_process();
init_buffer();

// node_modules/@aws-sdk/util-endpoints/dist-es/types/TreeRuleObject.js
init_process();
init_buffer();

// node_modules/@aws-sdk/util-endpoints/dist-es/types/shared.js
init_process();
init_buffer();

// node_modules/@aws-sdk/middleware-user-agent/dist-es/constants.js
init_process();
init_buffer();
var USER_AGENT = "user-agent";
var X_AMZ_USER_AGENT = "x-amz-user-agent";
var SPACE = " ";
var UA_NAME_SEPARATOR = "/";
var UA_NAME_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g;
var UA_VALUE_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g;
var UA_ESCAPE_CHAR = "-";

// node_modules/@aws-sdk/middleware-user-agent/dist-es/user-agent-middleware.js
var userAgentMiddleware = (options) => (next, context) => async (args) => {
  const { request } = args;
  if (!HttpRequest.isInstance(request))
    return next(args);
  const { headers } = request;
  const userAgent = context?.userAgent?.map(escapeUserAgent) || [];
  const defaultUserAgent2 = (await options.defaultUserAgentProvider()).map(escapeUserAgent);
  const customUserAgent = options?.customUserAgent?.map(escapeUserAgent) || [];
  const prefix = getUserAgentPrefix();
  const sdkUserAgentValue = (prefix ? [prefix] : []).concat([...defaultUserAgent2, ...userAgent, ...customUserAgent]).join(SPACE);
  const normalUAValue = [
    ...defaultUserAgent2.filter((section) => section.startsWith("aws-sdk-")),
    ...customUserAgent
  ].join(SPACE);
  if (options.runtime !== "browser") {
    if (normalUAValue) {
      headers[X_AMZ_USER_AGENT] = headers[X_AMZ_USER_AGENT] ? `${headers[USER_AGENT]} ${normalUAValue}` : normalUAValue;
    }
    headers[USER_AGENT] = sdkUserAgentValue;
  } else {
    headers[X_AMZ_USER_AGENT] = sdkUserAgentValue;
  }
  return next({
    ...args,
    request
  });
};
var escapeUserAgent = (userAgentPair) => {
  const name = userAgentPair[0].split(UA_NAME_SEPARATOR).map((part) => part.replace(UA_NAME_ESCAPE_REGEX, UA_ESCAPE_CHAR)).join(UA_NAME_SEPARATOR);
  const version5 = userAgentPair[1]?.replace(UA_VALUE_ESCAPE_REGEX, UA_ESCAPE_CHAR);
  const prefixSeparatorIndex = name.indexOf(UA_NAME_SEPARATOR);
  const prefix = name.substring(0, prefixSeparatorIndex);
  let uaName = name.substring(prefixSeparatorIndex + 1);
  if (prefix === "api") {
    uaName = uaName.toLowerCase();
  }
  return [prefix, uaName, version5].filter((item) => item && item.length > 0).reduce((acc, item, index3) => {
    switch (index3) {
      case 0:
        return item;
      case 1:
        return `${acc}/${item}`;
      default:
        return `${acc}#${item}`;
    }
  }, "");
};
var getUserAgentMiddlewareOptions = {
  name: "getUserAgentMiddleware",
  step: "build",
  priority: "low",
  tags: ["SET_USER_AGENT", "USER_AGENT"],
  override: true
};
var getUserAgentPlugin = (config3) => ({
  applyToStack: (clientStack) => {
    clientStack.add(userAgentMiddleware(config3), getUserAgentMiddlewareOptions);
  }
});

// node_modules/@smithy/config-resolver/dist-es/index.js
init_process();
init_buffer();

// node_modules/@smithy/config-resolver/dist-es/endpointsConfig/index.js
init_process();
init_buffer();

// node_modules/@smithy/config-resolver/dist-es/endpointsConfig/NodeUseDualstackEndpointConfigOptions.js
init_process();
init_buffer();
var DEFAULT_USE_DUALSTACK_ENDPOINT = false;

// node_modules/@smithy/config-resolver/dist-es/endpointsConfig/NodeUseFipsEndpointConfigOptions.js
init_process();
init_buffer();
var DEFAULT_USE_FIPS_ENDPOINT = false;

// node_modules/@smithy/config-resolver/dist-es/endpointsConfig/resolveCustomEndpointsConfig.js
init_process();
init_buffer();

// node_modules/@smithy/config-resolver/dist-es/endpointsConfig/resolveEndpointsConfig.js
init_process();
init_buffer();

// node_modules/@smithy/config-resolver/dist-es/endpointsConfig/utils/getEndpointFromRegion.js
init_process();
init_buffer();

// node_modules/@smithy/config-resolver/dist-es/regionConfig/index.js
init_process();
init_buffer();

// node_modules/@smithy/config-resolver/dist-es/regionConfig/config.js
init_process();
init_buffer();

// node_modules/@smithy/config-resolver/dist-es/regionConfig/resolveRegionConfig.js
init_process();
init_buffer();

// node_modules/@smithy/config-resolver/dist-es/regionConfig/getRealRegion.js
init_process();
init_buffer();

// node_modules/@smithy/config-resolver/dist-es/regionConfig/isFipsRegion.js
init_process();
init_buffer();
var isFipsRegion = (region) => typeof region === "string" && (region.startsWith("fips-") || region.endsWith("-fips"));

// node_modules/@smithy/config-resolver/dist-es/regionConfig/getRealRegion.js
var getRealRegion = (region) => isFipsRegion(region) ? ["fips-aws-global", "aws-fips"].includes(region) ? "us-east-1" : region.replace(/fips-(dkr-|prod-)?|-fips/, "") : region;

// node_modules/@smithy/config-resolver/dist-es/regionConfig/resolveRegionConfig.js
var resolveRegionConfig = (input) => {
  const { region, useFipsEndpoint } = input;
  if (!region) {
    throw new Error("Region is missing");
  }
  return {
    ...input,
    region: async () => {
      if (typeof region === "string") {
        return getRealRegion(region);
      }
      const providedRegion = await region();
      return getRealRegion(providedRegion);
    },
    useFipsEndpoint: async () => {
      const providedRegion = typeof region === "string" ? region : await region();
      if (isFipsRegion(providedRegion)) {
        return true;
      }
      return typeof useFipsEndpoint !== "function" ? Promise.resolve(!!useFipsEndpoint) : useFipsEndpoint();
    }
  };
};

// node_modules/@smithy/config-resolver/dist-es/regionInfo/index.js
init_process();
init_buffer();

// node_modules/@smithy/config-resolver/dist-es/regionInfo/PartitionHash.js
init_process();
init_buffer();

// node_modules/@smithy/config-resolver/dist-es/regionInfo/RegionHash.js
init_process();
init_buffer();

// node_modules/@smithy/config-resolver/dist-es/regionInfo/getRegionInfo.js
init_process();
init_buffer();

// node_modules/@smithy/config-resolver/dist-es/regionInfo/getHostnameFromVariants.js
init_process();
init_buffer();

// node_modules/@smithy/config-resolver/dist-es/regionInfo/getResolvedHostname.js
init_process();
init_buffer();

// node_modules/@smithy/config-resolver/dist-es/regionInfo/getResolvedPartition.js
init_process();
init_buffer();

// node_modules/@smithy/config-resolver/dist-es/regionInfo/getResolvedSigningRegion.js
init_process();
init_buffer();

// node_modules/@smithy/eventstream-serde-config-resolver/dist-es/index.js
init_process();
init_buffer();

// node_modules/@smithy/eventstream-serde-config-resolver/dist-es/EventStreamSerdeConfig.js
init_process();
init_buffer();
var resolveEventStreamSerdeConfig = (input) => ({
  ...input,
  eventStreamMarshaller: input.eventStreamSerdeProvider(input)
});

// node_modules/@smithy/middleware-content-length/dist-es/index.js
init_process();
init_buffer();
var CONTENT_LENGTH_HEADER2 = "content-length";
function contentLengthMiddleware(bodyLengthChecker) {
  return (next) => async (args) => {
    const request = args.request;
    if (HttpRequest.isInstance(request)) {
      const { body: body3, headers } = request;
      if (body3 && Object.keys(headers).map((str) => str.toLowerCase()).indexOf(CONTENT_LENGTH_HEADER2) === -1) {
        try {
          const length = bodyLengthChecker(body3);
          request.headers = {
            ...request.headers,
            [CONTENT_LENGTH_HEADER2]: String(length)
          };
        } catch (error3) {
        }
      }
    }
    return next({
      ...args,
      request
    });
  };
}
var contentLengthMiddlewareOptions = {
  step: "build",
  tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
  name: "contentLengthMiddleware",
  override: true
};
var getContentLengthPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(contentLengthMiddleware(options.bodyLengthChecker), contentLengthMiddlewareOptions);
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/auth/httpAuthSchemeProvider.js
init_process();
init_buffer();

// node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/index.js
init_process();
init_buffer();

// node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/AwsSdkSigV4Signer.js
init_process();
init_buffer();

// node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/getDateHeader.js
init_process();
init_buffer();
var getDateHeader = (response) => HttpResponse.isInstance(response) ? response.headers?.date ?? response.headers?.Date : void 0;

// node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/getSkewCorrectedDate.js
init_process();
init_buffer();
var getSkewCorrectedDate = (systemClockOffset) => new Date(Date.now() + systemClockOffset);

// node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/getUpdatedSystemClockOffset.js
init_process();
init_buffer();

// node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/isClockSkewed.js
init_process();
init_buffer();
var isClockSkewed = (clockTime, systemClockOffset) => Math.abs(getSkewCorrectedDate(systemClockOffset).getTime() - clockTime) >= 3e5;

// node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/getUpdatedSystemClockOffset.js
var getUpdatedSystemClockOffset = (clockTime, currentSystemClockOffset) => {
  const clockTimeInMs = Date.parse(clockTime);
  if (isClockSkewed(clockTimeInMs, currentSystemClockOffset)) {
    return clockTimeInMs - Date.now();
  }
  return currentSystemClockOffset;
};

// node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/AwsSdkSigV4Signer.js
var throwSigningPropertyError = (name, property) => {
  if (!property) {
    throw new Error(`Property \`${name}\` is not resolved for AWS SDK SigV4Auth`);
  }
  return property;
};
var validateSigningProperties = async (signingProperties) => {
  const context = throwSigningPropertyError("context", signingProperties.context);
  const config3 = throwSigningPropertyError("config", signingProperties.config);
  const authScheme = context.endpointV2?.properties?.authSchemes?.[0];
  const signerFunction = throwSigningPropertyError("signer", config3.signer);
  const signer = await signerFunction(authScheme);
  const signingRegion = signingProperties?.signingRegion;
  const signingRegionSet = signingProperties?.signingRegionSet;
  const signingName = signingProperties?.signingName;
  return {
    config: config3,
    signer,
    signingRegion,
    signingRegionSet,
    signingName
  };
};
var AwsSdkSigV4Signer = class {
  async sign(httpRequest, identity, signingProperties) {
    if (!HttpRequest.isInstance(httpRequest)) {
      throw new Error("The request is not an instance of `HttpRequest` and cannot be signed");
    }
    const validatedProps = await validateSigningProperties(signingProperties);
    const { config: config3, signer } = validatedProps;
    let { signingRegion, signingName } = validatedProps;
    const handlerExecutionContext = signingProperties.context;
    if (handlerExecutionContext?.authSchemes?.length ?? 0 > 1) {
      const [first, second] = handlerExecutionContext.authSchemes;
      if (first?.name === "sigv4a" && second?.name === "sigv4") {
        signingRegion = second?.signingRegion ?? signingRegion;
        signingName = second?.signingName ?? signingName;
      }
    }
    const signedRequest = await signer.sign(httpRequest, {
      signingDate: getSkewCorrectedDate(config3.systemClockOffset),
      signingRegion,
      signingService: signingName
    });
    return signedRequest;
  }
  errorHandler(signingProperties) {
    return (error3) => {
      const serverTime = error3.ServerTime ?? getDateHeader(error3.$response);
      if (serverTime) {
        const config3 = throwSigningPropertyError("config", signingProperties.config);
        const initialSystemClockOffset = config3.systemClockOffset;
        config3.systemClockOffset = getUpdatedSystemClockOffset(serverTime, config3.systemClockOffset);
        const clockSkewCorrected = config3.systemClockOffset !== initialSystemClockOffset;
        if (clockSkewCorrected && error3.$metadata) {
          error3.$metadata.clockSkewCorrected = true;
        }
      }
      throw error3;
    };
  }
  successHandler(httpResponse, signingProperties) {
    const dateHeader = getDateHeader(httpResponse);
    if (dateHeader) {
      const config3 = throwSigningPropertyError("config", signingProperties.config);
      config3.systemClockOffset = getUpdatedSystemClockOffset(dateHeader, config3.systemClockOffset);
    }
  }
};

// node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/AwsSdkSigV4ASigner.js
init_process();
init_buffer();
var AwsSdkSigV4ASigner = class extends AwsSdkSigV4Signer {
  async sign(httpRequest, identity, signingProperties) {
    if (!HttpRequest.isInstance(httpRequest)) {
      throw new Error("The request is not an instance of `HttpRequest` and cannot be signed");
    }
    const { config: config3, signer, signingRegion, signingRegionSet, signingName } = await validateSigningProperties(signingProperties);
    const multiRegionOverride = signingRegionSet?.join?.(",") ?? signingRegion;
    const signedRequest = await signer.sign(httpRequest, {
      signingDate: getSkewCorrectedDate(config3.systemClockOffset),
      signingRegion: multiRegionOverride,
      signingService: signingName
    });
    return signedRequest;
  }
};

// node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/resolveAwsSdkSigV4Config.js
init_process();
init_buffer();
var resolveAwsSdkSigV4Config = (config3) => {
  let normalizedCreds;
  if (config3.credentials) {
    normalizedCreds = memoizeIdentityProvider(config3.credentials, isIdentityExpired, doesIdentityRequireRefresh);
  }
  if (!normalizedCreds) {
    if (config3.credentialDefaultProvider) {
      normalizedCreds = normalizeProvider2(config3.credentialDefaultProvider(Object.assign({}, config3, {
        parentClientConfig: config3
      })));
    } else {
      normalizedCreds = async () => {
        throw new Error("`credentials` is missing");
      };
    }
  }
  const { signingEscapePath = true, systemClockOffset = config3.systemClockOffset || 0, sha256: sha2562 } = config3;
  let signer;
  if (config3.signer) {
    signer = normalizeProvider2(config3.signer);
  } else if (config3.regionInfoProvider) {
    signer = () => normalizeProvider2(config3.region)().then(async (region) => [
      await config3.regionInfoProvider(region, {
        useFipsEndpoint: await config3.useFipsEndpoint(),
        useDualstackEndpoint: await config3.useDualstackEndpoint()
      }) || {},
      region
    ]).then(([regionInfo, region]) => {
      const { signingRegion, signingService } = regionInfo;
      config3.signingRegion = config3.signingRegion || signingRegion || region;
      config3.signingName = config3.signingName || signingService || config3.serviceId;
      const params = {
        ...config3,
        credentials: normalizedCreds,
        region: config3.signingRegion,
        service: config3.signingName,
        sha256: sha2562,
        uriEscapePath: signingEscapePath
      };
      const SignerCtor = config3.signerConstructor || SignatureV4;
      return new SignerCtor(params);
    });
  } else {
    signer = async (authScheme) => {
      authScheme = Object.assign({}, {
        name: "sigv4",
        signingName: config3.signingName || config3.defaultSigningName,
        signingRegion: await normalizeProvider2(config3.region)(),
        properties: {}
      }, authScheme);
      const signingRegion = authScheme.signingRegion;
      const signingService = authScheme.signingName;
      config3.signingRegion = config3.signingRegion || signingRegion;
      config3.signingName = config3.signingName || signingService || config3.serviceId;
      const params = {
        ...config3,
        credentials: normalizedCreds,
        region: config3.signingRegion,
        service: config3.signingName,
        sha256: sha2562,
        uriEscapePath: signingEscapePath
      };
      const SignerCtor = config3.signerConstructor || SignatureV4;
      return new SignerCtor(params);
    };
  }
  return {
    ...config3,
    systemClockOffset,
    signingEscapePath,
    credentials: normalizedCreds,
    signer
  };
};

// node_modules/@aws-sdk/core/dist-es/submodules/protocols/common.js
init_process();
init_buffer();
var collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body3) => context.utf8Encoder(body3));

// node_modules/@aws-sdk/core/dist-es/submodules/protocols/xml/parseXmlBody.js
init_process();
init_buffer();
var import_fast_xml_parser = __toESM(require_fxp());
var parseXmlBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
  if (encoded.length) {
    const parser = new import_fast_xml_parser.XMLParser({
      attributeNamePrefix: "",
      htmlEntities: true,
      ignoreAttributes: false,
      ignoreDeclaration: true,
      parseTagValue: false,
      trimValues: false,
      tagValueProcessor: (_, val2) => val2.trim() === "" && val2.includes("\n") ? "" : void 0
    });
    parser.addEntity("#xD", "\r");
    parser.addEntity("#10", "\n");
    let parsedObj;
    try {
      parsedObj = parser.parse(encoded, true);
    } catch (e2) {
      if (e2 && typeof e2 === "object") {
        Object.defineProperty(e2, "$responseBodyText", {
          value: encoded
        });
      }
      throw e2;
    }
    const textNodeName = "#text";
    const key2 = Object.keys(parsedObj)[0];
    const parsedObjToReturn = parsedObj[key2];
    if (parsedObjToReturn[textNodeName]) {
      parsedObjToReturn[key2] = parsedObjToReturn[textNodeName];
      delete parsedObjToReturn[textNodeName];
    }
    return getValueFromTextNode(parsedObjToReturn);
  }
  return {};
});
var parseXmlErrorBody = async (errorBody, context) => {
  const value = await parseXmlBody(errorBody, context);
  if (value.Error) {
    value.Error.message = value.Error.message ?? value.Error.Message;
  }
  return value;
};
var loadRestXmlErrorCode = (output, data) => {
  if (data?.Error?.Code !== void 0) {
    return data.Error.Code;
  }
  if (data?.Code !== void 0) {
    return data.Code;
  }
  if (output.statusCode == 404) {
    return "NotFound";
  }
};

// node_modules/@aws-sdk/signature-v4-multi-region/dist-es/index.js
init_process();
init_buffer();

// node_modules/@aws-sdk/signature-v4-multi-region/dist-es/SignatureV4MultiRegion.js
init_process();
init_buffer();

// node_modules/@aws-sdk/signature-v4-multi-region/dist-es/signature-v4-crt-container.js
init_process();
init_buffer();
var signatureV4CrtContainer = {
  CrtSignerV4: null
};

// node_modules/@aws-sdk/signature-v4-multi-region/dist-es/SignatureV4MultiRegion.js
var SignatureV4MultiRegion = class {
  constructor(options) {
    this.sigv4Signer = new SignatureV4S3Express(options);
    this.signerOptions = options;
  }
  async sign(requestToSign, options = {}) {
    if (options.signingRegion === "*") {
      if (this.signerOptions.runtime !== "node")
        throw new Error("This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js");
      return this.getSigv4aSigner().sign(requestToSign, options);
    }
    return this.sigv4Signer.sign(requestToSign, options);
  }
  async signWithCredentials(requestToSign, credentials, options = {}) {
    if (options.signingRegion === "*") {
      if (this.signerOptions.runtime !== "node")
        throw new Error("This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js");
      return this.getSigv4aSigner().signWithCredentials(requestToSign, credentials, options);
    }
    return this.sigv4Signer.signWithCredentials(requestToSign, credentials, options);
  }
  async presign(originalRequest, options = {}) {
    if (options.signingRegion === "*") {
      if (this.signerOptions.runtime !== "node")
        throw new Error("This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js");
      return this.getSigv4aSigner().presign(originalRequest, options);
    }
    return this.sigv4Signer.presign(originalRequest, options);
  }
  async presignWithCredentials(originalRequest, credentials, options = {}) {
    if (options.signingRegion === "*") {
      throw new Error("Method presignWithCredentials is not supported for [signingRegion=*].");
    }
    return this.sigv4Signer.presignWithCredentials(originalRequest, credentials, options);
  }
  getSigv4aSigner() {
    if (!this.sigv4aSigner) {
      let CrtSignerV4 = null;
      try {
        CrtSignerV4 = signatureV4CrtContainer.CrtSignerV4;
        if (typeof CrtSignerV4 !== "function")
          throw new Error();
      } catch (e2) {
        e2.message = `${e2.message}
Please check whether you have installed the "@aws-sdk/signature-v4-crt" package explicitly. 
You must also register the package by calling [require("@aws-sdk/signature-v4-crt");] or an ESM equivalent such as [import "@aws-sdk/signature-v4-crt";]. 
For more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt`;
        throw e2;
      }
      this.sigv4aSigner = new CrtSignerV4({
        ...this.signerOptions,
        signingAlgorithm: 1
      });
    }
    return this.sigv4aSigner;
  }
};

// node_modules/@aws-sdk/client-s3/dist-es/endpoint/endpointResolver.js
init_process();
init_buffer();

// node_modules/@aws-sdk/client-s3/dist-es/endpoint/ruleset.js
init_process();
init_buffer();
var ce = "required";
var cf = "type";
var cg = "conditions";
var ch = "fn";
var ci = "argv";
var cj = "ref";
var ck = "assign";
var cl = "url";
var cm = "properties";
var cn = "backend";
var co = "authSchemes";
var cp = "disableDoubleEncoding";
var cq = "signingName";
var cr = "signingRegion";
var cs = "headers";
var ct = "signingRegionSet";
var a = false;
var b = true;
var c = "isSet";
var d = "booleanEquals";
var e = "error";
var f = "aws.partition";
var g = "stringEquals";
var h = "getAttr";
var i = "name";
var j = "substring";
var k = "bucketSuffix";
var l = "parseURL";
var m = "{url#scheme}://{url#authority}/{uri_encoded_bucket}{url#path}";
var n = "endpoint";
var o = "tree";
var p = "aws.isVirtualHostableS3Bucket";
var q = "{url#scheme}://{Bucket}.{url#authority}{url#path}";
var r = "not";
var s = "{url#scheme}://{url#authority}{url#path}";
var t2 = "hardwareType";
var u = "regionPrefix";
var v = "bucketAliasSuffix";
var w = "outpostId";
var x = "isValidHostLabel";
var y = "sigv4a";
var z = "s3-outposts";
var A = "s3";
var B = "{url#scheme}://{url#authority}{url#normalizedPath}{Bucket}";
var C = "https://{Bucket}.s3-accelerate.{partitionResult#dnsSuffix}";
var D = "https://{Bucket}.s3.{partitionResult#dnsSuffix}";
var E = "aws.parseArn";
var F = "bucketArn";
var G = "arnType";
var H = "";
var I = "s3-object-lambda";
var J = "accesspoint";
var K = "accessPointName";
var L = "{url#scheme}://{accessPointName}-{bucketArn#accountId}.{url#authority}{url#path}";
var M = "mrapPartition";
var N = "outpostType";
var O = "arnPrefix";
var P = "{url#scheme}://{url#authority}{url#normalizedPath}{uri_encoded_bucket}";
var Q = "https://s3.{partitionResult#dnsSuffix}/{uri_encoded_bucket}";
var R = "https://s3.{partitionResult#dnsSuffix}";
var S = { [ce]: false, [cf]: "String" };
var T = { [ce]: true, "default": false, [cf]: "Boolean" };
var U = { [ce]: false, [cf]: "Boolean" };
var V = { [ch]: d, [ci]: [{ [cj]: "Accelerate" }, true] };
var W = { [ch]: d, [ci]: [{ [cj]: "UseFIPS" }, true] };
var X = { [ch]: d, [ci]: [{ [cj]: "UseDualStack" }, true] };
var Y = { [ch]: c, [ci]: [{ [cj]: "Endpoint" }] };
var Z = { [ch]: f, [ci]: [{ [cj]: "Region" }], [ck]: "partitionResult" };
var aa = { [ch]: g, [ci]: [{ [ch]: h, [ci]: [{ [cj]: "partitionResult" }, i] }, "aws-cn"] };
var ab = { [ch]: c, [ci]: [{ [cj]: "Bucket" }] };
var ac = { [cj]: "Bucket" };
var ad = { [ch]: l, [ci]: [{ [cj]: "Endpoint" }], [ck]: "url" };
var ae = { [ch]: d, [ci]: [{ [ch]: h, [ci]: [{ [cj]: "url" }, "isIp"] }, true] };
var af = { [cj]: "url" };
var ag = { [ch]: "uriEncode", [ci]: [ac], [ck]: "uri_encoded_bucket" };
var ah = { [cn]: "S3Express", [co]: [{ [cp]: true, [i]: "sigv4", [cq]: "s3express", [cr]: "{Region}" }] };
var ai = {};
var aj = { [ch]: p, [ci]: [ac, false] };
var ak = { [e]: "S3Express bucket name is not a valid virtual hostable name.", [cf]: e };
var al = { [cn]: "S3Express", [co]: [{ [cp]: true, [i]: "sigv4-s3express", [cq]: "s3express", [cr]: "{Region}" }] };
var am = { [ch]: c, [ci]: [{ [cj]: "UseS3ExpressControlEndpoint" }] };
var an = { [ch]: d, [ci]: [{ [cj]: "UseS3ExpressControlEndpoint" }, true] };
var ao = { [ch]: r, [ci]: [Y] };
var ap = { [e]: "Unrecognized S3Express bucket name format.", [cf]: e };
var aq = { [ch]: r, [ci]: [ab] };
var ar = { [cj]: t2 };
var as = { [cg]: [ao], [e]: "Expected a endpoint to be specified but no endpoint was found", [cf]: e };
var at = { [co]: [{ [cp]: true, [i]: y, [cq]: z, [ct]: ["*"] }, { [cp]: true, [i]: "sigv4", [cq]: z, [cr]: "{Region}" }] };
var au = { [ch]: d, [ci]: [{ [cj]: "ForcePathStyle" }, false] };
var av = { [cj]: "ForcePathStyle" };
var aw = { [ch]: d, [ci]: [{ [cj]: "Accelerate" }, false] };
var ax = { [ch]: g, [ci]: [{ [cj]: "Region" }, "aws-global"] };
var ay = { [co]: [{ [cp]: true, [i]: "sigv4", [cq]: A, [cr]: "us-east-1" }] };
var az = { [ch]: r, [ci]: [ax] };
var aA = { [ch]: d, [ci]: [{ [cj]: "UseGlobalEndpoint" }, true] };
var aB = { [cl]: "https://{Bucket}.s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}", [cm]: { [co]: [{ [cp]: true, [i]: "sigv4", [cq]: A, [cr]: "{Region}" }] }, [cs]: {} };
var aC = { [co]: [{ [cp]: true, [i]: "sigv4", [cq]: A, [cr]: "{Region}" }] };
var aD = { [ch]: d, [ci]: [{ [cj]: "UseGlobalEndpoint" }, false] };
var aE = { [ch]: d, [ci]: [{ [cj]: "UseDualStack" }, false] };
var aF = { [cl]: "https://{Bucket}.s3-fips.{Region}.{partitionResult#dnsSuffix}", [cm]: aC, [cs]: {} };
var aG = { [ch]: d, [ci]: [{ [cj]: "UseFIPS" }, false] };
var aH = { [cl]: "https://{Bucket}.s3-accelerate.dualstack.{partitionResult#dnsSuffix}", [cm]: aC, [cs]: {} };
var aI = { [cl]: "https://{Bucket}.s3.dualstack.{Region}.{partitionResult#dnsSuffix}", [cm]: aC, [cs]: {} };
var aJ = { [ch]: d, [ci]: [{ [ch]: h, [ci]: [af, "isIp"] }, false] };
var aK = { [cl]: B, [cm]: aC, [cs]: {} };
var aL = { [cl]: q, [cm]: aC, [cs]: {} };
var aM = { [n]: aL, [cf]: n };
var aN = { [cl]: C, [cm]: aC, [cs]: {} };
var aO = { [cl]: "https://{Bucket}.s3.{Region}.{partitionResult#dnsSuffix}", [cm]: aC, [cs]: {} };
var aP = { [e]: "Invalid region: region was not a valid DNS name.", [cf]: e };
var aQ = { [cj]: F };
var aR = { [cj]: G };
var aS = { [ch]: h, [ci]: [aQ, "service"] };
var aT = { [cj]: K };
var aU = { [cg]: [X], [e]: "S3 Object Lambda does not support Dual-stack", [cf]: e };
var aV = { [cg]: [V], [e]: "S3 Object Lambda does not support S3 Accelerate", [cf]: e };
var aW = { [cg]: [{ [ch]: c, [ci]: [{ [cj]: "DisableAccessPoints" }] }, { [ch]: d, [ci]: [{ [cj]: "DisableAccessPoints" }, true] }], [e]: "Access points are not supported for this operation", [cf]: e };
var aX = { [cg]: [{ [ch]: c, [ci]: [{ [cj]: "UseArnRegion" }] }, { [ch]: d, [ci]: [{ [cj]: "UseArnRegion" }, false] }, { [ch]: r, [ci]: [{ [ch]: g, [ci]: [{ [ch]: h, [ci]: [aQ, "region"] }, "{Region}"] }] }], [e]: "Invalid configuration: region from ARN `{bucketArn#region}` does not match client region `{Region}` and UseArnRegion is `false`", [cf]: e };
var aY = { [ch]: h, [ci]: [{ [cj]: "bucketPartition" }, i] };
var aZ = { [ch]: h, [ci]: [aQ, "accountId"] };
var ba = { [co]: [{ [cp]: true, [i]: "sigv4", [cq]: I, [cr]: "{bucketArn#region}" }] };
var bb = { [e]: "Invalid ARN: The access point name may only contain a-z, A-Z, 0-9 and `-`. Found: `{accessPointName}`", [cf]: e };
var bc = { [e]: "Invalid ARN: The account id may only contain a-z, A-Z, 0-9 and `-`. Found: `{bucketArn#accountId}`", [cf]: e };
var bd = { [e]: "Invalid region in ARN: `{bucketArn#region}` (invalid DNS name)", [cf]: e };
var be = { [e]: "Client was configured for partition `{partitionResult#name}` but ARN (`{Bucket}`) has `{bucketPartition#name}`", [cf]: e };
var bf = { [e]: "Invalid ARN: The ARN may only contain a single resource component after `accesspoint`.", [cf]: e };
var bg = { [e]: "Invalid ARN: Expected a resource of the format `accesspoint:<accesspoint name>` but no name was provided", [cf]: e };
var bh = { [co]: [{ [cp]: true, [i]: "sigv4", [cq]: A, [cr]: "{bucketArn#region}" }] };
var bi = { [co]: [{ [cp]: true, [i]: y, [cq]: z, [ct]: ["*"] }, { [cp]: true, [i]: "sigv4", [cq]: z, [cr]: "{bucketArn#region}" }] };
var bj = { [ch]: E, [ci]: [ac] };
var bk = { [cl]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cm]: aC, [cs]: {} };
var bl = { [cl]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cm]: aC, [cs]: {} };
var bm = { [cl]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cm]: aC, [cs]: {} };
var bn = { [cl]: P, [cm]: aC, [cs]: {} };
var bo = { [cl]: "https://s3.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cm]: aC, [cs]: {} };
var bp = { [cj]: "UseObjectLambdaEndpoint" };
var bq = { [co]: [{ [cp]: true, [i]: "sigv4", [cq]: I, [cr]: "{Region}" }] };
var br = { [cl]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}", [cm]: aC, [cs]: {} };
var bs = { [cl]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}", [cm]: aC, [cs]: {} };
var bt = { [cl]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}", [cm]: aC, [cs]: {} };
var bu = { [cl]: s, [cm]: aC, [cs]: {} };
var bv = { [cl]: "https://s3.{Region}.{partitionResult#dnsSuffix}", [cm]: aC, [cs]: {} };
var bw = [{ [cj]: "Region" }];
var bx = [{ [cj]: "Endpoint" }];
var by = [ac];
var bz = [X];
var bA = [V];
var bB = [Y, ad];
var bC = [{ [ch]: c, [ci]: [{ [cj]: "DisableS3ExpressSessionAuth" }] }, { [ch]: d, [ci]: [{ [cj]: "DisableS3ExpressSessionAuth" }, true] }];
var bD = [ae];
var bE = [ag];
var bF = [aj];
var bG = [W];
var bH = [{ [ch]: j, [ci]: [ac, 6, 14, true], [ck]: "s3expressAvailabilityZoneId" }, { [ch]: j, [ci]: [ac, 14, 16, true], [ck]: "s3expressAvailabilityZoneDelim" }, { [ch]: g, [ci]: [{ [cj]: "s3expressAvailabilityZoneDelim" }, "--"] }];
var bI = [{ [cg]: [W], [n]: { [cl]: "https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com", [cm]: ah, [cs]: {} }, [cf]: n }, { [n]: { [cl]: "https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com", [cm]: ah, [cs]: {} }, [cf]: n }];
var bJ = [{ [ch]: j, [ci]: [ac, 6, 15, true], [ck]: "s3expressAvailabilityZoneId" }, { [ch]: j, [ci]: [ac, 15, 17, true], [ck]: "s3expressAvailabilityZoneDelim" }, { [ch]: g, [ci]: [{ [cj]: "s3expressAvailabilityZoneDelim" }, "--"] }];
var bK = [{ [cg]: [W], [n]: { [cl]: "https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com", [cm]: al, [cs]: {} }, [cf]: n }, { [n]: { [cl]: "https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com", [cm]: al, [cs]: {} }, [cf]: n }];
var bL = [ab];
var bM = [{ [ch]: x, [ci]: [{ [cj]: w }, false] }];
var bN = [{ [ch]: g, [ci]: [{ [cj]: u }, "beta"] }];
var bO = ["*"];
var bP = [Z];
var bQ = [{ [ch]: x, [ci]: [{ [cj]: "Region" }, false] }];
var bR = [{ [ch]: g, [ci]: [{ [cj]: "Region" }, "us-east-1"] }];
var bS = [{ [ch]: g, [ci]: [aR, J] }];
var bT = [{ [ch]: h, [ci]: [aQ, "resourceId[1]"], [ck]: K }, { [ch]: r, [ci]: [{ [ch]: g, [ci]: [aT, H] }] }];
var bU = [aQ, "resourceId[1]"];
var bV = [{ [ch]: r, [ci]: [{ [ch]: g, [ci]: [{ [ch]: h, [ci]: [aQ, "region"] }, H] }] }];
var bW = [{ [ch]: r, [ci]: [{ [ch]: c, [ci]: [{ [ch]: h, [ci]: [aQ, "resourceId[2]"] }] }] }];
var bX = [aQ, "resourceId[2]"];
var bY = [{ [ch]: f, [ci]: [{ [ch]: h, [ci]: [aQ, "region"] }], [ck]: "bucketPartition" }];
var bZ = [{ [ch]: g, [ci]: [aY, { [ch]: h, [ci]: [{ [cj]: "partitionResult" }, i] }] }];
var ca = [{ [ch]: x, [ci]: [{ [ch]: h, [ci]: [aQ, "region"] }, true] }];
var cb = [{ [ch]: x, [ci]: [aZ, false] }];
var cc = [{ [ch]: x, [ci]: [aT, false] }];
var cd = [{ [ch]: x, [ci]: [{ [cj]: "Region" }, true] }];
var _data = { version: "1.0", parameters: { Bucket: S, Region: S, UseFIPS: T, UseDualStack: T, Endpoint: S, ForcePathStyle: T, Accelerate: T, UseGlobalEndpoint: T, UseObjectLambdaEndpoint: U, Key: S, Prefix: S, CopySource: S, DisableAccessPoints: U, DisableMultiRegionAccessPoints: T, UseArnRegion: U, UseS3ExpressControlEndpoint: U, DisableS3ExpressSessionAuth: U }, rules: [{ [cg]: [{ [ch]: c, [ci]: bw }], rules: [{ [cg]: [V, W], error: "Accelerate cannot be used with FIPS", [cf]: e }, { [cg]: [X, Y], error: "Cannot set dual-stack in combination with a custom endpoint.", [cf]: e }, { [cg]: [Y, W], error: "A custom endpoint cannot be combined with FIPS", [cf]: e }, { [cg]: [Y, V], error: "A custom endpoint cannot be combined with S3 Accelerate", [cf]: e }, { [cg]: [W, Z, aa], error: "Partition does not support FIPS", [cf]: e }, { [cg]: [ab, { [ch]: j, [ci]: [ac, 0, 6, b], [ck]: k }, { [ch]: g, [ci]: [{ [cj]: k }, "--x-s3"] }], rules: [{ [cg]: bz, error: "S3Express does not support Dual-stack.", [cf]: e }, { [cg]: bA, error: "S3Express does not support S3 Accelerate.", [cf]: e }, { [cg]: bB, rules: [{ [cg]: bC, rules: [{ [cg]: bD, rules: [{ [cg]: bE, rules: [{ endpoint: { [cl]: m, [cm]: ah, [cs]: ai }, [cf]: n }], [cf]: o }], [cf]: o }, { [cg]: bF, rules: [{ endpoint: { [cl]: q, [cm]: ah, [cs]: ai }, [cf]: n }], [cf]: o }, ak], [cf]: o }, { [cg]: bD, rules: [{ [cg]: bE, rules: [{ endpoint: { [cl]: m, [cm]: al, [cs]: ai }, [cf]: n }], [cf]: o }], [cf]: o }, { [cg]: bF, rules: [{ endpoint: { [cl]: q, [cm]: al, [cs]: ai }, [cf]: n }], [cf]: o }, ak], [cf]: o }, { [cg]: [am, an], rules: [{ [cg]: [ag, ao], rules: [{ [cg]: bG, endpoint: { [cl]: "https://s3express-control-fips.{Region}.amazonaws.com/{uri_encoded_bucket}", [cm]: ah, [cs]: ai }, [cf]: n }, { endpoint: { [cl]: "https://s3express-control.{Region}.amazonaws.com/{uri_encoded_bucket}", [cm]: ah, [cs]: ai }, [cf]: n }], [cf]: o }], [cf]: o }, { [cg]: bF, rules: [{ [cg]: bC, rules: [{ [cg]: bH, rules: bI, [cf]: o }, { [cg]: bJ, rules: bI, [cf]: o }, ap], [cf]: o }, { [cg]: bH, rules: bK, [cf]: o }, { [cg]: bJ, rules: bK, [cf]: o }, ap], [cf]: o }, ak], [cf]: o }, { [cg]: [aq, am, an], rules: [{ [cg]: bB, endpoint: { [cl]: s, [cm]: ah, [cs]: ai }, [cf]: n }, { [cg]: bG, endpoint: { [cl]: "https://s3express-control-fips.{Region}.amazonaws.com", [cm]: ah, [cs]: ai }, [cf]: n }, { endpoint: { [cl]: "https://s3express-control.{Region}.amazonaws.com", [cm]: ah, [cs]: ai }, [cf]: n }], [cf]: o }, { [cg]: [ab, { [ch]: j, [ci]: [ac, 49, 50, b], [ck]: t2 }, { [ch]: j, [ci]: [ac, 8, 12, b], [ck]: u }, { [ch]: j, [ci]: [ac, 0, 7, b], [ck]: v }, { [ch]: j, [ci]: [ac, 32, 49, b], [ck]: w }, { [ch]: f, [ci]: bw, [ck]: "regionPartition" }, { [ch]: g, [ci]: [{ [cj]: v }, "--op-s3"] }], rules: [{ [cg]: bM, rules: [{ [cg]: [{ [ch]: g, [ci]: [ar, "e"] }], rules: [{ [cg]: bN, rules: [as, { [cg]: bB, endpoint: { [cl]: "https://{Bucket}.ec2.{url#authority}", [cm]: at, [cs]: ai }, [cf]: n }], [cf]: o }, { endpoint: { [cl]: "https://{Bucket}.ec2.s3-outposts.{Region}.{regionPartition#dnsSuffix}", [cm]: at, [cs]: ai }, [cf]: n }], [cf]: o }, { [cg]: [{ [ch]: g, [ci]: [ar, "o"] }], rules: [{ [cg]: bN, rules: [as, { [cg]: bB, endpoint: { [cl]: "https://{Bucket}.op-{outpostId}.{url#authority}", [cm]: at, [cs]: ai }, [cf]: n }], [cf]: o }, { endpoint: { [cl]: "https://{Bucket}.op-{outpostId}.s3-outposts.{Region}.{regionPartition#dnsSuffix}", [cm]: at, [cs]: ai }, [cf]: n }], [cf]: o }, { error: 'Unrecognized hardware type: "Expected hardware type o or e but got {hardwareType}"', [cf]: e }], [cf]: o }, { error: "Invalid ARN: The outpost Id must only contain a-z, A-Z, 0-9 and `-`.", [cf]: e }], [cf]: o }, { [cg]: bL, rules: [{ [cg]: [Y, { [ch]: r, [ci]: [{ [ch]: c, [ci]: [{ [ch]: l, [ci]: bx }] }] }], error: "Custom endpoint `{Endpoint}` was not a valid URI", [cf]: e }, { [cg]: [au, aj], rules: [{ [cg]: bP, rules: [{ [cg]: bQ, rules: [{ [cg]: [V, aa], error: "S3 Accelerate cannot be used in this region", [cf]: e }, { [cg]: [X, W, aw, ao, ax], endpoint: { [cl]: "https://{Bucket}.s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [X, W, aw, ao, az, aA], rules: [{ endpoint: aB, [cf]: n }], [cf]: o }, { [cg]: [X, W, aw, ao, az, aD], endpoint: aB, [cf]: n }, { [cg]: [aE, W, aw, ao, ax], endpoint: { [cl]: "https://{Bucket}.s3-fips.us-east-1.{partitionResult#dnsSuffix}", [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [aE, W, aw, ao, az, aA], rules: [{ endpoint: aF, [cf]: n }], [cf]: o }, { [cg]: [aE, W, aw, ao, az, aD], endpoint: aF, [cf]: n }, { [cg]: [X, aG, V, ao, ax], endpoint: { [cl]: "https://{Bucket}.s3-accelerate.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [X, aG, V, ao, az, aA], rules: [{ endpoint: aH, [cf]: n }], [cf]: o }, { [cg]: [X, aG, V, ao, az, aD], endpoint: aH, [cf]: n }, { [cg]: [X, aG, aw, ao, ax], endpoint: { [cl]: "https://{Bucket}.s3.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [X, aG, aw, ao, az, aA], rules: [{ endpoint: aI, [cf]: n }], [cf]: o }, { [cg]: [X, aG, aw, ao, az, aD], endpoint: aI, [cf]: n }, { [cg]: [aE, aG, aw, Y, ad, ae, ax], endpoint: { [cl]: B, [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [aE, aG, aw, Y, ad, aJ, ax], endpoint: { [cl]: q, [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [aE, aG, aw, Y, ad, ae, az, aA], rules: [{ [cg]: bR, endpoint: aK, [cf]: n }, { endpoint: aK, [cf]: n }], [cf]: o }, { [cg]: [aE, aG, aw, Y, ad, aJ, az, aA], rules: [{ [cg]: bR, endpoint: aL, [cf]: n }, aM], [cf]: o }, { [cg]: [aE, aG, aw, Y, ad, ae, az, aD], endpoint: aK, [cf]: n }, { [cg]: [aE, aG, aw, Y, ad, aJ, az, aD], endpoint: aL, [cf]: n }, { [cg]: [aE, aG, V, ao, ax], endpoint: { [cl]: C, [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [aE, aG, V, ao, az, aA], rules: [{ [cg]: bR, endpoint: aN, [cf]: n }, { endpoint: aN, [cf]: n }], [cf]: o }, { [cg]: [aE, aG, V, ao, az, aD], endpoint: aN, [cf]: n }, { [cg]: [aE, aG, aw, ao, ax], endpoint: { [cl]: D, [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [aE, aG, aw, ao, az, aA], rules: [{ [cg]: bR, endpoint: { [cl]: D, [cm]: aC, [cs]: ai }, [cf]: n }, { endpoint: aO, [cf]: n }], [cf]: o }, { [cg]: [aE, aG, aw, ao, az, aD], endpoint: aO, [cf]: n }], [cf]: o }, aP], [cf]: o }], [cf]: o }, { [cg]: [Y, ad, { [ch]: g, [ci]: [{ [ch]: h, [ci]: [af, "scheme"] }, "http"] }, { [ch]: p, [ci]: [ac, b] }, au, aG, aE, aw], rules: [{ [cg]: bP, rules: [{ [cg]: bQ, rules: [aM], [cf]: o }, aP], [cf]: o }], [cf]: o }, { [cg]: [au, { [ch]: E, [ci]: by, [ck]: F }], rules: [{ [cg]: [{ [ch]: h, [ci]: [aQ, "resourceId[0]"], [ck]: G }, { [ch]: r, [ci]: [{ [ch]: g, [ci]: [aR, H] }] }], rules: [{ [cg]: [{ [ch]: g, [ci]: [aS, I] }], rules: [{ [cg]: bS, rules: [{ [cg]: bT, rules: [aU, aV, { [cg]: bV, rules: [aW, { [cg]: bW, rules: [aX, { [cg]: bY, rules: [{ [cg]: bP, rules: [{ [cg]: bZ, rules: [{ [cg]: ca, rules: [{ [cg]: [{ [ch]: g, [ci]: [aZ, H] }], error: "Invalid ARN: Missing account id", [cf]: e }, { [cg]: cb, rules: [{ [cg]: cc, rules: [{ [cg]: bB, endpoint: { [cl]: L, [cm]: ba, [cs]: ai }, [cf]: n }, { [cg]: bG, endpoint: { [cl]: "https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cm]: ba, [cs]: ai }, [cf]: n }, { endpoint: { [cl]: "https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cm]: ba, [cs]: ai }, [cf]: n }], [cf]: o }, bb], [cf]: o }, bc], [cf]: o }, bd], [cf]: o }, be], [cf]: o }], [cf]: o }], [cf]: o }, bf], [cf]: o }, { error: "Invalid ARN: bucket ARN is missing a region", [cf]: e }], [cf]: o }, bg], [cf]: o }, { error: "Invalid ARN: Object Lambda ARNs only support `accesspoint` arn types, but found: `{arnType}`", [cf]: e }], [cf]: o }, { [cg]: bS, rules: [{ [cg]: bT, rules: [{ [cg]: bV, rules: [{ [cg]: bS, rules: [{ [cg]: bV, rules: [aW, { [cg]: bW, rules: [aX, { [cg]: bY, rules: [{ [cg]: bP, rules: [{ [cg]: [{ [ch]: g, [ci]: [aY, "{partitionResult#name}"] }], rules: [{ [cg]: ca, rules: [{ [cg]: [{ [ch]: g, [ci]: [aS, A] }], rules: [{ [cg]: cb, rules: [{ [cg]: cc, rules: [{ [cg]: bA, error: "Access Points do not support S3 Accelerate", [cf]: e }, { [cg]: [W, X], endpoint: { [cl]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cm]: bh, [cs]: ai }, [cf]: n }, { [cg]: [W, aE], endpoint: { [cl]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cm]: bh, [cs]: ai }, [cf]: n }, { [cg]: [aG, X], endpoint: { [cl]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cm]: bh, [cs]: ai }, [cf]: n }, { [cg]: [aG, aE, Y, ad], endpoint: { [cl]: L, [cm]: bh, [cs]: ai }, [cf]: n }, { [cg]: [aG, aE], endpoint: { [cl]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cm]: bh, [cs]: ai }, [cf]: n }], [cf]: o }, bb], [cf]: o }, bc], [cf]: o }, { error: "Invalid ARN: The ARN was not for the S3 service, found: {bucketArn#service}", [cf]: e }], [cf]: o }, bd], [cf]: o }, be], [cf]: o }], [cf]: o }], [cf]: o }, bf], [cf]: o }], [cf]: o }], [cf]: o }, { [cg]: [{ [ch]: x, [ci]: [aT, b] }], rules: [{ [cg]: bz, error: "S3 MRAP does not support dual-stack", [cf]: e }, { [cg]: bG, error: "S3 MRAP does not support FIPS", [cf]: e }, { [cg]: bA, error: "S3 MRAP does not support S3 Accelerate", [cf]: e }, { [cg]: [{ [ch]: d, [ci]: [{ [cj]: "DisableMultiRegionAccessPoints" }, b] }], error: "Invalid configuration: Multi-Region Access Point ARNs are disabled.", [cf]: e }, { [cg]: [{ [ch]: f, [ci]: bw, [ck]: M }], rules: [{ [cg]: [{ [ch]: g, [ci]: [{ [ch]: h, [ci]: [{ [cj]: M }, i] }, { [ch]: h, [ci]: [aQ, "partition"] }] }], rules: [{ endpoint: { [cl]: "https://{accessPointName}.accesspoint.s3-global.{mrapPartition#dnsSuffix}", [cm]: { [co]: [{ [cp]: b, name: y, [cq]: A, [ct]: bO }] }, [cs]: ai }, [cf]: n }], [cf]: o }, { error: "Client was configured for partition `{mrapPartition#name}` but bucket referred to partition `{bucketArn#partition}`", [cf]: e }], [cf]: o }], [cf]: o }, { error: "Invalid Access Point Name", [cf]: e }], [cf]: o }, bg], [cf]: o }, { [cg]: [{ [ch]: g, [ci]: [aS, z] }], rules: [{ [cg]: bz, error: "S3 Outposts does not support Dual-stack", [cf]: e }, { [cg]: bG, error: "S3 Outposts does not support FIPS", [cf]: e }, { [cg]: bA, error: "S3 Outposts does not support S3 Accelerate", [cf]: e }, { [cg]: [{ [ch]: c, [ci]: [{ [ch]: h, [ci]: [aQ, "resourceId[4]"] }] }], error: "Invalid Arn: Outpost Access Point ARN contains sub resources", [cf]: e }, { [cg]: [{ [ch]: h, [ci]: bU, [ck]: w }], rules: [{ [cg]: bM, rules: [aX, { [cg]: bY, rules: [{ [cg]: bP, rules: [{ [cg]: bZ, rules: [{ [cg]: ca, rules: [{ [cg]: cb, rules: [{ [cg]: [{ [ch]: h, [ci]: bX, [ck]: N }], rules: [{ [cg]: [{ [ch]: h, [ci]: [aQ, "resourceId[3]"], [ck]: K }], rules: [{ [cg]: [{ [ch]: g, [ci]: [{ [cj]: N }, J] }], rules: [{ [cg]: bB, endpoint: { [cl]: "https://{accessPointName}-{bucketArn#accountId}.{outpostId}.{url#authority}", [cm]: bi, [cs]: ai }, [cf]: n }, { endpoint: { [cl]: "https://{accessPointName}-{bucketArn#accountId}.{outpostId}.s3-outposts.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cm]: bi, [cs]: ai }, [cf]: n }], [cf]: o }, { error: "Expected an outpost type `accesspoint`, found {outpostType}", [cf]: e }], [cf]: o }, { error: "Invalid ARN: expected an access point name", [cf]: e }], [cf]: o }, { error: "Invalid ARN: Expected a 4-component resource", [cf]: e }], [cf]: o }, bc], [cf]: o }, bd], [cf]: o }, be], [cf]: o }], [cf]: o }], [cf]: o }, { error: "Invalid ARN: The outpost Id may only contain a-z, A-Z, 0-9 and `-`. Found: `{outpostId}`", [cf]: e }], [cf]: o }, { error: "Invalid ARN: The Outpost Id was not set", [cf]: e }], [cf]: o }, { error: "Invalid ARN: Unrecognized format: {Bucket} (type: {arnType})", [cf]: e }], [cf]: o }, { error: "Invalid ARN: No ARN type specified", [cf]: e }], [cf]: o }, { [cg]: [{ [ch]: j, [ci]: [ac, 0, 4, a], [ck]: O }, { [ch]: g, [ci]: [{ [cj]: O }, "arn:"] }, { [ch]: r, [ci]: [{ [ch]: c, [ci]: [bj] }] }], error: "Invalid ARN: `{Bucket}` was not a valid ARN", [cf]: e }, { [cg]: [{ [ch]: d, [ci]: [av, b] }, bj], error: "Path-style addressing cannot be used with ARN buckets", [cf]: e }, { [cg]: bE, rules: [{ [cg]: bP, rules: [{ [cg]: [aw], rules: [{ [cg]: [X, ao, W, ax], endpoint: { [cl]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [X, ao, W, az, aA], rules: [{ endpoint: bk, [cf]: n }], [cf]: o }, { [cg]: [X, ao, W, az, aD], endpoint: bk, [cf]: n }, { [cg]: [aE, ao, W, ax], endpoint: { [cl]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [aE, ao, W, az, aA], rules: [{ endpoint: bl, [cf]: n }], [cf]: o }, { [cg]: [aE, ao, W, az, aD], endpoint: bl, [cf]: n }, { [cg]: [X, ao, aG, ax], endpoint: { [cl]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [X, ao, aG, az, aA], rules: [{ endpoint: bm, [cf]: n }], [cf]: o }, { [cg]: [X, ao, aG, az, aD], endpoint: bm, [cf]: n }, { [cg]: [aE, Y, ad, aG, ax], endpoint: { [cl]: P, [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [aE, Y, ad, aG, az, aA], rules: [{ [cg]: bR, endpoint: bn, [cf]: n }, { endpoint: bn, [cf]: n }], [cf]: o }, { [cg]: [aE, Y, ad, aG, az, aD], endpoint: bn, [cf]: n }, { [cg]: [aE, ao, aG, ax], endpoint: { [cl]: Q, [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [aE, ao, aG, az, aA], rules: [{ [cg]: bR, endpoint: { [cl]: Q, [cm]: aC, [cs]: ai }, [cf]: n }, { endpoint: bo, [cf]: n }], [cf]: o }, { [cg]: [aE, ao, aG, az, aD], endpoint: bo, [cf]: n }], [cf]: o }, { error: "Path-style addressing cannot be used with S3 Accelerate", [cf]: e }], [cf]: o }], [cf]: o }], [cf]: o }, { [cg]: [{ [ch]: c, [ci]: [bp] }, { [ch]: d, [ci]: [bp, b] }], rules: [{ [cg]: bP, rules: [{ [cg]: cd, rules: [aU, aV, { [cg]: bB, endpoint: { [cl]: s, [cm]: bq, [cs]: ai }, [cf]: n }, { [cg]: bG, endpoint: { [cl]: "https://s3-object-lambda-fips.{Region}.{partitionResult#dnsSuffix}", [cm]: bq, [cs]: ai }, [cf]: n }, { endpoint: { [cl]: "https://s3-object-lambda.{Region}.{partitionResult#dnsSuffix}", [cm]: bq, [cs]: ai }, [cf]: n }], [cf]: o }, aP], [cf]: o }], [cf]: o }, { [cg]: [aq], rules: [{ [cg]: bP, rules: [{ [cg]: cd, rules: [{ [cg]: [W, X, ao, ax], endpoint: { [cl]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [W, X, ao, az, aA], rules: [{ endpoint: br, [cf]: n }], [cf]: o }, { [cg]: [W, X, ao, az, aD], endpoint: br, [cf]: n }, { [cg]: [W, aE, ao, ax], endpoint: { [cl]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}", [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [W, aE, ao, az, aA], rules: [{ endpoint: bs, [cf]: n }], [cf]: o }, { [cg]: [W, aE, ao, az, aD], endpoint: bs, [cf]: n }, { [cg]: [aG, X, ao, ax], endpoint: { [cl]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [aG, X, ao, az, aA], rules: [{ endpoint: bt, [cf]: n }], [cf]: o }, { [cg]: [aG, X, ao, az, aD], endpoint: bt, [cf]: n }, { [cg]: [aG, aE, Y, ad, ax], endpoint: { [cl]: s, [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [aG, aE, Y, ad, az, aA], rules: [{ [cg]: bR, endpoint: bu, [cf]: n }, { endpoint: bu, [cf]: n }], [cf]: o }, { [cg]: [aG, aE, Y, ad, az, aD], endpoint: bu, [cf]: n }, { [cg]: [aG, aE, ao, ax], endpoint: { [cl]: R, [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [aG, aE, ao, az, aA], rules: [{ [cg]: bR, endpoint: { [cl]: R, [cm]: aC, [cs]: ai }, [cf]: n }, { endpoint: bv, [cf]: n }], [cf]: o }, { [cg]: [aG, aE, ao, az, aD], endpoint: bv, [cf]: n }], [cf]: o }, aP], [cf]: o }], [cf]: o }], [cf]: o }, { error: "A region must be set when sending requests to S3.", [cf]: e }] };
var ruleSet = _data;

// node_modules/@aws-sdk/client-s3/dist-es/endpoint/endpointResolver.js
var defaultEndpointResolver = (endpointParams, context = {}) => {
  return resolveEndpoint(ruleSet, {
    endpointParams,
    logger: context.logger
  });
};
customEndpointFunctions.aws = awsEndpointFunctions;

// node_modules/@aws-sdk/client-s3/dist-es/auth/httpAuthSchemeProvider.js
var createEndpointRuleSetHttpAuthSchemeParametersProvider = (defaultHttpAuthSchemeParametersProvider) => async (config3, context, input) => {
  if (!input) {
    throw new Error(`Could not find \`input\` for \`defaultEndpointRuleSetHttpAuthSchemeParametersProvider\``);
  }
  const defaultParameters = await defaultHttpAuthSchemeParametersProvider(config3, context, input);
  const instructionsFn = getSmithyContext(context)?.commandInstance?.constructor?.getEndpointParameterInstructions;
  if (!instructionsFn) {
    throw new Error(`getEndpointParameterInstructions() is not defined on \`${context.commandName}\``);
  }
  const endpointParameters = await resolveParams(input, { getEndpointParameterInstructions: instructionsFn }, config3);
  return Object.assign(defaultParameters, endpointParameters);
};
var _defaultS3HttpAuthSchemeParametersProvider = async (config3, context, input) => {
  return {
    operation: getSmithyContext(context).operation,
    region: await normalizeProvider(config3.region)() || (() => {
      throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
    })()
  };
};
var defaultS3HttpAuthSchemeParametersProvider = createEndpointRuleSetHttpAuthSchemeParametersProvider(_defaultS3HttpAuthSchemeParametersProvider);
function createAwsAuthSigv4HttpAuthOption(authParameters) {
  return {
    schemeId: "aws.auth#sigv4",
    signingProperties: {
      name: "s3",
      region: authParameters.region
    },
    propertiesExtractor: (config3, context) => ({
      signingProperties: {
        config: config3,
        context
      }
    })
  };
}
function createAwsAuthSigv4aHttpAuthOption(authParameters) {
  return {
    schemeId: "aws.auth#sigv4a",
    signingProperties: {
      name: "s3",
      region: authParameters.region
    },
    propertiesExtractor: (config3, context) => ({
      signingProperties: {
        config: config3,
        context
      }
    })
  };
}
var createEndpointRuleSetHttpAuthSchemeProvider = (defaultEndpointResolver2, defaultHttpAuthSchemeResolver, createHttpAuthOptionFunctions) => {
  const endpointRuleSetHttpAuthSchemeProvider = (authParameters) => {
    const endpoint = defaultEndpointResolver2(authParameters);
    const authSchemes = endpoint.properties?.authSchemes;
    if (!authSchemes) {
      return defaultHttpAuthSchemeResolver(authParameters);
    }
    const options = [];
    for (const scheme of authSchemes) {
      const { name: resolvedName, properties = {}, ...rest } = scheme;
      const name = resolvedName.toLowerCase();
      if (resolvedName !== name) {
        console.warn(`HttpAuthScheme has been normalized with lowercasing: \`${resolvedName}\` to \`${name}\``);
      }
      let schemeId;
      if (name === "sigv4a") {
        schemeId = "aws.auth#sigv4a";
        const sigv4Present = authSchemes.find((s2) => {
          const name2 = s2.name.toLowerCase();
          return name2 !== "sigv4a" && name2.startsWith("sigv4");
        });
        if (!signatureV4CrtContainer.CrtSignerV4 && sigv4Present) {
          continue;
        }
      } else if (name.startsWith("sigv4")) {
        schemeId = "aws.auth#sigv4";
      } else {
        throw new Error(`Unknown HttpAuthScheme found in \`@smithy.rules#endpointRuleSet\`: \`${name}\``);
      }
      const createOption = createHttpAuthOptionFunctions[schemeId];
      if (!createOption) {
        throw new Error(`Could not find HttpAuthOption create function for \`${schemeId}\``);
      }
      const option2 = createOption(authParameters);
      option2.schemeId = schemeId;
      option2.signingProperties = { ...option2.signingProperties || {}, ...rest, ...properties };
      options.push(option2);
    }
    return options;
  };
  return endpointRuleSetHttpAuthSchemeProvider;
};
var _defaultS3HttpAuthSchemeProvider = (authParameters) => {
  const options = [];
  switch (authParameters.operation) {
    default: {
      options.push(createAwsAuthSigv4HttpAuthOption(authParameters));
      options.push(createAwsAuthSigv4aHttpAuthOption(authParameters));
    }
  }
  return options;
};
var defaultS3HttpAuthSchemeProvider = createEndpointRuleSetHttpAuthSchemeProvider(defaultEndpointResolver, _defaultS3HttpAuthSchemeProvider, {
  "aws.auth#sigv4": createAwsAuthSigv4HttpAuthOption,
  "aws.auth#sigv4a": createAwsAuthSigv4aHttpAuthOption
});
var resolveHttpAuthSchemeConfig = (config3) => {
  const config_0 = resolveAwsSdkSigV4Config(config3);
  return {
    ...config_0
  };
};

// node_modules/@aws-sdk/client-s3/dist-es/commands/CreateSessionCommand.js
init_process();
init_buffer();

// node_modules/@aws-sdk/client-s3/dist-es/endpoint/EndpointParameters.js
init_process();
init_buffer();
var resolveClientEndpointParameters = (options) => {
  return {
    ...options,
    useFipsEndpoint: options.useFipsEndpoint ?? false,
    useDualstackEndpoint: options.useDualstackEndpoint ?? false,
    forcePathStyle: options.forcePathStyle ?? false,
    useAccelerateEndpoint: options.useAccelerateEndpoint ?? false,
    useGlobalEndpoint: options.useGlobalEndpoint ?? false,
    disableMultiregionAccessPoints: options.disableMultiregionAccessPoints ?? false,
    defaultSigningName: "s3"
  };
};
var commonParams = {
  ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
  UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
  DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
  Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
  DisableS3ExpressSessionAuth: { type: "clientContextParams", name: "disableS3ExpressSessionAuth" },
  UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
  UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
  Endpoint: { type: "builtInParams", name: "endpoint" },
  Region: { type: "builtInParams", name: "region" },
  UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
};

// node_modules/@aws-sdk/client-s3/dist-es/models/models_0.js
init_process();
init_buffer();

// node_modules/@aws-sdk/client-s3/dist-es/models/S3ServiceException.js
init_process();
init_buffer();
var S3ServiceException = class extends ServiceException {
  constructor(options) {
    super(options);
    Object.setPrototypeOf(this, S3ServiceException.prototype);
  }
};

// node_modules/@aws-sdk/client-s3/dist-es/models/models_0.js
var NoSuchUpload = class extends S3ServiceException {
  constructor(opts) {
    super({
      name: "NoSuchUpload",
      $fault: "client",
      ...opts
    });
    this.name = "NoSuchUpload";
    this.$fault = "client";
    Object.setPrototypeOf(this, NoSuchUpload.prototype);
  }
};
var ObjectNotInActiveTierError = class extends S3ServiceException {
  constructor(opts) {
    super({
      name: "ObjectNotInActiveTierError",
      $fault: "client",
      ...opts
    });
    this.name = "ObjectNotInActiveTierError";
    this.$fault = "client";
    Object.setPrototypeOf(this, ObjectNotInActiveTierError.prototype);
  }
};
var BucketAlreadyExists = class extends S3ServiceException {
  constructor(opts) {
    super({
      name: "BucketAlreadyExists",
      $fault: "client",
      ...opts
    });
    this.name = "BucketAlreadyExists";
    this.$fault = "client";
    Object.setPrototypeOf(this, BucketAlreadyExists.prototype);
  }
};
var BucketAlreadyOwnedByYou = class extends S3ServiceException {
  constructor(opts) {
    super({
      name: "BucketAlreadyOwnedByYou",
      $fault: "client",
      ...opts
    });
    this.name = "BucketAlreadyOwnedByYou";
    this.$fault = "client";
    Object.setPrototypeOf(this, BucketAlreadyOwnedByYou.prototype);
  }
};
var NoSuchBucket = class extends S3ServiceException {
  constructor(opts) {
    super({
      name: "NoSuchBucket",
      $fault: "client",
      ...opts
    });
    this.name = "NoSuchBucket";
    this.$fault = "client";
    Object.setPrototypeOf(this, NoSuchBucket.prototype);
  }
};
var AnalyticsFilter;
(function(AnalyticsFilter2) {
  AnalyticsFilter2.visit = (value, visitor) => {
    if (value.Prefix !== void 0)
      return visitor.Prefix(value.Prefix);
    if (value.Tag !== void 0)
      return visitor.Tag(value.Tag);
    if (value.And !== void 0)
      return visitor.And(value.And);
    return visitor._(value.$unknown[0], value.$unknown[1]);
  };
})(AnalyticsFilter || (AnalyticsFilter = {}));
var LifecycleRuleFilter;
(function(LifecycleRuleFilter2) {
  LifecycleRuleFilter2.visit = (value, visitor) => {
    if (value.Prefix !== void 0)
      return visitor.Prefix(value.Prefix);
    if (value.Tag !== void 0)
      return visitor.Tag(value.Tag);
    if (value.ObjectSizeGreaterThan !== void 0)
      return visitor.ObjectSizeGreaterThan(value.ObjectSizeGreaterThan);
    if (value.ObjectSizeLessThan !== void 0)
      return visitor.ObjectSizeLessThan(value.ObjectSizeLessThan);
    if (value.And !== void 0)
      return visitor.And(value.And);
    return visitor._(value.$unknown[0], value.$unknown[1]);
  };
})(LifecycleRuleFilter || (LifecycleRuleFilter = {}));
var MetricsFilter;
(function(MetricsFilter2) {
  MetricsFilter2.visit = (value, visitor) => {
    if (value.Prefix !== void 0)
      return visitor.Prefix(value.Prefix);
    if (value.Tag !== void 0)
      return visitor.Tag(value.Tag);
    if (value.AccessPointArn !== void 0)
      return visitor.AccessPointArn(value.AccessPointArn);
    if (value.And !== void 0)
      return visitor.And(value.And);
    return visitor._(value.$unknown[0], value.$unknown[1]);
  };
})(MetricsFilter || (MetricsFilter = {}));
var ReplicationRuleFilter;
(function(ReplicationRuleFilter2) {
  ReplicationRuleFilter2.visit = (value, visitor) => {
    if (value.Prefix !== void 0)
      return visitor.Prefix(value.Prefix);
    if (value.Tag !== void 0)
      return visitor.Tag(value.Tag);
    if (value.And !== void 0)
      return visitor.And(value.And);
    return visitor._(value.$unknown[0], value.$unknown[1]);
  };
})(ReplicationRuleFilter || (ReplicationRuleFilter = {}));
var InvalidObjectState = class extends S3ServiceException {
  constructor(opts) {
    super({
      name: "InvalidObjectState",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidObjectState";
    this.$fault = "client";
    Object.setPrototypeOf(this, InvalidObjectState.prototype);
    this.StorageClass = opts.StorageClass;
    this.AccessTier = opts.AccessTier;
  }
};
var NoSuchKey = class extends S3ServiceException {
  constructor(opts) {
    super({
      name: "NoSuchKey",
      $fault: "client",
      ...opts
    });
    this.name = "NoSuchKey";
    this.$fault = "client";
    Object.setPrototypeOf(this, NoSuchKey.prototype);
  }
};
var NotFound = class extends S3ServiceException {
  constructor(opts) {
    super({
      name: "NotFound",
      $fault: "client",
      ...opts
    });
    this.name = "NotFound";
    this.$fault = "client";
    Object.setPrototypeOf(this, NotFound.prototype);
  }
};
var SessionCredentialsFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.SecretAccessKey && { SecretAccessKey: SENSITIVE_STRING },
  ...obj.SessionToken && { SessionToken: SENSITIVE_STRING }
});
var CreateSessionOutputFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.Credentials && { Credentials: SessionCredentialsFilterSensitiveLog(obj.Credentials) }
});

// node_modules/@aws-sdk/client-s3/dist-es/protocols/Aws_restXml.js
init_process();
init_buffer();

// node_modules/@aws-sdk/xml-builder/dist-es/index.js
init_process();
init_buffer();

// node_modules/@aws-sdk/xml-builder/dist-es/XmlNode.js
init_process();
init_buffer();

// node_modules/@aws-sdk/xml-builder/dist-es/escape-attribute.js
init_process();
init_buffer();

// node_modules/@aws-sdk/xml-builder/dist-es/XmlText.js
init_process();
init_buffer();

// node_modules/@aws-sdk/xml-builder/dist-es/escape-element.js
init_process();
init_buffer();

// node_modules/@aws-sdk/client-s3/dist-es/models/models_1.js
init_process();
init_buffer();
var ObjectAlreadyInActiveTierError = class extends S3ServiceException {
  constructor(opts) {
    super({
      name: "ObjectAlreadyInActiveTierError",
      $fault: "client",
      ...opts
    });
    this.name = "ObjectAlreadyInActiveTierError";
    this.$fault = "client";
    Object.setPrototypeOf(this, ObjectAlreadyInActiveTierError.prototype);
  }
};
var SelectObjectContentEventStream;
(function(SelectObjectContentEventStream2) {
  SelectObjectContentEventStream2.visit = (value, visitor) => {
    if (value.Records !== void 0)
      return visitor.Records(value.Records);
    if (value.Stats !== void 0)
      return visitor.Stats(value.Stats);
    if (value.Progress !== void 0)
      return visitor.Progress(value.Progress);
    if (value.Cont !== void 0)
      return visitor.Cont(value.Cont);
    if (value.End !== void 0)
      return visitor.End(value.End);
    return visitor._(value.$unknown[0], value.$unknown[1]);
  };
})(SelectObjectContentEventStream || (SelectObjectContentEventStream = {}));
var PutObjectOutputFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING },
  ...obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: SENSITIVE_STRING }
});
var PutObjectRequestFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.SSECustomerKey && { SSECustomerKey: SENSITIVE_STRING },
  ...obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING },
  ...obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: SENSITIVE_STRING }
});

// node_modules/@aws-sdk/client-s3/dist-es/protocols/Aws_restXml.js
var se_CreateSessionCommand = async (input, context) => {
  const b2 = requestBuilder(input, context);
  const headers = map3({}, isSerializableHeaderValue, {
    [_xacsm]: input[_SM]
  });
  b2.bp("/");
  b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
  const query = map3({
    [_s]: [, ""]
  });
  let body3;
  b2.m("GET").h(headers).q(query).b(body3);
  return b2.build();
};
var se_PutObjectCommand = async (input, context) => {
  const b2 = requestBuilder(input, context);
  const headers = map3({}, isSerializableHeaderValue, {
    [_ct]: input[_CT] || "application/octet-stream",
    [_xaa]: input[_ACL],
    [_cc]: input[_CC],
    [_cd]: input[_CD],
    [_ce]: input[_CE],
    [_cl]: input[_CL],
    [_cl_]: [() => isSerializableHeaderValue(input[_CLo]), () => input[_CLo].toString()],
    [_cm]: input[_CMD],
    [_xasca]: input[_CA],
    [_xacc]: input[_CCRC],
    [_xacc_]: input[_CCRCC],
    [_xacs]: input[_CSHA],
    [_xacs_]: input[_CSHAh],
    [_e]: [() => isSerializableHeaderValue(input[_E]), () => dateToUtcString(input[_E]).toString()],
    [_xagfc]: input[_GFC],
    [_xagr]: input[_GR],
    [_xagra]: input[_GRACP],
    [_xagwa]: input[_GWACP],
    [_xasse]: input[_SSE],
    [_xasc]: input[_SC],
    [_xawrl]: input[_WRL],
    [_xasseca]: input[_SSECA],
    [_xasseck]: input[_SSECK],
    [_xasseckm]: input[_SSECKMD],
    [_xasseakki]: input[_SSEKMSKI],
    [_xassec]: input[_SSEKMSEC],
    [_xassebke]: [() => isSerializableHeaderValue(input[_BKE]), () => input[_BKE].toString()],
    [_xarp]: input[_RP],
    [_xat]: input[_T],
    [_xaolm]: input[_OLM],
    [_xaolrud]: [() => isSerializableHeaderValue(input[_OLRUD]), () => serializeDateTime(input[_OLRUD]).toString()],
    [_xaollh]: input[_OLLHS],
    [_xaebo]: input[_EBO],
    ...input.Metadata !== void 0 && Object.keys(input.Metadata).reduce((acc, suffix) => {
      acc[`x-amz-meta-${suffix.toLowerCase()}`] = input.Metadata[suffix];
      return acc;
    }, {})
  });
  b2.bp("/{Key+}");
  b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
  b2.p("Key", () => input.Key, "{Key+}", true);
  const query = map3({
    [_xi]: [, "PutObject"]
  });
  let body3;
  let contents;
  if (input.Body !== void 0) {
    contents = input.Body;
    body3 = contents;
  }
  b2.m("PUT").h(headers).q(query).b(body3);
  return b2.build();
};
var de_CreateSessionCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const contents = map3({
    $metadata: deserializeMetadata2(output)
  });
  const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
  if (data[_C] != null) {
    contents[_C] = de_SessionCredentials(data[_C], context);
  }
  return contents;
};
var de_PutObjectCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const contents = map3({
    $metadata: deserializeMetadata2(output),
    [_Exp]: [, output.headers[_xae]],
    [_ETa]: [, output.headers[_eta]],
    [_CCRC]: [, output.headers[_xacc]],
    [_CCRCC]: [, output.headers[_xacc_]],
    [_CSHA]: [, output.headers[_xacs]],
    [_CSHAh]: [, output.headers[_xacs_]],
    [_SSE]: [, output.headers[_xasse]],
    [_VI]: [, output.headers[_xavi]],
    [_SSECA]: [, output.headers[_xasseca]],
    [_SSECKMD]: [, output.headers[_xasseckm]],
    [_SSEKMSKI]: [, output.headers[_xasseakki]],
    [_SSEKMSEC]: [, output.headers[_xassec]],
    [_BKE]: [() => void 0 !== output.headers[_xassebke], () => parseBoolean(output.headers[_xassebke])],
    [_RC]: [, output.headers[_xarc]]
  });
  await collectBody(output.body, context);
  return contents;
};
var de_CommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseXmlErrorBody(output.body, context)
  };
  const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "NoSuchUpload":
    case "com.amazonaws.s3#NoSuchUpload":
      throw await de_NoSuchUploadRes(parsedOutput, context);
    case "ObjectNotInActiveTierError":
    case "com.amazonaws.s3#ObjectNotInActiveTierError":
      throw await de_ObjectNotInActiveTierErrorRes(parsedOutput, context);
    case "BucketAlreadyExists":
    case "com.amazonaws.s3#BucketAlreadyExists":
      throw await de_BucketAlreadyExistsRes(parsedOutput, context);
    case "BucketAlreadyOwnedByYou":
    case "com.amazonaws.s3#BucketAlreadyOwnedByYou":
      throw await de_BucketAlreadyOwnedByYouRes(parsedOutput, context);
    case "NoSuchBucket":
    case "com.amazonaws.s3#NoSuchBucket":
      throw await de_NoSuchBucketRes(parsedOutput, context);
    case "InvalidObjectState":
    case "com.amazonaws.s3#InvalidObjectState":
      throw await de_InvalidObjectStateRes(parsedOutput, context);
    case "NoSuchKey":
    case "com.amazonaws.s3#NoSuchKey":
      throw await de_NoSuchKeyRes(parsedOutput, context);
    case "NotFound":
    case "com.amazonaws.s3#NotFound":
      throw await de_NotFoundRes(parsedOutput, context);
    case "ObjectAlreadyInActiveTierError":
    case "com.amazonaws.s3#ObjectAlreadyInActiveTierError":
      throw await de_ObjectAlreadyInActiveTierErrorRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError2({
        output,
        parsedBody,
        errorCode
      });
  }
};
var throwDefaultError2 = withBaseException(S3ServiceException);
var de_BucketAlreadyExistsRes = async (parsedOutput, context) => {
  const contents = map3({});
  const data = parsedOutput.body;
  const exception = new BucketAlreadyExists({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var de_BucketAlreadyOwnedByYouRes = async (parsedOutput, context) => {
  const contents = map3({});
  const data = parsedOutput.body;
  const exception = new BucketAlreadyOwnedByYou({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var de_InvalidObjectStateRes = async (parsedOutput, context) => {
  const contents = map3({});
  const data = parsedOutput.body;
  if (data[_AT] != null) {
    contents[_AT] = expectString(data[_AT]);
  }
  if (data[_SC] != null) {
    contents[_SC] = expectString(data[_SC]);
  }
  const exception = new InvalidObjectState({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var de_NoSuchBucketRes = async (parsedOutput, context) => {
  const contents = map3({});
  const data = parsedOutput.body;
  const exception = new NoSuchBucket({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var de_NoSuchKeyRes = async (parsedOutput, context) => {
  const contents = map3({});
  const data = parsedOutput.body;
  const exception = new NoSuchKey({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var de_NoSuchUploadRes = async (parsedOutput, context) => {
  const contents = map3({});
  const data = parsedOutput.body;
  const exception = new NoSuchUpload({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var de_NotFoundRes = async (parsedOutput, context) => {
  const contents = map3({});
  const data = parsedOutput.body;
  const exception = new NotFound({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var de_ObjectAlreadyInActiveTierErrorRes = async (parsedOutput, context) => {
  const contents = map3({});
  const data = parsedOutput.body;
  const exception = new ObjectAlreadyInActiveTierError({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var de_ObjectNotInActiveTierErrorRes = async (parsedOutput, context) => {
  const contents = map3({});
  const data = parsedOutput.body;
  const exception = new ObjectNotInActiveTierError({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var de_SessionCredentials = (output, context) => {
  const contents = {};
  if (output[_AKI] != null) {
    contents[_AKI] = expectString(output[_AKI]);
  }
  if (output[_SAK] != null) {
    contents[_SAK] = expectString(output[_SAK]);
  }
  if (output[_ST] != null) {
    contents[_ST] = expectString(output[_ST]);
  }
  if (output[_Exp] != null) {
    contents[_Exp] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_Exp]));
  }
  return contents;
};
var deserializeMetadata2 = (output) => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
});
var isSerializableHeaderValue = (value) => value !== void 0 && value !== null && value !== "" && (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) && (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
var _ACL = "ACL";
var _AKI = "AccessKeyId";
var _AT = "AccessTier";
var _BKE = "BucketKeyEnabled";
var _C = "Credentials";
var _CA = "ChecksumAlgorithm";
var _CC = "CacheControl";
var _CCRC = "ChecksumCRC32";
var _CCRCC = "ChecksumCRC32C";
var _CD = "ContentDisposition";
var _CE = "ContentEncoding";
var _CL = "ContentLanguage";
var _CLo = "ContentLength";
var _CMD = "ContentMD5";
var _CSHA = "ChecksumSHA1";
var _CSHAh = "ChecksumSHA256";
var _CT = "ContentType";
var _E = "Expires";
var _EBO = "ExpectedBucketOwner";
var _ETa = "ETag";
var _Exp = "Expiration";
var _GFC = "GrantFullControl";
var _GR = "GrantRead";
var _GRACP = "GrantReadACP";
var _GWACP = "GrantWriteACP";
var _OLLHS = "ObjectLockLegalHoldStatus";
var _OLM = "ObjectLockMode";
var _OLRUD = "ObjectLockRetainUntilDate";
var _RC = "RequestCharged";
var _RP = "RequestPayer";
var _SAK = "SecretAccessKey";
var _SC = "StorageClass";
var _SM = "SessionMode";
var _SSE = "ServerSideEncryption";
var _SSECA = "SSECustomerAlgorithm";
var _SSECK = "SSECustomerKey";
var _SSECKMD = "SSECustomerKeyMD5";
var _SSEKMSEC = "SSEKMSEncryptionContext";
var _SSEKMSKI = "SSEKMSKeyId";
var _ST = "SessionToken";
var _T = "Tagging";
var _VI = "VersionId";
var _WRL = "WebsiteRedirectLocation";
var _cc = "cache-control";
var _cd = "content-disposition";
var _ce = "content-encoding";
var _cl = "content-language";
var _cl_ = "content-length";
var _cm = "content-md5";
var _ct = "content-type";
var _e = "expires";
var _eta = "etag";
var _s = "session";
var _xaa = "x-amz-acl";
var _xacc = "x-amz-checksum-crc32";
var _xacc_ = "x-amz-checksum-crc32c";
var _xacs = "x-amz-checksum-sha1";
var _xacs_ = "x-amz-checksum-sha256";
var _xacsm = "x-amz-create-session-mode";
var _xae = "x-amz-expiration";
var _xaebo = "x-amz-expected-bucket-owner";
var _xagfc = "x-amz-grant-full-control";
var _xagr = "x-amz-grant-read";
var _xagra = "x-amz-grant-read-acp";
var _xagwa = "x-amz-grant-write-acp";
var _xaollh = "x-amz-object-lock-legal-hold";
var _xaolm = "x-amz-object-lock-mode";
var _xaolrud = "x-amz-object-lock-retain-until-date";
var _xarc = "x-amz-request-charged";
var _xarp = "x-amz-request-payer";
var _xasc = "x-amz-storage-class";
var _xasca = "x-amz-sdk-checksum-algorithm";
var _xasse = "x-amz-server-side-encryption";
var _xasseakki = "x-amz-server-side-encryption-aws-kms-key-id";
var _xassebke = "x-amz-server-side-encryption-bucket-key-enabled";
var _xassec = "x-amz-server-side-encryption-context";
var _xasseca = "x-amz-server-side-encryption-customer-algorithm";
var _xasseck = "x-amz-server-side-encryption-customer-key";
var _xasseckm = "x-amz-server-side-encryption-customer-key-md5";
var _xat = "x-amz-tagging";
var _xavi = "x-amz-version-id";
var _xawrl = "x-amz-website-redirect-location";
var _xi = "x-id";

// node_modules/@aws-sdk/client-s3/dist-es/commands/CreateSessionCommand.js
var CreateSessionCommand = class extends Command.classBuilder().ep({
  ...commonParams,
  DisableS3ExpressSessionAuth: { type: "staticContextParams", value: true },
  Bucket: { type: "contextParams", name: "Bucket" }
}).m(function(Command2, cs2, config3, o2) {
  return [
    getSerdePlugin(config3, this.serialize, this.deserialize),
    getEndpointPlugin(config3, Command2.getEndpointParameterInstructions()),
    getThrow200ExceptionsPlugin(config3)
  ];
}).s("AmazonS3", "CreateSession", {}).n("S3Client", "CreateSessionCommand").f(void 0, CreateSessionOutputFilterSensitiveLog).ser(se_CreateSessionCommand).de(de_CreateSessionCommand).build() {
};

// node_modules/@aws-sdk/client-s3/dist-es/runtimeConfig.browser.js
init_process();
init_buffer();

// node_modules/@aws-sdk/client-s3/package.json
var package_default = {
  name: "@aws-sdk/client-s3",
  description: "AWS SDK for JavaScript S3 Client for Node.js, Browser and React Native",
  version: "3.626.0",
  scripts: {
    build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "node ../../scripts/compilation/inline client-s3",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "extract:docs": "api-extractor run --local",
    "generate:client": "node ../../scripts/generate-clients/single-service --solo s3",
    test: "yarn test:unit",
    "test:e2e": "yarn test:e2e:node && yarn test:e2e:browser",
    "test:e2e:browser": "ts-mocha test/**/*.browser.ispec.ts && karma start karma.conf.js",
    "test:e2e:node": "jest --c jest.config.e2e.js",
    "test:unit": "ts-mocha test/unit/**/*.spec.ts"
  },
  main: "./dist-cjs/index.js",
  types: "./dist-types/index.d.ts",
  module: "./dist-es/index.js",
  sideEffects: false,
  dependencies: {
    "@aws-crypto/sha1-browser": "5.2.0",
    "@aws-crypto/sha256-browser": "5.2.0",
    "@aws-crypto/sha256-js": "5.2.0",
    "@aws-sdk/client-sso-oidc": "3.624.0",
    "@aws-sdk/client-sts": "3.624.0",
    "@aws-sdk/core": "3.624.0",
    "@aws-sdk/credential-provider-node": "3.624.0",
    "@aws-sdk/middleware-bucket-endpoint": "3.620.0",
    "@aws-sdk/middleware-expect-continue": "3.620.0",
    "@aws-sdk/middleware-flexible-checksums": "3.620.0",
    "@aws-sdk/middleware-host-header": "3.620.0",
    "@aws-sdk/middleware-location-constraint": "3.609.0",
    "@aws-sdk/middleware-logger": "3.609.0",
    "@aws-sdk/middleware-recursion-detection": "3.620.0",
    "@aws-sdk/middleware-sdk-s3": "3.626.0",
    "@aws-sdk/middleware-ssec": "3.609.0",
    "@aws-sdk/middleware-user-agent": "3.620.0",
    "@aws-sdk/region-config-resolver": "3.614.0",
    "@aws-sdk/signature-v4-multi-region": "3.626.0",
    "@aws-sdk/types": "3.609.0",
    "@aws-sdk/util-endpoints": "3.614.0",
    "@aws-sdk/util-user-agent-browser": "3.609.0",
    "@aws-sdk/util-user-agent-node": "3.614.0",
    "@aws-sdk/xml-builder": "3.609.0",
    "@smithy/config-resolver": "^3.0.5",
    "@smithy/core": "^2.3.2",
    "@smithy/eventstream-serde-browser": "^3.0.5",
    "@smithy/eventstream-serde-config-resolver": "^3.0.3",
    "@smithy/eventstream-serde-node": "^3.0.4",
    "@smithy/fetch-http-handler": "^3.2.4",
    "@smithy/hash-blob-browser": "^3.1.2",
    "@smithy/hash-node": "^3.0.3",
    "@smithy/hash-stream-node": "^3.1.2",
    "@smithy/invalid-dependency": "^3.0.3",
    "@smithy/md5-js": "^3.0.3",
    "@smithy/middleware-content-length": "^3.0.5",
    "@smithy/middleware-endpoint": "^3.1.0",
    "@smithy/middleware-retry": "^3.0.14",
    "@smithy/middleware-serde": "^3.0.3",
    "@smithy/middleware-stack": "^3.0.3",
    "@smithy/node-config-provider": "^3.1.4",
    "@smithy/node-http-handler": "^3.1.4",
    "@smithy/protocol-http": "^4.1.0",
    "@smithy/smithy-client": "^3.1.12",
    "@smithy/types": "^3.3.0",
    "@smithy/url-parser": "^3.0.3",
    "@smithy/util-base64": "^3.0.0",
    "@smithy/util-body-length-browser": "^3.0.0",
    "@smithy/util-body-length-node": "^3.0.0",
    "@smithy/util-defaults-mode-browser": "^3.0.14",
    "@smithy/util-defaults-mode-node": "^3.0.14",
    "@smithy/util-endpoints": "^2.0.5",
    "@smithy/util-middleware": "^3.0.3",
    "@smithy/util-retry": "^3.0.3",
    "@smithy/util-stream": "^3.1.3",
    "@smithy/util-utf8": "^3.0.0",
    "@smithy/util-waiter": "^3.1.2",
    tslib: "^2.6.2"
  },
  devDependencies: {
    "@aws-sdk/signature-v4-crt": "3.626.0",
    "@tsconfig/node16": "16.1.3",
    "@types/chai": "^4.2.11",
    "@types/mocha": "^8.0.4",
    "@types/node": "^16.18.96",
    concurrently: "7.0.0",
    "downlevel-dts": "0.10.1",
    rimraf: "3.0.2",
    typescript: "~4.9.5"
  },
  engines: {
    node: ">=16.0.0"
  },
  typesVersions: {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  files: [
    "dist-*/**"
  ],
  author: {
    name: "AWS SDK for JavaScript Team",
    url: "https://aws.amazon.com/javascript/"
  },
  license: "Apache-2.0",
  browser: {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
  },
  "react-native": {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
  },
  homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-s3",
  repository: {
    type: "git",
    url: "https://github.com/aws/aws-sdk-js-v3.git",
    directory: "clients/client-s3"
  }
};

// node_modules/@aws-crypto/sha1-browser/build/module/index.js
init_process();
init_buffer();

// node_modules/@aws-crypto/sha1-browser/build/module/crossPlatformSha1.js
init_process();
init_buffer();

// node_modules/@aws-crypto/sha1-browser/build/module/webCryptoSha1.js
init_process();
init_buffer();

// node_modules/@aws-crypto/sha1-browser/node_modules/@smithy/util-utf8/dist-es/index.js
init_process();
init_buffer();

// node_modules/@aws-crypto/sha1-browser/node_modules/@smithy/util-utf8/dist-es/fromUtf8.browser.js
init_process();
init_buffer();
var fromUtf82 = (input) => new TextEncoder().encode(input);

// node_modules/@aws-crypto/sha1-browser/node_modules/@smithy/util-utf8/dist-es/toUint8Array.js
init_process();
init_buffer();

// node_modules/@aws-crypto/sha1-browser/node_modules/@smithy/util-utf8/dist-es/toUtf8.browser.js
init_process();
init_buffer();

// node_modules/@aws-crypto/sha1-browser/build/module/isEmptyData.js
init_process();
init_buffer();
function isEmptyData(data) {
  if (typeof data === "string") {
    return data.length === 0;
  }
  return data.byteLength === 0;
}

// node_modules/@aws-crypto/sha1-browser/build/module/constants.js
init_process();
init_buffer();
var SHA_1_HASH = { name: "SHA-1" };
var SHA_1_HMAC_ALGO = {
  name: "HMAC",
  hash: SHA_1_HASH
};
var EMPTY_DATA_SHA_1 = new Uint8Array([
  218,
  57,
  163,
  238,
  94,
  107,
  75,
  13,
  50,
  85,
  191,
  239,
  149,
  96,
  24,
  144,
  175,
  216,
  7,
  9
]);

// node_modules/@aws-sdk/util-locate-window/dist-es/index.js
init_process();
init_buffer();
var fallbackWindow = {};
function locateWindow() {
  if (typeof window !== "undefined") {
    return window;
  } else if (typeof self !== "undefined") {
    return self;
  }
  return fallbackWindow;
}

// node_modules/@aws-crypto/sha1-browser/build/module/webCryptoSha1.js
var Sha1 = (
  /** @class */
  function() {
    function Sha13(secret) {
      this.toHash = new Uint8Array(0);
      if (secret !== void 0) {
        this.key = new Promise(function(resolve2, reject) {
          locateWindow().crypto.subtle.importKey("raw", convertToBuffer(secret), SHA_1_HMAC_ALGO, false, ["sign"]).then(resolve2, reject);
        });
        this.key.catch(function() {
        });
      }
    }
    Sha13.prototype.update = function(data) {
      if (isEmptyData(data)) {
        return;
      }
      var update = convertToBuffer(data);
      var typedArray = new Uint8Array(this.toHash.byteLength + update.byteLength);
      typedArray.set(this.toHash, 0);
      typedArray.set(update, this.toHash.byteLength);
      this.toHash = typedArray;
    };
    Sha13.prototype.digest = function() {
      var _this = this;
      if (this.key) {
        return this.key.then(function(key2) {
          return locateWindow().crypto.subtle.sign(SHA_1_HMAC_ALGO, key2, _this.toHash).then(function(data) {
            return new Uint8Array(data);
          });
        });
      }
      if (isEmptyData(this.toHash)) {
        return Promise.resolve(EMPTY_DATA_SHA_1);
      }
      return Promise.resolve().then(function() {
        return locateWindow().crypto.subtle.digest(SHA_1_HASH, _this.toHash);
      }).then(function(data) {
        return Promise.resolve(new Uint8Array(data));
      });
    };
    Sha13.prototype.reset = function() {
      this.toHash = new Uint8Array(0);
    };
    return Sha13;
  }()
);
function convertToBuffer(data) {
  if (typeof data === "string") {
    return fromUtf82(data);
  }
  if (ArrayBuffer.isView(data)) {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
  }
  return new Uint8Array(data);
}

// node_modules/@aws-crypto/supports-web-crypto/build/module/index.js
init_process();
init_buffer();

// node_modules/@aws-crypto/supports-web-crypto/build/module/supportsWebCrypto.js
init_process();
init_buffer();

// node_modules/tslib/tslib.es6.mjs
init_process();
init_buffer();
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body3) {
  var _ = { label: 0, sent: function() {
    if (t3[0] & 1)
      throw t3[1];
    return t3[1];
  }, trys: [], ops: [] }, f2, y2, t3, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_ = 0)), _)
      try {
        if (f2 = 1, y2 && (t3 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t3 = y2["return"]) && t3.call(y2), 0) : y2.next) && !(t3 = t3.call(y2, op[1])).done)
          return t3;
        if (y2 = 0, t3)
          op = [op[0] & 2, t3.value];
        switch (op[0]) {
          case 0:
          case 1:
            t3 = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t3 = _.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t3[1]) {
              _.label = t3[1];
              t3 = op;
              break;
            }
            if (t3 && _.label < t3[2]) {
              _.label = t3[2];
              _.ops.push(op);
              break;
            }
            if (t3[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body3.call(thisArg, _);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t3 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
  if (m2)
    return m2.call(o2);
  if (o2 && typeof o2.length === "number")
    return {
      next: function() {
        if (o2 && i2 >= o2.length)
          o2 = void 0;
        return { value: o2 && o2[i2++], done: !o2 };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

// node_modules/@aws-crypto/supports-web-crypto/build/module/supportsWebCrypto.js
var subtleCryptoMethods = [
  "decrypt",
  "digest",
  "encrypt",
  "exportKey",
  "generateKey",
  "importKey",
  "sign",
  "verify"
];
function supportsWebCrypto(window2) {
  if (supportsSecureRandom(window2) && typeof window2.crypto.subtle === "object") {
    var subtle = window2.crypto.subtle;
    return supportsSubtleCrypto(subtle);
  }
  return false;
}
function supportsSecureRandom(window2) {
  if (typeof window2 === "object" && typeof window2.crypto === "object") {
    var getRandomValues2 = window2.crypto.getRandomValues;
    return typeof getRandomValues2 === "function";
  }
  return false;
}
function supportsSubtleCrypto(subtle) {
  return subtle && subtleCryptoMethods.every(function(methodName) {
    return typeof subtle[methodName] === "function";
  });
}

// node_modules/@aws-crypto/util/build/module/index.js
init_process();
init_buffer();

// node_modules/@aws-crypto/util/build/module/convertToBuffer.js
init_process();
init_buffer();

// node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/dist-es/index.js
init_process();
init_buffer();

// node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/dist-es/fromUtf8.browser.js
init_process();
init_buffer();
var fromUtf83 = (input) => new TextEncoder().encode(input);

// node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/dist-es/toUint8Array.js
init_process();
init_buffer();

// node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/dist-es/toUtf8.browser.js
init_process();
init_buffer();

// node_modules/@aws-crypto/util/build/module/convertToBuffer.js
var fromUtf84 = typeof Buffer2 !== "undefined" && Buffer2.from ? function(input) {
  return Buffer2.from(input, "utf8");
} : fromUtf83;
function convertToBuffer2(data) {
  if (data instanceof Uint8Array)
    return data;
  if (typeof data === "string") {
    return fromUtf84(data);
  }
  if (ArrayBuffer.isView(data)) {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
  }
  return new Uint8Array(data);
}

// node_modules/@aws-crypto/util/build/module/isEmptyData.js
init_process();
init_buffer();
function isEmptyData2(data) {
  if (typeof data === "string") {
    return data.length === 0;
  }
  return data.byteLength === 0;
}

// node_modules/@aws-crypto/util/build/module/numToUint8.js
init_process();
init_buffer();
function numToUint8(num) {
  return new Uint8Array([
    (num & 4278190080) >> 24,
    (num & 16711680) >> 16,
    (num & 65280) >> 8,
    num & 255
  ]);
}

// node_modules/@aws-crypto/util/build/module/uint32ArrayFrom.js
init_process();
init_buffer();
function uint32ArrayFrom(a_lookUpTable2) {
  if (!Uint32Array.from) {
    var return_array = new Uint32Array(a_lookUpTable2.length);
    var a_index = 0;
    while (a_index < a_lookUpTable2.length) {
      return_array[a_index] = a_lookUpTable2[a_index];
      a_index += 1;
    }
    return return_array;
  }
  return Uint32Array.from(a_lookUpTable2);
}

// node_modules/@aws-crypto/sha1-browser/build/module/crossPlatformSha1.js
var Sha12 = (
  /** @class */
  function() {
    function Sha13(secret) {
      if (supportsWebCrypto(locateWindow())) {
        this.hash = new Sha1(secret);
      } else {
        throw new Error("SHA1 not supported");
      }
    }
    Sha13.prototype.update = function(data, encoding) {
      this.hash.update(convertToBuffer2(data));
    };
    Sha13.prototype.digest = function() {
      return this.hash.digest();
    };
    Sha13.prototype.reset = function() {
      this.hash.reset();
    };
    return Sha13;
  }()
);

// node_modules/@aws-crypto/sha256-browser/build/module/index.js
init_process();
init_buffer();

// node_modules/@aws-crypto/sha256-browser/build/module/crossPlatformSha256.js
init_process();
init_buffer();

// node_modules/@aws-crypto/sha256-browser/build/module/webCryptoSha256.js
init_process();
init_buffer();

// node_modules/@aws-crypto/sha256-browser/build/module/constants.js
init_process();
init_buffer();
var SHA_256_HASH = { name: "SHA-256" };
var SHA_256_HMAC_ALGO = {
  name: "HMAC",
  hash: SHA_256_HASH
};
var EMPTY_DATA_SHA_256 = new Uint8Array([
  227,
  176,
  196,
  66,
  152,
  252,
  28,
  20,
  154,
  251,
  244,
  200,
  153,
  111,
  185,
  36,
  39,
  174,
  65,
  228,
  100,
  155,
  147,
  76,
  164,
  149,
  153,
  27,
  120,
  82,
  184,
  85
]);

// node_modules/@aws-crypto/sha256-browser/build/module/webCryptoSha256.js
var Sha256 = (
  /** @class */
  function() {
    function Sha2564(secret) {
      this.toHash = new Uint8Array(0);
      this.secret = secret;
      this.reset();
    }
    Sha2564.prototype.update = function(data) {
      if (isEmptyData2(data)) {
        return;
      }
      var update = convertToBuffer2(data);
      var typedArray = new Uint8Array(this.toHash.byteLength + update.byteLength);
      typedArray.set(this.toHash, 0);
      typedArray.set(update, this.toHash.byteLength);
      this.toHash = typedArray;
    };
    Sha2564.prototype.digest = function() {
      var _this = this;
      if (this.key) {
        return this.key.then(function(key2) {
          return locateWindow().crypto.subtle.sign(SHA_256_HMAC_ALGO, key2, _this.toHash).then(function(data) {
            return new Uint8Array(data);
          });
        });
      }
      if (isEmptyData2(this.toHash)) {
        return Promise.resolve(EMPTY_DATA_SHA_256);
      }
      return Promise.resolve().then(function() {
        return locateWindow().crypto.subtle.digest(SHA_256_HASH, _this.toHash);
      }).then(function(data) {
        return Promise.resolve(new Uint8Array(data));
      });
    };
    Sha2564.prototype.reset = function() {
      var _this = this;
      this.toHash = new Uint8Array(0);
      if (this.secret && this.secret !== void 0) {
        this.key = new Promise(function(resolve2, reject) {
          locateWindow().crypto.subtle.importKey("raw", convertToBuffer2(_this.secret), SHA_256_HMAC_ALGO, false, ["sign"]).then(resolve2, reject);
        });
        this.key.catch(function() {
        });
      }
    };
    return Sha2564;
  }()
);

// node_modules/@aws-crypto/sha256-js/build/module/index.js
init_process();
init_buffer();

// node_modules/@aws-crypto/sha256-js/build/module/jsSha256.js
init_process();
init_buffer();

// node_modules/@aws-crypto/sha256-js/build/module/constants.js
init_process();
init_buffer();
var BLOCK_SIZE = 64;
var DIGEST_LENGTH = 32;
var KEY = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var INIT = [
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
];
var MAX_HASHABLE_LENGTH = Math.pow(2, 53) - 1;

// node_modules/@aws-crypto/sha256-js/build/module/RawSha256.js
init_process();
init_buffer();
var RawSha256 = (
  /** @class */
  function() {
    function RawSha2562() {
      this.state = Int32Array.from(INIT);
      this.temp = new Int32Array(64);
      this.buffer = new Uint8Array(64);
      this.bufferLength = 0;
      this.bytesHashed = 0;
      this.finished = false;
    }
    RawSha2562.prototype.update = function(data) {
      if (this.finished) {
        throw new Error("Attempted to update an already finished hash.");
      }
      var position4 = 0;
      var byteLength3 = data.byteLength;
      this.bytesHashed += byteLength3;
      if (this.bytesHashed * 8 > MAX_HASHABLE_LENGTH) {
        throw new Error("Cannot hash more than 2^53 - 1 bits");
      }
      while (byteLength3 > 0) {
        this.buffer[this.bufferLength++] = data[position4++];
        byteLength3--;
        if (this.bufferLength === BLOCK_SIZE) {
          this.hashBuffer();
          this.bufferLength = 0;
        }
      }
    };
    RawSha2562.prototype.digest = function() {
      if (!this.finished) {
        var bitsHashed = this.bytesHashed * 8;
        var bufferView = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);
        var undecoratedLength = this.bufferLength;
        bufferView.setUint8(this.bufferLength++, 128);
        if (undecoratedLength % BLOCK_SIZE >= BLOCK_SIZE - 8) {
          for (var i2 = this.bufferLength; i2 < BLOCK_SIZE; i2++) {
            bufferView.setUint8(i2, 0);
          }
          this.hashBuffer();
          this.bufferLength = 0;
        }
        for (var i2 = this.bufferLength; i2 < BLOCK_SIZE - 8; i2++) {
          bufferView.setUint8(i2, 0);
        }
        bufferView.setUint32(BLOCK_SIZE - 8, Math.floor(bitsHashed / 4294967296), true);
        bufferView.setUint32(BLOCK_SIZE - 4, bitsHashed);
        this.hashBuffer();
        this.finished = true;
      }
      var out = new Uint8Array(DIGEST_LENGTH);
      for (var i2 = 0; i2 < 8; i2++) {
        out[i2 * 4] = this.state[i2] >>> 24 & 255;
        out[i2 * 4 + 1] = this.state[i2] >>> 16 & 255;
        out[i2 * 4 + 2] = this.state[i2] >>> 8 & 255;
        out[i2 * 4 + 3] = this.state[i2] >>> 0 & 255;
      }
      return out;
    };
    RawSha2562.prototype.hashBuffer = function() {
      var _a89 = this, buffer = _a89.buffer, state = _a89.state;
      var state0 = state[0], state1 = state[1], state2 = state[2], state3 = state[3], state4 = state[4], state5 = state[5], state6 = state[6], state7 = state[7];
      for (var i2 = 0; i2 < BLOCK_SIZE; i2++) {
        if (i2 < 16) {
          this.temp[i2] = (buffer[i2 * 4] & 255) << 24 | (buffer[i2 * 4 + 1] & 255) << 16 | (buffer[i2 * 4 + 2] & 255) << 8 | buffer[i2 * 4 + 3] & 255;
        } else {
          var u2 = this.temp[i2 - 2];
          var t1_1 = (u2 >>> 17 | u2 << 15) ^ (u2 >>> 19 | u2 << 13) ^ u2 >>> 10;
          u2 = this.temp[i2 - 15];
          var t2_1 = (u2 >>> 7 | u2 << 25) ^ (u2 >>> 18 | u2 << 14) ^ u2 >>> 3;
          this.temp[i2] = (t1_1 + this.temp[i2 - 7] | 0) + (t2_1 + this.temp[i2 - 16] | 0);
        }
        var t1 = (((state4 >>> 6 | state4 << 26) ^ (state4 >>> 11 | state4 << 21) ^ (state4 >>> 25 | state4 << 7)) + (state4 & state5 ^ ~state4 & state6) | 0) + (state7 + (KEY[i2] + this.temp[i2] | 0) | 0) | 0;
        var t22 = ((state0 >>> 2 | state0 << 30) ^ (state0 >>> 13 | state0 << 19) ^ (state0 >>> 22 | state0 << 10)) + (state0 & state1 ^ state0 & state2 ^ state1 & state2) | 0;
        state7 = state6;
        state6 = state5;
        state5 = state4;
        state4 = state3 + t1 | 0;
        state3 = state2;
        state2 = state1;
        state1 = state0;
        state0 = t1 + t22 | 0;
      }
      state[0] += state0;
      state[1] += state1;
      state[2] += state2;
      state[3] += state3;
      state[4] += state4;
      state[5] += state5;
      state[6] += state6;
      state[7] += state7;
    };
    return RawSha2562;
  }()
);

// node_modules/@aws-crypto/sha256-js/build/module/jsSha256.js
var Sha2562 = (
  /** @class */
  function() {
    function Sha2564(secret) {
      this.secret = secret;
      this.hash = new RawSha256();
      this.reset();
    }
    Sha2564.prototype.update = function(toHash) {
      if (isEmptyData2(toHash) || this.error) {
        return;
      }
      try {
        this.hash.update(convertToBuffer2(toHash));
      } catch (e2) {
        this.error = e2;
      }
    };
    Sha2564.prototype.digestSync = function() {
      if (this.error) {
        throw this.error;
      }
      if (this.outer) {
        if (!this.outer.finished) {
          this.outer.update(this.hash.digest());
        }
        return this.outer.digest();
      }
      return this.hash.digest();
    };
    Sha2564.prototype.digest = function() {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a89) {
          return [2, this.digestSync()];
        });
      });
    };
    Sha2564.prototype.reset = function() {
      this.hash = new RawSha256();
      if (this.secret) {
        this.outer = new RawSha256();
        var inner = bufferFromSecret(this.secret);
        var outer = new Uint8Array(BLOCK_SIZE);
        outer.set(inner);
        for (var i2 = 0; i2 < BLOCK_SIZE; i2++) {
          inner[i2] ^= 54;
          outer[i2] ^= 92;
        }
        this.hash.update(inner);
        this.outer.update(outer);
        for (var i2 = 0; i2 < inner.byteLength; i2++) {
          inner[i2] = 0;
        }
      }
    };
    return Sha2564;
  }()
);
function bufferFromSecret(secret) {
  var input = convertToBuffer2(secret);
  if (input.byteLength > BLOCK_SIZE) {
    var bufferHash = new RawSha256();
    bufferHash.update(input);
    input = bufferHash.digest();
  }
  var buffer = new Uint8Array(BLOCK_SIZE);
  buffer.set(input);
  return buffer;
}

// node_modules/@aws-crypto/sha256-browser/build/module/crossPlatformSha256.js
var Sha2563 = (
  /** @class */
  function() {
    function Sha2564(secret) {
      if (supportsWebCrypto(locateWindow())) {
        this.hash = new Sha256(secret);
      } else {
        this.hash = new Sha2562(secret);
      }
    }
    Sha2564.prototype.update = function(data, encoding) {
      this.hash.update(convertToBuffer2(data));
    };
    Sha2564.prototype.digest = function() {
      return this.hash.digest();
    };
    Sha2564.prototype.reset = function() {
      this.hash.reset();
    };
    return Sha2564;
  }()
);

// node_modules/@aws-sdk/util-user-agent-browser/dist-es/index.js
init_process();
init_buffer();
var import_bowser = __toESM(require_es5());
var defaultUserAgent = ({ serviceId, clientVersion }) => async () => {
  const parsedUA = typeof window !== "undefined" && window?.navigator?.userAgent ? import_bowser.default.parse(window.navigator.userAgent) : void 0;
  const sections = [
    ["aws-sdk-js", clientVersion],
    ["ua", "2.0"],
    [`os/${parsedUA?.os?.name || "other"}`, parsedUA?.os?.version],
    ["lang/js"],
    ["md/browser", `${parsedUA?.browser?.name ?? "unknown"}_${parsedUA?.browser?.version ?? "unknown"}`]
  ];
  if (serviceId) {
    sections.push([`api/${serviceId}`, clientVersion]);
  }
  return sections;
};

// node_modules/@smithy/eventstream-serde-browser/dist-es/index.js
init_process();
init_buffer();

// node_modules/@smithy/eventstream-serde-browser/dist-es/EventStreamMarshaller.js
init_process();
init_buffer();

// node_modules/@smithy/eventstream-serde-universal/dist-es/index.js
init_process();
init_buffer();

// node_modules/@smithy/eventstream-serde-universal/dist-es/EventStreamMarshaller.js
init_process();
init_buffer();

// node_modules/@smithy/eventstream-codec/dist-es/index.js
init_process();
init_buffer();

// node_modules/@smithy/eventstream-codec/dist-es/EventStreamCodec.js
init_process();
init_buffer();

// node_modules/@aws-crypto/crc32/build/module/index.js
init_process();
init_buffer();

// node_modules/@aws-crypto/crc32/build/module/aws_crc32.js
init_process();
init_buffer();
var AwsCrc32 = (
  /** @class */
  function() {
    function AwsCrc322() {
      this.crc32 = new Crc32();
    }
    AwsCrc322.prototype.update = function(toHash) {
      if (isEmptyData2(toHash))
        return;
      this.crc32.update(convertToBuffer2(toHash));
    };
    AwsCrc322.prototype.digest = function() {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a89) {
          return [2, numToUint8(this.crc32.digest())];
        });
      });
    };
    AwsCrc322.prototype.reset = function() {
      this.crc32 = new Crc32();
    };
    return AwsCrc322;
  }()
);

// node_modules/@aws-crypto/crc32/build/module/index.js
var Crc32 = (
  /** @class */
  function() {
    function Crc322() {
      this.checksum = 4294967295;
    }
    Crc322.prototype.update = function(data) {
      var e_1, _a89;
      try {
        for (var data_1 = __values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
          var byte2 = data_1_1.value;
          this.checksum = this.checksum >>> 8 ^ lookupTable[(this.checksum ^ byte2) & 255];
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (data_1_1 && !data_1_1.done && (_a89 = data_1.return))
            _a89.call(data_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return this;
    };
    Crc322.prototype.digest = function() {
      return (this.checksum ^ 4294967295) >>> 0;
    };
    return Crc322;
  }()
);
var a_lookUpTable = [
  0,
  1996959894,
  3993919788,
  2567524794,
  124634137,
  1886057615,
  3915621685,
  2657392035,
  249268274,
  2044508324,
  3772115230,
  2547177864,
  162941995,
  2125561021,
  3887607047,
  2428444049,
  498536548,
  1789927666,
  4089016648,
  2227061214,
  450548861,
  1843258603,
  4107580753,
  2211677639,
  325883990,
  1684777152,
  4251122042,
  2321926636,
  335633487,
  1661365465,
  4195302755,
  2366115317,
  997073096,
  1281953886,
  3579855332,
  2724688242,
  1006888145,
  1258607687,
  3524101629,
  2768942443,
  901097722,
  1119000684,
  3686517206,
  2898065728,
  853044451,
  1172266101,
  3705015759,
  2882616665,
  651767980,
  1373503546,
  3369554304,
  3218104598,
  565507253,
  1454621731,
  3485111705,
  3099436303,
  671266974,
  1594198024,
  3322730930,
  2970347812,
  795835527,
  1483230225,
  3244367275,
  3060149565,
  1994146192,
  31158534,
  2563907772,
  4023717930,
  1907459465,
  112637215,
  2680153253,
  3904427059,
  2013776290,
  251722036,
  2517215374,
  3775830040,
  2137656763,
  141376813,
  2439277719,
  3865271297,
  1802195444,
  476864866,
  2238001368,
  4066508878,
  1812370925,
  453092731,
  2181625025,
  4111451223,
  1706088902,
  314042704,
  2344532202,
  4240017532,
  1658658271,
  366619977,
  2362670323,
  4224994405,
  1303535960,
  984961486,
  2747007092,
  3569037538,
  1256170817,
  1037604311,
  2765210733,
  3554079995,
  1131014506,
  879679996,
  2909243462,
  3663771856,
  1141124467,
  855842277,
  2852801631,
  3708648649,
  1342533948,
  654459306,
  3188396048,
  3373015174,
  1466479909,
  544179635,
  3110523913,
  3462522015,
  1591671054,
  702138776,
  2966460450,
  3352799412,
  1504918807,
  783551873,
  3082640443,
  3233442989,
  3988292384,
  2596254646,
  62317068,
  1957810842,
  3939845945,
  2647816111,
  81470997,
  1943803523,
  3814918930,
  2489596804,
  225274430,
  2053790376,
  3826175755,
  2466906013,
  167816743,
  2097651377,
  4027552580,
  2265490386,
  503444072,
  1762050814,
  4150417245,
  2154129355,
  426522225,
  1852507879,
  4275313526,
  2312317920,
  282753626,
  1742555852,
  4189708143,
  2394877945,
  397917763,
  1622183637,
  3604390888,
  2714866558,
  953729732,
  1340076626,
  3518719985,
  2797360999,
  1068828381,
  1219638859,
  3624741850,
  2936675148,
  906185462,
  1090812512,
  3747672003,
  2825379669,
  829329135,
  1181335161,
  3412177804,
  3160834842,
  628085408,
  1382605366,
  3423369109,
  3138078467,
  570562233,
  1426400815,
  3317316542,
  2998733608,
  733239954,
  1555261956,
  3268935591,
  3050360625,
  752459403,
  1541320221,
  2607071920,
  3965973030,
  1969922972,
  40735498,
  2617837225,
  3943577151,
  1913087877,
  83908371,
  2512341634,
  3803740692,
  2075208622,
  213261112,
  2463272603,
  3855990285,
  2094854071,
  198958881,
  2262029012,
  4057260610,
  1759359992,
  534414190,
  2176718541,
  4139329115,
  1873836001,
  414664567,
  2282248934,
  4279200368,
  1711684554,
  285281116,
  2405801727,
  4167216745,
  1634467795,
  376229701,
  2685067896,
  3608007406,
  1308918612,
  956543938,
  2808555105,
  3495958263,
  1231636301,
  1047427035,
  2932959818,
  3654703836,
  1088359270,
  936918e3,
  2847714899,
  3736837829,
  1202900863,
  817233897,
  3183342108,
  3401237130,
  1404277552,
  615818150,
  3134207493,
  3453421203,
  1423857449,
  601450431,
  3009837614,
  3294710456,
  1567103746,
  711928724,
  3020668471,
  3272380065,
  1510334235,
  755167117
];
var lookupTable = uint32ArrayFrom(a_lookUpTable);

// node_modules/@smithy/eventstream-codec/dist-es/HeaderMarshaller.js
init_process();
init_buffer();

// node_modules/@smithy/eventstream-codec/dist-es/Int64.js
init_process();
init_buffer();
var Int642 = class {
  constructor(bytes) {
    this.bytes = bytes;
    if (bytes.byteLength !== 8) {
      throw new Error("Int64 buffers must be exactly 8 bytes");
    }
  }
  static fromNumber(number2) {
    if (number2 > 9223372036854776e3 || number2 < -9223372036854776e3) {
      throw new Error(`${number2} is too large (or, if negative, too small) to represent as an Int64`);
    }
    const bytes = new Uint8Array(8);
    for (let i2 = 7, remaining = Math.abs(Math.round(number2)); i2 > -1 && remaining > 0; i2--, remaining /= 256) {
      bytes[i2] = remaining;
    }
    if (number2 < 0) {
      negate2(bytes);
    }
    return new Int642(bytes);
  }
  valueOf() {
    const bytes = this.bytes.slice(0);
    const negative = bytes[0] & 128;
    if (negative) {
      negate2(bytes);
    }
    return parseInt(toHex2(bytes), 16) * (negative ? -1 : 1);
  }
  toString() {
    return String(this.valueOf());
  }
};
function negate2(bytes) {
  for (let i2 = 0; i2 < 8; i2++) {
    bytes[i2] ^= 255;
  }
  for (let i2 = 7; i2 > -1; i2--) {
    bytes[i2]++;
    if (bytes[i2] !== 0)
      break;
  }
}

// node_modules/@smithy/eventstream-codec/dist-es/HeaderMarshaller.js
var HeaderMarshaller = class {
  constructor(toUtf82, fromUtf85) {
    this.toUtf8 = toUtf82;
    this.fromUtf8 = fromUtf85;
  }
  format(headers) {
    const chunks = [];
    for (const headerName of Object.keys(headers)) {
      const bytes = this.fromUtf8(headerName);
      chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));
    }
    const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));
    let position4 = 0;
    for (const chunk of chunks) {
      out.set(chunk, position4);
      position4 += chunk.byteLength;
    }
    return out;
  }
  formatHeaderValue(header) {
    switch (header.type) {
      case "boolean":
        return Uint8Array.from([header.value ? 0 : 1]);
      case "byte":
        return Uint8Array.from([2, header.value]);
      case "short":
        const shortView = new DataView(new ArrayBuffer(3));
        shortView.setUint8(0, 3);
        shortView.setInt16(1, header.value, false);
        return new Uint8Array(shortView.buffer);
      case "integer":
        const intView = new DataView(new ArrayBuffer(5));
        intView.setUint8(0, 4);
        intView.setInt32(1, header.value, false);
        return new Uint8Array(intView.buffer);
      case "long":
        const longBytes = new Uint8Array(9);
        longBytes[0] = 5;
        longBytes.set(header.value.bytes, 1);
        return longBytes;
      case "binary":
        const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));
        binView.setUint8(0, 6);
        binView.setUint16(1, header.value.byteLength, false);
        const binBytes = new Uint8Array(binView.buffer);
        binBytes.set(header.value, 3);
        return binBytes;
      case "string":
        const utf8Bytes = this.fromUtf8(header.value);
        const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));
        strView.setUint8(0, 7);
        strView.setUint16(1, utf8Bytes.byteLength, false);
        const strBytes = new Uint8Array(strView.buffer);
        strBytes.set(utf8Bytes, 3);
        return strBytes;
      case "timestamp":
        const tsBytes = new Uint8Array(9);
        tsBytes[0] = 8;
        tsBytes.set(Int642.fromNumber(header.value.valueOf()).bytes, 1);
        return tsBytes;
      case "uuid":
        if (!UUID_PATTERN2.test(header.value)) {
          throw new Error(`Invalid UUID received: ${header.value}`);
        }
        const uuidBytes = new Uint8Array(17);
        uuidBytes[0] = 9;
        uuidBytes.set(fromHex(header.value.replace(/\-/g, "")), 1);
        return uuidBytes;
    }
  }
  parse(headers) {
    const out = {};
    let position4 = 0;
    while (position4 < headers.byteLength) {
      const nameLength = headers.getUint8(position4++);
      const name = this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position4, nameLength));
      position4 += nameLength;
      switch (headers.getUint8(position4++)) {
        case 0:
          out[name] = {
            type: BOOLEAN_TAG,
            value: true
          };
          break;
        case 1:
          out[name] = {
            type: BOOLEAN_TAG,
            value: false
          };
          break;
        case 2:
          out[name] = {
            type: BYTE_TAG,
            value: headers.getInt8(position4++)
          };
          break;
        case 3:
          out[name] = {
            type: SHORT_TAG,
            value: headers.getInt16(position4, false)
          };
          position4 += 2;
          break;
        case 4:
          out[name] = {
            type: INT_TAG,
            value: headers.getInt32(position4, false)
          };
          position4 += 4;
          break;
        case 5:
          out[name] = {
            type: LONG_TAG,
            value: new Int642(new Uint8Array(headers.buffer, headers.byteOffset + position4, 8))
          };
          position4 += 8;
          break;
        case 6:
          const binaryLength = headers.getUint16(position4, false);
          position4 += 2;
          out[name] = {
            type: BINARY_TAG,
            value: new Uint8Array(headers.buffer, headers.byteOffset + position4, binaryLength)
          };
          position4 += binaryLength;
          break;
        case 7:
          const stringLength = headers.getUint16(position4, false);
          position4 += 2;
          out[name] = {
            type: STRING_TAG,
            value: this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position4, stringLength))
          };
          position4 += stringLength;
          break;
        case 8:
          out[name] = {
            type: TIMESTAMP_TAG,
            value: new Date(new Int642(new Uint8Array(headers.buffer, headers.byteOffset + position4, 8)).valueOf())
          };
          position4 += 8;
          break;
        case 9:
          const uuidBytes = new Uint8Array(headers.buffer, headers.byteOffset + position4, 16);
          position4 += 16;
          out[name] = {
            type: UUID_TAG,
            value: `${toHex2(uuidBytes.subarray(0, 4))}-${toHex2(uuidBytes.subarray(4, 6))}-${toHex2(uuidBytes.subarray(6, 8))}-${toHex2(uuidBytes.subarray(8, 10))}-${toHex2(uuidBytes.subarray(10))}`
          };
          break;
        default:
          throw new Error(`Unrecognized header type tag`);
      }
    }
    return out;
  }
};
var HEADER_VALUE_TYPE2;
(function(HEADER_VALUE_TYPE3) {
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["boolTrue"] = 0] = "boolTrue";
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["boolFalse"] = 1] = "boolFalse";
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["byte"] = 2] = "byte";
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["short"] = 3] = "short";
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["integer"] = 4] = "integer";
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["long"] = 5] = "long";
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["byteArray"] = 6] = "byteArray";
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["string"] = 7] = "string";
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["timestamp"] = 8] = "timestamp";
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["uuid"] = 9] = "uuid";
})(HEADER_VALUE_TYPE2 || (HEADER_VALUE_TYPE2 = {}));
var BOOLEAN_TAG = "boolean";
var BYTE_TAG = "byte";
var SHORT_TAG = "short";
var INT_TAG = "integer";
var LONG_TAG = "long";
var BINARY_TAG = "binary";
var STRING_TAG = "string";
var TIMESTAMP_TAG = "timestamp";
var UUID_TAG = "uuid";
var UUID_PATTERN2 = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;

// node_modules/@smithy/eventstream-codec/dist-es/splitMessage.js
init_process();
init_buffer();
var PRELUDE_MEMBER_LENGTH = 4;
var PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;
var CHECKSUM_LENGTH = 4;
var MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;
function splitMessage({ byteLength: byteLength3, byteOffset, buffer }) {
  if (byteLength3 < MINIMUM_MESSAGE_LENGTH) {
    throw new Error("Provided message too short to accommodate event stream message overhead");
  }
  const view = new DataView(buffer, byteOffset, byteLength3);
  const messageLength = view.getUint32(0, false);
  if (byteLength3 !== messageLength) {
    throw new Error("Reported message length does not match received message length");
  }
  const headerLength = view.getUint32(PRELUDE_MEMBER_LENGTH, false);
  const expectedPreludeChecksum = view.getUint32(PRELUDE_LENGTH, false);
  const expectedMessageChecksum = view.getUint32(byteLength3 - CHECKSUM_LENGTH, false);
  const checksummer = new Crc32().update(new Uint8Array(buffer, byteOffset, PRELUDE_LENGTH));
  if (expectedPreludeChecksum !== checksummer.digest()) {
    throw new Error(`The prelude checksum specified in the message (${expectedPreludeChecksum}) does not match the calculated CRC32 checksum (${checksummer.digest()})`);
  }
  checksummer.update(new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH, byteLength3 - (PRELUDE_LENGTH + CHECKSUM_LENGTH)));
  if (expectedMessageChecksum !== checksummer.digest()) {
    throw new Error(`The message checksum (${checksummer.digest()}) did not match the expected value of ${expectedMessageChecksum}`);
  }
  return {
    headers: new DataView(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH, headerLength),
    body: new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH + headerLength, messageLength - headerLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH + CHECKSUM_LENGTH))
  };
}

// node_modules/@smithy/eventstream-codec/dist-es/EventStreamCodec.js
var EventStreamCodec = class {
  constructor(toUtf82, fromUtf85) {
    this.headerMarshaller = new HeaderMarshaller(toUtf82, fromUtf85);
    this.messageBuffer = [];
    this.isEndOfStream = false;
  }
  feed(message2) {
    this.messageBuffer.push(this.decode(message2));
  }
  endOfStream() {
    this.isEndOfStream = true;
  }
  getMessage() {
    const message2 = this.messageBuffer.pop();
    const isEndOfStream = this.isEndOfStream;
    return {
      getMessage() {
        return message2;
      },
      isEndOfStream() {
        return isEndOfStream;
      }
    };
  }
  getAvailableMessages() {
    const messages = this.messageBuffer;
    this.messageBuffer = [];
    const isEndOfStream = this.isEndOfStream;
    return {
      getMessages() {
        return messages;
      },
      isEndOfStream() {
        return isEndOfStream;
      }
    };
  }
  encode({ headers: rawHeaders, body: body3 }) {
    const headers = this.headerMarshaller.format(rawHeaders);
    const length = headers.byteLength + body3.byteLength + 16;
    const out = new Uint8Array(length);
    const view = new DataView(out.buffer, out.byteOffset, out.byteLength);
    const checksum2 = new Crc32();
    view.setUint32(0, length, false);
    view.setUint32(4, headers.byteLength, false);
    view.setUint32(8, checksum2.update(out.subarray(0, 8)).digest(), false);
    out.set(headers, 12);
    out.set(body3, headers.byteLength + 12);
    view.setUint32(length - 4, checksum2.update(out.subarray(8, length - 4)).digest(), false);
    return out;
  }
  decode(message2) {
    const { headers, body: body3 } = splitMessage(message2);
    return { headers: this.headerMarshaller.parse(headers), body: body3 };
  }
  formatHeaders(rawHeaders) {
    return this.headerMarshaller.format(rawHeaders);
  }
};

// node_modules/@smithy/eventstream-codec/dist-es/Message.js
init_process();
init_buffer();

// node_modules/@smithy/eventstream-codec/dist-es/MessageDecoderStream.js
init_process();
init_buffer();
var MessageDecoderStream = class {
  constructor(options) {
    this.options = options;
  }
  [Symbol.asyncIterator]() {
    return this.asyncIterator();
  }
  async *asyncIterator() {
    for await (const bytes of this.options.inputStream) {
      const decoded = this.options.decoder.decode(bytes);
      yield decoded;
    }
  }
};

// node_modules/@smithy/eventstream-codec/dist-es/MessageEncoderStream.js
init_process();
init_buffer();
var MessageEncoderStream = class {
  constructor(options) {
    this.options = options;
  }
  [Symbol.asyncIterator]() {
    return this.asyncIterator();
  }
  async *asyncIterator() {
    for await (const msg of this.options.messageStream) {
      const encoded = this.options.encoder.encode(msg);
      yield encoded;
    }
    if (this.options.includeEndFrame) {
      yield new Uint8Array(0);
    }
  }
};

// node_modules/@smithy/eventstream-codec/dist-es/SmithyMessageDecoderStream.js
init_process();
init_buffer();
var SmithyMessageDecoderStream = class {
  constructor(options) {
    this.options = options;
  }
  [Symbol.asyncIterator]() {
    return this.asyncIterator();
  }
  async *asyncIterator() {
    for await (const message2 of this.options.messageStream) {
      const deserialized = await this.options.deserializer(message2);
      if (deserialized === void 0)
        continue;
      yield deserialized;
    }
  }
};

// node_modules/@smithy/eventstream-codec/dist-es/SmithyMessageEncoderStream.js
init_process();
init_buffer();
var SmithyMessageEncoderStream = class {
  constructor(options) {
    this.options = options;
  }
  [Symbol.asyncIterator]() {
    return this.asyncIterator();
  }
  async *asyncIterator() {
    for await (const chunk of this.options.inputStream) {
      const payloadBuf = this.options.serializer(chunk);
      yield payloadBuf;
    }
  }
};

// node_modules/@smithy/eventstream-serde-universal/dist-es/getChunkedStream.js
init_process();
init_buffer();
function getChunkedStream(source) {
  let currentMessageTotalLength = 0;
  let currentMessagePendingLength = 0;
  let currentMessage = null;
  let messageLengthBuffer = null;
  const allocateMessage = (size) => {
    if (typeof size !== "number") {
      throw new Error("Attempted to allocate an event message where size was not a number: " + size);
    }
    currentMessageTotalLength = size;
    currentMessagePendingLength = 4;
    currentMessage = new Uint8Array(size);
    const currentMessageView = new DataView(currentMessage.buffer);
    currentMessageView.setUint32(0, size, false);
  };
  const iterator = async function* () {
    const sourceIterator = source[Symbol.asyncIterator]();
    while (true) {
      const { value, done: done2 } = await sourceIterator.next();
      if (done2) {
        if (!currentMessageTotalLength) {
          return;
        } else if (currentMessageTotalLength === currentMessagePendingLength) {
          yield currentMessage;
        } else {
          throw new Error("Truncated event message received.");
        }
        return;
      }
      const chunkLength = value.length;
      let currentOffset = 0;
      while (currentOffset < chunkLength) {
        if (!currentMessage) {
          const bytesRemaining = chunkLength - currentOffset;
          if (!messageLengthBuffer) {
            messageLengthBuffer = new Uint8Array(4);
          }
          const numBytesForTotal = Math.min(4 - currentMessagePendingLength, bytesRemaining);
          messageLengthBuffer.set(value.slice(currentOffset, currentOffset + numBytesForTotal), currentMessagePendingLength);
          currentMessagePendingLength += numBytesForTotal;
          currentOffset += numBytesForTotal;
          if (currentMessagePendingLength < 4) {
            break;
          }
          allocateMessage(new DataView(messageLengthBuffer.buffer).getUint32(0, false));
          messageLengthBuffer = null;
        }
        const numBytesToWrite = Math.min(currentMessageTotalLength - currentMessagePendingLength, chunkLength - currentOffset);
        currentMessage.set(value.slice(currentOffset, currentOffset + numBytesToWrite), currentMessagePendingLength);
        currentMessagePendingLength += numBytesToWrite;
        currentOffset += numBytesToWrite;
        if (currentMessageTotalLength && currentMessageTotalLength === currentMessagePendingLength) {
          yield currentMessage;
          currentMessage = null;
          currentMessageTotalLength = 0;
          currentMessagePendingLength = 0;
        }
      }
    }
  };
  return {
    [Symbol.asyncIterator]: iterator
  };
}

// node_modules/@smithy/eventstream-serde-universal/dist-es/getUnmarshalledStream.js
init_process();
init_buffer();
function getMessageUnmarshaller(deserializer2, toUtf82) {
  return async function(message2) {
    const { value: messageType } = message2.headers[":message-type"];
    if (messageType === "error") {
      const unmodeledError = new Error(message2.headers[":error-message"].value || "UnknownError");
      unmodeledError.name = message2.headers[":error-code"].value;
      throw unmodeledError;
    } else if (messageType === "exception") {
      const code4 = message2.headers[":exception-type"].value;
      const exception = { [code4]: message2 };
      const deserializedException = await deserializer2(exception);
      if (deserializedException.$unknown) {
        const error3 = new Error(toUtf82(message2.body));
        error3.name = code4;
        throw error3;
      }
      throw deserializedException[code4];
    } else if (messageType === "event") {
      const event = {
        [message2.headers[":event-type"].value]: message2
      };
      const deserialized = await deserializer2(event);
      if (deserialized.$unknown)
        return;
      return deserialized;
    } else {
      throw Error(`Unrecognizable event type: ${message2.headers[":event-type"].value}`);
    }
  };
}

// node_modules/@smithy/eventstream-serde-universal/dist-es/EventStreamMarshaller.js
var EventStreamMarshaller = class {
  constructor({ utf8Encoder, utf8Decoder }) {
    this.eventStreamCodec = new EventStreamCodec(utf8Encoder, utf8Decoder);
    this.utfEncoder = utf8Encoder;
  }
  deserialize(body3, deserializer2) {
    const inputStream = getChunkedStream(body3);
    return new SmithyMessageDecoderStream({
      messageStream: new MessageDecoderStream({ inputStream, decoder: this.eventStreamCodec }),
      deserializer: getMessageUnmarshaller(deserializer2, this.utfEncoder)
    });
  }
  serialize(inputStream, serializer2) {
    return new MessageEncoderStream({
      messageStream: new SmithyMessageEncoderStream({ inputStream, serializer: serializer2 }),
      encoder: this.eventStreamCodec,
      includeEndFrame: true
    });
  }
};

// node_modules/@smithy/eventstream-serde-universal/dist-es/provider.js
init_process();
init_buffer();

// node_modules/@smithy/eventstream-serde-browser/dist-es/utils.js
init_process();
init_buffer();
var readableStreamtoIterable = (readableStream) => ({
  [Symbol.asyncIterator]: async function* () {
    const reader = readableStream.getReader();
    try {
      while (true) {
        const { done: done2, value } = await reader.read();
        if (done2)
          return;
        yield value;
      }
    } finally {
      reader.releaseLock();
    }
  }
});
var iterableToReadableStream = (asyncIterable) => {
  const iterator = asyncIterable[Symbol.asyncIterator]();
  return new ReadableStream({
    async pull(controller) {
      const { done: done2, value } = await iterator.next();
      if (done2) {
        return controller.close();
      }
      controller.enqueue(value);
    }
  });
};

// node_modules/@smithy/eventstream-serde-browser/dist-es/EventStreamMarshaller.js
var EventStreamMarshaller2 = class {
  constructor({ utf8Encoder, utf8Decoder }) {
    this.universalMarshaller = new EventStreamMarshaller({
      utf8Decoder,
      utf8Encoder
    });
  }
  deserialize(body3, deserializer2) {
    const bodyIterable = isReadableStream2(body3) ? readableStreamtoIterable(body3) : body3;
    return this.universalMarshaller.deserialize(bodyIterable, deserializer2);
  }
  serialize(input, serializer2) {
    const serialziedIterable = this.universalMarshaller.serialize(input, serializer2);
    return typeof ReadableStream === "function" ? iterableToReadableStream(serialziedIterable) : serialziedIterable;
  }
};
var isReadableStream2 = (body3) => typeof ReadableStream === "function" && body3 instanceof ReadableStream;

// node_modules/@smithy/eventstream-serde-browser/dist-es/provider.js
init_process();
init_buffer();
var eventStreamSerdeProvider = (options) => new EventStreamMarshaller2(options);

// node_modules/@smithy/hash-blob-browser/dist-es/index.js
init_process();
init_buffer();

// node_modules/@smithy/chunked-blob-reader/dist-es/index.js
init_process();
init_buffer();
function blobReader(blob, onChunk, chunkSize = 1024 * 1024) {
  return new Promise((resolve2, reject) => {
    const fileReader = new FileReader();
    fileReader.addEventListener("error", reject);
    fileReader.addEventListener("abort", reject);
    const size = blob.size;
    let totalBytesRead = 0;
    function read2() {
      if (totalBytesRead >= size) {
        resolve2();
        return;
      }
      fileReader.readAsArrayBuffer(blob.slice(totalBytesRead, Math.min(size, totalBytesRead + chunkSize)));
    }
    fileReader.addEventListener("load", (event) => {
      const result = event.target.result;
      onChunk(new Uint8Array(result));
      totalBytesRead += result.byteLength;
      read2();
    });
    read2();
  });
}

// node_modules/@smithy/hash-blob-browser/dist-es/index.js
var blobHasher = async function blobHasher2(hashCtor, blob) {
  const hash = new hashCtor();
  await blobReader(blob, (chunk) => {
    hash.update(chunk);
  });
  return hash.digest();
};

// node_modules/@smithy/invalid-dependency/dist-es/index.js
init_process();
init_buffer();

// node_modules/@smithy/invalid-dependency/dist-es/invalidFunction.js
init_process();
init_buffer();

// node_modules/@smithy/invalid-dependency/dist-es/invalidProvider.js
init_process();
init_buffer();
var invalidProvider = (message2) => () => Promise.reject(message2);

// node_modules/@smithy/md5-js/dist-es/index.js
init_process();
init_buffer();

// node_modules/@smithy/md5-js/dist-es/constants.js
init_process();
init_buffer();
var BLOCK_SIZE2 = 64;
var DIGEST_LENGTH2 = 16;
var INIT2 = [1732584193, 4023233417, 2562383102, 271733878];

// node_modules/@smithy/md5-js/dist-es/index.js
var Md5 = class {
  constructor() {
    this.reset();
  }
  update(sourceData) {
    if (isEmptyData3(sourceData)) {
      return;
    } else if (this.finished) {
      throw new Error("Attempted to update an already finished hash.");
    }
    const data = convertToBuffer3(sourceData);
    let position4 = 0;
    let { byteLength: byteLength3 } = data;
    this.bytesHashed += byteLength3;
    while (byteLength3 > 0) {
      this.buffer.setUint8(this.bufferLength++, data[position4++]);
      byteLength3--;
      if (this.bufferLength === BLOCK_SIZE2) {
        this.hashBuffer();
        this.bufferLength = 0;
      }
    }
  }
  async digest() {
    if (!this.finished) {
      const { buffer, bufferLength: undecoratedLength, bytesHashed } = this;
      const bitsHashed = bytesHashed * 8;
      buffer.setUint8(this.bufferLength++, 128);
      if (undecoratedLength % BLOCK_SIZE2 >= BLOCK_SIZE2 - 8) {
        for (let i2 = this.bufferLength; i2 < BLOCK_SIZE2; i2++) {
          buffer.setUint8(i2, 0);
        }
        this.hashBuffer();
        this.bufferLength = 0;
      }
      for (let i2 = this.bufferLength; i2 < BLOCK_SIZE2 - 8; i2++) {
        buffer.setUint8(i2, 0);
      }
      buffer.setUint32(BLOCK_SIZE2 - 8, bitsHashed >>> 0, true);
      buffer.setUint32(BLOCK_SIZE2 - 4, Math.floor(bitsHashed / 4294967296), true);
      this.hashBuffer();
      this.finished = true;
    }
    const out = new DataView(new ArrayBuffer(DIGEST_LENGTH2));
    for (let i2 = 0; i2 < 4; i2++) {
      out.setUint32(i2 * 4, this.state[i2], true);
    }
    return new Uint8Array(out.buffer, out.byteOffset, out.byteLength);
  }
  hashBuffer() {
    const { buffer, state } = this;
    let a2 = state[0], b2 = state[1], c2 = state[2], d2 = state[3];
    a2 = ff(a2, b2, c2, d2, buffer.getUint32(0, true), 7, 3614090360);
    d2 = ff(d2, a2, b2, c2, buffer.getUint32(4, true), 12, 3905402710);
    c2 = ff(c2, d2, a2, b2, buffer.getUint32(8, true), 17, 606105819);
    b2 = ff(b2, c2, d2, a2, buffer.getUint32(12, true), 22, 3250441966);
    a2 = ff(a2, b2, c2, d2, buffer.getUint32(16, true), 7, 4118548399);
    d2 = ff(d2, a2, b2, c2, buffer.getUint32(20, true), 12, 1200080426);
    c2 = ff(c2, d2, a2, b2, buffer.getUint32(24, true), 17, 2821735955);
    b2 = ff(b2, c2, d2, a2, buffer.getUint32(28, true), 22, 4249261313);
    a2 = ff(a2, b2, c2, d2, buffer.getUint32(32, true), 7, 1770035416);
    d2 = ff(d2, a2, b2, c2, buffer.getUint32(36, true), 12, 2336552879);
    c2 = ff(c2, d2, a2, b2, buffer.getUint32(40, true), 17, 4294925233);
    b2 = ff(b2, c2, d2, a2, buffer.getUint32(44, true), 22, 2304563134);
    a2 = ff(a2, b2, c2, d2, buffer.getUint32(48, true), 7, 1804603682);
    d2 = ff(d2, a2, b2, c2, buffer.getUint32(52, true), 12, 4254626195);
    c2 = ff(c2, d2, a2, b2, buffer.getUint32(56, true), 17, 2792965006);
    b2 = ff(b2, c2, d2, a2, buffer.getUint32(60, true), 22, 1236535329);
    a2 = gg(a2, b2, c2, d2, buffer.getUint32(4, true), 5, 4129170786);
    d2 = gg(d2, a2, b2, c2, buffer.getUint32(24, true), 9, 3225465664);
    c2 = gg(c2, d2, a2, b2, buffer.getUint32(44, true), 14, 643717713);
    b2 = gg(b2, c2, d2, a2, buffer.getUint32(0, true), 20, 3921069994);
    a2 = gg(a2, b2, c2, d2, buffer.getUint32(20, true), 5, 3593408605);
    d2 = gg(d2, a2, b2, c2, buffer.getUint32(40, true), 9, 38016083);
    c2 = gg(c2, d2, a2, b2, buffer.getUint32(60, true), 14, 3634488961);
    b2 = gg(b2, c2, d2, a2, buffer.getUint32(16, true), 20, 3889429448);
    a2 = gg(a2, b2, c2, d2, buffer.getUint32(36, true), 5, 568446438);
    d2 = gg(d2, a2, b2, c2, buffer.getUint32(56, true), 9, 3275163606);
    c2 = gg(c2, d2, a2, b2, buffer.getUint32(12, true), 14, 4107603335);
    b2 = gg(b2, c2, d2, a2, buffer.getUint32(32, true), 20, 1163531501);
    a2 = gg(a2, b2, c2, d2, buffer.getUint32(52, true), 5, 2850285829);
    d2 = gg(d2, a2, b2, c2, buffer.getUint32(8, true), 9, 4243563512);
    c2 = gg(c2, d2, a2, b2, buffer.getUint32(28, true), 14, 1735328473);
    b2 = gg(b2, c2, d2, a2, buffer.getUint32(48, true), 20, 2368359562);
    a2 = hh(a2, b2, c2, d2, buffer.getUint32(20, true), 4, 4294588738);
    d2 = hh(d2, a2, b2, c2, buffer.getUint32(32, true), 11, 2272392833);
    c2 = hh(c2, d2, a2, b2, buffer.getUint32(44, true), 16, 1839030562);
    b2 = hh(b2, c2, d2, a2, buffer.getUint32(56, true), 23, 4259657740);
    a2 = hh(a2, b2, c2, d2, buffer.getUint32(4, true), 4, 2763975236);
    d2 = hh(d2, a2, b2, c2, buffer.getUint32(16, true), 11, 1272893353);
    c2 = hh(c2, d2, a2, b2, buffer.getUint32(28, true), 16, 4139469664);
    b2 = hh(b2, c2, d2, a2, buffer.getUint32(40, true), 23, 3200236656);
    a2 = hh(a2, b2, c2, d2, buffer.getUint32(52, true), 4, 681279174);
    d2 = hh(d2, a2, b2, c2, buffer.getUint32(0, true), 11, 3936430074);
    c2 = hh(c2, d2, a2, b2, buffer.getUint32(12, true), 16, 3572445317);
    b2 = hh(b2, c2, d2, a2, buffer.getUint32(24, true), 23, 76029189);
    a2 = hh(a2, b2, c2, d2, buffer.getUint32(36, true), 4, 3654602809);
    d2 = hh(d2, a2, b2, c2, buffer.getUint32(48, true), 11, 3873151461);
    c2 = hh(c2, d2, a2, b2, buffer.getUint32(60, true), 16, 530742520);
    b2 = hh(b2, c2, d2, a2, buffer.getUint32(8, true), 23, 3299628645);
    a2 = ii(a2, b2, c2, d2, buffer.getUint32(0, true), 6, 4096336452);
    d2 = ii(d2, a2, b2, c2, buffer.getUint32(28, true), 10, 1126891415);
    c2 = ii(c2, d2, a2, b2, buffer.getUint32(56, true), 15, 2878612391);
    b2 = ii(b2, c2, d2, a2, buffer.getUint32(20, true), 21, 4237533241);
    a2 = ii(a2, b2, c2, d2, buffer.getUint32(48, true), 6, 1700485571);
    d2 = ii(d2, a2, b2, c2, buffer.getUint32(12, true), 10, 2399980690);
    c2 = ii(c2, d2, a2, b2, buffer.getUint32(40, true), 15, 4293915773);
    b2 = ii(b2, c2, d2, a2, buffer.getUint32(4, true), 21, 2240044497);
    a2 = ii(a2, b2, c2, d2, buffer.getUint32(32, true), 6, 1873313359);
    d2 = ii(d2, a2, b2, c2, buffer.getUint32(60, true), 10, 4264355552);
    c2 = ii(c2, d2, a2, b2, buffer.getUint32(24, true), 15, 2734768916);
    b2 = ii(b2, c2, d2, a2, buffer.getUint32(52, true), 21, 1309151649);
    a2 = ii(a2, b2, c2, d2, buffer.getUint32(16, true), 6, 4149444226);
    d2 = ii(d2, a2, b2, c2, buffer.getUint32(44, true), 10, 3174756917);
    c2 = ii(c2, d2, a2, b2, buffer.getUint32(8, true), 15, 718787259);
    b2 = ii(b2, c2, d2, a2, buffer.getUint32(36, true), 21, 3951481745);
    state[0] = a2 + state[0] & 4294967295;
    state[1] = b2 + state[1] & 4294967295;
    state[2] = c2 + state[2] & 4294967295;
    state[3] = d2 + state[3] & 4294967295;
  }
  reset() {
    this.state = Uint32Array.from(INIT2);
    this.buffer = new DataView(new ArrayBuffer(BLOCK_SIZE2));
    this.bufferLength = 0;
    this.bytesHashed = 0;
    this.finished = false;
  }
};
function cmn(q2, a2, b2, x2, s2, t3) {
  a2 = (a2 + q2 & 4294967295) + (x2 + t3 & 4294967295) & 4294967295;
  return (a2 << s2 | a2 >>> 32 - s2) + b2 & 4294967295;
}
function ff(a2, b2, c2, d2, x2, s2, t3) {
  return cmn(b2 & c2 | ~b2 & d2, a2, b2, x2, s2, t3);
}
function gg(a2, b2, c2, d2, x2, s2, t3) {
  return cmn(b2 & d2 | c2 & ~d2, a2, b2, x2, s2, t3);
}
function hh(a2, b2, c2, d2, x2, s2, t3) {
  return cmn(b2 ^ c2 ^ d2, a2, b2, x2, s2, t3);
}
function ii(a2, b2, c2, d2, x2, s2, t3) {
  return cmn(c2 ^ (b2 | ~d2), a2, b2, x2, s2, t3);
}
function isEmptyData3(data) {
  if (typeof data === "string") {
    return data.length === 0;
  }
  return data.byteLength === 0;
}
function convertToBuffer3(data) {
  if (typeof data === "string") {
    return fromUtf8(data);
  }
  if (ArrayBuffer.isView(data)) {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
  }
  return new Uint8Array(data);
}

// node_modules/@smithy/util-body-length-browser/dist-es/index.js
init_process();
init_buffer();

// node_modules/@smithy/util-body-length-browser/dist-es/calculateBodyLength.js
init_process();
init_buffer();
var TEXT_ENCODER = typeof TextEncoder == "function" ? new TextEncoder() : null;
var calculateBodyLength = (body3) => {
  if (typeof body3 === "string") {
    if (TEXT_ENCODER) {
      return TEXT_ENCODER.encode(body3).byteLength;
    }
    let len = body3.length;
    for (let i2 = len - 1; i2 >= 0; i2--) {
      const code4 = body3.charCodeAt(i2);
      if (code4 > 127 && code4 <= 2047)
        len++;
      else if (code4 > 2047 && code4 <= 65535)
        len += 2;
      if (code4 >= 56320 && code4 <= 57343)
        i2--;
    }
    return len;
  } else if (typeof body3.byteLength === "number") {
    return body3.byteLength;
  } else if (typeof body3.size === "number") {
    return body3.size;
  }
  throw new Error(`Body Length computation failed for ${body3}`);
};

// node_modules/@aws-sdk/client-s3/dist-es/runtimeConfig.shared.js
init_process();
init_buffer();
var getRuntimeConfig = (config3) => {
  return {
    apiVersion: "2006-03-01",
    base64Decoder: config3?.base64Decoder ?? fromBase64,
    base64Encoder: config3?.base64Encoder ?? toBase64,
    disableHostPrefix: config3?.disableHostPrefix ?? false,
    endpointProvider: config3?.endpointProvider ?? defaultEndpointResolver,
    extensions: config3?.extensions ?? [],
    getAwsChunkedEncodingStream: config3?.getAwsChunkedEncodingStream ?? getAwsChunkedEncodingStream,
    httpAuthSchemeProvider: config3?.httpAuthSchemeProvider ?? defaultS3HttpAuthSchemeProvider,
    httpAuthSchemes: config3?.httpAuthSchemes ?? [
      {
        schemeId: "aws.auth#sigv4",
        identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
        signer: new AwsSdkSigV4Signer()
      },
      {
        schemeId: "aws.auth#sigv4a",
        identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4a"),
        signer: new AwsSdkSigV4ASigner()
      }
    ],
    logger: config3?.logger ?? new NoOpLogger(),
    sdkStreamMixin: config3?.sdkStreamMixin ?? sdkStreamMixin,
    serviceId: config3?.serviceId ?? "S3",
    signerConstructor: config3?.signerConstructor ?? SignatureV4MultiRegion,
    signingEscapePath: config3?.signingEscapePath ?? false,
    urlParser: config3?.urlParser ?? parseUrl,
    useArnRegion: config3?.useArnRegion ?? false,
    utf8Decoder: config3?.utf8Decoder ?? fromUtf8,
    utf8Encoder: config3?.utf8Encoder ?? toUtf8
  };
};

// node_modules/@smithy/util-defaults-mode-browser/dist-es/index.js
init_process();
init_buffer();

// node_modules/@smithy/util-defaults-mode-browser/dist-es/resolveDefaultsModeConfig.js
init_process();
init_buffer();

// node_modules/@smithy/property-provider/dist-es/index.js
init_process();
init_buffer();

// node_modules/@smithy/property-provider/dist-es/CredentialsProviderError.js
init_process();
init_buffer();

// node_modules/@smithy/property-provider/dist-es/ProviderError.js
init_process();
init_buffer();

// node_modules/@smithy/property-provider/dist-es/TokenProviderError.js
init_process();
init_buffer();

// node_modules/@smithy/property-provider/dist-es/chain.js
init_process();
init_buffer();

// node_modules/@smithy/property-provider/dist-es/fromStatic.js
init_process();
init_buffer();

// node_modules/@smithy/property-provider/dist-es/memoize.js
init_process();
init_buffer();
var memoize = (provider, isExpired, requiresRefresh) => {
  let resolved;
  let pending;
  let hasResult;
  let isConstant = false;
  const coalesceProvider = async () => {
    if (!pending) {
      pending = provider();
    }
    try {
      resolved = await pending;
      hasResult = true;
      isConstant = false;
    } finally {
      pending = void 0;
    }
    return resolved;
  };
  if (isExpired === void 0) {
    return async (options) => {
      if (!hasResult || options?.forceRefresh) {
        resolved = await coalesceProvider();
      }
      return resolved;
    };
  }
  return async (options) => {
    if (!hasResult || options?.forceRefresh) {
      resolved = await coalesceProvider();
    }
    if (isConstant) {
      return resolved;
    }
    if (requiresRefresh && !requiresRefresh(resolved)) {
      isConstant = true;
      return resolved;
    }
    if (isExpired(resolved)) {
      await coalesceProvider();
      return resolved;
    }
    return resolved;
  };
};

// node_modules/@smithy/util-defaults-mode-browser/dist-es/resolveDefaultsModeConfig.js
var import_bowser2 = __toESM(require_es5());

// node_modules/@smithy/util-defaults-mode-browser/dist-es/constants.js
init_process();
init_buffer();
var DEFAULTS_MODE_OPTIONS = ["in-region", "cross-region", "mobile", "standard", "legacy"];

// node_modules/@smithy/util-defaults-mode-browser/dist-es/resolveDefaultsModeConfig.js
var resolveDefaultsModeConfig = ({ defaultsMode } = {}) => memoize(async () => {
  const mode = typeof defaultsMode === "function" ? await defaultsMode() : defaultsMode;
  switch (mode?.toLowerCase()) {
    case "auto":
      return Promise.resolve(isMobileBrowser() ? "mobile" : "standard");
    case "mobile":
    case "in-region":
    case "cross-region":
    case "standard":
    case "legacy":
      return Promise.resolve(mode?.toLocaleLowerCase());
    case void 0:
      return Promise.resolve("legacy");
    default:
      throw new Error(`Invalid parameter for "defaultsMode", expect ${DEFAULTS_MODE_OPTIONS.join(", ")}, got ${mode}`);
  }
});
var isMobileBrowser = () => {
  const parsedUA = typeof window !== "undefined" && window?.navigator?.userAgent ? import_bowser2.default.parse(window.navigator.userAgent) : void 0;
  const platform3 = parsedUA?.platform?.type;
  return platform3 === "tablet" || platform3 === "mobile";
};

// node_modules/@aws-sdk/client-s3/dist-es/runtimeConfig.browser.js
var getRuntimeConfig2 = (config3) => {
  const defaultsMode = resolveDefaultsModeConfig(config3);
  const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode);
  const clientSharedValues = getRuntimeConfig(config3);
  return {
    ...clientSharedValues,
    ...config3,
    runtime: "browser",
    defaultsMode,
    bodyLengthChecker: config3?.bodyLengthChecker ?? calculateBodyLength,
    credentialDefaultProvider: config3?.credentialDefaultProvider ?? ((_) => () => Promise.reject(new Error("Credential is missing"))),
    defaultUserAgentProvider: config3?.defaultUserAgentProvider ?? defaultUserAgent({ serviceId: clientSharedValues.serviceId, clientVersion: package_default.version }),
    eventStreamSerdeProvider: config3?.eventStreamSerdeProvider ?? eventStreamSerdeProvider,
    maxAttempts: config3?.maxAttempts ?? DEFAULT_MAX_ATTEMPTS,
    md5: config3?.md5 ?? Md5,
    region: config3?.region ?? invalidProvider("Region is missing"),
    requestHandler: FetchHttpHandler.create(config3?.requestHandler ?? defaultConfigProvider),
    retryMode: config3?.retryMode ?? (async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE),
    sha1: config3?.sha1 ?? Sha12,
    sha256: config3?.sha256 ?? Sha2563,
    streamCollector: config3?.streamCollector ?? streamCollector,
    streamHasher: config3?.streamHasher ?? blobHasher,
    useDualstackEndpoint: config3?.useDualstackEndpoint ?? (() => Promise.resolve(DEFAULT_USE_DUALSTACK_ENDPOINT)),
    useFipsEndpoint: config3?.useFipsEndpoint ?? (() => Promise.resolve(DEFAULT_USE_FIPS_ENDPOINT))
  };
};

// node_modules/@aws-sdk/client-s3/dist-es/runtimeExtensions.js
init_process();
init_buffer();

// node_modules/@aws-sdk/region-config-resolver/dist-es/index.js
init_process();
init_buffer();

// node_modules/@aws-sdk/region-config-resolver/dist-es/extensions/index.js
init_process();
init_buffer();
var getAwsRegionExtensionConfiguration = (runtimeConfig) => {
  let runtimeConfigRegion = async () => {
    if (runtimeConfig.region === void 0) {
      throw new Error("Region is missing from runtimeConfig");
    }
    const region = runtimeConfig.region;
    if (typeof region === "string") {
      return region;
    }
    return region();
  };
  return {
    setRegion(region) {
      runtimeConfigRegion = region;
    },
    region() {
      return runtimeConfigRegion;
    }
  };
};
var resolveAwsRegionExtensionConfiguration = (awsRegionExtensionConfiguration) => {
  return {
    region: awsRegionExtensionConfiguration.region()
  };
};

// node_modules/@aws-sdk/region-config-resolver/dist-es/regionConfig/index.js
init_process();
init_buffer();

// node_modules/@aws-sdk/region-config-resolver/dist-es/regionConfig/config.js
init_process();
init_buffer();

// node_modules/@aws-sdk/region-config-resolver/dist-es/regionConfig/resolveRegionConfig.js
init_process();
init_buffer();

// node_modules/@aws-sdk/region-config-resolver/dist-es/regionConfig/getRealRegion.js
init_process();
init_buffer();

// node_modules/@aws-sdk/region-config-resolver/dist-es/regionConfig/isFipsRegion.js
init_process();
init_buffer();

// node_modules/@aws-sdk/client-s3/dist-es/auth/httpAuthExtensionConfiguration.js
init_process();
init_buffer();
var getHttpAuthExtensionConfiguration = (runtimeConfig) => {
  const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;
  let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;
  let _credentials = runtimeConfig.credentials;
  return {
    setHttpAuthScheme(httpAuthScheme) {
      const index3 = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
      if (index3 === -1) {
        _httpAuthSchemes.push(httpAuthScheme);
      } else {
        _httpAuthSchemes.splice(index3, 1, httpAuthScheme);
      }
    },
    httpAuthSchemes() {
      return _httpAuthSchemes;
    },
    setHttpAuthSchemeProvider(httpAuthSchemeProvider) {
      _httpAuthSchemeProvider = httpAuthSchemeProvider;
    },
    httpAuthSchemeProvider() {
      return _httpAuthSchemeProvider;
    },
    setCredentials(credentials) {
      _credentials = credentials;
    },
    credentials() {
      return _credentials;
    }
  };
};
var resolveHttpAuthRuntimeConfig = (config3) => {
  return {
    httpAuthSchemes: config3.httpAuthSchemes(),
    httpAuthSchemeProvider: config3.httpAuthSchemeProvider(),
    credentials: config3.credentials()
  };
};

// node_modules/@aws-sdk/client-s3/dist-es/runtimeExtensions.js
var asPartial = (t3) => t3;
var resolveRuntimeExtensions = (runtimeConfig, extensions) => {
  const extensionConfiguration = {
    ...asPartial(getAwsRegionExtensionConfiguration(runtimeConfig)),
    ...asPartial(getDefaultExtensionConfiguration(runtimeConfig)),
    ...asPartial(getHttpHandlerExtensionConfiguration(runtimeConfig)),
    ...asPartial(getHttpAuthExtensionConfiguration(runtimeConfig))
  };
  extensions.forEach((extension2) => extension2.configure(extensionConfiguration));
  return {
    ...runtimeConfig,
    ...resolveAwsRegionExtensionConfiguration(extensionConfiguration),
    ...resolveDefaultRuntimeConfig(extensionConfiguration),
    ...resolveHttpHandlerRuntimeConfig(extensionConfiguration),
    ...resolveHttpAuthRuntimeConfig(extensionConfiguration)
  };
};

// node_modules/@aws-sdk/client-s3/dist-es/S3Client.js
var S3Client = class extends Client {
  constructor(...[configuration]) {
    const _config_0 = getRuntimeConfig2(configuration || {});
    const _config_1 = resolveClientEndpointParameters(_config_0);
    const _config_2 = resolveUserAgentConfig(_config_1);
    const _config_3 = resolveRetryConfig(_config_2);
    const _config_4 = resolveRegionConfig(_config_3);
    const _config_5 = resolveHostHeaderConfig(_config_4);
    const _config_6 = resolveEndpointConfig(_config_5);
    const _config_7 = resolveEventStreamSerdeConfig(_config_6);
    const _config_8 = resolveHttpAuthSchemeConfig(_config_7);
    const _config_9 = resolveS3Config(_config_8, { session: [() => this, CreateSessionCommand] });
    const _config_10 = resolveRuntimeExtensions(_config_9, configuration?.extensions || []);
    super(_config_10);
    this.config = _config_10;
    this.middlewareStack.use(getUserAgentPlugin(this.config));
    this.middlewareStack.use(getRetryPlugin(this.config));
    this.middlewareStack.use(getContentLengthPlugin(this.config));
    this.middlewareStack.use(getHostHeaderPlugin(this.config));
    this.middlewareStack.use(getLoggerPlugin(this.config));
    this.middlewareStack.use(getRecursionDetectionPlugin(this.config));
    this.middlewareStack.use(getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {
      httpAuthSchemeParametersProvider: defaultS3HttpAuthSchemeParametersProvider,
      identityProviderConfigProvider: async (config3) => new DefaultIdentityProviderConfig({
        "aws.auth#sigv4": config3.credentials,
        "aws.auth#sigv4a": config3.credentials
      })
    }));
    this.middlewareStack.use(getHttpSigningPlugin(this.config));
    this.middlewareStack.use(getValidateBucketNamePlugin(this.config));
    this.middlewareStack.use(getAddExpectContinuePlugin(this.config));
    this.middlewareStack.use(getRegionRedirectMiddlewarePlugin(this.config));
    this.middlewareStack.use(getS3ExpressPlugin(this.config));
    this.middlewareStack.use(getS3ExpressHttpSigningPlugin(this.config));
  }
  destroy() {
    super.destroy();
  }
};

// node_modules/@aws-sdk/middleware-ssec/dist-es/index.js
init_process();
init_buffer();
function ssecMiddleware(options) {
  return (next) => async (args) => {
    const input = { ...args.input };
    const properties = [
      {
        target: "SSECustomerKey",
        hash: "SSECustomerKeyMD5"
      },
      {
        target: "CopySourceSSECustomerKey",
        hash: "CopySourceSSECustomerKeyMD5"
      }
    ];
    for (const prop of properties) {
      const value = input[prop.target];
      if (value) {
        let valueForHash;
        if (typeof value === "string") {
          if (isValidBase64EncodedSSECustomerKey(value, options)) {
            valueForHash = options.base64Decoder(value);
          } else {
            valueForHash = options.utf8Decoder(value);
            input[prop.target] = options.base64Encoder(valueForHash);
          }
        } else {
          valueForHash = ArrayBuffer.isView(value) ? new Uint8Array(value.buffer, value.byteOffset, value.byteLength) : new Uint8Array(value);
          input[prop.target] = options.base64Encoder(valueForHash);
        }
        const hash = new options.md5();
        hash.update(valueForHash);
        input[prop.hash] = options.base64Encoder(await hash.digest());
      }
    }
    return next({
      ...args,
      input
    });
  };
}
var ssecMiddlewareOptions = {
  name: "ssecMiddleware",
  step: "initialize",
  tags: ["SSE"],
  override: true
};
var getSsecPlugin = (config3) => ({
  applyToStack: (clientStack) => {
    clientStack.add(ssecMiddleware(config3), ssecMiddlewareOptions);
  }
});
function isValidBase64EncodedSSECustomerKey(str, options) {
  const base64Regex = /^(?:[A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
  if (!base64Regex.test(str))
    return false;
  try {
    const decodedBytes = options.base64Decoder(str);
    return decodedBytes.length === 32;
  } catch {
    return false;
  }
}

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/index.js
init_process();
init_buffer();

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/constants.js
init_process();
init_buffer();
var ChecksumAlgorithm;
(function(ChecksumAlgorithm2) {
  ChecksumAlgorithm2["MD5"] = "MD5";
  ChecksumAlgorithm2["CRC32"] = "CRC32";
  ChecksumAlgorithm2["CRC32C"] = "CRC32C";
  ChecksumAlgorithm2["SHA1"] = "SHA1";
  ChecksumAlgorithm2["SHA256"] = "SHA256";
})(ChecksumAlgorithm || (ChecksumAlgorithm = {}));
var ChecksumLocation;
(function(ChecksumLocation2) {
  ChecksumLocation2["HEADER"] = "header";
  ChecksumLocation2["TRAILER"] = "trailer";
})(ChecksumLocation || (ChecksumLocation = {}));
var DEFAULT_CHECKSUM_ALGORITHM = ChecksumAlgorithm.MD5;
var S3_EXPRESS_DEFAULT_CHECKSUM_ALGORITHM = ChecksumAlgorithm.CRC32;

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/flexibleChecksumsMiddleware.js
init_process();
init_buffer();

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getChecksumAlgorithmForRequest.js
init_process();
init_buffer();

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/types.js
init_process();
init_buffer();
var CLIENT_SUPPORTED_ALGORITHMS = [
  ChecksumAlgorithm.CRC32,
  ChecksumAlgorithm.CRC32C,
  ChecksumAlgorithm.SHA1,
  ChecksumAlgorithm.SHA256
];
var PRIORITY_ORDER_ALGORITHMS = [
  ChecksumAlgorithm.CRC32,
  ChecksumAlgorithm.CRC32C,
  ChecksumAlgorithm.SHA1,
  ChecksumAlgorithm.SHA256
];

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getChecksumAlgorithmForRequest.js
var getChecksumAlgorithmForRequest = (input, { requestChecksumRequired, requestAlgorithmMember }, isS3Express) => {
  const defaultAlgorithm = isS3Express ? S3_EXPRESS_DEFAULT_CHECKSUM_ALGORITHM : DEFAULT_CHECKSUM_ALGORITHM;
  if (!requestAlgorithmMember || !input[requestAlgorithmMember]) {
    return requestChecksumRequired ? defaultAlgorithm : void 0;
  }
  const checksumAlgorithm = input[requestAlgorithmMember];
  if (!CLIENT_SUPPORTED_ALGORITHMS.includes(checksumAlgorithm)) {
    throw new Error(`The checksum algorithm "${checksumAlgorithm}" is not supported by the client. Select one of ${CLIENT_SUPPORTED_ALGORITHMS}.`);
  }
  return checksumAlgorithm;
};

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getChecksumLocationName.js
init_process();
init_buffer();
var getChecksumLocationName = (algorithm) => algorithm === ChecksumAlgorithm.MD5 ? "content-md5" : `x-amz-checksum-${algorithm.toLowerCase()}`;

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/hasHeader.js
init_process();
init_buffer();
var hasHeader2 = (header, headers) => {
  const soughtHeader = header.toLowerCase();
  for (const headerName of Object.keys(headers)) {
    if (soughtHeader === headerName.toLowerCase()) {
      return true;
    }
  }
  return false;
};

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/isStreaming.js
init_process();
init_buffer();
var isStreaming = (body3) => body3 !== void 0 && typeof body3 !== "string" && !ArrayBuffer.isView(body3) && !isArrayBuffer(body3);

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/selectChecksumAlgorithmFunction.js
init_process();
init_buffer();

// node_modules/@aws-crypto/crc32c/build/module/index.js
init_process();
init_buffer();

// node_modules/@aws-crypto/crc32c/build/module/aws_crc32c.js
init_process();
init_buffer();
var AwsCrc32c = (
  /** @class */
  function() {
    function AwsCrc32c2() {
      this.crc32c = new Crc32c();
    }
    AwsCrc32c2.prototype.update = function(toHash) {
      if (isEmptyData2(toHash))
        return;
      this.crc32c.update(convertToBuffer2(toHash));
    };
    AwsCrc32c2.prototype.digest = function() {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a89) {
          return [2, numToUint8(this.crc32c.digest())];
        });
      });
    };
    AwsCrc32c2.prototype.reset = function() {
      this.crc32c = new Crc32c();
    };
    return AwsCrc32c2;
  }()
);

// node_modules/@aws-crypto/crc32c/build/module/index.js
var Crc32c = (
  /** @class */
  function() {
    function Crc32c2() {
      this.checksum = 4294967295;
    }
    Crc32c2.prototype.update = function(data) {
      var e_1, _a89;
      try {
        for (var data_1 = __values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
          var byte2 = data_1_1.value;
          this.checksum = this.checksum >>> 8 ^ lookupTable2[(this.checksum ^ byte2) & 255];
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (data_1_1 && !data_1_1.done && (_a89 = data_1.return))
            _a89.call(data_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return this;
    };
    Crc32c2.prototype.digest = function() {
      return (this.checksum ^ 4294967295) >>> 0;
    };
    return Crc32c2;
  }()
);
var a_lookupTable = [
  0,
  4067132163,
  3778769143,
  324072436,
  3348797215,
  904991772,
  648144872,
  3570033899,
  2329499855,
  2024987596,
  1809983544,
  2575936315,
  1296289744,
  3207089363,
  2893594407,
  1578318884,
  274646895,
  3795141740,
  4049975192,
  51262619,
  3619967088,
  632279923,
  922689671,
  3298075524,
  2592579488,
  1760304291,
  2075979607,
  2312596564,
  1562183871,
  2943781820,
  3156637768,
  1313733451,
  549293790,
  3537243613,
  3246849577,
  871202090,
  3878099393,
  357341890,
  102525238,
  4101499445,
  2858735121,
  1477399826,
  1264559846,
  3107202533,
  1845379342,
  2677391885,
  2361733625,
  2125378298,
  820201905,
  3263744690,
  3520608582,
  598981189,
  4151959214,
  85089709,
  373468761,
  3827903834,
  3124367742,
  1213305469,
  1526817161,
  2842354314,
  2107672161,
  2412447074,
  2627466902,
  1861252501,
  1098587580,
  3004210879,
  2688576843,
  1378610760,
  2262928035,
  1955203488,
  1742404180,
  2511436119,
  3416409459,
  969524848,
  714683780,
  3639785095,
  205050476,
  4266873199,
  3976438427,
  526918040,
  1361435347,
  2739821008,
  2954799652,
  1114974503,
  2529119692,
  1691668175,
  2005155131,
  2247081528,
  3690758684,
  697762079,
  986182379,
  3366744552,
  476452099,
  3993867776,
  4250756596,
  255256311,
  1640403810,
  2477592673,
  2164122517,
  1922457750,
  2791048317,
  1412925310,
  1197962378,
  3037525897,
  3944729517,
  427051182,
  170179418,
  4165941337,
  746937522,
  3740196785,
  3451792453,
  1070968646,
  1905808397,
  2213795598,
  2426610938,
  1657317369,
  3053634322,
  1147748369,
  1463399397,
  2773627110,
  4215344322,
  153784257,
  444234805,
  3893493558,
  1021025245,
  3467647198,
  3722505002,
  797665321,
  2197175160,
  1889384571,
  1674398607,
  2443626636,
  1164749927,
  3070701412,
  2757221520,
  1446797203,
  137323447,
  4198817972,
  3910406976,
  461344835,
  3484808360,
  1037989803,
  781091935,
  3705997148,
  2460548119,
  1623424788,
  1939049696,
  2180517859,
  1429367560,
  2807687179,
  3020495871,
  1180866812,
  410100952,
  3927582683,
  4182430767,
  186734380,
  3756733383,
  763408580,
  1053836080,
  3434856499,
  2722870694,
  1344288421,
  1131464017,
  2971354706,
  1708204729,
  2545590714,
  2229949006,
  1988219213,
  680717673,
  3673779818,
  3383336350,
  1002577565,
  4010310262,
  493091189,
  238226049,
  4233660802,
  2987750089,
  1082061258,
  1395524158,
  2705686845,
  1972364758,
  2279892693,
  2494862625,
  1725896226,
  952904198,
  3399985413,
  3656866545,
  731699698,
  4283874585,
  222117402,
  510512622,
  3959836397,
  3280807620,
  837199303,
  582374963,
  3504198960,
  68661723,
  4135334616,
  3844915500,
  390545967,
  1230274059,
  3141532936,
  2825850620,
  1510247935,
  2395924756,
  2091215383,
  1878366691,
  2644384480,
  3553878443,
  565732008,
  854102364,
  3229815391,
  340358836,
  3861050807,
  4117890627,
  119113024,
  1493875044,
  2875275879,
  3090270611,
  1247431312,
  2660249211,
  1828433272,
  2141937292,
  2378227087,
  3811616794,
  291187481,
  34330861,
  4032846830,
  615137029,
  3603020806,
  3314634738,
  939183345,
  1776939221,
  2609017814,
  2295496738,
  2058945313,
  2926798794,
  1545135305,
  1330124605,
  3173225534,
  4084100981,
  17165430,
  307568514,
  3762199681,
  888469610,
  3332340585,
  3587147933,
  665062302,
  2042050490,
  2346497209,
  2559330125,
  1793573966,
  3190661285,
  1279665062,
  1595330642,
  2910671697
];
var lookupTable2 = uint32ArrayFrom(a_lookupTable);

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/selectChecksumAlgorithmFunction.js
var selectChecksumAlgorithmFunction = (checksumAlgorithm, config3) => ({
  [ChecksumAlgorithm.MD5]: config3.md5,
  [ChecksumAlgorithm.CRC32]: AwsCrc32,
  [ChecksumAlgorithm.CRC32C]: AwsCrc32c,
  [ChecksumAlgorithm.SHA1]: config3.sha1,
  [ChecksumAlgorithm.SHA256]: config3.sha256
})[checksumAlgorithm];

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/stringHasher.js
init_process();
init_buffer();
var stringHasher = (checksumAlgorithmFn, body3) => {
  const hash = new checksumAlgorithmFn();
  hash.update(toUint8Array(body3 || ""));
  return hash.digest();
};

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/flexibleChecksumsMiddleware.js
var flexibleChecksumsMiddlewareOptions = {
  name: "flexibleChecksumsMiddleware",
  step: "build",
  tags: ["BODY_CHECKSUM"],
  override: true
};
var flexibleChecksumsMiddleware = (config3, middlewareConfig) => (next, context) => async (args) => {
  if (!HttpRequest.isInstance(args.request)) {
    return next(args);
  }
  const { request } = args;
  const { body: requestBody, headers } = request;
  const { base64Encoder, streamHasher } = config3;
  const { input, requestChecksumRequired, requestAlgorithmMember } = middlewareConfig;
  const checksumAlgorithm = getChecksumAlgorithmForRequest(input, {
    requestChecksumRequired,
    requestAlgorithmMember
  }, !!context.isS3ExpressBucket);
  let updatedBody = requestBody;
  let updatedHeaders = headers;
  if (checksumAlgorithm) {
    const checksumLocationName = getChecksumLocationName(checksumAlgorithm);
    const checksumAlgorithmFn = selectChecksumAlgorithmFunction(checksumAlgorithm, config3);
    if (isStreaming(requestBody)) {
      const { getAwsChunkedEncodingStream: getAwsChunkedEncodingStream2, bodyLengthChecker } = config3;
      updatedBody = getAwsChunkedEncodingStream2(requestBody, {
        base64Encoder,
        bodyLengthChecker,
        checksumLocationName,
        checksumAlgorithmFn,
        streamHasher
      });
      updatedHeaders = {
        ...headers,
        "content-encoding": headers["content-encoding"] ? `${headers["content-encoding"]},aws-chunked` : "aws-chunked",
        "transfer-encoding": "chunked",
        "x-amz-decoded-content-length": headers["content-length"],
        "x-amz-content-sha256": "STREAMING-UNSIGNED-PAYLOAD-TRAILER",
        "x-amz-trailer": checksumLocationName
      };
      delete updatedHeaders["content-length"];
    } else if (!hasHeader2(checksumLocationName, headers)) {
      const rawChecksum = await stringHasher(checksumAlgorithmFn, requestBody);
      updatedHeaders = {
        ...headers,
        [checksumLocationName]: base64Encoder(rawChecksum)
      };
    }
  }
  const result = await next({
    ...args,
    request: {
      ...request,
      headers: updatedHeaders,
      body: updatedBody
    }
  });
  return result;
};

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getFlexibleChecksumsPlugin.js
init_process();
init_buffer();

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/flexibleChecksumsResponseMiddleware.js
init_process();
init_buffer();

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getChecksumAlgorithmListForResponse.js
init_process();
init_buffer();
var getChecksumAlgorithmListForResponse = (responseAlgorithms = []) => {
  const validChecksumAlgorithms = [];
  for (const algorithm of PRIORITY_ORDER_ALGORITHMS) {
    if (!responseAlgorithms.includes(algorithm) || !CLIENT_SUPPORTED_ALGORITHMS.includes(algorithm)) {
      continue;
    }
    validChecksumAlgorithms.push(algorithm);
  }
  return validChecksumAlgorithms;
};

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/isChecksumWithPartNumber.js
init_process();
init_buffer();
var isChecksumWithPartNumber = (checksum2) => {
  const lastHyphenIndex = checksum2.lastIndexOf("-");
  if (lastHyphenIndex !== -1) {
    const numberPart = checksum2.slice(lastHyphenIndex + 1);
    if (!numberPart.startsWith("0")) {
      const number2 = parseInt(numberPart, 10);
      if (!isNaN(number2) && number2 >= 1 && number2 <= 1e4) {
        return true;
      }
    }
  }
  return false;
};

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/streams/create-read-stream-on-buffer.browser.js
init_process();
init_buffer();
function createReadStreamOnBuffer(buffer) {
  return new Blob([buffer]).stream();
}

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/validateChecksumFromResponse.js
init_process();
init_buffer();

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getChecksum.js
init_process();
init_buffer();
var getChecksum = async (body3, { streamHasher, checksumAlgorithmFn, base64Encoder }) => {
  const digest = isStreaming(body3) ? streamHasher(checksumAlgorithmFn, body3) : stringHasher(checksumAlgorithmFn, body3);
  return base64Encoder(await digest);
};

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/validateChecksumFromResponse.js
var validateChecksumFromResponse = async (response, { config: config3, responseAlgorithms }) => {
  const checksumAlgorithms = getChecksumAlgorithmListForResponse(responseAlgorithms);
  const { body: responseBody, headers: responseHeaders } = response;
  for (const algorithm of checksumAlgorithms) {
    const responseHeader = getChecksumLocationName(algorithm);
    const checksumFromResponse = responseHeaders[responseHeader];
    if (checksumFromResponse) {
      const checksumAlgorithmFn = selectChecksumAlgorithmFunction(algorithm, config3);
      const { streamHasher, base64Encoder } = config3;
      const checksum2 = await getChecksum(responseBody, { streamHasher, checksumAlgorithmFn, base64Encoder });
      if (checksum2 === checksumFromResponse) {
        break;
      }
      throw new Error(`Checksum mismatch: expected "${checksum2}" but received "${checksumFromResponse}" in response header "${responseHeader}".`);
    }
  }
};

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/flexibleChecksumsResponseMiddleware.js
var flexibleChecksumsResponseMiddlewareOptions = {
  name: "flexibleChecksumsResponseMiddleware",
  toMiddleware: "deserializerMiddleware",
  relation: "after",
  tags: ["BODY_CHECKSUM"],
  override: true
};
var flexibleChecksumsResponseMiddleware = (config3, middlewareConfig) => (next, context) => async (args) => {
  if (!HttpRequest.isInstance(args.request)) {
    return next(args);
  }
  const input = args.input;
  const result = await next(args);
  const response = result.response;
  let collectedStream = void 0;
  const { requestValidationModeMember, responseAlgorithms } = middlewareConfig;
  if (requestValidationModeMember && input[requestValidationModeMember] === "ENABLED") {
    const { clientName, commandName } = context;
    const isS3WholeObjectMultipartGetResponseChecksum = clientName === "S3Client" && commandName === "GetObjectCommand" && getChecksumAlgorithmListForResponse(responseAlgorithms).every((algorithm) => {
      const responseHeader = getChecksumLocationName(algorithm);
      const checksumFromResponse = response.headers[responseHeader];
      return !checksumFromResponse || isChecksumWithPartNumber(checksumFromResponse);
    });
    if (isS3WholeObjectMultipartGetResponseChecksum) {
      return result;
    }
    const isStreamingBody = isStreaming(response.body);
    if (isStreamingBody) {
      collectedStream = await config3.streamCollector(response.body);
      response.body = createReadStreamOnBuffer(collectedStream);
    }
    await validateChecksumFromResponse(result.response, {
      config: config3,
      responseAlgorithms
    });
    if (isStreamingBody && collectedStream) {
      response.body = createReadStreamOnBuffer(collectedStream);
    }
  }
  return result;
};

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getFlexibleChecksumsPlugin.js
var getFlexibleChecksumsPlugin = (config3, middlewareConfig) => ({
  applyToStack: (clientStack) => {
    clientStack.add(flexibleChecksumsMiddleware(config3, middlewareConfig), flexibleChecksumsMiddlewareOptions);
    clientStack.addRelativeTo(flexibleChecksumsResponseMiddleware(config3, middlewareConfig), flexibleChecksumsResponseMiddlewareOptions);
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/PutObjectCommand.js
init_process();
init_buffer();
var PutObjectCommand = class extends Command.classBuilder().ep({
  ...commonParams,
  Bucket: { type: "contextParams", name: "Bucket" },
  Key: { type: "contextParams", name: "Key" }
}).m(function(Command2, cs2, config3, o2) {
  return [
    getSerdePlugin(config3, this.serialize, this.deserialize),
    getEndpointPlugin(config3, Command2.getEndpointParameterInstructions()),
    getFlexibleChecksumsPlugin(config3, {
      input: this.input,
      requestAlgorithmMember: "ChecksumAlgorithm",
      requestChecksumRequired: false
    }),
    getCheckContentLengthHeaderPlugin(config3),
    getThrow200ExceptionsPlugin(config3),
    getSsecPlugin(config3)
  ];
}).s("AmazonS3", "PutObject", {}).n("S3Client", "PutObjectCommand").f(PutObjectRequestFilterSensitiveLog, PutObjectOutputFilterSensitiveLog).ser(se_PutObjectCommand).de(de_PutObjectCommand).build() {
};

// node-modules-polyfills:path
init_process();
init_buffer();
function normalizeArray(parts, allowAboveRoot) {
  var up = 0;
  for (var i2 = parts.length - 1; i2 >= 0; i2--) {
    var last = parts[i2];
    if (last === ".") {
      parts.splice(i2, 1);
    } else if (last === "..") {
      parts.splice(i2, 1);
      up++;
    } else if (up) {
      parts.splice(i2, 1);
      up--;
    }
  }
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift("..");
    }
  }
  return parts;
}
var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};
function resolve() {
  var resolvedPath2 = "", resolvedAbsolute = false;
  for (var i2 = arguments.length - 1; i2 >= -1 && !resolvedAbsolute; i2--) {
    var path2 = i2 >= 0 ? arguments[i2] : "/";
    if (typeof path2 !== "string") {
      throw new TypeError("Arguments to path.resolve must be strings");
    } else if (!path2) {
      continue;
    }
    resolvedPath2 = path2 + "/" + resolvedPath2;
    resolvedAbsolute = path2.charAt(0) === "/";
  }
  resolvedPath2 = normalizeArray(filter(resolvedPath2.split("/"), function(p3) {
    return !!p3;
  }), !resolvedAbsolute).join("/");
  return (resolvedAbsolute ? "/" : "") + resolvedPath2 || ".";
}
function normalize(path2) {
  var isPathAbsolute = isAbsolute(path2), trailingSlash = substr(path2, -1) === "/";
  path2 = normalizeArray(filter(path2.split("/"), function(p3) {
    return !!p3;
  }), !isPathAbsolute).join("/");
  if (!path2 && !isPathAbsolute) {
    path2 = ".";
  }
  if (path2 && trailingSlash) {
    path2 += "/";
  }
  return (isPathAbsolute ? "/" : "") + path2;
}
function isAbsolute(path2) {
  return path2.charAt(0) === "/";
}
function join() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return normalize(filter(paths, function(p3, index3) {
    if (typeof p3 !== "string") {
      throw new TypeError("Arguments to path.join must be strings");
    }
    return p3;
  }).join("/"));
}
function relative(from3, to) {
  from3 = resolve(from3).substr(1);
  to = resolve(to).substr(1);
  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== "")
        break;
    }
    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== "")
        break;
    }
    if (start > end)
      return [];
    return arr.slice(start, end - start + 1);
  }
  var fromParts = trim(from3.split("/"));
  var toParts = trim(to.split("/"));
  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i2 = 0; i2 < length; i2++) {
    if (fromParts[i2] !== toParts[i2]) {
      samePartsLength = i2;
      break;
    }
  }
  var outputParts = [];
  for (var i2 = samePartsLength; i2 < fromParts.length; i2++) {
    outputParts.push("..");
  }
  outputParts = outputParts.concat(toParts.slice(samePartsLength));
  return outputParts.join("/");
}
var sep = "/";
var delimiter = ":";
function dirname(path2) {
  var result = splitPath(path2), root4 = result[0], dir = result[1];
  if (!root4 && !dir) {
    return ".";
  }
  if (dir) {
    dir = dir.substr(0, dir.length - 1);
  }
  return root4 + dir;
}
function basename(path2, ext) {
  var f2 = splitPath(path2)[2];
  if (ext && f2.substr(-1 * ext.length) === ext) {
    f2 = f2.substr(0, f2.length - ext.length);
  }
  return f2;
}
function extname(path2) {
  return splitPath(path2)[3];
}
var path_default = {
  extname,
  basename,
  dirname,
  sep,
  delimiter,
  relative,
  join,
  isAbsolute,
  normalize,
  resolve
};
function filter(xs, f2) {
  if (xs.filter)
    return xs.filter(f2);
  var res = [];
  for (var i2 = 0; i2 < xs.length; i2++) {
    if (f2(xs[i2], i2, xs))
      res.push(xs[i2]);
  }
  return res;
}
var substr = "ab".substr(-1) === "b" ? function(str, start, len) {
  return str.substr(start, len);
} : function(str, start, len) {
  if (start < 0)
    start = str.length + start;
  return str.substr(start, len);
};

// server/src/utils/s3.ts
init_process();
init_buffer();
function createS3Client() {
  const env5 = getEnv();
  const region = env5.S3_REGION;
  const endpoint = env5.S3_ENDPOINT;
  const accessKeyId = env5.S3_ACCESS_KEY_ID;
  const secretAccessKey = env5.S3_SECRET_ACCESS_KEY;
  const forcePathStyle = env5.S3_FORCE_PATH_STYLE === "true";
  return new S3Client({
    region,
    endpoint,
    forcePathStyle,
    credentials: {
      accessKeyId,
      secretAccessKey
    }
  });
}

// server/src/utils/cache.ts
var CacheImpl = class {
  cache = /* @__PURE__ */ new Map();
  db;
  env;
  cacheUrl;
  type;
  loaded = false;
  s3 = createS3Client();
  constructor(type = "cache") {
    this.type = type;
    this.db = getDB();
    this.env = getEnv();
    this.cache = /* @__PURE__ */ new Map();
    const slash = this.env.S3_ACCESS_HOST.endsWith("/") ? "" : "/";
    this.cacheUrl = this.env.S3_ACCESS_HOST + slash + path_default.join(this.env.S3_CACHE_FOLDER || "cache", `${type}.json`);
  }
  async load() {
    console.log("Cache load", this.cacheUrl);
    try {
      const response = await fetch(new Request(this.cacheUrl));
      const data = await response.json();
      for (let key2 in data) {
        this.cache.set(key2, data[key2]);
      }
      this.loaded = true;
    } catch (e2) {
      console.error("Cache load failed");
      console.error(e2.message);
    }
  }
  async all() {
    if (!this.loaded) {
      await this.load();
    }
    return this.cache;
  }
  async get(key2) {
    if (!this.loaded) {
      await this.load();
    }
    return this.cache.get(key2);
  }
  async getByPrefix(prefix) {
    if (!this.loaded) {
      await this.load();
    }
    const result = [];
    for (let key2 of this.cache.keys()) {
      if (key2.startsWith(prefix)) {
        result.push(this.cache.get(key2));
      }
    }
    return result;
  }
  async getBySuffix(suffix) {
    if (!this.loaded) {
      await this.load();
    }
    const result = [];
    for (let key2 of this.cache.keys()) {
      if (key2.endsWith(suffix)) {
        result.push(this.cache.get(key2));
      }
    }
    return result;
  }
  async getOrSet(key2, value) {
    const cached = await this.get(key2);
    if (cached !== void 0) {
      console.log("Cache hit", key2);
      return cached;
    }
    console.log("Cache miss", key2);
    const newValue = await value();
    await this.set(key2, newValue);
    return newValue;
  }
  async getOrDefault(key2, defaultValue) {
    return this.getOrSet(key2, async () => defaultValue);
  }
  async set(key2, value, save = true) {
    if (!this.loaded)
      await this.load();
    this.cache.set(key2, value);
    if (save) {
      await this.save();
    }
  }
  async delete(key2, save = true) {
    if (!this.loaded)
      await this.load();
    this.cache.delete(key2);
    if (save) {
      await this.save();
    }
  }
  async deletePrefix(prefix) {
    for (let key2 of this.cache.keys()) {
      console.log("Cache key", key2);
      if (key2.startsWith(prefix)) {
        console.log("Cache delete", key2);
        await this.delete(key2, false);
      }
    }
    await this.save();
  }
  async deleteSuffix(suffix) {
    for (let key2 of this.cache.keys()) {
      console.log("Cache key", key2);
      if (key2.endsWith(suffix)) {
        console.log("Cache delete", key2);
        await this.delete(key2, false);
      }
    }
    await this.save();
  }
  async clear() {
    this.cache.clear();
    await this.save();
  }
  async save() {
    const cacheKey = path_default.join(this.env.S3_CACHE_FOLDER, `${this.type}.json`);
    await this.s3.send(new PutObjectCommand({
      Bucket: this.env.S3_BUCKET,
      Key: cacheKey,
      Body: JSON.stringify(Object.fromEntries(this.cache))
    })).then(() => {
      console.log("Cache saved");
    }).catch((e2) => {
      console.error("Cache save failed");
      console.error(e2.message);
    });
  }
};
CacheImpl = __decorateClass([
  Service()
], CacheImpl);
var PublicCache = () => esm5_default.get("cache");
var ServerConfig = () => esm5_default.get("server.config");
var ClientConfig = () => esm5_default.get("client.config");

// server/src/utils/config.ts
init_process();
init_buffer();
var Config;
((Config2) => {
  Config2.webhookUrl = "WEBHOOK_URL";
})(Config || (Config = {}));

// server/src/utils/webhook.ts
init_process();
init_buffer();
async function sendWebhook(url, data) {
  return await fetch(url, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify(data)
  });
}
async function notify(webhook_url, message2) {
  if (!webhook_url) {
    console.error("Please set WEBHOOK_URL");
    return;
  }
  return await sendWebhook(webhook_url, { content: message2 });
}

// server/src/services/comments.ts
function CommentService() {
  const db = getDB();
  const env5 = getEnv();
  return new Elysia({ aot: false }).use(setup()).group(
    "/feed/comment",
    (group) => group.get("/:feed", async ({ params: { feed } }) => {
      const feedId = parseInt(feed);
      const comment_list = await db.query.comments.findMany({
        where: eq(comments.feedId, feedId),
        columns: { feedId: false, userId: false },
        with: {
          user: {
            columns: { id: true, username: true, avatar: true, permission: true }
          }
        },
        orderBy: [desc(comments.createdAt)]
      });
      return comment_list;
    }).post("/:feed", async ({ uid, set, params: { feed }, body: { content: content3 } }) => {
      if (!uid) {
        set.status = 401;
        return "Unauthorized";
      }
      if (!content3) {
        set.status = 400;
        return "Content is required";
      }
      const feedId = parseInt(feed);
      const userId = parseInt(uid);
      const user = await db.query.users.findFirst({ where: eq(users.id, userId) });
      if (!user) {
        set.status = 400;
        return "User not found";
      }
      const exist = await db.query.feeds.findFirst({ where: eq(feeds.id, feedId) });
      if (!exist) {
        set.status = 400;
        return "Feed not found";
      }
      await db.insert(comments).values({
        feedId,
        userId,
        content: content3
      });
      const webhookUrl = await ServerConfig().get(Config.webhookUrl) || env5.WEBHOOK_URL;
      await notify(webhookUrl, `${env5.FRONTEND_URL}/feed/${feedId}
${user.username} \u8BC4\u8BBA\u4E86: ${exist.title}
${content3}`);
      return "OK";
    }, {
      body: t.Object({
        content: t.String()
      })
    })
  ).group(
    "/comment",
    (group) => group.delete("/:id", async ({ uid, admin, set, params: { id } }) => {
      if (uid === void 0) {
        set.status = 401;
        return "Unauthorized";
      }
      const id_num = parseInt(id);
      const comment2 = await db.query.comments.findFirst({ where: eq(comments.id, id_num) });
      if (!comment2) {
        set.status = 404;
        return "Not found";
      }
      if (!admin && comment2.userId !== parseInt(uid)) {
        set.status = 403;
        return "Permission denied";
      }
      await db.delete(comments).where(eq(comments.id, id_num));
      return "OK";
    })
  );
}

// server/src/services/feed.ts
init_process();
init_buffer();
var import_fast_xml_parser2 = __toESM(require_fxp(), 1);
var import_html_to_md = __toESM(require_dist2(), 1);

// server/src/utils/image.ts
init_process();
init_buffer();
function extractImage(content3) {
  const img_reg = /!\[.*?\]\((.*?)\)/;
  const img_match = img_reg.exec(content3);
  let avatar = void 0;
  if (img_match) {
    avatar = img_match[1];
  }
  return avatar;
}

// server/src/services/tag.ts
init_process();
init_buffer();
function TagService() {
  const db = getDB();
  return new Elysia({ aot: false }).use(setup()).group(
    "/tag",
    (group) => group.get("/", async () => {
      const tag_list = await db.query.hashtags.findMany({
        with: {
          feeds: {
            columns: { feedId: true }
          }
        }
      });
      return tag_list.map((tag2) => {
        return {
          ...tag2,
          feeds: tag2.feeds.length
        };
      });
    }).get("/:name", async ({ admin, set, params: { name } }) => {
      const nameDecoded = decodeURI(name);
      const tag2 = await db.query.hashtags.findFirst({
        where: eq(hashtags.name, nameDecoded),
        with: {
          feeds: {
            with: {
              feed: {
                columns: {
                  id: true,
                  title: true,
                  summary: true,
                  content: true,
                  createdAt: true,
                  updatedAt: true,
                  draft: false,
                  listed: false
                },
                with: {
                  user: {
                    columns: { id: true, username: true, avatar: true }
                  },
                  hashtags: {
                    columns: {},
                    with: {
                      hashtag: {
                        columns: { id: true, name: true }
                      }
                    }
                  }
                },
                where: (feeds2) => admin ? void 0 : and(eq(feeds2.draft, 0), eq(feeds2.listed, 1))
              }
            }
          }
        }
      });
      const tagFeeds = tag2?.feeds.map((tag3) => {
        if (!tag3.feed) {
          return null;
        }
        return {
          ...tag3.feed,
          hashtags: tag3.feed.hashtags.map((tag4) => tag4.hashtag)
        };
      }).filter((feed) => feed !== null);
      if (!tag2) {
        set.status = 404;
        return "Not found";
      }
      return {
        ...tag2,
        feeds: tagFeeds
      };
    })
  );
}
async function bindTagToPost(db, feedId, tags) {
  await db.delete(feedHashtags).where(
    eq(feedHashtags.feedId, feedId)
  );
  for (const tag2 of tags) {
    const tagId = await getTagIdOrCreate(db, tag2);
    await db.insert(feedHashtags).values({
      feedId,
      hashtagId: tagId
    });
  }
}
async function getTagByName(db, name) {
  return await db.query.hashtags.findFirst({ where: eq(hashtags.name, name) });
}
async function getTagIdOrCreate(db, name) {
  const tag2 = await getTagByName(db, name);
  if (tag2) {
    return tag2.id;
  } else {
    const result = await db.insert(hashtags).values({
      name
    }).returning({ insertedId: hashtags.id });
    if (result.length === 0) {
      throw new Error("Failed to insert");
    } else {
      return result[0].insertedId;
    }
  }
}

// server/src/services/feed.ts
function FeedService() {
  const db = getDB();
  return new Elysia({ aot: false }).use(setup()).group(
    "/feed",
    (group) => group.get("/", async ({ admin, set, query: { page, limit, type } }) => {
      if ((type === "draft" || type === "unlisted") && !admin) {
        set.status = 403;
        return "Permission denied";
      }
      const cache = PublicCache();
      const page_num = (page ? page > 0 ? page : 1 : 1) - 1;
      const limit_num = limit ? +limit > 50 ? 50 : +limit : 20;
      const cacheKey = `feeds_${type}_${page_num}_${limit_num}`;
      const cached = await cache.get(cacheKey);
      if (cached) {
        return cached;
      }
      const where = type === "draft" ? eq(feeds.draft, 1) : type === "unlisted" ? and(eq(feeds.draft, 0), eq(feeds.listed, 0)) : and(eq(feeds.draft, 0), eq(feeds.listed, 1));
      const size = await db.select({ count: count() }).from(feeds).where(where);
      if (size[0].count === 0) {
        return {
          size: 0,
          data: [],
          hasNext: false
        };
      }
      const feed_list = (await db.query.feeds.findMany({
        where,
        columns: admin ? void 0 : {
          draft: false,
          listed: false
        },
        with: {
          hashtags: {
            columns: {},
            with: {
              hashtag: {
                columns: { id: true, name: true }
              }
            }
          },
          user: {
            columns: { id: true, username: true, avatar: true }
          }
        },
        orderBy: [desc(feeds.top), desc(feeds.createdAt), desc(feeds.updatedAt)],
        offset: page_num * limit_num,
        limit: limit_num + 1
      })).map(({ content: content3, hashtags: hashtags2, summary, ...other }) => {
        const avatar = extractImage(content3);
        return {
          summary: summary.length > 0 ? summary : content3.length > 100 ? content3.slice(0, 100) : content3,
          hashtags: hashtags2.map(({ hashtag }) => hashtag),
          avatar,
          ...other
        };
      });
      let hasNext = false;
      if (feed_list.length === limit_num + 1) {
        feed_list.pop();
        hasNext = true;
      }
      const data = {
        size: size[0].count,
        data: feed_list,
        hasNext
      };
      if (type === void 0 || type === "normal" || type === "")
        await cache.set(cacheKey, data);
      return data;
    }, {
      query: t.Object({
        page: t.Optional(t.Numeric()),
        limit: t.Optional(t.Numeric()),
        type: t.Optional(t.String())
      })
    }).get("/timeline", async () => {
      const where = and(eq(feeds.draft, 0), eq(feeds.listed, 1));
      return await db.query.feeds.findMany({
        where,
        columns: {
          id: true,
          title: true,
          createdAt: true
        },
        orderBy: [desc(feeds.createdAt), desc(feeds.updatedAt)]
      });
    }).post("/", async ({ admin, set, uid, body: { title: title3, alias, listed, content: content3, summary, draft, tags, createdAt } }) => {
      if (!admin) {
        set.status = 403;
        return "Permission denied";
      }
      if (!title3) {
        set.status = 400;
        return "Title is required";
      }
      if (!content3) {
        set.status = 400;
        return "Content is required";
      }
      const exist = await db.query.feeds.findFirst({
        where: or(eq(feeds.title, title3), eq(feeds.content, content3))
      });
      if (exist) {
        set.status = 400;
        return "Content already exists";
      }
      const date2 = createdAt ? new Date(createdAt) : /* @__PURE__ */ new Date();
      const result = await db.insert(feeds).values({
        title: title3,
        content: content3,
        summary,
        uid,
        alias,
        listed: listed ? 1 : 0,
        draft: draft ? 1 : 0,
        createdAt: date2,
        updatedAt: date2
      }).returning({ insertedId: feeds.id });
      await bindTagToPost(db, result[0].insertedId, tags);
      await PublicCache().deletePrefix("feeds_");
      if (result.length === 0) {
        set.status = 500;
        return "Failed to insert";
      } else {
        return result[0];
      }
    }, {
      body: t.Object({
        title: t.String(),
        content: t.String(),
        summary: t.String(),
        alias: t.Optional(t.String()),
        draft: t.Boolean(),
        listed: t.Boolean(),
        createdAt: t.Optional(t.Date()),
        tags: t.Array(t.String())
      })
    }).get("/:id", async ({ uid, admin, set, headers, params: { id } }) => {
      const id_num = parseInt(id);
      const cache = PublicCache();
      const cacheKey = `feed_${id}`;
      const feed = await cache.getOrSet(cacheKey, () => db.query.feeds.findFirst({
        where: or(eq(feeds.id, id_num), eq(feeds.alias, id)),
        with: {
          hashtags: {
            columns: {},
            with: {
              hashtag: {
                columns: { id: true, name: true }
              }
            }
          },
          user: {
            columns: { id: true, username: true, avatar: true }
          }
        }
      }));
      if (!feed) {
        set.status = 404;
        return "Not found";
      }
      if (feed.draft && feed.uid !== uid && !admin) {
        set.status = 403;
        return "Permission denied";
      }
      const { hashtags: hashtags2, ...other } = feed;
      const hashtags_flatten = hashtags2.map((f2) => f2.hashtag);
      const config3 = ClientConfig();
      const enableVisit = await config3.getOrDefault("counter.enabled", true);
      let pv = 0;
      let uv = 0;
      if (enableVisit) {
        const ip = headers["cf-connecting-ip"] || headers["x-real-ip"] || "UNK";
        await db.insert(visits).values({
          feedId: feed.id,
          ip
        });
        const visit2 = await db.query.visits.findMany({
          where: eq(visits.feedId, feed.id),
          columns: { id: true, ip: true }
        });
        pv = visit2.length;
        uv = new Set(visit2.map((v2) => v2.ip)).size;
      }
      const data = {
        ...other,
        hashtags: hashtags_flatten,
        pv,
        uv
      };
      return data;
    }).get("/adjacent/:id", async ({ set, params: { id } }) => {
      let id_num;
      if (isNaN(parseInt(id))) {
        const aliasRecord = await db.select({ id: feeds.id }).from(feeds).where(eq(feeds.alias, id));
        if (aliasRecord.length === 0) {
          set.status = 404;
          return "Not found";
        }
        id_num = aliasRecord[0].id;
      } else {
        id_num = parseInt(id);
      }
      const feed = await db.query.feeds.findFirst({
        where: eq(feeds.id, id_num),
        columns: { createdAt: true }
      });
      if (!feed) {
        set.status = 404;
        return "Not found";
      }
      const created_at2 = feed.createdAt;
      const cache = PublicCache();
      function formatAndCacheData(feed2, feedDirection) {
        if (feed2) {
          const hashtags_flatten = feed2.hashtags.map((f2) => f2.hashtag);
          const summary = feed2.summary.length > 0 ? feed2.summary : feed2.content.length > 50 ? feed2.content.slice(0, 50) : feed2.content;
          const cacheKey = `${feed2.id}_${feedDirection}_${id_num}`;
          const cacheData = {
            id: feed2.id,
            title: feed2.title,
            summary,
            hashtags: hashtags_flatten,
            createdAt: feed2.createdAt,
            updatedAt: feed2.updatedAt
          };
          cache.set(cacheKey, cacheData);
          return cacheData;
        }
        return null;
      }
      const getPreviousFeed = async () => {
        const previousFeedCached = await cache.getBySuffix(
          `previous_feed_${id_num}`
        );
        if (previousFeedCached && previousFeedCached.length > 0) {
          return previousFeedCached[0];
        } else {
          const tempPreviousFeed = await db.query.feeds.findFirst({
            where: and(
              and(eq(feeds.draft, 0), eq(feeds.listed, 1)),
              lt(feeds.createdAt, created_at2)
            ),
            orderBy: [desc(feeds.createdAt)],
            with: {
              hashtags: {
                columns: {},
                with: {
                  hashtag: {
                    columns: { id: true, name: true }
                  }
                }
              },
              user: {
                columns: { id: true, username: true, avatar: true }
              }
            }
          });
          return formatAndCacheData(tempPreviousFeed, "previous_feed");
        }
      };
      const getNextFeed = async () => {
        const nextFeedCached = await cache.getBySuffix(
          `next_feed_${id_num}`
        );
        if (nextFeedCached && nextFeedCached.length > 0) {
          return nextFeedCached[0];
        } else {
          const tempNextFeed = await db.query.feeds.findFirst({
            where: and(
              and(eq(feeds.draft, 0), eq(feeds.listed, 1)),
              gt(feeds.createdAt, created_at2)
            ),
            orderBy: [asc(feeds.createdAt)],
            with: {
              hashtags: {
                columns: {},
                with: {
                  hashtag: {
                    columns: { id: true, name: true }
                  }
                }
              },
              user: {
                columns: { id: true, username: true, avatar: true }
              }
            }
          });
          return formatAndCacheData(tempNextFeed, "next_feed");
        }
      };
      const [previousFeed, nextFeed] = await Promise.all([
        getPreviousFeed(),
        getNextFeed()
      ]);
      return {
        previousFeed,
        nextFeed
      };
    }).post("/:id", async ({
      admin,
      set,
      uid,
      params: { id },
      body: { title: title3, listed, content: content3, summary, alias, draft, top, tags, createdAt }
    }) => {
      const id_num = parseInt(id);
      const feed = await db.query.feeds.findFirst({
        where: eq(feeds.id, id_num)
      });
      if (!feed) {
        set.status = 404;
        return "Not found";
      }
      if (feed.uid !== uid && !admin) {
        set.status = 403;
        return "Permission denied";
      }
      await db.update(feeds).set({
        title: title3,
        content: content3,
        summary,
        alias,
        top,
        listed: listed ? 1 : 0,
        draft: draft ? 1 : 0,
        createdAt: createdAt ? new Date(createdAt) : void 0,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq(feeds.id, id_num));
      if (tags) {
        await bindTagToPost(db, id_num, tags);
      }
      await clearFeedCache(id_num, feed.alias, alias || null);
      return "Updated";
    }, {
      body: t.Object({
        title: t.Optional(t.String()),
        alias: t.Optional(t.String()),
        content: t.Optional(t.String()),
        summary: t.Optional(t.String()),
        listed: t.Boolean(),
        draft: t.Optional(t.Boolean()),
        createdAt: t.Optional(t.Date()),
        tags: t.Optional(t.Array(t.String())),
        top: t.Optional(t.Integer())
      })
    }).post("/top/:id", async ({
      admin,
      set,
      uid,
      params: { id },
      body: { top }
    }) => {
      const id_num = parseInt(id);
      const feed = await db.query.feeds.findFirst({
        where: eq(feeds.id, id_num)
      });
      if (!feed) {
        set.status = 404;
        return "Not found";
      }
      if (feed.uid !== uid && !admin) {
        set.status = 403;
        return "Permission denied";
      }
      await db.update(feeds).set({
        top
      }).where(eq(feeds.id, feed.id));
      await clearFeedCache(feed.id, null, null);
      return "Updated";
    }, {
      body: t.Object({
        top: t.Integer()
      })
    }).delete("/:id", async ({ admin, set, uid, params: { id } }) => {
      const id_num = parseInt(id);
      const feed = await db.query.feeds.findFirst({
        where: eq(feeds.id, id_num)
      });
      if (!feed) {
        set.status = 404;
        return "Not found";
      }
      if (feed.uid !== uid && !admin) {
        set.status = 403;
        return "Permission denied";
      }
      await db.delete(feeds).where(eq(feeds.id, id_num));
      await clearFeedCache(id_num, feed.alias, null);
      return "Deleted";
    })
  ).get("/search/:keyword", async ({ admin, params: { keyword }, query: { page, limit } }) => {
    keyword = decodeURI(keyword);
    const cache = PublicCache();
    const page_num = (page ? page > 0 ? page : 1 : 1) - 1;
    const limit_num = limit ? +limit > 50 ? 50 : +limit : 20;
    if (keyword === void 0 || keyword.trim().length === 0) {
      return {
        size: 0,
        data: [],
        hasNext: false
      };
    }
    const cacheKey = `search_${keyword}`;
    const searchKeyword = `%${keyword}%`;
    const whereClause = or(
      like(feeds.title, searchKeyword),
      like(feeds.content, searchKeyword),
      like(feeds.summary, searchKeyword),
      like(feeds.alias, searchKeyword)
    );
    const feed_list = (await cache.getOrSet(cacheKey, () => db.query.feeds.findMany({
      where: admin ? whereClause : and(whereClause, eq(feeds.draft, 0)),
      columns: admin ? void 0 : {
        draft: false,
        listed: false
      },
      with: {
        hashtags: {
          columns: {},
          with: {
            hashtag: {
              columns: { id: true, name: true }
            }
          }
        },
        user: {
          columns: { id: true, username: true, avatar: true }
        }
      },
      orderBy: [desc(feeds.createdAt), desc(feeds.updatedAt)]
    }))).map(({ content: content3, hashtags: hashtags2, summary, ...other }) => {
      return {
        summary: summary.length > 0 ? summary : content3.length > 100 ? content3.slice(0, 100) : content3,
        hashtags: hashtags2.map(({ hashtag }) => hashtag),
        ...other
      };
    });
    if (feed_list.length <= page_num * limit_num) {
      return {
        size: feed_list.length,
        data: [],
        hasNext: false
      };
    } else if (feed_list.length <= page_num * limit_num + limit_num) {
      return {
        size: feed_list.length,
        data: feed_list.slice(page_num * limit_num),
        hasNext: false
      };
    } else {
      return {
        size: feed_list.length,
        data: feed_list.slice(page_num * limit_num, page_num * limit_num + limit_num),
        hasNext: true
      };
    }
  }, {
    query: t.Object({
      page: t.Optional(t.Numeric()),
      limit: t.Optional(t.Numeric())
    })
  }).post("wp", async ({ set, admin, body: { data } }) => {
    if (!admin) {
      set.status = 403;
      return "Permission denied";
    }
    if (!data) {
      set.status = 400;
      return "Data is required";
    }
    const xml2 = await data.text();
    const parser = new import_fast_xml_parser2.XMLParser();
    const result = await parser.parse(xml2);
    const items = result.rss.channel.item;
    if (!items) {
      set.status = 404;
      return "No items found";
    }
    const feedItems = items?.map((item) => {
      const createdAt = new Date(item?.["wp:post_date"]);
      const updatedAt = new Date(item?.["wp:post_modified"]);
      const draft = item?.["wp:status"] !== "publish";
      const contentHtml = item?.["content:encoded"];
      const content3 = (0, import_html_to_md.default)(contentHtml);
      const summary = content3.length > 100 ? content3.slice(0, 100) : content3;
      let tags = item?.["category"];
      if (tags && Array.isArray(tags)) {
        tags = tags.map((tag2) => tag2 + "");
      } else if (tags && typeof tags === "string") {
        tags = [tags];
      }
      return {
        title: item.title,
        summary,
        content: content3,
        draft,
        createdAt,
        updatedAt,
        tags
      };
    });
    let success = 0;
    let skipped = 0;
    let skippedList = [];
    for (const item of feedItems) {
      if (!item.content) {
        skippedList.push({ title: item.title, reason: "no content" });
        skipped++;
        continue;
      }
      const exist = await db.query.feeds.findFirst({
        where: eq(feeds.content, item.content)
      });
      if (exist) {
        skippedList.push({ title: item.title, reason: "content exists" });
        skipped++;
        continue;
      }
      const result2 = await db.insert(feeds).values({
        title: item.title,
        content: item.content,
        summary: item.summary,
        uid: 1,
        listed: 1,
        draft: item.draft ? 1 : 0,
        createdAt: item.createdAt,
        updatedAt: item.updatedAt
      }).returning({ insertedId: feeds.id });
      if (item.tags) {
        await bindTagToPost(db, result2[0].insertedId, item.tags);
      }
      success++;
    }
    PublicCache().deletePrefix("feeds_");
    return {
      success,
      skipped,
      skippedList
    };
  }, {
    body: t.Object({
      data: t.File()
    })
  });
}
async function clearFeedCache(id, alias, newAlias) {
  const cache = PublicCache();
  await cache.deletePrefix("feeds_");
  await cache.deletePrefix("search_");
  await cache.delete(`feed_${id}`, false);
  await cache.deletePrefix(`${id}_previous_feed`);
  await cache.deletePrefix(`${id}_next_feed`);
  if (alias === newAlias)
    return;
  if (alias)
    await cache.delete(`feed_${alias}`, false);
  if (newAlias)
    await cache.delete(`feed_${newAlias}`, false);
}

// server/src/services/friends.ts
init_process();
init_buffer();
function FriendService() {
  const db = getDB();
  const env5 = getEnv();
  return new Elysia({ aot: false }).use(setup()).group(
    "/friend",
    (group) => group.get("/", async ({ admin, uid }) => {
      const friend_list = await (admin ? db.query.friends.findMany() : db.query.friends.findMany({ where: eq(friends.accepted, 1) }));
      const uid_num = parseInt(uid);
      const apply_list = await db.query.friends.findFirst({ where: eq(friends.uid, uid_num ?? null) });
      return { friend_list, apply_list };
    }).post("/", async ({ admin, uid, username, set, body: { name, desc: desc2, avatar, url } }) => {
      const config3 = ClientConfig();
      const enable = await config3.getOrDefault("friend_apply_enable", true);
      if (!enable && !admin) {
        set.status = 403;
        return "Friend Link Apply Disabled";
      }
      if (name.length > 20 || desc2.length > 100 || avatar.length > 100 || url.length > 100) {
        set.status = 400;
        return "Invalid input";
      }
      if (name.length === 0 || desc2.length === 0 || avatar.length === 0 || url.length === 0) {
        set.status = 400;
        return "Invalid input";
      }
      if (!uid) {
        set.status = 401;
        return "Unauthorized";
      }
      if (!admin) {
        const exist = await db.query.friends.findFirst({
          where: eq(friends.uid, uid)
        });
        if (exist) {
          set.status = 400;
          return "Already sent";
        }
      }
      const uid_num = parseInt(uid);
      const accepted = admin ? 1 : 0;
      await db.insert(friends).values({
        name,
        desc: desc2,
        avatar,
        url,
        uid: uid_num,
        accepted
      });
      if (!admin) {
        const webhookUrl = await ServerConfig().get(Config.webhookUrl) || env5.WEBHOOK_URL;
        const content3 = `${env5.FRONTEND_URL}/friends
${username} \u7533\u8BF7\u53CB\u94FE: ${name}
${desc2}
${url}`;
        await notify(webhookUrl, content3);
      }
      return "OK";
    }, {
      body: t.Object({
        name: t.String(),
        desc: t.String(),
        avatar: t.String(),
        url: t.String()
      })
    }).put("/:id", async ({ admin, uid, username, set, params: { id }, body: { name, desc: desc2, avatar, url, accepted } }) => {
      const config3 = ClientConfig();
      const enable = await config3.getOrDefault("friend_apply_enable", true);
      if (!enable && !admin) {
        set.status = 403;
        return "Friend Link Apply Disabled";
      }
      if (!uid) {
        set.status = 401;
        return "Unauthorized";
      }
      const exist = await db.query.friends.findFirst({
        where: eq(friends.id, parseInt(id))
      });
      if (!exist) {
        set.status = 404;
        return "Not found";
      }
      if (!admin && exist.uid !== uid) {
        set.status = 403;
        return "Permission denied";
      }
      if (!admin) {
        accepted = 0;
      }
      function wrap3(s2) {
        return s2 ? s2.length === 0 ? void 0 : s2 : void 0;
      }
      await db.update(friends).set({
        name: wrap3(name),
        desc: wrap3(desc2),
        avatar: wrap3(avatar),
        url: wrap3(url),
        accepted: accepted === void 0 ? void 0 : accepted
      }).where(eq(friends.id, parseInt(id)));
      if (!admin) {
        const webhookUrl = await ServerConfig().get(Config.webhookUrl) || env5.WEBHOOK_URL;
        const content3 = `${env5.FRONTEND_URL}/friends
${username} \u66F4\u65B0\u53CB\u94FE: ${name}
${desc2}
${url}`;
        await notify(webhookUrl, content3);
      }
      return "OK";
    }, {
      body: t.Object({
        name: t.String(),
        desc: t.String(),
        avatar: t.Optional(t.String()),
        url: t.String(),
        accepted: t.Optional(t.Integer())
      })
    }).delete("/:id", async ({ admin, uid, set, params: { id } }) => {
      if (!uid) {
        set.status = 401;
        return "Unauthorized";
      }
      const exist = await db.query.friends.findFirst({
        where: eq(friends.id, parseInt(id))
      });
      if (!exist) {
        set.status = 404;
        return "Not found";
      }
      if (!admin && exist.uid !== uid) {
        set.status = 403;
        return "Permission denied";
      }
      await db.delete(friends).where(eq(friends.id, parseInt(id)));
      return "OK";
    })
  );
}
async function friendCrontab(env5, ctx) {
  const config3 = ServerConfig();
  const enable = await config3.getOrDefault("friend_crontab", true);
  const ua = await config3.get("friend_ua") || "Rin-Check/0.1.0";
  if (!enable) {
    console.info("friend crontab disabled");
    return;
  }
  const db = drizzle(env5.DB, { schema: schema_exports });
  const friend_list = await db.query.friends.findMany();
  console.info(`total friends: ${friend_list.length}`);
  let health = 0;
  let unhealthy = 0;
  for (const friend of friend_list) {
    console.info(`checking ${friend.name}: ${friend.url}`);
    try {
      const response = await fetch(new Request(friend.url, { method: "GET", headers: { "User-Agent": ua } }));
      console.info(`response status: ${response.status}`);
      console.info(`response statusText: ${response.statusText}`);
      if (response.ok) {
        ctx.waitUntil(db.update(friends).set({ health: "" }).where(eq(friends.id, friend.id)));
        health++;
      } else {
        ctx.waitUntil(db.update(friends).set({ health: `${response.status}` }).where(eq(friends.id, friend.id)));
        unhealthy++;
      }
    } catch (e2) {
      console.error(e2.message);
      ctx.waitUntil(db.update(friends).set({ health: e2.message }).where(eq(friends.id, friend.id)));
      unhealthy++;
    }
  }
  console.info(`update friends health done. Total: ${health + unhealthy}, Healthy: ${health}, Unhealthy: ${unhealthy}`);
}

// server/src/services/rss.ts
init_process();
init_buffer();
var import_feed = __toESM(require_feed(), 1);

// node_modules/rehype-stringify/index.js
init_process();
init_buffer();

// node_modules/rehype-stringify/lib/index.js
init_process();
init_buffer();

// node_modules/hast-util-to-html/index.js
init_process();
init_buffer();

// node_modules/hast-util-to-html/lib/index.js
init_process();
init_buffer();

// node_modules/html-void-elements/index.js
init_process();
init_buffer();
var htmlVoidElements = [
  "area",
  "base",
  "basefont",
  "bgsound",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "image",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];

// node_modules/property-information/index.js
init_process();
init_buffer();

// node_modules/property-information/lib/util/merge.js
init_process();
init_buffer();

// node_modules/property-information/lib/util/schema.js
init_process();
init_buffer();
var Schema2 = class {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(property, normal, space2) {
    this.property = property;
    this.normal = normal;
    if (space2) {
      this.space = space2;
    }
  }
};
Schema2.prototype.property = {};
Schema2.prototype.normal = {};
Schema2.prototype.space = null;

// node_modules/property-information/lib/util/merge.js
function merge(definitions, space2) {
  const property = {};
  const normal = {};
  let index3 = -1;
  while (++index3 < definitions.length) {
    Object.assign(property, definitions[index3].property);
    Object.assign(normal, definitions[index3].normal);
  }
  return new Schema2(property, normal, space2);
}

// node_modules/property-information/lib/xlink.js
init_process();
init_buffer();

// node_modules/property-information/lib/util/create.js
init_process();
init_buffer();

// node_modules/property-information/lib/normalize.js
init_process();
init_buffer();
function normalize2(value) {
  return value.toLowerCase();
}

// node_modules/property-information/lib/util/defined-info.js
init_process();
init_buffer();

// node_modules/property-information/lib/util/info.js
init_process();
init_buffer();
var Info = class {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(property, attribute) {
    this.property = property;
    this.attribute = attribute;
  }
};
Info.prototype.space = null;
Info.prototype.boolean = false;
Info.prototype.booleanish = false;
Info.prototype.overloadedBoolean = false;
Info.prototype.number = false;
Info.prototype.commaSeparated = false;
Info.prototype.spaceSeparated = false;
Info.prototype.commaOrSpaceSeparated = false;
Info.prototype.mustUseProperty = false;
Info.prototype.defined = false;

// node_modules/property-information/lib/util/types.js
var types_exports = {};
__export(types_exports, {
  boolean: () => boolean,
  booleanish: () => booleanish,
  commaOrSpaceSeparated: () => commaOrSpaceSeparated,
  commaSeparated: () => commaSeparated,
  number: () => number,
  overloadedBoolean: () => overloadedBoolean,
  spaceSeparated: () => spaceSeparated
});
init_process();
init_buffer();
var powers = 0;
var boolean = increment();
var booleanish = increment();
var overloadedBoolean = increment();
var number = increment();
var spaceSeparated = increment();
var commaSeparated = increment();
var commaOrSpaceSeparated = increment();
function increment() {
  return 2 ** ++powers;
}

// node_modules/property-information/lib/util/defined-info.js
var checks = Object.keys(types_exports);
var DefinedInfo = class extends Info {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(property, attribute, mask, space2) {
    let index3 = -1;
    super(property, attribute);
    mark(this, "space", space2);
    if (typeof mask === "number") {
      while (++index3 < checks.length) {
        const check = checks[index3];
        mark(this, checks[index3], (mask & types_exports[check]) === types_exports[check]);
      }
    }
  }
};
DefinedInfo.prototype.defined = true;
function mark(values, key2, value) {
  if (value) {
    values[key2] = value;
  }
}

// node_modules/property-information/lib/util/create.js
var own = {}.hasOwnProperty;
function create(definition3) {
  const property = {};
  const normal = {};
  let prop;
  for (prop in definition3.properties) {
    if (own.call(definition3.properties, prop)) {
      const value = definition3.properties[prop];
      const info2 = new DefinedInfo(
        prop,
        definition3.transform(definition3.attributes || {}, prop),
        value,
        definition3.space
      );
      if (definition3.mustUseProperty && definition3.mustUseProperty.includes(prop)) {
        info2.mustUseProperty = true;
      }
      property[prop] = info2;
      normal[normalize2(prop)] = prop;
      normal[normalize2(info2.attribute)] = prop;
    }
  }
  return new Schema2(property, normal, definition3.space);
}

// node_modules/property-information/lib/xlink.js
var xlink = create({
  space: "xlink",
  transform(_, prop) {
    return "xlink:" + prop.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
});

// node_modules/property-information/lib/xml.js
init_process();
init_buffer();
var xml = create({
  space: "xml",
  transform(_, prop) {
    return "xml:" + prop.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});

// node_modules/property-information/lib/xmlns.js
init_process();
init_buffer();

// node_modules/property-information/lib/util/case-insensitive-transform.js
init_process();
init_buffer();

// node_modules/property-information/lib/util/case-sensitive-transform.js
init_process();
init_buffer();
function caseSensitiveTransform(attributes, attribute) {
  return attribute in attributes ? attributes[attribute] : attribute;
}

// node_modules/property-information/lib/util/case-insensitive-transform.js
function caseInsensitiveTransform(attributes, property) {
  return caseSensitiveTransform(attributes, property.toLowerCase());
}

// node_modules/property-information/lib/xmlns.js
var xmlns = create({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: caseInsensitiveTransform,
  properties: { xmlns: null, xmlnsXLink: null }
});

// node_modules/property-information/lib/aria.js
init_process();
init_buffer();
var aria = create({
  transform(_, prop) {
    return prop === "role" ? prop : "aria-" + prop.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: booleanish,
    ariaAutoComplete: null,
    ariaBusy: booleanish,
    ariaChecked: booleanish,
    ariaColCount: number,
    ariaColIndex: number,
    ariaColSpan: number,
    ariaControls: spaceSeparated,
    ariaCurrent: null,
    ariaDescribedBy: spaceSeparated,
    ariaDetails: null,
    ariaDisabled: booleanish,
    ariaDropEffect: spaceSeparated,
    ariaErrorMessage: null,
    ariaExpanded: booleanish,
    ariaFlowTo: spaceSeparated,
    ariaGrabbed: booleanish,
    ariaHasPopup: null,
    ariaHidden: booleanish,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: spaceSeparated,
    ariaLevel: number,
    ariaLive: null,
    ariaModal: booleanish,
    ariaMultiLine: booleanish,
    ariaMultiSelectable: booleanish,
    ariaOrientation: null,
    ariaOwns: spaceSeparated,
    ariaPlaceholder: null,
    ariaPosInSet: number,
    ariaPressed: booleanish,
    ariaReadOnly: booleanish,
    ariaRelevant: null,
    ariaRequired: booleanish,
    ariaRoleDescription: spaceSeparated,
    ariaRowCount: number,
    ariaRowIndex: number,
    ariaRowSpan: number,
    ariaSelected: booleanish,
    ariaSetSize: number,
    ariaSort: null,
    ariaValueMax: number,
    ariaValueMin: number,
    ariaValueNow: number,
    ariaValueText: null,
    role: null
  }
});

// node_modules/property-information/lib/html.js
init_process();
init_buffer();
var html = create({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: caseInsensitiveTransform,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: commaSeparated,
    acceptCharset: spaceSeparated,
    accessKey: spaceSeparated,
    action: null,
    allow: null,
    allowFullScreen: boolean,
    allowPaymentRequest: boolean,
    allowUserMedia: boolean,
    alt: null,
    as: null,
    async: boolean,
    autoCapitalize: null,
    autoComplete: spaceSeparated,
    autoFocus: boolean,
    autoPlay: boolean,
    blocking: spaceSeparated,
    capture: null,
    charSet: null,
    checked: boolean,
    cite: null,
    className: spaceSeparated,
    cols: number,
    colSpan: null,
    content: null,
    contentEditable: booleanish,
    controls: boolean,
    controlsList: spaceSeparated,
    coords: number | commaSeparated,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: boolean,
    defer: boolean,
    dir: null,
    dirName: null,
    disabled: boolean,
    download: overloadedBoolean,
    draggable: booleanish,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: boolean,
    formTarget: null,
    headers: spaceSeparated,
    height: number,
    hidden: boolean,
    high: number,
    href: null,
    hrefLang: null,
    htmlFor: spaceSeparated,
    httpEquiv: spaceSeparated,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: boolean,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: boolean,
    itemId: null,
    itemProp: spaceSeparated,
    itemRef: spaceSeparated,
    itemScope: boolean,
    itemType: spaceSeparated,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: boolean,
    low: number,
    manifest: null,
    max: null,
    maxLength: number,
    media: null,
    method: null,
    min: null,
    minLength: number,
    multiple: boolean,
    muted: boolean,
    name: null,
    nonce: null,
    noModule: boolean,
    noValidate: boolean,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: boolean,
    optimum: number,
    pattern: null,
    ping: spaceSeparated,
    placeholder: null,
    playsInline: boolean,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: boolean,
    referrerPolicy: null,
    rel: spaceSeparated,
    required: boolean,
    reversed: boolean,
    rows: number,
    rowSpan: number,
    sandbox: spaceSeparated,
    scope: null,
    scoped: boolean,
    seamless: boolean,
    selected: boolean,
    shadowRootClonable: boolean,
    shadowRootDelegatesFocus: boolean,
    shadowRootMode: null,
    shape: null,
    size: number,
    sizes: null,
    slot: null,
    span: number,
    spellCheck: booleanish,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: number,
    step: null,
    style: null,
    tabIndex: number,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: boolean,
    useMap: null,
    value: booleanish,
    width: number,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: spaceSeparated,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: number,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: number,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: boolean,
    // Lists. Use CSS to reduce space between items instead
    declare: boolean,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: number,
    // `<img>` and `<object>`
    leftMargin: number,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: number,
    // `<body>`
    marginWidth: number,
    // `<body>`
    noResize: boolean,
    // `<frame>`
    noHref: boolean,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: boolean,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: boolean,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: number,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: booleanish,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: number,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: number,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: boolean,
    disableRemotePlayback: boolean,
    prefix: null,
    property: null,
    results: number,
    security: null,
    unselectable: null
  }
});

// node_modules/property-information/lib/svg.js
init_process();
init_buffer();
var svg = create({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: caseSensitiveTransform,
  properties: {
    about: commaOrSpaceSeparated,
    accentHeight: number,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: number,
    amplitude: number,
    arabicForm: null,
    ascent: number,
    attributeName: null,
    attributeType: null,
    azimuth: number,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: number,
    by: null,
    calcMode: null,
    capHeight: number,
    className: spaceSeparated,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: number,
    diffuseConstant: number,
    direction: null,
    display: null,
    dur: null,
    divisor: number,
    dominantBaseline: null,
    download: boolean,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: number,
    enableBackground: null,
    end: null,
    event: null,
    exponent: number,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: number,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: commaSeparated,
    g2: commaSeparated,
    glyphName: commaSeparated,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: number,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: number,
    horizOriginX: number,
    horizOriginY: number,
    id: null,
    ideographic: number,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: number,
    k: number,
    k1: number,
    k2: number,
    k3: number,
    k4: number,
    kernelMatrix: commaOrSpaceSeparated,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: number,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: number,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: number,
    overlineThickness: number,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: number,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: spaceSeparated,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: number,
    pointsAtY: number,
    pointsAtZ: number,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: commaOrSpaceSeparated,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: commaOrSpaceSeparated,
    rev: commaOrSpaceSeparated,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: commaOrSpaceSeparated,
    requiredFeatures: commaOrSpaceSeparated,
    requiredFonts: commaOrSpaceSeparated,
    requiredFormats: commaOrSpaceSeparated,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: number,
    specularExponent: number,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: number,
    strikethroughThickness: number,
    string: null,
    stroke: null,
    strokeDashArray: commaOrSpaceSeparated,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: number,
    strokeOpacity: number,
    strokeWidth: null,
    style: null,
    surfaceScale: number,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: commaOrSpaceSeparated,
    tabIndex: number,
    tableValues: null,
    target: null,
    targetX: number,
    targetY: number,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: commaOrSpaceSeparated,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: number,
    underlineThickness: number,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: number,
    values: null,
    vAlphabetic: number,
    vMathematical: number,
    vectorEffect: null,
    vHanging: number,
    vIdeographic: number,
    version: null,
    vertAdvY: number,
    vertOriginX: number,
    vertOriginY: number,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: number,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
});

// node_modules/property-information/lib/find.js
init_process();
init_buffer();
var valid = /^data[-\w.:]+$/i;
var dash = /-[a-z]/g;
var cap = /[A-Z]/g;
function find(schema, value) {
  const normal = normalize2(value);
  let prop = value;
  let Type2 = Info;
  if (normal in schema.normal) {
    return schema.property[schema.normal[normal]];
  }
  if (normal.length > 4 && normal.slice(0, 4) === "data" && valid.test(value)) {
    if (value.charAt(4) === "-") {
      const rest = value.slice(5).replace(dash, camelcase);
      prop = "data" + rest.charAt(0).toUpperCase() + rest.slice(1);
    } else {
      const rest = value.slice(4);
      if (!dash.test(rest)) {
        let dashes = rest.replace(cap, kebab);
        if (dashes.charAt(0) !== "-") {
          dashes = "-" + dashes;
        }
        value = "data" + dashes;
      }
    }
    Type2 = DefinedInfo;
  }
  return new Type2(prop, value);
}
function kebab($0) {
  return "-" + $0.toLowerCase();
}
function camelcase($0) {
  return $0.charAt(1).toUpperCase();
}

// node_modules/property-information/index.js
var html2 = merge([xml, xlink, xmlns, aria, html], "html");
var svg2 = merge([xml, xlink, xmlns, aria, svg], "svg");

// node_modules/hast-util-to-html/lib/handle/index.js
init_process();
init_buffer();

// node_modules/zwitch/index.js
init_process();
init_buffer();
var own2 = {}.hasOwnProperty;
function zwitch(key2, options) {
  const settings = options || {};
  function one4(value, ...parameters) {
    let fn = one4.invalid;
    const handlers2 = one4.handlers;
    if (value && own2.call(value, key2)) {
      const id = String(value[key2]);
      fn = own2.call(handlers2, id) ? handlers2[id] : one4.unknown;
    }
    if (fn) {
      return fn.call(this, value, ...parameters);
    }
  }
  one4.handlers = settings.handlers || {};
  one4.invalid = settings.invalid;
  one4.unknown = settings.unknown;
  return one4;
}

// node_modules/hast-util-to-html/lib/handle/comment.js
init_process();
init_buffer();

// node_modules/stringify-entities/lib/index.js
init_process();
init_buffer();

// node_modules/stringify-entities/lib/core.js
init_process();
init_buffer();
var defaultSubsetRegex = /["&'<>`]/g;
var surrogatePairsRegex = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
var controlCharactersRegex = (
  // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
  /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g
);
var regexEscapeRegex = /[|\\{}()[\]^$+*?.]/g;
var subsetToRegexCache = /* @__PURE__ */ new WeakMap();
function core(value, options) {
  value = value.replace(
    options.subset ? charactersToExpressionCached(options.subset) : defaultSubsetRegex,
    basic
  );
  if (options.subset || options.escapeOnly) {
    return value;
  }
  return value.replace(surrogatePairsRegex, surrogate).replace(controlCharactersRegex, basic);
  function surrogate(pair, index3, all4) {
    return options.format(
      (pair.charCodeAt(0) - 55296) * 1024 + pair.charCodeAt(1) - 56320 + 65536,
      all4.charCodeAt(index3 + 2),
      options
    );
  }
  function basic(character, index3, all4) {
    return options.format(
      character.charCodeAt(0),
      all4.charCodeAt(index3 + 1),
      options
    );
  }
}
function charactersToExpressionCached(subset) {
  let cached = subsetToRegexCache.get(subset);
  if (!cached) {
    cached = charactersToExpression(subset);
    subsetToRegexCache.set(subset, cached);
  }
  return cached;
}
function charactersToExpression(subset) {
  const groups = [];
  let index3 = -1;
  while (++index3 < subset.length) {
    groups.push(subset[index3].replace(regexEscapeRegex, "\\$&"));
  }
  return new RegExp("(?:" + groups.join("|") + ")", "g");
}

// node_modules/stringify-entities/lib/util/format-smart.js
init_process();
init_buffer();

// node_modules/stringify-entities/lib/util/to-hexadecimal.js
init_process();
init_buffer();
var hexadecimalRegex = /[\dA-Fa-f]/;
function toHexadecimal(code4, next, omit) {
  const value = "&#x" + code4.toString(16).toUpperCase();
  return omit && next && !hexadecimalRegex.test(String.fromCharCode(next)) ? value : value + ";";
}

// node_modules/stringify-entities/lib/util/to-decimal.js
init_process();
init_buffer();
var decimalRegex = /\d/;
function toDecimal(code4, next, omit) {
  const value = "&#" + String(code4);
  return omit && next && !decimalRegex.test(String.fromCharCode(next)) ? value : value + ";";
}

// node_modules/stringify-entities/lib/util/to-named.js
init_process();
init_buffer();

// node_modules/stringify-entities/node_modules/character-entities-legacy/index.js
init_process();
init_buffer();
var characterEntitiesLegacy = [
  "AElig",
  "AMP",
  "Aacute",
  "Acirc",
  "Agrave",
  "Aring",
  "Atilde",
  "Auml",
  "COPY",
  "Ccedil",
  "ETH",
  "Eacute",
  "Ecirc",
  "Egrave",
  "Euml",
  "GT",
  "Iacute",
  "Icirc",
  "Igrave",
  "Iuml",
  "LT",
  "Ntilde",
  "Oacute",
  "Ocirc",
  "Ograve",
  "Oslash",
  "Otilde",
  "Ouml",
  "QUOT",
  "REG",
  "THORN",
  "Uacute",
  "Ucirc",
  "Ugrave",
  "Uuml",
  "Yacute",
  "aacute",
  "acirc",
  "acute",
  "aelig",
  "agrave",
  "amp",
  "aring",
  "atilde",
  "auml",
  "brvbar",
  "ccedil",
  "cedil",
  "cent",
  "copy",
  "curren",
  "deg",
  "divide",
  "eacute",
  "ecirc",
  "egrave",
  "eth",
  "euml",
  "frac12",
  "frac14",
  "frac34",
  "gt",
  "iacute",
  "icirc",
  "iexcl",
  "igrave",
  "iquest",
  "iuml",
  "laquo",
  "lt",
  "macr",
  "micro",
  "middot",
  "nbsp",
  "not",
  "ntilde",
  "oacute",
  "ocirc",
  "ograve",
  "ordf",
  "ordm",
  "oslash",
  "otilde",
  "ouml",
  "para",
  "plusmn",
  "pound",
  "quot",
  "raquo",
  "reg",
  "sect",
  "shy",
  "sup1",
  "sup2",
  "sup3",
  "szlig",
  "thorn",
  "times",
  "uacute",
  "ucirc",
  "ugrave",
  "uml",
  "uuml",
  "yacute",
  "yen",
  "yuml"
];

// node_modules/character-entities-html4/index.js
init_process();
init_buffer();
var characterEntitiesHtml4 = {
  nbsp: "\xA0",
  iexcl: "\xA1",
  cent: "\xA2",
  pound: "\xA3",
  curren: "\xA4",
  yen: "\xA5",
  brvbar: "\xA6",
  sect: "\xA7",
  uml: "\xA8",
  copy: "\xA9",
  ordf: "\xAA",
  laquo: "\xAB",
  not: "\xAC",
  shy: "\xAD",
  reg: "\xAE",
  macr: "\xAF",
  deg: "\xB0",
  plusmn: "\xB1",
  sup2: "\xB2",
  sup3: "\xB3",
  acute: "\xB4",
  micro: "\xB5",
  para: "\xB6",
  middot: "\xB7",
  cedil: "\xB8",
  sup1: "\xB9",
  ordm: "\xBA",
  raquo: "\xBB",
  frac14: "\xBC",
  frac12: "\xBD",
  frac34: "\xBE",
  iquest: "\xBF",
  Agrave: "\xC0",
  Aacute: "\xC1",
  Acirc: "\xC2",
  Atilde: "\xC3",
  Auml: "\xC4",
  Aring: "\xC5",
  AElig: "\xC6",
  Ccedil: "\xC7",
  Egrave: "\xC8",
  Eacute: "\xC9",
  Ecirc: "\xCA",
  Euml: "\xCB",
  Igrave: "\xCC",
  Iacute: "\xCD",
  Icirc: "\xCE",
  Iuml: "\xCF",
  ETH: "\xD0",
  Ntilde: "\xD1",
  Ograve: "\xD2",
  Oacute: "\xD3",
  Ocirc: "\xD4",
  Otilde: "\xD5",
  Ouml: "\xD6",
  times: "\xD7",
  Oslash: "\xD8",
  Ugrave: "\xD9",
  Uacute: "\xDA",
  Ucirc: "\xDB",
  Uuml: "\xDC",
  Yacute: "\xDD",
  THORN: "\xDE",
  szlig: "\xDF",
  agrave: "\xE0",
  aacute: "\xE1",
  acirc: "\xE2",
  atilde: "\xE3",
  auml: "\xE4",
  aring: "\xE5",
  aelig: "\xE6",
  ccedil: "\xE7",
  egrave: "\xE8",
  eacute: "\xE9",
  ecirc: "\xEA",
  euml: "\xEB",
  igrave: "\xEC",
  iacute: "\xED",
  icirc: "\xEE",
  iuml: "\xEF",
  eth: "\xF0",
  ntilde: "\xF1",
  ograve: "\xF2",
  oacute: "\xF3",
  ocirc: "\xF4",
  otilde: "\xF5",
  ouml: "\xF6",
  divide: "\xF7",
  oslash: "\xF8",
  ugrave: "\xF9",
  uacute: "\xFA",
  ucirc: "\xFB",
  uuml: "\xFC",
  yacute: "\xFD",
  thorn: "\xFE",
  yuml: "\xFF",
  fnof: "\u0192",
  Alpha: "\u0391",
  Beta: "\u0392",
  Gamma: "\u0393",
  Delta: "\u0394",
  Epsilon: "\u0395",
  Zeta: "\u0396",
  Eta: "\u0397",
  Theta: "\u0398",
  Iota: "\u0399",
  Kappa: "\u039A",
  Lambda: "\u039B",
  Mu: "\u039C",
  Nu: "\u039D",
  Xi: "\u039E",
  Omicron: "\u039F",
  Pi: "\u03A0",
  Rho: "\u03A1",
  Sigma: "\u03A3",
  Tau: "\u03A4",
  Upsilon: "\u03A5",
  Phi: "\u03A6",
  Chi: "\u03A7",
  Psi: "\u03A8",
  Omega: "\u03A9",
  alpha: "\u03B1",
  beta: "\u03B2",
  gamma: "\u03B3",
  delta: "\u03B4",
  epsilon: "\u03B5",
  zeta: "\u03B6",
  eta: "\u03B7",
  theta: "\u03B8",
  iota: "\u03B9",
  kappa: "\u03BA",
  lambda: "\u03BB",
  mu: "\u03BC",
  nu: "\u03BD",
  xi: "\u03BE",
  omicron: "\u03BF",
  pi: "\u03C0",
  rho: "\u03C1",
  sigmaf: "\u03C2",
  sigma: "\u03C3",
  tau: "\u03C4",
  upsilon: "\u03C5",
  phi: "\u03C6",
  chi: "\u03C7",
  psi: "\u03C8",
  omega: "\u03C9",
  thetasym: "\u03D1",
  upsih: "\u03D2",
  piv: "\u03D6",
  bull: "\u2022",
  hellip: "\u2026",
  prime: "\u2032",
  Prime: "\u2033",
  oline: "\u203E",
  frasl: "\u2044",
  weierp: "\u2118",
  image: "\u2111",
  real: "\u211C",
  trade: "\u2122",
  alefsym: "\u2135",
  larr: "\u2190",
  uarr: "\u2191",
  rarr: "\u2192",
  darr: "\u2193",
  harr: "\u2194",
  crarr: "\u21B5",
  lArr: "\u21D0",
  uArr: "\u21D1",
  rArr: "\u21D2",
  dArr: "\u21D3",
  hArr: "\u21D4",
  forall: "\u2200",
  part: "\u2202",
  exist: "\u2203",
  empty: "\u2205",
  nabla: "\u2207",
  isin: "\u2208",
  notin: "\u2209",
  ni: "\u220B",
  prod: "\u220F",
  sum: "\u2211",
  minus: "\u2212",
  lowast: "\u2217",
  radic: "\u221A",
  prop: "\u221D",
  infin: "\u221E",
  ang: "\u2220",
  and: "\u2227",
  or: "\u2228",
  cap: "\u2229",
  cup: "\u222A",
  int: "\u222B",
  there4: "\u2234",
  sim: "\u223C",
  cong: "\u2245",
  asymp: "\u2248",
  ne: "\u2260",
  equiv: "\u2261",
  le: "\u2264",
  ge: "\u2265",
  sub: "\u2282",
  sup: "\u2283",
  nsub: "\u2284",
  sube: "\u2286",
  supe: "\u2287",
  oplus: "\u2295",
  otimes: "\u2297",
  perp: "\u22A5",
  sdot: "\u22C5",
  lceil: "\u2308",
  rceil: "\u2309",
  lfloor: "\u230A",
  rfloor: "\u230B",
  lang: "\u2329",
  rang: "\u232A",
  loz: "\u25CA",
  spades: "\u2660",
  clubs: "\u2663",
  hearts: "\u2665",
  diams: "\u2666",
  quot: '"',
  amp: "&",
  lt: "<",
  gt: ">",
  OElig: "\u0152",
  oelig: "\u0153",
  Scaron: "\u0160",
  scaron: "\u0161",
  Yuml: "\u0178",
  circ: "\u02C6",
  tilde: "\u02DC",
  ensp: "\u2002",
  emsp: "\u2003",
  thinsp: "\u2009",
  zwnj: "\u200C",
  zwj: "\u200D",
  lrm: "\u200E",
  rlm: "\u200F",
  ndash: "\u2013",
  mdash: "\u2014",
  lsquo: "\u2018",
  rsquo: "\u2019",
  sbquo: "\u201A",
  ldquo: "\u201C",
  rdquo: "\u201D",
  bdquo: "\u201E",
  dagger: "\u2020",
  Dagger: "\u2021",
  permil: "\u2030",
  lsaquo: "\u2039",
  rsaquo: "\u203A",
  euro: "\u20AC"
};

// node_modules/stringify-entities/lib/constant/dangerous.js
init_process();
init_buffer();
var dangerous = [
  "cent",
  "copy",
  "divide",
  "gt",
  "lt",
  "not",
  "para",
  "times"
];

// node_modules/stringify-entities/lib/util/to-named.js
var own3 = {}.hasOwnProperty;
var characters = {};
var key;
for (key in characterEntitiesHtml4) {
  if (own3.call(characterEntitiesHtml4, key)) {
    characters[characterEntitiesHtml4[key]] = key;
  }
}
var notAlphanumericRegex = /[^\dA-Za-z]/;
function toNamed(code4, next, omit, attribute) {
  const character = String.fromCharCode(code4);
  if (own3.call(characters, character)) {
    const name = characters[character];
    const value = "&" + name;
    if (omit && characterEntitiesLegacy.includes(name) && !dangerous.includes(name) && (!attribute || next && next !== 61 && notAlphanumericRegex.test(String.fromCharCode(next)))) {
      return value;
    }
    return value + ";";
  }
  return "";
}

// node_modules/stringify-entities/lib/util/format-smart.js
function formatSmart(code4, next, options) {
  let numeric = toHexadecimal(code4, next, options.omitOptionalSemicolons);
  let named;
  if (options.useNamedReferences || options.useShortestReferences) {
    named = toNamed(
      code4,
      next,
      options.omitOptionalSemicolons,
      options.attribute
    );
  }
  if ((options.useShortestReferences || !named) && options.useShortestReferences) {
    const decimal = toDecimal(code4, next, options.omitOptionalSemicolons);
    if (decimal.length < numeric.length) {
      numeric = decimal;
    }
  }
  return named && (!options.useShortestReferences || named.length < numeric.length) ? named : numeric;
}

// node_modules/stringify-entities/lib/index.js
function stringifyEntities(value, options) {
  return core(value, Object.assign({ format: formatSmart }, options));
}

// node_modules/hast-util-to-html/lib/handle/comment.js
var htmlCommentRegex = /^>|^->|<!--|-->|--!>|<!-$/g;
var bogusCommentEntitySubset = [">"];
var commentEntitySubset = ["<", ">"];
function comment(node3, _1, _2, state) {
  return state.settings.bogusComments ? "<?" + stringifyEntities(
    node3.value,
    Object.assign({}, state.settings.characterReferences, {
      subset: bogusCommentEntitySubset
    })
  ) + ">" : "<!--" + node3.value.replace(htmlCommentRegex, encode3) + "-->";
  function encode3($0) {
    return stringifyEntities(
      $0,
      Object.assign({}, state.settings.characterReferences, {
        subset: commentEntitySubset
      })
    );
  }
}

// node_modules/hast-util-to-html/lib/handle/doctype.js
init_process();
init_buffer();
function doctype(_1, _2, _3, state) {
  return "<!" + (state.settings.upperDoctype ? "DOCTYPE" : "doctype") + (state.settings.tightDoctype ? "" : " ") + "html>";
}

// node_modules/hast-util-to-html/lib/handle/element.js
init_process();
init_buffer();

// node_modules/ccount/index.js
init_process();
init_buffer();
function ccount(value, character) {
  const source = String(value);
  if (typeof character !== "string") {
    throw new TypeError("Expected character");
  }
  let count2 = 0;
  let index3 = source.indexOf(character);
  while (index3 !== -1) {
    count2++;
    index3 = source.indexOf(character, index3 + character.length);
  }
  return count2;
}

// node_modules/comma-separated-tokens/index.js
init_process();
init_buffer();
function stringify(values, options) {
  const settings = options || {};
  const input = values[values.length - 1] === "" ? [...values, ""] : values;
  return input.join(
    (settings.padRight ? " " : "") + "," + (settings.padLeft === false ? "" : " ")
  ).trim();
}

// node_modules/space-separated-tokens/index.js
init_process();
init_buffer();
function stringify2(values) {
  return values.join(" ").trim();
}

// node_modules/hast-util-to-html/lib/omission/closing.js
init_process();
init_buffer();

// node_modules/hast-util-whitespace/index.js
init_process();
init_buffer();

// node_modules/hast-util-whitespace/lib/index.js
init_process();
init_buffer();
var re = /[ \t\n\f\r]/g;
function whitespace(thing) {
  return typeof thing === "object" ? thing.type === "text" ? empty(thing.value) : false : empty(thing);
}
function empty(value) {
  return value.replace(re, "") === "";
}

// node_modules/hast-util-to-html/lib/omission/util/siblings.js
init_process();
init_buffer();
var siblingAfter = siblings(1);
var siblingBefore = siblings(-1);
var emptyChildren = [];
function siblings(increment2) {
  return sibling;
  function sibling(parent, index3, includeWhitespace) {
    const siblings2 = parent ? parent.children : emptyChildren;
    let offset = (index3 || 0) + increment2;
    let next = siblings2[offset];
    if (!includeWhitespace) {
      while (next && whitespace(next)) {
        offset += increment2;
        next = siblings2[offset];
      }
    }
    return next;
  }
}

// node_modules/hast-util-to-html/lib/omission/omission.js
init_process();
init_buffer();
var own4 = {}.hasOwnProperty;
function omission(handlers2) {
  return omit;
  function omit(node3, index3, parent) {
    return own4.call(handlers2, node3.tagName) && handlers2[node3.tagName](node3, index3, parent);
  }
}

// node_modules/hast-util-to-html/lib/omission/closing.js
var closing = omission({
  body,
  caption: headOrColgroupOrCaption,
  colgroup: headOrColgroupOrCaption,
  dd,
  dt,
  head: headOrColgroupOrCaption,
  html: html3,
  li,
  optgroup,
  option,
  p: p2,
  rp: rubyElement,
  rt: rubyElement,
  tbody,
  td: cells,
  tfoot,
  th: cells,
  thead,
  tr
});
function headOrColgroupOrCaption(_, index3, parent) {
  const next = siblingAfter(parent, index3, true);
  return !next || next.type !== "comment" && !(next.type === "text" && whitespace(next.value.charAt(0)));
}
function html3(_, index3, parent) {
  const next = siblingAfter(parent, index3);
  return !next || next.type !== "comment";
}
function body(_, index3, parent) {
  const next = siblingAfter(parent, index3);
  return !next || next.type !== "comment";
}
function p2(_, index3, parent) {
  const next = siblingAfter(parent, index3);
  return next ? next.type === "element" && (next.tagName === "address" || next.tagName === "article" || next.tagName === "aside" || next.tagName === "blockquote" || next.tagName === "details" || next.tagName === "div" || next.tagName === "dl" || next.tagName === "fieldset" || next.tagName === "figcaption" || next.tagName === "figure" || next.tagName === "footer" || next.tagName === "form" || next.tagName === "h1" || next.tagName === "h2" || next.tagName === "h3" || next.tagName === "h4" || next.tagName === "h5" || next.tagName === "h6" || next.tagName === "header" || next.tagName === "hgroup" || next.tagName === "hr" || next.tagName === "main" || next.tagName === "menu" || next.tagName === "nav" || next.tagName === "ol" || next.tagName === "p" || next.tagName === "pre" || next.tagName === "section" || next.tagName === "table" || next.tagName === "ul") : !parent || // Confusing parent.
  !(parent.type === "element" && (parent.tagName === "a" || parent.tagName === "audio" || parent.tagName === "del" || parent.tagName === "ins" || parent.tagName === "map" || parent.tagName === "noscript" || parent.tagName === "video"));
}
function li(_, index3, parent) {
  const next = siblingAfter(parent, index3);
  return !next || next.type === "element" && next.tagName === "li";
}
function dt(_, index3, parent) {
  const next = siblingAfter(parent, index3);
  return Boolean(
    next && next.type === "element" && (next.tagName === "dt" || next.tagName === "dd")
  );
}
function dd(_, index3, parent) {
  const next = siblingAfter(parent, index3);
  return !next || next.type === "element" && (next.tagName === "dt" || next.tagName === "dd");
}
function rubyElement(_, index3, parent) {
  const next = siblingAfter(parent, index3);
  return !next || next.type === "element" && (next.tagName === "rp" || next.tagName === "rt");
}
function optgroup(_, index3, parent) {
  const next = siblingAfter(parent, index3);
  return !next || next.type === "element" && next.tagName === "optgroup";
}
function option(_, index3, parent) {
  const next = siblingAfter(parent, index3);
  return !next || next.type === "element" && (next.tagName === "option" || next.tagName === "optgroup");
}
function thead(_, index3, parent) {
  const next = siblingAfter(parent, index3);
  return Boolean(
    next && next.type === "element" && (next.tagName === "tbody" || next.tagName === "tfoot")
  );
}
function tbody(_, index3, parent) {
  const next = siblingAfter(parent, index3);
  return !next || next.type === "element" && (next.tagName === "tbody" || next.tagName === "tfoot");
}
function tfoot(_, index3, parent) {
  return !siblingAfter(parent, index3);
}
function tr(_, index3, parent) {
  const next = siblingAfter(parent, index3);
  return !next || next.type === "element" && next.tagName === "tr";
}
function cells(_, index3, parent) {
  const next = siblingAfter(parent, index3);
  return !next || next.type === "element" && (next.tagName === "td" || next.tagName === "th");
}

// node_modules/hast-util-to-html/lib/omission/opening.js
init_process();
init_buffer();
var opening = omission({
  body: body2,
  colgroup,
  head,
  html: html4,
  tbody: tbody2
});
function html4(node3) {
  const head2 = siblingAfter(node3, -1);
  return !head2 || head2.type !== "comment";
}
function head(node3) {
  const children = node3.children;
  const seen = [];
  let index3 = -1;
  while (++index3 < children.length) {
    const child = children[index3];
    if (child.type === "element" && (child.tagName === "title" || child.tagName === "base")) {
      if (seen.includes(child.tagName))
        return false;
      seen.push(child.tagName);
    }
  }
  return children.length > 0;
}
function body2(node3) {
  const head2 = siblingAfter(node3, -1, true);
  return !head2 || head2.type !== "comment" && !(head2.type === "text" && whitespace(head2.value.charAt(0))) && !(head2.type === "element" && (head2.tagName === "meta" || head2.tagName === "link" || head2.tagName === "script" || head2.tagName === "style" || head2.tagName === "template"));
}
function colgroup(node3, index3, parent) {
  const previous3 = siblingBefore(parent, index3);
  const head2 = siblingAfter(node3, -1, true);
  if (parent && previous3 && previous3.type === "element" && previous3.tagName === "colgroup" && closing(previous3, parent.children.indexOf(previous3), parent)) {
    return false;
  }
  return Boolean(head2 && head2.type === "element" && head2.tagName === "col");
}
function tbody2(node3, index3, parent) {
  const previous3 = siblingBefore(parent, index3);
  const head2 = siblingAfter(node3, -1);
  if (parent && previous3 && previous3.type === "element" && (previous3.tagName === "thead" || previous3.tagName === "tbody") && closing(previous3, parent.children.indexOf(previous3), parent)) {
    return false;
  }
  return Boolean(head2 && head2.type === "element" && head2.tagName === "tr");
}

// node_modules/hast-util-to-html/lib/handle/element.js
var constants = {
  // See: <https://html.spec.whatwg.org/#attribute-name-state>.
  name: [
    ["	\n\f\r &/=>".split(""), "	\n\f\r \"&'/=>`".split("")],
    [`\0	
\f\r "&'/<=>`.split(""), "\0	\n\f\r \"&'/<=>`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(unquoted)-state>.
  unquoted: [
    ["	\n\f\r &>".split(""), "\0	\n\f\r \"&'<=>`".split("")],
    ["\0	\n\f\r \"&'<=>`".split(""), "\0	\n\f\r \"&'<=>`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(single-quoted)-state>.
  single: [
    ["&'".split(""), "\"&'`".split("")],
    ["\0&'".split(""), "\0\"&'`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(double-quoted)-state>.
  double: [
    ['"&'.split(""), "\"&'`".split("")],
    ['\0"&'.split(""), "\0\"&'`".split("")]
  ]
};
function element(node3, index3, parent, state) {
  const schema = state.schema;
  const omit = schema.space === "svg" ? false : state.settings.omitOptionalTags;
  let selfClosing = schema.space === "svg" ? state.settings.closeEmptyElements : state.settings.voids.includes(node3.tagName.toLowerCase());
  const parts = [];
  let last;
  if (schema.space === "html" && node3.tagName === "svg") {
    state.schema = svg2;
  }
  const attributes = serializeAttributes(state, node3.properties);
  const content3 = state.all(
    schema.space === "html" && node3.tagName === "template" ? node3.content : node3
  );
  state.schema = schema;
  if (content3)
    selfClosing = false;
  if (attributes || !omit || !opening(node3, index3, parent)) {
    parts.push("<", node3.tagName, attributes ? " " + attributes : "");
    if (selfClosing && (schema.space === "svg" || state.settings.closeSelfClosing)) {
      last = attributes.charAt(attributes.length - 1);
      if (!state.settings.tightSelfClosing || last === "/" || last && last !== '"' && last !== "'") {
        parts.push(" ");
      }
      parts.push("/");
    }
    parts.push(">");
  }
  parts.push(content3);
  if (!selfClosing && (!omit || !closing(node3, index3, parent))) {
    parts.push("</" + node3.tagName + ">");
  }
  return parts.join("");
}
function serializeAttributes(state, properties) {
  const values = [];
  let index3 = -1;
  let key2;
  if (properties) {
    for (key2 in properties) {
      if (properties[key2] !== null && properties[key2] !== void 0) {
        const value = serializeAttribute(state, key2, properties[key2]);
        if (value)
          values.push(value);
      }
    }
  }
  while (++index3 < values.length) {
    const last = state.settings.tightAttributes ? values[index3].charAt(values[index3].length - 1) : void 0;
    if (index3 !== values.length - 1 && last !== '"' && last !== "'") {
      values[index3] += " ";
    }
  }
  return values.join("");
}
function serializeAttribute(state, key2, value) {
  const info2 = find(state.schema, key2);
  const x2 = state.settings.allowParseErrors && state.schema.space === "html" ? 0 : 1;
  const y2 = state.settings.allowDangerousCharacters ? 0 : 1;
  let quote = state.quote;
  let result;
  if (info2.overloadedBoolean && (value === info2.attribute || value === "")) {
    value = true;
  } else if (info2.boolean || info2.overloadedBoolean && typeof value !== "string") {
    value = Boolean(value);
  }
  if (value === null || value === void 0 || value === false || typeof value === "number" && Number.isNaN(value)) {
    return "";
  }
  const name = stringifyEntities(
    info2.attribute,
    Object.assign({}, state.settings.characterReferences, {
      // Always encode without parse errors in non-HTML.
      subset: constants.name[x2][y2]
    })
  );
  if (value === true)
    return name;
  value = Array.isArray(value) ? (info2.commaSeparated ? stringify : stringify2)(value, {
    padLeft: !state.settings.tightCommaSeparatedLists
  }) : String(value);
  if (state.settings.collapseEmptyAttributes && !value)
    return name;
  if (state.settings.preferUnquoted) {
    result = stringifyEntities(
      value,
      Object.assign({}, state.settings.characterReferences, {
        attribute: true,
        subset: constants.unquoted[x2][y2]
      })
    );
  }
  if (result !== value) {
    if (state.settings.quoteSmart && ccount(value, quote) > ccount(value, state.alternative)) {
      quote = state.alternative;
    }
    result = quote + stringifyEntities(
      value,
      Object.assign({}, state.settings.characterReferences, {
        // Always encode without parse errors in non-HTML.
        subset: (quote === "'" ? constants.single : constants.double)[x2][y2],
        attribute: true
      })
    ) + quote;
  }
  return name + (result ? "=" + result : result);
}

// node_modules/hast-util-to-html/lib/handle/raw.js
init_process();
init_buffer();

// node_modules/hast-util-to-html/lib/handle/text.js
init_process();
init_buffer();
var textEntitySubset = ["<", "&"];
function text2(node3, _, parent, state) {
  return parent && parent.type === "element" && (parent.tagName === "script" || parent.tagName === "style") ? node3.value : stringifyEntities(
    node3.value,
    Object.assign({}, state.settings.characterReferences, {
      subset: textEntitySubset
    })
  );
}

// node_modules/hast-util-to-html/lib/handle/raw.js
function raw(node3, index3, parent, state) {
  return state.settings.allowDangerousHtml ? node3.value : text2(node3, index3, parent, state);
}

// node_modules/hast-util-to-html/lib/handle/root.js
init_process();
init_buffer();
function root(node3, _1, _2, state) {
  return state.all(node3);
}

// node_modules/hast-util-to-html/lib/handle/index.js
var handle = zwitch("type", {
  invalid,
  unknown,
  handlers: { comment, doctype, element, raw, root, text: text2 }
});
function invalid(node3) {
  throw new Error("Expected node, not `" + node3 + "`");
}
function unknown(node_) {
  const node3 = (
    /** @type {Nodes} */
    node_
  );
  throw new Error("Cannot compile unknown node `" + node3.type + "`");
}

// node_modules/hast-util-to-html/lib/index.js
var emptyOptions = {};
var emptyCharacterReferences = {};
var emptyChildren2 = [];
function toHtml(tree, options) {
  const options_ = options || emptyOptions;
  const quote = options_.quote || '"';
  const alternative = quote === '"' ? "'" : '"';
  if (quote !== '"' && quote !== "'") {
    throw new Error("Invalid quote `" + quote + "`, expected `'` or `\"`");
  }
  const state = {
    one,
    all,
    settings: {
      omitOptionalTags: options_.omitOptionalTags || false,
      allowParseErrors: options_.allowParseErrors || false,
      allowDangerousCharacters: options_.allowDangerousCharacters || false,
      quoteSmart: options_.quoteSmart || false,
      preferUnquoted: options_.preferUnquoted || false,
      tightAttributes: options_.tightAttributes || false,
      upperDoctype: options_.upperDoctype || false,
      tightDoctype: options_.tightDoctype || false,
      bogusComments: options_.bogusComments || false,
      tightCommaSeparatedLists: options_.tightCommaSeparatedLists || false,
      tightSelfClosing: options_.tightSelfClosing || false,
      collapseEmptyAttributes: options_.collapseEmptyAttributes || false,
      allowDangerousHtml: options_.allowDangerousHtml || false,
      voids: options_.voids || htmlVoidElements,
      characterReferences: options_.characterReferences || emptyCharacterReferences,
      closeSelfClosing: options_.closeSelfClosing || false,
      closeEmptyElements: options_.closeEmptyElements || false
    },
    schema: options_.space === "svg" ? svg2 : html2,
    quote,
    alternative
  };
  return state.one(
    Array.isArray(tree) ? { type: "root", children: tree } : tree,
    void 0,
    void 0
  );
}
function one(node3, index3, parent) {
  return handle(node3, index3, parent, this);
}
function all(parent) {
  const results = [];
  const children = parent && parent.children || emptyChildren2;
  let index3 = -1;
  while (++index3 < children.length) {
    results[index3] = this.one(children[index3], index3, parent);
  }
  return results.join("");
}

// node_modules/rehype-stringify/lib/index.js
function rehypeStringify(options) {
  const self2 = this;
  const settings = { ...self2.data("settings"), ...options };
  self2.compiler = compiler2;
  function compiler2(tree) {
    return toHtml(tree, settings);
  }
}

// node_modules/remark-gfm/index.js
init_process();
init_buffer();

// node_modules/remark-gfm/lib/index.js
init_process();
init_buffer();

// node_modules/mdast-util-gfm/index.js
init_process();
init_buffer();

// node_modules/mdast-util-gfm/lib/index.js
init_process();
init_buffer();

// node_modules/mdast-util-gfm-autolink-literal/index.js
init_process();
init_buffer();

// node_modules/mdast-util-gfm-autolink-literal/lib/index.js
init_process();
init_buffer();

// node_modules/devlop/lib/default.js
init_process();
init_buffer();
function ok() {
}

// node_modules/micromark-util-character/index.js
init_process();
init_buffer();
var asciiAlpha = regexCheck(/[A-Za-z]/);
var asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
var asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
function asciiControl(code4) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    code4 !== null && (code4 < 32 || code4 === 127)
  );
}
var asciiDigit = regexCheck(/\d/);
var asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
var asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
function markdownLineEnding(code4) {
  return code4 !== null && code4 < -2;
}
function markdownLineEndingOrSpace(code4) {
  return code4 !== null && (code4 < 0 || code4 === 32);
}
function markdownSpace(code4) {
  return code4 === -2 || code4 === -1 || code4 === 32;
}
var unicodePunctuation = regexCheck(/\p{P}|\p{S}/u);
var unicodeWhitespace = regexCheck(/\s/);
function regexCheck(regex2) {
  return check;
  function check(code4) {
    return code4 !== null && code4 > -1 && regex2.test(String.fromCharCode(code4));
  }
}

// node_modules/mdast-util-find-and-replace/index.js
init_process();
init_buffer();

// node_modules/mdast-util-find-and-replace/lib/index.js
init_process();
init_buffer();

// node_modules/mdast-util-find-and-replace/node_modules/escape-string-regexp/index.js
init_process();
init_buffer();
function escapeStringRegexp(string3) {
  if (typeof string3 !== "string") {
    throw new TypeError("Expected a string");
  }
  return string3.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}

// node_modules/unist-util-visit-parents/index.js
init_process();
init_buffer();

// node_modules/unist-util-visit-parents/lib/index.js
init_process();
init_buffer();

// node_modules/unist-util-is/index.js
init_process();
init_buffer();

// node_modules/unist-util-is/lib/index.js
init_process();
init_buffer();
var convert = (
  // Note: overloads in JSDoc can’t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(test) {
    if (test === null || test === void 0) {
      return ok2;
    }
    if (typeof test === "function") {
      return castFactory(test);
    }
    if (typeof test === "object") {
      return Array.isArray(test) ? anyFactory(test) : propsFactory(test);
    }
    if (typeof test === "string") {
      return typeFactory(test);
    }
    throw new Error("Expected function, string, or object as test");
  }
);
function anyFactory(tests) {
  const checks2 = [];
  let index3 = -1;
  while (++index3 < tests.length) {
    checks2[index3] = convert(tests[index3]);
  }
  return castFactory(any);
  function any(...parameters) {
    let index4 = -1;
    while (++index4 < checks2.length) {
      if (checks2[index4].apply(this, parameters))
        return true;
    }
    return false;
  }
}
function propsFactory(check) {
  const checkAsRecord = (
    /** @type {Record<string, unknown>} */
    check
  );
  return castFactory(all4);
  function all4(node3) {
    const nodeAsRecord = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      node3
    );
    let key2;
    for (key2 in check) {
      if (nodeAsRecord[key2] !== checkAsRecord[key2])
        return false;
    }
    return true;
  }
}
function typeFactory(check) {
  return castFactory(type);
  function type(node3) {
    return node3 && node3.type === check;
  }
}
function castFactory(testFunction) {
  return check;
  function check(value, index3, parent) {
    return Boolean(
      looksLikeANode(value) && testFunction.call(
        this,
        value,
        typeof index3 === "number" ? index3 : void 0,
        parent || void 0
      )
    );
  }
}
function ok2() {
  return true;
}
function looksLikeANode(value) {
  return value !== null && typeof value === "object" && "type" in value;
}

// node_modules/unist-util-visit-parents/lib/color.js
init_process();
init_buffer();
function color(d2) {
  return d2;
}

// node_modules/unist-util-visit-parents/lib/index.js
var empty2 = [];
var CONTINUE = true;
var EXIT = false;
var SKIP = "skip";
function visitParents(tree, test, visitor, reverse) {
  let check;
  if (typeof test === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test;
  } else {
    check = test;
  }
  const is3 = convert(check);
  const step = reverse ? -1 : 1;
  factory(tree, void 0, [])();
  function factory(node3, index3, parents) {
    const value = (
      /** @type {Record<string, unknown>} */
      node3 && typeof node3 === "object" ? node3 : {}
    );
    if (typeof value.type === "string") {
      const name = (
        // `hast`
        typeof value.tagName === "string" ? value.tagName : (
          // `xast`
          typeof value.name === "string" ? value.name : void 0
        )
      );
      Object.defineProperty(visit2, "name", {
        value: "node (" + color(node3.type + (name ? "<" + name + ">" : "")) + ")"
      });
    }
    return visit2;
    function visit2() {
      let result = empty2;
      let subresult;
      let offset;
      let grandparents;
      if (!test || is3(node3, index3, parents[parents.length - 1] || void 0)) {
        result = toResult(visitor(node3, parents));
        if (result[0] === EXIT) {
          return result;
        }
      }
      if ("children" in node3 && node3.children) {
        const nodeAsParent = (
          /** @type {UnistParent} */
          node3
        );
        if (nodeAsParent.children && result[0] !== SKIP) {
          offset = (reverse ? nodeAsParent.children.length : -1) + step;
          grandparents = parents.concat(nodeAsParent);
          while (offset > -1 && offset < nodeAsParent.children.length) {
            const child = nodeAsParent.children[offset];
            subresult = factory(child, offset, grandparents)();
            if (subresult[0] === EXIT) {
              return subresult;
            }
            offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
          }
        }
      }
      return result;
    }
  }
}
function toResult(value) {
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE, value];
  }
  return value === null || value === void 0 ? empty2 : [value];
}

// node_modules/mdast-util-find-and-replace/lib/index.js
function findAndReplace(tree, list4, options) {
  const settings = options || {};
  const ignored = convert(settings.ignore || []);
  const pairs = toPairs(list4);
  let pairIndex = -1;
  while (++pairIndex < pairs.length) {
    visitParents(tree, "text", visitor);
  }
  function visitor(node3, parents) {
    let index3 = -1;
    let grandparent;
    while (++index3 < parents.length) {
      const parent = parents[index3];
      const siblings2 = grandparent ? grandparent.children : void 0;
      if (ignored(
        parent,
        siblings2 ? siblings2.indexOf(parent) : void 0,
        grandparent
      )) {
        return;
      }
      grandparent = parent;
    }
    if (grandparent) {
      return handler(node3, parents);
    }
  }
  function handler(node3, parents) {
    const parent = parents[parents.length - 1];
    const find2 = pairs[pairIndex][0];
    const replace2 = pairs[pairIndex][1];
    let start = 0;
    const siblings2 = parent.children;
    const index3 = siblings2.indexOf(node3);
    let change = false;
    let nodes = [];
    find2.lastIndex = 0;
    let match = find2.exec(node3.value);
    while (match) {
      const position4 = match.index;
      const matchObject = {
        index: match.index,
        input: match.input,
        stack: [...parents, node3]
      };
      let value = replace2(...match, matchObject);
      if (typeof value === "string") {
        value = value.length > 0 ? { type: "text", value } : void 0;
      }
      if (value === false) {
        find2.lastIndex = position4 + 1;
      } else {
        if (start !== position4) {
          nodes.push({
            type: "text",
            value: node3.value.slice(start, position4)
          });
        }
        if (Array.isArray(value)) {
          nodes.push(...value);
        } else if (value) {
          nodes.push(value);
        }
        start = position4 + match[0].length;
        change = true;
      }
      if (!find2.global) {
        break;
      }
      match = find2.exec(node3.value);
    }
    if (change) {
      if (start < node3.value.length) {
        nodes.push({ type: "text", value: node3.value.slice(start) });
      }
      parent.children.splice(index3, 1, ...nodes);
    } else {
      nodes = [node3];
    }
    return index3 + nodes.length;
  }
}
function toPairs(tupleOrList) {
  const result = [];
  if (!Array.isArray(tupleOrList)) {
    throw new TypeError("Expected find and replace tuple or list of tuples");
  }
  const list4 = !tupleOrList[0] || Array.isArray(tupleOrList[0]) ? tupleOrList : [tupleOrList];
  let index3 = -1;
  while (++index3 < list4.length) {
    const tuple = list4[index3];
    result.push([toExpression(tuple[0]), toFunction(tuple[1])]);
  }
  return result;
}
function toExpression(find2) {
  return typeof find2 === "string" ? new RegExp(escapeStringRegexp(find2), "g") : find2;
}
function toFunction(replace2) {
  return typeof replace2 === "function" ? replace2 : function() {
    return replace2;
  };
}

// node_modules/mdast-util-gfm-autolink-literal/lib/index.js
var inConstruct = "phrasing";
var notInConstruct = ["autolink", "link", "image", "label"];
function gfmAutolinkLiteralFromMarkdown() {
  return {
    transforms: [transformGfmAutolinkLiterals],
    enter: {
      literalAutolink: enterLiteralAutolink,
      literalAutolinkEmail: enterLiteralAutolinkValue,
      literalAutolinkHttp: enterLiteralAutolinkValue,
      literalAutolinkWww: enterLiteralAutolinkValue
    },
    exit: {
      literalAutolink: exitLiteralAutolink,
      literalAutolinkEmail: exitLiteralAutolinkEmail,
      literalAutolinkHttp: exitLiteralAutolinkHttp,
      literalAutolinkWww: exitLiteralAutolinkWww
    }
  };
}
function gfmAutolinkLiteralToMarkdown() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct,
        notInConstruct
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct,
        notInConstruct
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct,
        notInConstruct
      }
    ]
  };
}
function enterLiteralAutolink(token) {
  this.enter({ type: "link", title: null, url: "", children: [] }, token);
}
function enterLiteralAutolinkValue(token) {
  this.config.enter.autolinkProtocol.call(this, token);
}
function exitLiteralAutolinkHttp(token) {
  this.config.exit.autolinkProtocol.call(this, token);
}
function exitLiteralAutolinkWww(token) {
  this.config.exit.data.call(this, token);
  const node3 = this.stack[this.stack.length - 1];
  ok(node3.type === "link");
  node3.url = "http://" + this.sliceSerialize(token);
}
function exitLiteralAutolinkEmail(token) {
  this.config.exit.autolinkEmail.call(this, token);
}
function exitLiteralAutolink(token) {
  this.exit(token);
}
function transformGfmAutolinkLiterals(tree) {
  findAndReplace(
    tree,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, findUrl],
      [/([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/g, findEmail]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function findUrl(_, protocol, domain3, path2, match) {
  let prefix = "";
  if (!previous(match)) {
    return false;
  }
  if (/^w/i.test(protocol)) {
    domain3 = protocol + domain3;
    protocol = "";
    prefix = "http://";
  }
  if (!isCorrectDomain(domain3)) {
    return false;
  }
  const parts = splitUrl(domain3 + path2);
  if (!parts[0])
    return false;
  const result = {
    type: "link",
    title: null,
    url: prefix + protocol + parts[0],
    children: [{ type: "text", value: protocol + parts[0] }]
  };
  if (parts[1]) {
    return [result, { type: "text", value: parts[1] }];
  }
  return result;
}
function findEmail(_, atext, label, match) {
  if (
    // Not an expected previous character.
    !previous(match, true) || // Label ends in not allowed character.
    /[-\d_]$/.test(label)
  ) {
    return false;
  }
  return {
    type: "link",
    title: null,
    url: "mailto:" + atext + "@" + label,
    children: [{ type: "text", value: atext + "@" + label }]
  };
}
function isCorrectDomain(domain3) {
  const parts = domain3.split(".");
  if (parts.length < 2 || parts[parts.length - 1] && (/_/.test(parts[parts.length - 1]) || !/[a-zA-Z\d]/.test(parts[parts.length - 1])) || parts[parts.length - 2] && (/_/.test(parts[parts.length - 2]) || !/[a-zA-Z\d]/.test(parts[parts.length - 2]))) {
    return false;
  }
  return true;
}
function splitUrl(url) {
  const trailExec = /[!"&'),.:;<>?\]}]+$/.exec(url);
  if (!trailExec) {
    return [url, void 0];
  }
  url = url.slice(0, trailExec.index);
  let trail2 = trailExec[0];
  let closingParenIndex = trail2.indexOf(")");
  const openingParens = ccount(url, "(");
  let closingParens = ccount(url, ")");
  while (closingParenIndex !== -1 && openingParens > closingParens) {
    url += trail2.slice(0, closingParenIndex + 1);
    trail2 = trail2.slice(closingParenIndex + 1);
    closingParenIndex = trail2.indexOf(")");
    closingParens++;
  }
  return [url, trail2];
}
function previous(match, email) {
  const code4 = match.input.charCodeAt(match.index - 1);
  return (match.index === 0 || unicodeWhitespace(code4) || unicodePunctuation(code4)) && (!email || code4 !== 47);
}

// node_modules/mdast-util-gfm-footnote/index.js
init_process();
init_buffer();

// node_modules/mdast-util-gfm-footnote/lib/index.js
init_process();
init_buffer();

// node_modules/mdast-util-gfm-footnote/node_modules/micromark-util-normalize-identifier/index.js
init_process();
init_buffer();
function normalizeIdentifier(value) {
  return value.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}

// node_modules/mdast-util-gfm-footnote/lib/index.js
footnoteReference.peek = footnoteReferencePeek;
function gfmFootnoteFromMarkdown() {
  return {
    enter: {
      gfmFootnoteDefinition: enterFootnoteDefinition,
      gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,
      gfmFootnoteCall: enterFootnoteCall,
      gfmFootnoteCallString: enterFootnoteCallString
    },
    exit: {
      gfmFootnoteDefinition: exitFootnoteDefinition,
      gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,
      gfmFootnoteCall: exitFootnoteCall,
      gfmFootnoteCallString: exitFootnoteCallString
    }
  };
}
function gfmFootnoteToMarkdown() {
  return {
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["phrasing", "label", "reference"] }],
    handlers: { footnoteDefinition, footnoteReference }
  };
}
function enterFootnoteDefinition(token) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    token
  );
}
function enterFootnoteDefinitionLabelString() {
  this.buffer();
}
function exitFootnoteDefinitionLabelString(token) {
  const label = this.resume();
  const node3 = this.stack[this.stack.length - 1];
  ok(node3.type === "footnoteDefinition");
  node3.label = label;
  node3.identifier = normalizeIdentifier(
    this.sliceSerialize(token)
  ).toLowerCase();
}
function exitFootnoteDefinition(token) {
  this.exit(token);
}
function enterFootnoteCall(token) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, token);
}
function enterFootnoteCallString() {
  this.buffer();
}
function exitFootnoteCallString(token) {
  const label = this.resume();
  const node3 = this.stack[this.stack.length - 1];
  ok(node3.type === "footnoteReference");
  node3.label = label;
  node3.identifier = normalizeIdentifier(
    this.sliceSerialize(token)
  ).toLowerCase();
}
function exitFootnoteCall(token) {
  this.exit(token);
}
function footnoteReference(node3, _, state, info2) {
  const tracker = state.createTracker(info2);
  let value = tracker.move("[^");
  const exit3 = state.enter("footnoteReference");
  const subexit = state.enter("reference");
  value += tracker.move(
    state.safe(state.associationId(node3), {
      ...tracker.current(),
      before: value,
      after: "]"
    })
  );
  subexit();
  exit3();
  value += tracker.move("]");
  return value;
}
function footnoteReferencePeek() {
  return "[";
}
function footnoteDefinition(node3, _, state, info2) {
  const tracker = state.createTracker(info2);
  let value = tracker.move("[^");
  const exit3 = state.enter("footnoteDefinition");
  const subexit = state.enter("label");
  value += tracker.move(
    state.safe(state.associationId(node3), {
      ...tracker.current(),
      before: value,
      after: "]"
    })
  );
  subexit();
  value += tracker.move(
    "]:" + (node3.children && node3.children.length > 0 ? " " : "")
  );
  tracker.shift(4);
  value += tracker.move(
    state.indentLines(state.containerFlow(node3, tracker.current()), map4)
  );
  exit3();
  return value;
}
function map4(line, index3, blank) {
  if (index3 === 0) {
    return line;
  }
  return (blank ? "" : "    ") + line;
}

// node_modules/mdast-util-gfm-strikethrough/index.js
init_process();
init_buffer();

// node_modules/mdast-util-gfm-strikethrough/lib/index.js
init_process();
init_buffer();
var constructsWithoutStrikethrough = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
handleDelete.peek = peekDelete;
function gfmStrikethroughFromMarkdown() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: enterStrikethrough },
    exit: { strikethrough: exitStrikethrough }
  };
}
function gfmStrikethroughToMarkdown() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: constructsWithoutStrikethrough
      }
    ],
    handlers: { delete: handleDelete }
  };
}
function enterStrikethrough(token) {
  this.enter({ type: "delete", children: [] }, token);
}
function exitStrikethrough(token) {
  this.exit(token);
}
function handleDelete(node3, _, state, info2) {
  const tracker = state.createTracker(info2);
  const exit3 = state.enter("strikethrough");
  let value = tracker.move("~~");
  value += state.containerPhrasing(node3, {
    ...tracker.current(),
    before: value,
    after: "~"
  });
  value += tracker.move("~~");
  exit3();
  return value;
}
function peekDelete() {
  return "~";
}

// node_modules/mdast-util-gfm-table/index.js
init_process();
init_buffer();

// node_modules/mdast-util-gfm-table/lib/index.js
init_process();
init_buffer();

// node_modules/markdown-table/index.js
init_process();
init_buffer();
function markdownTable(table2, options = {}) {
  const align = (options.align || []).concat();
  const stringLength = options.stringLength || defaultStringLength;
  const alignments = [];
  const cellMatrix = [];
  const sizeMatrix = [];
  const longestCellByColumn = [];
  let mostCellsPerRow = 0;
  let rowIndex = -1;
  while (++rowIndex < table2.length) {
    const row2 = [];
    const sizes2 = [];
    let columnIndex2 = -1;
    if (table2[rowIndex].length > mostCellsPerRow) {
      mostCellsPerRow = table2[rowIndex].length;
    }
    while (++columnIndex2 < table2[rowIndex].length) {
      const cell = serialize2(table2[rowIndex][columnIndex2]);
      if (options.alignDelimiters !== false) {
        const size = stringLength(cell);
        sizes2[columnIndex2] = size;
        if (longestCellByColumn[columnIndex2] === void 0 || size > longestCellByColumn[columnIndex2]) {
          longestCellByColumn[columnIndex2] = size;
        }
      }
      row2.push(cell);
    }
    cellMatrix[rowIndex] = row2;
    sizeMatrix[rowIndex] = sizes2;
  }
  let columnIndex = -1;
  if (typeof align === "object" && "length" in align) {
    while (++columnIndex < mostCellsPerRow) {
      alignments[columnIndex] = toAlignment(align[columnIndex]);
    }
  } else {
    const code4 = toAlignment(align);
    while (++columnIndex < mostCellsPerRow) {
      alignments[columnIndex] = code4;
    }
  }
  columnIndex = -1;
  const row = [];
  const sizes = [];
  while (++columnIndex < mostCellsPerRow) {
    const code4 = alignments[columnIndex];
    let before = "";
    let after = "";
    if (code4 === 99) {
      before = ":";
      after = ":";
    } else if (code4 === 108) {
      before = ":";
    } else if (code4 === 114) {
      after = ":";
    }
    let size = options.alignDelimiters === false ? 1 : Math.max(
      1,
      longestCellByColumn[columnIndex] - before.length - after.length
    );
    const cell = before + "-".repeat(size) + after;
    if (options.alignDelimiters !== false) {
      size = before.length + size + after.length;
      if (size > longestCellByColumn[columnIndex]) {
        longestCellByColumn[columnIndex] = size;
      }
      sizes[columnIndex] = size;
    }
    row[columnIndex] = cell;
  }
  cellMatrix.splice(1, 0, row);
  sizeMatrix.splice(1, 0, sizes);
  rowIndex = -1;
  const lines = [];
  while (++rowIndex < cellMatrix.length) {
    const row2 = cellMatrix[rowIndex];
    const sizes2 = sizeMatrix[rowIndex];
    columnIndex = -1;
    const line = [];
    while (++columnIndex < mostCellsPerRow) {
      const cell = row2[columnIndex] || "";
      let before = "";
      let after = "";
      if (options.alignDelimiters !== false) {
        const size = longestCellByColumn[columnIndex] - (sizes2[columnIndex] || 0);
        const code4 = alignments[columnIndex];
        if (code4 === 114) {
          before = " ".repeat(size);
        } else if (code4 === 99) {
          if (size % 2) {
            before = " ".repeat(size / 2 + 0.5);
            after = " ".repeat(size / 2 - 0.5);
          } else {
            before = " ".repeat(size / 2);
            after = before;
          }
        } else {
          after = " ".repeat(size);
        }
      }
      if (options.delimiterStart !== false && !columnIndex) {
        line.push("|");
      }
      if (options.padding !== false && // Don’t add the opening space if we’re not aligning and the cell is
      // empty: there will be a closing space.
      !(options.alignDelimiters === false && cell === "") && (options.delimiterStart !== false || columnIndex)) {
        line.push(" ");
      }
      if (options.alignDelimiters !== false) {
        line.push(before);
      }
      line.push(cell);
      if (options.alignDelimiters !== false) {
        line.push(after);
      }
      if (options.padding !== false) {
        line.push(" ");
      }
      if (options.delimiterEnd !== false || columnIndex !== mostCellsPerRow - 1) {
        line.push("|");
      }
    }
    lines.push(
      options.delimiterEnd === false ? line.join("").replace(/ +$/, "") : line.join("")
    );
  }
  return lines.join("\n");
}
function serialize2(value) {
  return value === null || value === void 0 ? "" : String(value);
}
function defaultStringLength(value) {
  return value.length;
}
function toAlignment(value) {
  const code4 = typeof value === "string" ? value.codePointAt(0) : 0;
  return code4 === 67 || code4 === 99 ? 99 : code4 === 76 || code4 === 108 ? 108 : code4 === 82 || code4 === 114 ? 114 : 0;
}

// node_modules/mdast-util-to-markdown/index.js
init_process();
init_buffer();

// node_modules/mdast-util-to-markdown/lib/handle/index.js
init_process();
init_buffer();

// node_modules/mdast-util-to-markdown/lib/handle/blockquote.js
init_process();
init_buffer();
function blockquote(node3, _, state, info2) {
  const exit3 = state.enter("blockquote");
  const tracker = state.createTracker(info2);
  tracker.move("> ");
  tracker.shift(2);
  const value = state.indentLines(
    state.containerFlow(node3, tracker.current()),
    map5
  );
  exit3();
  return value;
}
function map5(line, _, blank) {
  return ">" + (blank ? "" : " ") + line;
}

// node_modules/mdast-util-to-markdown/lib/handle/break.js
init_process();
init_buffer();

// node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js
init_process();
init_buffer();
function patternInScope(stack, pattern) {
  return listInScope(stack, pattern.inConstruct, true) && !listInScope(stack, pattern.notInConstruct, false);
}
function listInScope(stack, list4, none) {
  if (typeof list4 === "string") {
    list4 = [list4];
  }
  if (!list4 || list4.length === 0) {
    return none;
  }
  let index3 = -1;
  while (++index3 < list4.length) {
    if (stack.includes(list4[index3])) {
      return true;
    }
  }
  return false;
}

// node_modules/mdast-util-to-markdown/lib/handle/break.js
function hardBreak(_, _1, state, info2) {
  let index3 = -1;
  while (++index3 < state.unsafe.length) {
    if (state.unsafe[index3].character === "\n" && patternInScope(state.stack, state.unsafe[index3])) {
      return /[ \t]/.test(info2.before) ? "" : " ";
    }
  }
  return "\\\n";
}

// node_modules/mdast-util-to-markdown/lib/handle/code.js
init_process();
init_buffer();

// node_modules/longest-streak/index.js
init_process();
init_buffer();
function longestStreak(value, substring2) {
  const source = String(value);
  let index3 = source.indexOf(substring2);
  let expected = index3;
  let count2 = 0;
  let max = 0;
  if (typeof substring2 !== "string") {
    throw new TypeError("Expected substring");
  }
  while (index3 !== -1) {
    if (index3 === expected) {
      if (++count2 > max) {
        max = count2;
      }
    } else {
      count2 = 1;
    }
    expected = index3 + substring2.length;
    index3 = source.indexOf(substring2, expected);
  }
  return max;
}

// node_modules/mdast-util-to-markdown/lib/util/format-code-as-indented.js
init_process();
init_buffer();
function formatCodeAsIndented(node3, state) {
  return Boolean(
    state.options.fences === false && node3.value && // If there’s no info…
    !node3.lang && // And there’s a non-whitespace character…
    /[^ \r\n]/.test(node3.value) && // And the value doesn’t start or end in a blank…
    !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(node3.value)
  );
}

// node_modules/mdast-util-to-markdown/lib/util/check-fence.js
init_process();
init_buffer();
function checkFence(state) {
  const marker = state.options.fence || "`";
  if (marker !== "`" && marker !== "~") {
    throw new Error(
      "Cannot serialize code with `" + marker + "` for `options.fence`, expected `` ` `` or `~`"
    );
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/handle/code.js
function code(node3, _, state, info2) {
  const marker = checkFence(state);
  const raw2 = node3.value || "";
  const suffix = marker === "`" ? "GraveAccent" : "Tilde";
  if (formatCodeAsIndented(node3, state)) {
    const exit4 = state.enter("codeIndented");
    const value2 = state.indentLines(raw2, map6);
    exit4();
    return value2;
  }
  const tracker = state.createTracker(info2);
  const sequence = marker.repeat(Math.max(longestStreak(raw2, marker) + 1, 3));
  const exit3 = state.enter("codeFenced");
  let value = tracker.move(sequence);
  if (node3.lang) {
    const subexit = state.enter(`codeFencedLang${suffix}`);
    value += tracker.move(
      state.safe(node3.lang, {
        before: value,
        after: " ",
        encode: ["`"],
        ...tracker.current()
      })
    );
    subexit();
  }
  if (node3.lang && node3.meta) {
    const subexit = state.enter(`codeFencedMeta${suffix}`);
    value += tracker.move(" ");
    value += tracker.move(
      state.safe(node3.meta, {
        before: value,
        after: "\n",
        encode: ["`"],
        ...tracker.current()
      })
    );
    subexit();
  }
  value += tracker.move("\n");
  if (raw2) {
    value += tracker.move(raw2 + "\n");
  }
  value += tracker.move(sequence);
  exit3();
  return value;
}
function map6(line, _, blank) {
  return (blank ? "" : "    ") + line;
}

// node_modules/mdast-util-to-markdown/lib/handle/definition.js
init_process();
init_buffer();

// node_modules/mdast-util-to-markdown/lib/util/check-quote.js
init_process();
init_buffer();
function checkQuote(state) {
  const marker = state.options.quote || '"';
  if (marker !== '"' && marker !== "'") {
    throw new Error(
      "Cannot serialize title with `" + marker + "` for `options.quote`, expected `\"`, or `'`"
    );
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/handle/definition.js
function definition(node3, _, state, info2) {
  const quote = checkQuote(state);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const exit3 = state.enter("definition");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info2);
  let value = tracker.move("[");
  value += tracker.move(
    state.safe(state.associationId(node3), {
      before: value,
      after: "]",
      ...tracker.current()
    })
  );
  value += tracker.move("]: ");
  subexit();
  if (
    // If there’s no url, or…
    !node3.url || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(node3.url)
  ) {
    subexit = state.enter("destinationLiteral");
    value += tracker.move("<");
    value += tracker.move(
      state.safe(node3.url, { before: value, after: ">", ...tracker.current() })
    );
    value += tracker.move(">");
  } else {
    subexit = state.enter("destinationRaw");
    value += tracker.move(
      state.safe(node3.url, {
        before: value,
        after: node3.title ? " " : "\n",
        ...tracker.current()
      })
    );
  }
  subexit();
  if (node3.title) {
    subexit = state.enter(`title${suffix}`);
    value += tracker.move(" " + quote);
    value += tracker.move(
      state.safe(node3.title, {
        before: value,
        after: quote,
        ...tracker.current()
      })
    );
    value += tracker.move(quote);
    subexit();
  }
  exit3();
  return value;
}

// node_modules/mdast-util-to-markdown/lib/handle/emphasis.js
init_process();
init_buffer();

// node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js
init_process();
init_buffer();
function checkEmphasis(state) {
  const marker = state.options.emphasis || "*";
  if (marker !== "*" && marker !== "_") {
    throw new Error(
      "Cannot serialize emphasis with `" + marker + "` for `options.emphasis`, expected `*`, or `_`"
    );
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/handle/emphasis.js
emphasis.peek = emphasisPeek;
function emphasis(node3, _, state, info2) {
  const marker = checkEmphasis(state);
  const exit3 = state.enter("emphasis");
  const tracker = state.createTracker(info2);
  let value = tracker.move(marker);
  value += tracker.move(
    state.containerPhrasing(node3, {
      before: value,
      after: marker,
      ...tracker.current()
    })
  );
  value += tracker.move(marker);
  exit3();
  return value;
}
function emphasisPeek(_, _1, state) {
  return state.options.emphasis || "*";
}

// node_modules/mdast-util-to-markdown/lib/handle/heading.js
init_process();
init_buffer();

// node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js
init_process();
init_buffer();

// node_modules/unist-util-visit/index.js
init_process();
init_buffer();

// node_modules/unist-util-visit/lib/index.js
init_process();
init_buffer();
function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {
  let reverse;
  let test;
  let visitor;
  if (typeof testOrVisitor === "function" && typeof visitorOrReverse !== "function") {
    test = void 0;
    visitor = testOrVisitor;
    reverse = visitorOrReverse;
  } else {
    test = testOrVisitor;
    visitor = visitorOrReverse;
    reverse = maybeReverse;
  }
  visitParents(tree, test, overload, reverse);
  function overload(node3, parents) {
    const parent = parents[parents.length - 1];
    const index3 = parent ? parent.children.indexOf(node3) : void 0;
    return visitor(node3, index3, parent);
  }
}

// node_modules/mdast-util-to-markdown/node_modules/mdast-util-to-string/index.js
init_process();
init_buffer();

// node_modules/mdast-util-to-markdown/node_modules/mdast-util-to-string/lib/index.js
init_process();
init_buffer();
var emptyOptions2 = {};
function toString4(value, options) {
  const settings = options || emptyOptions2;
  const includeImageAlt = typeof settings.includeImageAlt === "boolean" ? settings.includeImageAlt : true;
  const includeHtml = typeof settings.includeHtml === "boolean" ? settings.includeHtml : true;
  return one2(value, includeImageAlt, includeHtml);
}
function one2(value, includeImageAlt, includeHtml) {
  if (node(value)) {
    if ("value" in value) {
      return value.type === "html" && !includeHtml ? "" : value.value;
    }
    if (includeImageAlt && "alt" in value && value.alt) {
      return value.alt;
    }
    if ("children" in value) {
      return all2(value.children, includeImageAlt, includeHtml);
    }
  }
  if (Array.isArray(value)) {
    return all2(value, includeImageAlt, includeHtml);
  }
  return "";
}
function all2(values, includeImageAlt, includeHtml) {
  const result = [];
  let index3 = -1;
  while (++index3 < values.length) {
    result[index3] = one2(values[index3], includeImageAlt, includeHtml);
  }
  return result.join("");
}
function node(value) {
  return Boolean(value && typeof value === "object");
}

// node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js
function formatHeadingAsSetext(node3, state) {
  let literalWithBreak = false;
  visit(node3, function(node4) {
    if ("value" in node4 && /\r?\n|\r/.test(node4.value) || node4.type === "break") {
      literalWithBreak = true;
      return EXIT;
    }
  });
  return Boolean(
    (!node3.depth || node3.depth < 3) && toString4(node3) && (state.options.setext || literalWithBreak)
  );
}

// node_modules/mdast-util-to-markdown/lib/handle/heading.js
function heading(node3, _, state, info2) {
  const rank = Math.max(Math.min(6, node3.depth || 1), 1);
  const tracker = state.createTracker(info2);
  if (formatHeadingAsSetext(node3, state)) {
    const exit4 = state.enter("headingSetext");
    const subexit2 = state.enter("phrasing");
    const value2 = state.containerPhrasing(node3, {
      ...tracker.current(),
      before: "\n",
      after: "\n"
    });
    subexit2();
    exit4();
    return value2 + "\n" + (rank === 1 ? "=" : "-").repeat(
      // The whole size…
      value2.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)…
      (Math.max(value2.lastIndexOf("\r"), value2.lastIndexOf("\n")) + 1)
    );
  }
  const sequence = "#".repeat(rank);
  const exit3 = state.enter("headingAtx");
  const subexit = state.enter("phrasing");
  tracker.move(sequence + " ");
  let value = state.containerPhrasing(node3, {
    before: "# ",
    after: "\n",
    ...tracker.current()
  });
  if (/^[\t ]/.test(value)) {
    value = "&#x" + value.charCodeAt(0).toString(16).toUpperCase() + ";" + value.slice(1);
  }
  value = value ? sequence + " " + value : sequence;
  if (state.options.closeAtx) {
    value += " " + sequence;
  }
  subexit();
  exit3();
  return value;
}

// node_modules/mdast-util-to-markdown/lib/handle/html.js
init_process();
init_buffer();
html5.peek = htmlPeek;
function html5(node3) {
  return node3.value || "";
}
function htmlPeek() {
  return "<";
}

// node_modules/mdast-util-to-markdown/lib/handle/image.js
init_process();
init_buffer();
image.peek = imagePeek;
function image(node3, _, state, info2) {
  const quote = checkQuote(state);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const exit3 = state.enter("image");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info2);
  let value = tracker.move("![");
  value += tracker.move(
    state.safe(node3.alt, { before: value, after: "]", ...tracker.current() })
  );
  value += tracker.move("](");
  subexit();
  if (
    // If there’s no url but there is a title…
    !node3.url && node3.title || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(node3.url)
  ) {
    subexit = state.enter("destinationLiteral");
    value += tracker.move("<");
    value += tracker.move(
      state.safe(node3.url, { before: value, after: ">", ...tracker.current() })
    );
    value += tracker.move(">");
  } else {
    subexit = state.enter("destinationRaw");
    value += tracker.move(
      state.safe(node3.url, {
        before: value,
        after: node3.title ? " " : ")",
        ...tracker.current()
      })
    );
  }
  subexit();
  if (node3.title) {
    subexit = state.enter(`title${suffix}`);
    value += tracker.move(" " + quote);
    value += tracker.move(
      state.safe(node3.title, {
        before: value,
        after: quote,
        ...tracker.current()
      })
    );
    value += tracker.move(quote);
    subexit();
  }
  value += tracker.move(")");
  exit3();
  return value;
}
function imagePeek() {
  return "!";
}

// node_modules/mdast-util-to-markdown/lib/handle/image-reference.js
init_process();
init_buffer();
imageReference.peek = imageReferencePeek;
function imageReference(node3, _, state, info2) {
  const type = node3.referenceType;
  const exit3 = state.enter("imageReference");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info2);
  let value = tracker.move("![");
  const alt = state.safe(node3.alt, {
    before: value,
    after: "]",
    ...tracker.current()
  });
  value += tracker.move(alt + "][");
  subexit();
  const stack = state.stack;
  state.stack = [];
  subexit = state.enter("reference");
  const reference = state.safe(state.associationId(node3), {
    before: value,
    after: "]",
    ...tracker.current()
  });
  subexit();
  state.stack = stack;
  exit3();
  if (type === "full" || !alt || alt !== reference) {
    value += tracker.move(reference + "]");
  } else if (type === "shortcut") {
    value = value.slice(0, -1);
  } else {
    value += tracker.move("]");
  }
  return value;
}
function imageReferencePeek() {
  return "!";
}

// node_modules/mdast-util-to-markdown/lib/handle/inline-code.js
init_process();
init_buffer();
inlineCode.peek = inlineCodePeek;
function inlineCode(node3, _, state) {
  let value = node3.value || "";
  let sequence = "`";
  let index3 = -1;
  while (new RegExp("(^|[^`])" + sequence + "([^`]|$)").test(value)) {
    sequence += "`";
  }
  if (/[^ \r\n]/.test(value) && (/^[ \r\n]/.test(value) && /[ \r\n]$/.test(value) || /^`|`$/.test(value))) {
    value = " " + value + " ";
  }
  while (++index3 < state.unsafe.length) {
    const pattern = state.unsafe[index3];
    const expression = state.compilePattern(pattern);
    let match;
    if (!pattern.atBreak)
      continue;
    while (match = expression.exec(value)) {
      let position4 = match.index;
      if (value.charCodeAt(position4) === 10 && value.charCodeAt(position4 - 1) === 13) {
        position4--;
      }
      value = value.slice(0, position4) + " " + value.slice(match.index + 1);
    }
  }
  return sequence + value + sequence;
}
function inlineCodePeek() {
  return "`";
}

// node_modules/mdast-util-to-markdown/lib/handle/link.js
init_process();
init_buffer();

// node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js
init_process();
init_buffer();
function formatLinkAsAutolink(node3, state) {
  const raw2 = toString4(node3);
  return Boolean(
    !state.options.resourceLink && // If there’s a url…
    node3.url && // And there’s a no title…
    !node3.title && // And the content of `node` is a single text node…
    node3.children && node3.children.length === 1 && node3.children[0].type === "text" && // And if the url is the same as the content…
    (raw2 === node3.url || "mailto:" + raw2 === node3.url) && // And that starts w/ a protocol…
    /^[a-z][a-z+.-]+:/i.test(node3.url) && // And that doesn’t contain ASCII control codes (character escapes and
    // references don’t work), space, or angle brackets…
    !/[\0- <>\u007F]/.test(node3.url)
  );
}

// node_modules/mdast-util-to-markdown/lib/handle/link.js
link.peek = linkPeek;
function link(node3, _, state, info2) {
  const quote = checkQuote(state);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const tracker = state.createTracker(info2);
  let exit3;
  let subexit;
  if (formatLinkAsAutolink(node3, state)) {
    const stack = state.stack;
    state.stack = [];
    exit3 = state.enter("autolink");
    let value2 = tracker.move("<");
    value2 += tracker.move(
      state.containerPhrasing(node3, {
        before: value2,
        after: ">",
        ...tracker.current()
      })
    );
    value2 += tracker.move(">");
    exit3();
    state.stack = stack;
    return value2;
  }
  exit3 = state.enter("link");
  subexit = state.enter("label");
  let value = tracker.move("[");
  value += tracker.move(
    state.containerPhrasing(node3, {
      before: value,
      after: "](",
      ...tracker.current()
    })
  );
  value += tracker.move("](");
  subexit();
  if (
    // If there’s no url but there is a title…
    !node3.url && node3.title || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(node3.url)
  ) {
    subexit = state.enter("destinationLiteral");
    value += tracker.move("<");
    value += tracker.move(
      state.safe(node3.url, { before: value, after: ">", ...tracker.current() })
    );
    value += tracker.move(">");
  } else {
    subexit = state.enter("destinationRaw");
    value += tracker.move(
      state.safe(node3.url, {
        before: value,
        after: node3.title ? " " : ")",
        ...tracker.current()
      })
    );
  }
  subexit();
  if (node3.title) {
    subexit = state.enter(`title${suffix}`);
    value += tracker.move(" " + quote);
    value += tracker.move(
      state.safe(node3.title, {
        before: value,
        after: quote,
        ...tracker.current()
      })
    );
    value += tracker.move(quote);
    subexit();
  }
  value += tracker.move(")");
  exit3();
  return value;
}
function linkPeek(node3, _, state) {
  return formatLinkAsAutolink(node3, state) ? "<" : "[";
}

// node_modules/mdast-util-to-markdown/lib/handle/link-reference.js
init_process();
init_buffer();
linkReference.peek = linkReferencePeek;
function linkReference(node3, _, state, info2) {
  const type = node3.referenceType;
  const exit3 = state.enter("linkReference");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info2);
  let value = tracker.move("[");
  const text8 = state.containerPhrasing(node3, {
    before: value,
    after: "]",
    ...tracker.current()
  });
  value += tracker.move(text8 + "][");
  subexit();
  const stack = state.stack;
  state.stack = [];
  subexit = state.enter("reference");
  const reference = state.safe(state.associationId(node3), {
    before: value,
    after: "]",
    ...tracker.current()
  });
  subexit();
  state.stack = stack;
  exit3();
  if (type === "full" || !text8 || text8 !== reference) {
    value += tracker.move(reference + "]");
  } else if (type === "shortcut") {
    value = value.slice(0, -1);
  } else {
    value += tracker.move("]");
  }
  return value;
}
function linkReferencePeek() {
  return "[";
}

// node_modules/mdast-util-to-markdown/lib/handle/list.js
init_process();
init_buffer();

// node_modules/mdast-util-to-markdown/lib/util/check-bullet.js
init_process();
init_buffer();
function checkBullet(state) {
  const marker = state.options.bullet || "*";
  if (marker !== "*" && marker !== "+" && marker !== "-") {
    throw new Error(
      "Cannot serialize items with `" + marker + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/util/check-bullet-other.js
init_process();
init_buffer();
function checkBulletOther(state) {
  const bullet = checkBullet(state);
  const bulletOther = state.options.bulletOther;
  if (!bulletOther) {
    return bullet === "*" ? "-" : "*";
  }
  if (bulletOther !== "*" && bulletOther !== "+" && bulletOther !== "-") {
    throw new Error(
      "Cannot serialize items with `" + bulletOther + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  }
  if (bulletOther === bullet) {
    throw new Error(
      "Expected `bullet` (`" + bullet + "`) and `bulletOther` (`" + bulletOther + "`) to be different"
    );
  }
  return bulletOther;
}

// node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered.js
init_process();
init_buffer();
function checkBulletOrdered(state) {
  const marker = state.options.bulletOrdered || ".";
  if (marker !== "." && marker !== ")") {
    throw new Error(
      "Cannot serialize items with `" + marker + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/util/check-rule.js
init_process();
init_buffer();
function checkRule(state) {
  const marker = state.options.rule || "*";
  if (marker !== "*" && marker !== "-" && marker !== "_") {
    throw new Error(
      "Cannot serialize rules with `" + marker + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/handle/list.js
function list(node3, parent, state, info2) {
  const exit3 = state.enter("list");
  const bulletCurrent = state.bulletCurrent;
  let bullet = node3.ordered ? checkBulletOrdered(state) : checkBullet(state);
  const bulletOther = node3.ordered ? bullet === "." ? ")" : "." : checkBulletOther(state);
  let useDifferentMarker = parent && state.bulletLastUsed ? bullet === state.bulletLastUsed : false;
  if (!node3.ordered) {
    const firstListItem = node3.children ? node3.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (bullet === "*" || bullet === "-") && // Empty first list item:
      firstListItem && (!firstListItem.children || !firstListItem.children[0]) && // Directly in two other list items:
      state.stack[state.stack.length - 1] === "list" && state.stack[state.stack.length - 2] === "listItem" && state.stack[state.stack.length - 3] === "list" && state.stack[state.stack.length - 4] === "listItem" && // That are each the first child.
      state.indexStack[state.indexStack.length - 1] === 0 && state.indexStack[state.indexStack.length - 2] === 0 && state.indexStack[state.indexStack.length - 3] === 0
    ) {
      useDifferentMarker = true;
    }
    if (checkRule(state) === bullet && firstListItem) {
      let index3 = -1;
      while (++index3 < node3.children.length) {
        const item = node3.children[index3];
        if (item && item.type === "listItem" && item.children && item.children[0] && item.children[0].type === "thematicBreak") {
          useDifferentMarker = true;
          break;
        }
      }
    }
  }
  if (useDifferentMarker) {
    bullet = bulletOther;
  }
  state.bulletCurrent = bullet;
  const value = state.containerFlow(node3, info2);
  state.bulletLastUsed = bullet;
  state.bulletCurrent = bulletCurrent;
  exit3();
  return value;
}

// node_modules/mdast-util-to-markdown/lib/handle/list-item.js
init_process();
init_buffer();

// node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js
init_process();
init_buffer();
function checkListItemIndent(state) {
  const style = state.options.listItemIndent || "one";
  if (style !== "tab" && style !== "one" && style !== "mixed") {
    throw new Error(
      "Cannot serialize items with `" + style + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  }
  return style;
}

// node_modules/mdast-util-to-markdown/lib/handle/list-item.js
function listItem(node3, parent, state, info2) {
  const listItemIndent = checkListItemIndent(state);
  let bullet = state.bulletCurrent || checkBullet(state);
  if (parent && parent.type === "list" && parent.ordered) {
    bullet = (typeof parent.start === "number" && parent.start > -1 ? parent.start : 1) + (state.options.incrementListMarker === false ? 0 : parent.children.indexOf(node3)) + bullet;
  }
  let size = bullet.length + 1;
  if (listItemIndent === "tab" || listItemIndent === "mixed" && (parent && parent.type === "list" && parent.spread || node3.spread)) {
    size = Math.ceil(size / 4) * 4;
  }
  const tracker = state.createTracker(info2);
  tracker.move(bullet + " ".repeat(size - bullet.length));
  tracker.shift(size);
  const exit3 = state.enter("listItem");
  const value = state.indentLines(
    state.containerFlow(node3, tracker.current()),
    map9
  );
  exit3();
  return value;
  function map9(line, index3, blank) {
    if (index3) {
      return (blank ? "" : " ".repeat(size)) + line;
    }
    return (blank ? bullet : bullet + " ".repeat(size - bullet.length)) + line;
  }
}

// node_modules/mdast-util-to-markdown/lib/handle/paragraph.js
init_process();
init_buffer();
function paragraph(node3, _, state, info2) {
  const exit3 = state.enter("paragraph");
  const subexit = state.enter("phrasing");
  const value = state.containerPhrasing(node3, info2);
  subexit();
  exit3();
  return value;
}

// node_modules/mdast-util-to-markdown/lib/handle/root.js
init_process();
init_buffer();

// node_modules/mdast-util-phrasing/index.js
init_process();
init_buffer();

// node_modules/mdast-util-phrasing/lib/index.js
init_process();
init_buffer();
var phrasing = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  convert([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);

// node_modules/mdast-util-to-markdown/lib/handle/root.js
function root2(node3, _, state, info2) {
  const hasPhrasing = node3.children.some(function(d2) {
    return phrasing(d2);
  });
  const fn = hasPhrasing ? state.containerPhrasing : state.containerFlow;
  return fn.call(state, node3, info2);
}

// node_modules/mdast-util-to-markdown/lib/handle/strong.js
init_process();
init_buffer();

// node_modules/mdast-util-to-markdown/lib/util/check-strong.js
init_process();
init_buffer();
function checkStrong(state) {
  const marker = state.options.strong || "*";
  if (marker !== "*" && marker !== "_") {
    throw new Error(
      "Cannot serialize strong with `" + marker + "` for `options.strong`, expected `*`, or `_`"
    );
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/handle/strong.js
strong.peek = strongPeek;
function strong(node3, _, state, info2) {
  const marker = checkStrong(state);
  const exit3 = state.enter("strong");
  const tracker = state.createTracker(info2);
  let value = tracker.move(marker + marker);
  value += tracker.move(
    state.containerPhrasing(node3, {
      before: value,
      after: marker,
      ...tracker.current()
    })
  );
  value += tracker.move(marker + marker);
  exit3();
  return value;
}
function strongPeek(_, _1, state) {
  return state.options.strong || "*";
}

// node_modules/mdast-util-to-markdown/lib/handle/text.js
init_process();
init_buffer();
function text3(node3, _, state, info2) {
  return state.safe(node3.value, info2);
}

// node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js
init_process();
init_buffer();

// node_modules/mdast-util-to-markdown/lib/util/check-rule-repetition.js
init_process();
init_buffer();
function checkRuleRepetition(state) {
  const repetition = state.options.ruleRepetition || 3;
  if (repetition < 3) {
    throw new Error(
      "Cannot serialize rules with repetition `" + repetition + "` for `options.ruleRepetition`, expected `3` or more"
    );
  }
  return repetition;
}

// node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js
function thematicBreak(_, _1, state) {
  const value = (checkRule(state) + (state.options.ruleSpaces ? " " : "")).repeat(checkRuleRepetition(state));
  return state.options.ruleSpaces ? value.slice(0, -1) : value;
}

// node_modules/mdast-util-to-markdown/lib/handle/index.js
var handle2 = {
  blockquote,
  break: hardBreak,
  code,
  definition,
  emphasis,
  hardBreak,
  heading,
  html: html5,
  image,
  imageReference,
  inlineCode,
  link,
  linkReference,
  list,
  listItem,
  paragraph,
  root: root2,
  strong,
  text: text3,
  thematicBreak
};

// node_modules/decode-named-character-reference/index.js
init_process();
init_buffer();

// node_modules/character-entities/index.js
init_process();
init_buffer();
var characterEntities = {
  AElig: "\xC6",
  AMP: "&",
  Aacute: "\xC1",
  Abreve: "\u0102",
  Acirc: "\xC2",
  Acy: "\u0410",
  Afr: "\u{1D504}",
  Agrave: "\xC0",
  Alpha: "\u0391",
  Amacr: "\u0100",
  And: "\u2A53",
  Aogon: "\u0104",
  Aopf: "\u{1D538}",
  ApplyFunction: "\u2061",
  Aring: "\xC5",
  Ascr: "\u{1D49C}",
  Assign: "\u2254",
  Atilde: "\xC3",
  Auml: "\xC4",
  Backslash: "\u2216",
  Barv: "\u2AE7",
  Barwed: "\u2306",
  Bcy: "\u0411",
  Because: "\u2235",
  Bernoullis: "\u212C",
  Beta: "\u0392",
  Bfr: "\u{1D505}",
  Bopf: "\u{1D539}",
  Breve: "\u02D8",
  Bscr: "\u212C",
  Bumpeq: "\u224E",
  CHcy: "\u0427",
  COPY: "\xA9",
  Cacute: "\u0106",
  Cap: "\u22D2",
  CapitalDifferentialD: "\u2145",
  Cayleys: "\u212D",
  Ccaron: "\u010C",
  Ccedil: "\xC7",
  Ccirc: "\u0108",
  Cconint: "\u2230",
  Cdot: "\u010A",
  Cedilla: "\xB8",
  CenterDot: "\xB7",
  Cfr: "\u212D",
  Chi: "\u03A7",
  CircleDot: "\u2299",
  CircleMinus: "\u2296",
  CirclePlus: "\u2295",
  CircleTimes: "\u2297",
  ClockwiseContourIntegral: "\u2232",
  CloseCurlyDoubleQuote: "\u201D",
  CloseCurlyQuote: "\u2019",
  Colon: "\u2237",
  Colone: "\u2A74",
  Congruent: "\u2261",
  Conint: "\u222F",
  ContourIntegral: "\u222E",
  Copf: "\u2102",
  Coproduct: "\u2210",
  CounterClockwiseContourIntegral: "\u2233",
  Cross: "\u2A2F",
  Cscr: "\u{1D49E}",
  Cup: "\u22D3",
  CupCap: "\u224D",
  DD: "\u2145",
  DDotrahd: "\u2911",
  DJcy: "\u0402",
  DScy: "\u0405",
  DZcy: "\u040F",
  Dagger: "\u2021",
  Darr: "\u21A1",
  Dashv: "\u2AE4",
  Dcaron: "\u010E",
  Dcy: "\u0414",
  Del: "\u2207",
  Delta: "\u0394",
  Dfr: "\u{1D507}",
  DiacriticalAcute: "\xB4",
  DiacriticalDot: "\u02D9",
  DiacriticalDoubleAcute: "\u02DD",
  DiacriticalGrave: "`",
  DiacriticalTilde: "\u02DC",
  Diamond: "\u22C4",
  DifferentialD: "\u2146",
  Dopf: "\u{1D53B}",
  Dot: "\xA8",
  DotDot: "\u20DC",
  DotEqual: "\u2250",
  DoubleContourIntegral: "\u222F",
  DoubleDot: "\xA8",
  DoubleDownArrow: "\u21D3",
  DoubleLeftArrow: "\u21D0",
  DoubleLeftRightArrow: "\u21D4",
  DoubleLeftTee: "\u2AE4",
  DoubleLongLeftArrow: "\u27F8",
  DoubleLongLeftRightArrow: "\u27FA",
  DoubleLongRightArrow: "\u27F9",
  DoubleRightArrow: "\u21D2",
  DoubleRightTee: "\u22A8",
  DoubleUpArrow: "\u21D1",
  DoubleUpDownArrow: "\u21D5",
  DoubleVerticalBar: "\u2225",
  DownArrow: "\u2193",
  DownArrowBar: "\u2913",
  DownArrowUpArrow: "\u21F5",
  DownBreve: "\u0311",
  DownLeftRightVector: "\u2950",
  DownLeftTeeVector: "\u295E",
  DownLeftVector: "\u21BD",
  DownLeftVectorBar: "\u2956",
  DownRightTeeVector: "\u295F",
  DownRightVector: "\u21C1",
  DownRightVectorBar: "\u2957",
  DownTee: "\u22A4",
  DownTeeArrow: "\u21A7",
  Downarrow: "\u21D3",
  Dscr: "\u{1D49F}",
  Dstrok: "\u0110",
  ENG: "\u014A",
  ETH: "\xD0",
  Eacute: "\xC9",
  Ecaron: "\u011A",
  Ecirc: "\xCA",
  Ecy: "\u042D",
  Edot: "\u0116",
  Efr: "\u{1D508}",
  Egrave: "\xC8",
  Element: "\u2208",
  Emacr: "\u0112",
  EmptySmallSquare: "\u25FB",
  EmptyVerySmallSquare: "\u25AB",
  Eogon: "\u0118",
  Eopf: "\u{1D53C}",
  Epsilon: "\u0395",
  Equal: "\u2A75",
  EqualTilde: "\u2242",
  Equilibrium: "\u21CC",
  Escr: "\u2130",
  Esim: "\u2A73",
  Eta: "\u0397",
  Euml: "\xCB",
  Exists: "\u2203",
  ExponentialE: "\u2147",
  Fcy: "\u0424",
  Ffr: "\u{1D509}",
  FilledSmallSquare: "\u25FC",
  FilledVerySmallSquare: "\u25AA",
  Fopf: "\u{1D53D}",
  ForAll: "\u2200",
  Fouriertrf: "\u2131",
  Fscr: "\u2131",
  GJcy: "\u0403",
  GT: ">",
  Gamma: "\u0393",
  Gammad: "\u03DC",
  Gbreve: "\u011E",
  Gcedil: "\u0122",
  Gcirc: "\u011C",
  Gcy: "\u0413",
  Gdot: "\u0120",
  Gfr: "\u{1D50A}",
  Gg: "\u22D9",
  Gopf: "\u{1D53E}",
  GreaterEqual: "\u2265",
  GreaterEqualLess: "\u22DB",
  GreaterFullEqual: "\u2267",
  GreaterGreater: "\u2AA2",
  GreaterLess: "\u2277",
  GreaterSlantEqual: "\u2A7E",
  GreaterTilde: "\u2273",
  Gscr: "\u{1D4A2}",
  Gt: "\u226B",
  HARDcy: "\u042A",
  Hacek: "\u02C7",
  Hat: "^",
  Hcirc: "\u0124",
  Hfr: "\u210C",
  HilbertSpace: "\u210B",
  Hopf: "\u210D",
  HorizontalLine: "\u2500",
  Hscr: "\u210B",
  Hstrok: "\u0126",
  HumpDownHump: "\u224E",
  HumpEqual: "\u224F",
  IEcy: "\u0415",
  IJlig: "\u0132",
  IOcy: "\u0401",
  Iacute: "\xCD",
  Icirc: "\xCE",
  Icy: "\u0418",
  Idot: "\u0130",
  Ifr: "\u2111",
  Igrave: "\xCC",
  Im: "\u2111",
  Imacr: "\u012A",
  ImaginaryI: "\u2148",
  Implies: "\u21D2",
  Int: "\u222C",
  Integral: "\u222B",
  Intersection: "\u22C2",
  InvisibleComma: "\u2063",
  InvisibleTimes: "\u2062",
  Iogon: "\u012E",
  Iopf: "\u{1D540}",
  Iota: "\u0399",
  Iscr: "\u2110",
  Itilde: "\u0128",
  Iukcy: "\u0406",
  Iuml: "\xCF",
  Jcirc: "\u0134",
  Jcy: "\u0419",
  Jfr: "\u{1D50D}",
  Jopf: "\u{1D541}",
  Jscr: "\u{1D4A5}",
  Jsercy: "\u0408",
  Jukcy: "\u0404",
  KHcy: "\u0425",
  KJcy: "\u040C",
  Kappa: "\u039A",
  Kcedil: "\u0136",
  Kcy: "\u041A",
  Kfr: "\u{1D50E}",
  Kopf: "\u{1D542}",
  Kscr: "\u{1D4A6}",
  LJcy: "\u0409",
  LT: "<",
  Lacute: "\u0139",
  Lambda: "\u039B",
  Lang: "\u27EA",
  Laplacetrf: "\u2112",
  Larr: "\u219E",
  Lcaron: "\u013D",
  Lcedil: "\u013B",
  Lcy: "\u041B",
  LeftAngleBracket: "\u27E8",
  LeftArrow: "\u2190",
  LeftArrowBar: "\u21E4",
  LeftArrowRightArrow: "\u21C6",
  LeftCeiling: "\u2308",
  LeftDoubleBracket: "\u27E6",
  LeftDownTeeVector: "\u2961",
  LeftDownVector: "\u21C3",
  LeftDownVectorBar: "\u2959",
  LeftFloor: "\u230A",
  LeftRightArrow: "\u2194",
  LeftRightVector: "\u294E",
  LeftTee: "\u22A3",
  LeftTeeArrow: "\u21A4",
  LeftTeeVector: "\u295A",
  LeftTriangle: "\u22B2",
  LeftTriangleBar: "\u29CF",
  LeftTriangleEqual: "\u22B4",
  LeftUpDownVector: "\u2951",
  LeftUpTeeVector: "\u2960",
  LeftUpVector: "\u21BF",
  LeftUpVectorBar: "\u2958",
  LeftVector: "\u21BC",
  LeftVectorBar: "\u2952",
  Leftarrow: "\u21D0",
  Leftrightarrow: "\u21D4",
  LessEqualGreater: "\u22DA",
  LessFullEqual: "\u2266",
  LessGreater: "\u2276",
  LessLess: "\u2AA1",
  LessSlantEqual: "\u2A7D",
  LessTilde: "\u2272",
  Lfr: "\u{1D50F}",
  Ll: "\u22D8",
  Lleftarrow: "\u21DA",
  Lmidot: "\u013F",
  LongLeftArrow: "\u27F5",
  LongLeftRightArrow: "\u27F7",
  LongRightArrow: "\u27F6",
  Longleftarrow: "\u27F8",
  Longleftrightarrow: "\u27FA",
  Longrightarrow: "\u27F9",
  Lopf: "\u{1D543}",
  LowerLeftArrow: "\u2199",
  LowerRightArrow: "\u2198",
  Lscr: "\u2112",
  Lsh: "\u21B0",
  Lstrok: "\u0141",
  Lt: "\u226A",
  Map: "\u2905",
  Mcy: "\u041C",
  MediumSpace: "\u205F",
  Mellintrf: "\u2133",
  Mfr: "\u{1D510}",
  MinusPlus: "\u2213",
  Mopf: "\u{1D544}",
  Mscr: "\u2133",
  Mu: "\u039C",
  NJcy: "\u040A",
  Nacute: "\u0143",
  Ncaron: "\u0147",
  Ncedil: "\u0145",
  Ncy: "\u041D",
  NegativeMediumSpace: "\u200B",
  NegativeThickSpace: "\u200B",
  NegativeThinSpace: "\u200B",
  NegativeVeryThinSpace: "\u200B",
  NestedGreaterGreater: "\u226B",
  NestedLessLess: "\u226A",
  NewLine: "\n",
  Nfr: "\u{1D511}",
  NoBreak: "\u2060",
  NonBreakingSpace: "\xA0",
  Nopf: "\u2115",
  Not: "\u2AEC",
  NotCongruent: "\u2262",
  NotCupCap: "\u226D",
  NotDoubleVerticalBar: "\u2226",
  NotElement: "\u2209",
  NotEqual: "\u2260",
  NotEqualTilde: "\u2242\u0338",
  NotExists: "\u2204",
  NotGreater: "\u226F",
  NotGreaterEqual: "\u2271",
  NotGreaterFullEqual: "\u2267\u0338",
  NotGreaterGreater: "\u226B\u0338",
  NotGreaterLess: "\u2279",
  NotGreaterSlantEqual: "\u2A7E\u0338",
  NotGreaterTilde: "\u2275",
  NotHumpDownHump: "\u224E\u0338",
  NotHumpEqual: "\u224F\u0338",
  NotLeftTriangle: "\u22EA",
  NotLeftTriangleBar: "\u29CF\u0338",
  NotLeftTriangleEqual: "\u22EC",
  NotLess: "\u226E",
  NotLessEqual: "\u2270",
  NotLessGreater: "\u2278",
  NotLessLess: "\u226A\u0338",
  NotLessSlantEqual: "\u2A7D\u0338",
  NotLessTilde: "\u2274",
  NotNestedGreaterGreater: "\u2AA2\u0338",
  NotNestedLessLess: "\u2AA1\u0338",
  NotPrecedes: "\u2280",
  NotPrecedesEqual: "\u2AAF\u0338",
  NotPrecedesSlantEqual: "\u22E0",
  NotReverseElement: "\u220C",
  NotRightTriangle: "\u22EB",
  NotRightTriangleBar: "\u29D0\u0338",
  NotRightTriangleEqual: "\u22ED",
  NotSquareSubset: "\u228F\u0338",
  NotSquareSubsetEqual: "\u22E2",
  NotSquareSuperset: "\u2290\u0338",
  NotSquareSupersetEqual: "\u22E3",
  NotSubset: "\u2282\u20D2",
  NotSubsetEqual: "\u2288",
  NotSucceeds: "\u2281",
  NotSucceedsEqual: "\u2AB0\u0338",
  NotSucceedsSlantEqual: "\u22E1",
  NotSucceedsTilde: "\u227F\u0338",
  NotSuperset: "\u2283\u20D2",
  NotSupersetEqual: "\u2289",
  NotTilde: "\u2241",
  NotTildeEqual: "\u2244",
  NotTildeFullEqual: "\u2247",
  NotTildeTilde: "\u2249",
  NotVerticalBar: "\u2224",
  Nscr: "\u{1D4A9}",
  Ntilde: "\xD1",
  Nu: "\u039D",
  OElig: "\u0152",
  Oacute: "\xD3",
  Ocirc: "\xD4",
  Ocy: "\u041E",
  Odblac: "\u0150",
  Ofr: "\u{1D512}",
  Ograve: "\xD2",
  Omacr: "\u014C",
  Omega: "\u03A9",
  Omicron: "\u039F",
  Oopf: "\u{1D546}",
  OpenCurlyDoubleQuote: "\u201C",
  OpenCurlyQuote: "\u2018",
  Or: "\u2A54",
  Oscr: "\u{1D4AA}",
  Oslash: "\xD8",
  Otilde: "\xD5",
  Otimes: "\u2A37",
  Ouml: "\xD6",
  OverBar: "\u203E",
  OverBrace: "\u23DE",
  OverBracket: "\u23B4",
  OverParenthesis: "\u23DC",
  PartialD: "\u2202",
  Pcy: "\u041F",
  Pfr: "\u{1D513}",
  Phi: "\u03A6",
  Pi: "\u03A0",
  PlusMinus: "\xB1",
  Poincareplane: "\u210C",
  Popf: "\u2119",
  Pr: "\u2ABB",
  Precedes: "\u227A",
  PrecedesEqual: "\u2AAF",
  PrecedesSlantEqual: "\u227C",
  PrecedesTilde: "\u227E",
  Prime: "\u2033",
  Product: "\u220F",
  Proportion: "\u2237",
  Proportional: "\u221D",
  Pscr: "\u{1D4AB}",
  Psi: "\u03A8",
  QUOT: '"',
  Qfr: "\u{1D514}",
  Qopf: "\u211A",
  Qscr: "\u{1D4AC}",
  RBarr: "\u2910",
  REG: "\xAE",
  Racute: "\u0154",
  Rang: "\u27EB",
  Rarr: "\u21A0",
  Rarrtl: "\u2916",
  Rcaron: "\u0158",
  Rcedil: "\u0156",
  Rcy: "\u0420",
  Re: "\u211C",
  ReverseElement: "\u220B",
  ReverseEquilibrium: "\u21CB",
  ReverseUpEquilibrium: "\u296F",
  Rfr: "\u211C",
  Rho: "\u03A1",
  RightAngleBracket: "\u27E9",
  RightArrow: "\u2192",
  RightArrowBar: "\u21E5",
  RightArrowLeftArrow: "\u21C4",
  RightCeiling: "\u2309",
  RightDoubleBracket: "\u27E7",
  RightDownTeeVector: "\u295D",
  RightDownVector: "\u21C2",
  RightDownVectorBar: "\u2955",
  RightFloor: "\u230B",
  RightTee: "\u22A2",
  RightTeeArrow: "\u21A6",
  RightTeeVector: "\u295B",
  RightTriangle: "\u22B3",
  RightTriangleBar: "\u29D0",
  RightTriangleEqual: "\u22B5",
  RightUpDownVector: "\u294F",
  RightUpTeeVector: "\u295C",
  RightUpVector: "\u21BE",
  RightUpVectorBar: "\u2954",
  RightVector: "\u21C0",
  RightVectorBar: "\u2953",
  Rightarrow: "\u21D2",
  Ropf: "\u211D",
  RoundImplies: "\u2970",
  Rrightarrow: "\u21DB",
  Rscr: "\u211B",
  Rsh: "\u21B1",
  RuleDelayed: "\u29F4",
  SHCHcy: "\u0429",
  SHcy: "\u0428",
  SOFTcy: "\u042C",
  Sacute: "\u015A",
  Sc: "\u2ABC",
  Scaron: "\u0160",
  Scedil: "\u015E",
  Scirc: "\u015C",
  Scy: "\u0421",
  Sfr: "\u{1D516}",
  ShortDownArrow: "\u2193",
  ShortLeftArrow: "\u2190",
  ShortRightArrow: "\u2192",
  ShortUpArrow: "\u2191",
  Sigma: "\u03A3",
  SmallCircle: "\u2218",
  Sopf: "\u{1D54A}",
  Sqrt: "\u221A",
  Square: "\u25A1",
  SquareIntersection: "\u2293",
  SquareSubset: "\u228F",
  SquareSubsetEqual: "\u2291",
  SquareSuperset: "\u2290",
  SquareSupersetEqual: "\u2292",
  SquareUnion: "\u2294",
  Sscr: "\u{1D4AE}",
  Star: "\u22C6",
  Sub: "\u22D0",
  Subset: "\u22D0",
  SubsetEqual: "\u2286",
  Succeeds: "\u227B",
  SucceedsEqual: "\u2AB0",
  SucceedsSlantEqual: "\u227D",
  SucceedsTilde: "\u227F",
  SuchThat: "\u220B",
  Sum: "\u2211",
  Sup: "\u22D1",
  Superset: "\u2283",
  SupersetEqual: "\u2287",
  Supset: "\u22D1",
  THORN: "\xDE",
  TRADE: "\u2122",
  TSHcy: "\u040B",
  TScy: "\u0426",
  Tab: "	",
  Tau: "\u03A4",
  Tcaron: "\u0164",
  Tcedil: "\u0162",
  Tcy: "\u0422",
  Tfr: "\u{1D517}",
  Therefore: "\u2234",
  Theta: "\u0398",
  ThickSpace: "\u205F\u200A",
  ThinSpace: "\u2009",
  Tilde: "\u223C",
  TildeEqual: "\u2243",
  TildeFullEqual: "\u2245",
  TildeTilde: "\u2248",
  Topf: "\u{1D54B}",
  TripleDot: "\u20DB",
  Tscr: "\u{1D4AF}",
  Tstrok: "\u0166",
  Uacute: "\xDA",
  Uarr: "\u219F",
  Uarrocir: "\u2949",
  Ubrcy: "\u040E",
  Ubreve: "\u016C",
  Ucirc: "\xDB",
  Ucy: "\u0423",
  Udblac: "\u0170",
  Ufr: "\u{1D518}",
  Ugrave: "\xD9",
  Umacr: "\u016A",
  UnderBar: "_",
  UnderBrace: "\u23DF",
  UnderBracket: "\u23B5",
  UnderParenthesis: "\u23DD",
  Union: "\u22C3",
  UnionPlus: "\u228E",
  Uogon: "\u0172",
  Uopf: "\u{1D54C}",
  UpArrow: "\u2191",
  UpArrowBar: "\u2912",
  UpArrowDownArrow: "\u21C5",
  UpDownArrow: "\u2195",
  UpEquilibrium: "\u296E",
  UpTee: "\u22A5",
  UpTeeArrow: "\u21A5",
  Uparrow: "\u21D1",
  Updownarrow: "\u21D5",
  UpperLeftArrow: "\u2196",
  UpperRightArrow: "\u2197",
  Upsi: "\u03D2",
  Upsilon: "\u03A5",
  Uring: "\u016E",
  Uscr: "\u{1D4B0}",
  Utilde: "\u0168",
  Uuml: "\xDC",
  VDash: "\u22AB",
  Vbar: "\u2AEB",
  Vcy: "\u0412",
  Vdash: "\u22A9",
  Vdashl: "\u2AE6",
  Vee: "\u22C1",
  Verbar: "\u2016",
  Vert: "\u2016",
  VerticalBar: "\u2223",
  VerticalLine: "|",
  VerticalSeparator: "\u2758",
  VerticalTilde: "\u2240",
  VeryThinSpace: "\u200A",
  Vfr: "\u{1D519}",
  Vopf: "\u{1D54D}",
  Vscr: "\u{1D4B1}",
  Vvdash: "\u22AA",
  Wcirc: "\u0174",
  Wedge: "\u22C0",
  Wfr: "\u{1D51A}",
  Wopf: "\u{1D54E}",
  Wscr: "\u{1D4B2}",
  Xfr: "\u{1D51B}",
  Xi: "\u039E",
  Xopf: "\u{1D54F}",
  Xscr: "\u{1D4B3}",
  YAcy: "\u042F",
  YIcy: "\u0407",
  YUcy: "\u042E",
  Yacute: "\xDD",
  Ycirc: "\u0176",
  Ycy: "\u042B",
  Yfr: "\u{1D51C}",
  Yopf: "\u{1D550}",
  Yscr: "\u{1D4B4}",
  Yuml: "\u0178",
  ZHcy: "\u0416",
  Zacute: "\u0179",
  Zcaron: "\u017D",
  Zcy: "\u0417",
  Zdot: "\u017B",
  ZeroWidthSpace: "\u200B",
  Zeta: "\u0396",
  Zfr: "\u2128",
  Zopf: "\u2124",
  Zscr: "\u{1D4B5}",
  aacute: "\xE1",
  abreve: "\u0103",
  ac: "\u223E",
  acE: "\u223E\u0333",
  acd: "\u223F",
  acirc: "\xE2",
  acute: "\xB4",
  acy: "\u0430",
  aelig: "\xE6",
  af: "\u2061",
  afr: "\u{1D51E}",
  agrave: "\xE0",
  alefsym: "\u2135",
  aleph: "\u2135",
  alpha: "\u03B1",
  amacr: "\u0101",
  amalg: "\u2A3F",
  amp: "&",
  and: "\u2227",
  andand: "\u2A55",
  andd: "\u2A5C",
  andslope: "\u2A58",
  andv: "\u2A5A",
  ang: "\u2220",
  ange: "\u29A4",
  angle: "\u2220",
  angmsd: "\u2221",
  angmsdaa: "\u29A8",
  angmsdab: "\u29A9",
  angmsdac: "\u29AA",
  angmsdad: "\u29AB",
  angmsdae: "\u29AC",
  angmsdaf: "\u29AD",
  angmsdag: "\u29AE",
  angmsdah: "\u29AF",
  angrt: "\u221F",
  angrtvb: "\u22BE",
  angrtvbd: "\u299D",
  angsph: "\u2222",
  angst: "\xC5",
  angzarr: "\u237C",
  aogon: "\u0105",
  aopf: "\u{1D552}",
  ap: "\u2248",
  apE: "\u2A70",
  apacir: "\u2A6F",
  ape: "\u224A",
  apid: "\u224B",
  apos: "'",
  approx: "\u2248",
  approxeq: "\u224A",
  aring: "\xE5",
  ascr: "\u{1D4B6}",
  ast: "*",
  asymp: "\u2248",
  asympeq: "\u224D",
  atilde: "\xE3",
  auml: "\xE4",
  awconint: "\u2233",
  awint: "\u2A11",
  bNot: "\u2AED",
  backcong: "\u224C",
  backepsilon: "\u03F6",
  backprime: "\u2035",
  backsim: "\u223D",
  backsimeq: "\u22CD",
  barvee: "\u22BD",
  barwed: "\u2305",
  barwedge: "\u2305",
  bbrk: "\u23B5",
  bbrktbrk: "\u23B6",
  bcong: "\u224C",
  bcy: "\u0431",
  bdquo: "\u201E",
  becaus: "\u2235",
  because: "\u2235",
  bemptyv: "\u29B0",
  bepsi: "\u03F6",
  bernou: "\u212C",
  beta: "\u03B2",
  beth: "\u2136",
  between: "\u226C",
  bfr: "\u{1D51F}",
  bigcap: "\u22C2",
  bigcirc: "\u25EF",
  bigcup: "\u22C3",
  bigodot: "\u2A00",
  bigoplus: "\u2A01",
  bigotimes: "\u2A02",
  bigsqcup: "\u2A06",
  bigstar: "\u2605",
  bigtriangledown: "\u25BD",
  bigtriangleup: "\u25B3",
  biguplus: "\u2A04",
  bigvee: "\u22C1",
  bigwedge: "\u22C0",
  bkarow: "\u290D",
  blacklozenge: "\u29EB",
  blacksquare: "\u25AA",
  blacktriangle: "\u25B4",
  blacktriangledown: "\u25BE",
  blacktriangleleft: "\u25C2",
  blacktriangleright: "\u25B8",
  blank: "\u2423",
  blk12: "\u2592",
  blk14: "\u2591",
  blk34: "\u2593",
  block: "\u2588",
  bne: "=\u20E5",
  bnequiv: "\u2261\u20E5",
  bnot: "\u2310",
  bopf: "\u{1D553}",
  bot: "\u22A5",
  bottom: "\u22A5",
  bowtie: "\u22C8",
  boxDL: "\u2557",
  boxDR: "\u2554",
  boxDl: "\u2556",
  boxDr: "\u2553",
  boxH: "\u2550",
  boxHD: "\u2566",
  boxHU: "\u2569",
  boxHd: "\u2564",
  boxHu: "\u2567",
  boxUL: "\u255D",
  boxUR: "\u255A",
  boxUl: "\u255C",
  boxUr: "\u2559",
  boxV: "\u2551",
  boxVH: "\u256C",
  boxVL: "\u2563",
  boxVR: "\u2560",
  boxVh: "\u256B",
  boxVl: "\u2562",
  boxVr: "\u255F",
  boxbox: "\u29C9",
  boxdL: "\u2555",
  boxdR: "\u2552",
  boxdl: "\u2510",
  boxdr: "\u250C",
  boxh: "\u2500",
  boxhD: "\u2565",
  boxhU: "\u2568",
  boxhd: "\u252C",
  boxhu: "\u2534",
  boxminus: "\u229F",
  boxplus: "\u229E",
  boxtimes: "\u22A0",
  boxuL: "\u255B",
  boxuR: "\u2558",
  boxul: "\u2518",
  boxur: "\u2514",
  boxv: "\u2502",
  boxvH: "\u256A",
  boxvL: "\u2561",
  boxvR: "\u255E",
  boxvh: "\u253C",
  boxvl: "\u2524",
  boxvr: "\u251C",
  bprime: "\u2035",
  breve: "\u02D8",
  brvbar: "\xA6",
  bscr: "\u{1D4B7}",
  bsemi: "\u204F",
  bsim: "\u223D",
  bsime: "\u22CD",
  bsol: "\\",
  bsolb: "\u29C5",
  bsolhsub: "\u27C8",
  bull: "\u2022",
  bullet: "\u2022",
  bump: "\u224E",
  bumpE: "\u2AAE",
  bumpe: "\u224F",
  bumpeq: "\u224F",
  cacute: "\u0107",
  cap: "\u2229",
  capand: "\u2A44",
  capbrcup: "\u2A49",
  capcap: "\u2A4B",
  capcup: "\u2A47",
  capdot: "\u2A40",
  caps: "\u2229\uFE00",
  caret: "\u2041",
  caron: "\u02C7",
  ccaps: "\u2A4D",
  ccaron: "\u010D",
  ccedil: "\xE7",
  ccirc: "\u0109",
  ccups: "\u2A4C",
  ccupssm: "\u2A50",
  cdot: "\u010B",
  cedil: "\xB8",
  cemptyv: "\u29B2",
  cent: "\xA2",
  centerdot: "\xB7",
  cfr: "\u{1D520}",
  chcy: "\u0447",
  check: "\u2713",
  checkmark: "\u2713",
  chi: "\u03C7",
  cir: "\u25CB",
  cirE: "\u29C3",
  circ: "\u02C6",
  circeq: "\u2257",
  circlearrowleft: "\u21BA",
  circlearrowright: "\u21BB",
  circledR: "\xAE",
  circledS: "\u24C8",
  circledast: "\u229B",
  circledcirc: "\u229A",
  circleddash: "\u229D",
  cire: "\u2257",
  cirfnint: "\u2A10",
  cirmid: "\u2AEF",
  cirscir: "\u29C2",
  clubs: "\u2663",
  clubsuit: "\u2663",
  colon: ":",
  colone: "\u2254",
  coloneq: "\u2254",
  comma: ",",
  commat: "@",
  comp: "\u2201",
  compfn: "\u2218",
  complement: "\u2201",
  complexes: "\u2102",
  cong: "\u2245",
  congdot: "\u2A6D",
  conint: "\u222E",
  copf: "\u{1D554}",
  coprod: "\u2210",
  copy: "\xA9",
  copysr: "\u2117",
  crarr: "\u21B5",
  cross: "\u2717",
  cscr: "\u{1D4B8}",
  csub: "\u2ACF",
  csube: "\u2AD1",
  csup: "\u2AD0",
  csupe: "\u2AD2",
  ctdot: "\u22EF",
  cudarrl: "\u2938",
  cudarrr: "\u2935",
  cuepr: "\u22DE",
  cuesc: "\u22DF",
  cularr: "\u21B6",
  cularrp: "\u293D",
  cup: "\u222A",
  cupbrcap: "\u2A48",
  cupcap: "\u2A46",
  cupcup: "\u2A4A",
  cupdot: "\u228D",
  cupor: "\u2A45",
  cups: "\u222A\uFE00",
  curarr: "\u21B7",
  curarrm: "\u293C",
  curlyeqprec: "\u22DE",
  curlyeqsucc: "\u22DF",
  curlyvee: "\u22CE",
  curlywedge: "\u22CF",
  curren: "\xA4",
  curvearrowleft: "\u21B6",
  curvearrowright: "\u21B7",
  cuvee: "\u22CE",
  cuwed: "\u22CF",
  cwconint: "\u2232",
  cwint: "\u2231",
  cylcty: "\u232D",
  dArr: "\u21D3",
  dHar: "\u2965",
  dagger: "\u2020",
  daleth: "\u2138",
  darr: "\u2193",
  dash: "\u2010",
  dashv: "\u22A3",
  dbkarow: "\u290F",
  dblac: "\u02DD",
  dcaron: "\u010F",
  dcy: "\u0434",
  dd: "\u2146",
  ddagger: "\u2021",
  ddarr: "\u21CA",
  ddotseq: "\u2A77",
  deg: "\xB0",
  delta: "\u03B4",
  demptyv: "\u29B1",
  dfisht: "\u297F",
  dfr: "\u{1D521}",
  dharl: "\u21C3",
  dharr: "\u21C2",
  diam: "\u22C4",
  diamond: "\u22C4",
  diamondsuit: "\u2666",
  diams: "\u2666",
  die: "\xA8",
  digamma: "\u03DD",
  disin: "\u22F2",
  div: "\xF7",
  divide: "\xF7",
  divideontimes: "\u22C7",
  divonx: "\u22C7",
  djcy: "\u0452",
  dlcorn: "\u231E",
  dlcrop: "\u230D",
  dollar: "$",
  dopf: "\u{1D555}",
  dot: "\u02D9",
  doteq: "\u2250",
  doteqdot: "\u2251",
  dotminus: "\u2238",
  dotplus: "\u2214",
  dotsquare: "\u22A1",
  doublebarwedge: "\u2306",
  downarrow: "\u2193",
  downdownarrows: "\u21CA",
  downharpoonleft: "\u21C3",
  downharpoonright: "\u21C2",
  drbkarow: "\u2910",
  drcorn: "\u231F",
  drcrop: "\u230C",
  dscr: "\u{1D4B9}",
  dscy: "\u0455",
  dsol: "\u29F6",
  dstrok: "\u0111",
  dtdot: "\u22F1",
  dtri: "\u25BF",
  dtrif: "\u25BE",
  duarr: "\u21F5",
  duhar: "\u296F",
  dwangle: "\u29A6",
  dzcy: "\u045F",
  dzigrarr: "\u27FF",
  eDDot: "\u2A77",
  eDot: "\u2251",
  eacute: "\xE9",
  easter: "\u2A6E",
  ecaron: "\u011B",
  ecir: "\u2256",
  ecirc: "\xEA",
  ecolon: "\u2255",
  ecy: "\u044D",
  edot: "\u0117",
  ee: "\u2147",
  efDot: "\u2252",
  efr: "\u{1D522}",
  eg: "\u2A9A",
  egrave: "\xE8",
  egs: "\u2A96",
  egsdot: "\u2A98",
  el: "\u2A99",
  elinters: "\u23E7",
  ell: "\u2113",
  els: "\u2A95",
  elsdot: "\u2A97",
  emacr: "\u0113",
  empty: "\u2205",
  emptyset: "\u2205",
  emptyv: "\u2205",
  emsp13: "\u2004",
  emsp14: "\u2005",
  emsp: "\u2003",
  eng: "\u014B",
  ensp: "\u2002",
  eogon: "\u0119",
  eopf: "\u{1D556}",
  epar: "\u22D5",
  eparsl: "\u29E3",
  eplus: "\u2A71",
  epsi: "\u03B5",
  epsilon: "\u03B5",
  epsiv: "\u03F5",
  eqcirc: "\u2256",
  eqcolon: "\u2255",
  eqsim: "\u2242",
  eqslantgtr: "\u2A96",
  eqslantless: "\u2A95",
  equals: "=",
  equest: "\u225F",
  equiv: "\u2261",
  equivDD: "\u2A78",
  eqvparsl: "\u29E5",
  erDot: "\u2253",
  erarr: "\u2971",
  escr: "\u212F",
  esdot: "\u2250",
  esim: "\u2242",
  eta: "\u03B7",
  eth: "\xF0",
  euml: "\xEB",
  euro: "\u20AC",
  excl: "!",
  exist: "\u2203",
  expectation: "\u2130",
  exponentiale: "\u2147",
  fallingdotseq: "\u2252",
  fcy: "\u0444",
  female: "\u2640",
  ffilig: "\uFB03",
  fflig: "\uFB00",
  ffllig: "\uFB04",
  ffr: "\u{1D523}",
  filig: "\uFB01",
  fjlig: "fj",
  flat: "\u266D",
  fllig: "\uFB02",
  fltns: "\u25B1",
  fnof: "\u0192",
  fopf: "\u{1D557}",
  forall: "\u2200",
  fork: "\u22D4",
  forkv: "\u2AD9",
  fpartint: "\u2A0D",
  frac12: "\xBD",
  frac13: "\u2153",
  frac14: "\xBC",
  frac15: "\u2155",
  frac16: "\u2159",
  frac18: "\u215B",
  frac23: "\u2154",
  frac25: "\u2156",
  frac34: "\xBE",
  frac35: "\u2157",
  frac38: "\u215C",
  frac45: "\u2158",
  frac56: "\u215A",
  frac58: "\u215D",
  frac78: "\u215E",
  frasl: "\u2044",
  frown: "\u2322",
  fscr: "\u{1D4BB}",
  gE: "\u2267",
  gEl: "\u2A8C",
  gacute: "\u01F5",
  gamma: "\u03B3",
  gammad: "\u03DD",
  gap: "\u2A86",
  gbreve: "\u011F",
  gcirc: "\u011D",
  gcy: "\u0433",
  gdot: "\u0121",
  ge: "\u2265",
  gel: "\u22DB",
  geq: "\u2265",
  geqq: "\u2267",
  geqslant: "\u2A7E",
  ges: "\u2A7E",
  gescc: "\u2AA9",
  gesdot: "\u2A80",
  gesdoto: "\u2A82",
  gesdotol: "\u2A84",
  gesl: "\u22DB\uFE00",
  gesles: "\u2A94",
  gfr: "\u{1D524}",
  gg: "\u226B",
  ggg: "\u22D9",
  gimel: "\u2137",
  gjcy: "\u0453",
  gl: "\u2277",
  glE: "\u2A92",
  gla: "\u2AA5",
  glj: "\u2AA4",
  gnE: "\u2269",
  gnap: "\u2A8A",
  gnapprox: "\u2A8A",
  gne: "\u2A88",
  gneq: "\u2A88",
  gneqq: "\u2269",
  gnsim: "\u22E7",
  gopf: "\u{1D558}",
  grave: "`",
  gscr: "\u210A",
  gsim: "\u2273",
  gsime: "\u2A8E",
  gsiml: "\u2A90",
  gt: ">",
  gtcc: "\u2AA7",
  gtcir: "\u2A7A",
  gtdot: "\u22D7",
  gtlPar: "\u2995",
  gtquest: "\u2A7C",
  gtrapprox: "\u2A86",
  gtrarr: "\u2978",
  gtrdot: "\u22D7",
  gtreqless: "\u22DB",
  gtreqqless: "\u2A8C",
  gtrless: "\u2277",
  gtrsim: "\u2273",
  gvertneqq: "\u2269\uFE00",
  gvnE: "\u2269\uFE00",
  hArr: "\u21D4",
  hairsp: "\u200A",
  half: "\xBD",
  hamilt: "\u210B",
  hardcy: "\u044A",
  harr: "\u2194",
  harrcir: "\u2948",
  harrw: "\u21AD",
  hbar: "\u210F",
  hcirc: "\u0125",
  hearts: "\u2665",
  heartsuit: "\u2665",
  hellip: "\u2026",
  hercon: "\u22B9",
  hfr: "\u{1D525}",
  hksearow: "\u2925",
  hkswarow: "\u2926",
  hoarr: "\u21FF",
  homtht: "\u223B",
  hookleftarrow: "\u21A9",
  hookrightarrow: "\u21AA",
  hopf: "\u{1D559}",
  horbar: "\u2015",
  hscr: "\u{1D4BD}",
  hslash: "\u210F",
  hstrok: "\u0127",
  hybull: "\u2043",
  hyphen: "\u2010",
  iacute: "\xED",
  ic: "\u2063",
  icirc: "\xEE",
  icy: "\u0438",
  iecy: "\u0435",
  iexcl: "\xA1",
  iff: "\u21D4",
  ifr: "\u{1D526}",
  igrave: "\xEC",
  ii: "\u2148",
  iiiint: "\u2A0C",
  iiint: "\u222D",
  iinfin: "\u29DC",
  iiota: "\u2129",
  ijlig: "\u0133",
  imacr: "\u012B",
  image: "\u2111",
  imagline: "\u2110",
  imagpart: "\u2111",
  imath: "\u0131",
  imof: "\u22B7",
  imped: "\u01B5",
  in: "\u2208",
  incare: "\u2105",
  infin: "\u221E",
  infintie: "\u29DD",
  inodot: "\u0131",
  int: "\u222B",
  intcal: "\u22BA",
  integers: "\u2124",
  intercal: "\u22BA",
  intlarhk: "\u2A17",
  intprod: "\u2A3C",
  iocy: "\u0451",
  iogon: "\u012F",
  iopf: "\u{1D55A}",
  iota: "\u03B9",
  iprod: "\u2A3C",
  iquest: "\xBF",
  iscr: "\u{1D4BE}",
  isin: "\u2208",
  isinE: "\u22F9",
  isindot: "\u22F5",
  isins: "\u22F4",
  isinsv: "\u22F3",
  isinv: "\u2208",
  it: "\u2062",
  itilde: "\u0129",
  iukcy: "\u0456",
  iuml: "\xEF",
  jcirc: "\u0135",
  jcy: "\u0439",
  jfr: "\u{1D527}",
  jmath: "\u0237",
  jopf: "\u{1D55B}",
  jscr: "\u{1D4BF}",
  jsercy: "\u0458",
  jukcy: "\u0454",
  kappa: "\u03BA",
  kappav: "\u03F0",
  kcedil: "\u0137",
  kcy: "\u043A",
  kfr: "\u{1D528}",
  kgreen: "\u0138",
  khcy: "\u0445",
  kjcy: "\u045C",
  kopf: "\u{1D55C}",
  kscr: "\u{1D4C0}",
  lAarr: "\u21DA",
  lArr: "\u21D0",
  lAtail: "\u291B",
  lBarr: "\u290E",
  lE: "\u2266",
  lEg: "\u2A8B",
  lHar: "\u2962",
  lacute: "\u013A",
  laemptyv: "\u29B4",
  lagran: "\u2112",
  lambda: "\u03BB",
  lang: "\u27E8",
  langd: "\u2991",
  langle: "\u27E8",
  lap: "\u2A85",
  laquo: "\xAB",
  larr: "\u2190",
  larrb: "\u21E4",
  larrbfs: "\u291F",
  larrfs: "\u291D",
  larrhk: "\u21A9",
  larrlp: "\u21AB",
  larrpl: "\u2939",
  larrsim: "\u2973",
  larrtl: "\u21A2",
  lat: "\u2AAB",
  latail: "\u2919",
  late: "\u2AAD",
  lates: "\u2AAD\uFE00",
  lbarr: "\u290C",
  lbbrk: "\u2772",
  lbrace: "{",
  lbrack: "[",
  lbrke: "\u298B",
  lbrksld: "\u298F",
  lbrkslu: "\u298D",
  lcaron: "\u013E",
  lcedil: "\u013C",
  lceil: "\u2308",
  lcub: "{",
  lcy: "\u043B",
  ldca: "\u2936",
  ldquo: "\u201C",
  ldquor: "\u201E",
  ldrdhar: "\u2967",
  ldrushar: "\u294B",
  ldsh: "\u21B2",
  le: "\u2264",
  leftarrow: "\u2190",
  leftarrowtail: "\u21A2",
  leftharpoondown: "\u21BD",
  leftharpoonup: "\u21BC",
  leftleftarrows: "\u21C7",
  leftrightarrow: "\u2194",
  leftrightarrows: "\u21C6",
  leftrightharpoons: "\u21CB",
  leftrightsquigarrow: "\u21AD",
  leftthreetimes: "\u22CB",
  leg: "\u22DA",
  leq: "\u2264",
  leqq: "\u2266",
  leqslant: "\u2A7D",
  les: "\u2A7D",
  lescc: "\u2AA8",
  lesdot: "\u2A7F",
  lesdoto: "\u2A81",
  lesdotor: "\u2A83",
  lesg: "\u22DA\uFE00",
  lesges: "\u2A93",
  lessapprox: "\u2A85",
  lessdot: "\u22D6",
  lesseqgtr: "\u22DA",
  lesseqqgtr: "\u2A8B",
  lessgtr: "\u2276",
  lesssim: "\u2272",
  lfisht: "\u297C",
  lfloor: "\u230A",
  lfr: "\u{1D529}",
  lg: "\u2276",
  lgE: "\u2A91",
  lhard: "\u21BD",
  lharu: "\u21BC",
  lharul: "\u296A",
  lhblk: "\u2584",
  ljcy: "\u0459",
  ll: "\u226A",
  llarr: "\u21C7",
  llcorner: "\u231E",
  llhard: "\u296B",
  lltri: "\u25FA",
  lmidot: "\u0140",
  lmoust: "\u23B0",
  lmoustache: "\u23B0",
  lnE: "\u2268",
  lnap: "\u2A89",
  lnapprox: "\u2A89",
  lne: "\u2A87",
  lneq: "\u2A87",
  lneqq: "\u2268",
  lnsim: "\u22E6",
  loang: "\u27EC",
  loarr: "\u21FD",
  lobrk: "\u27E6",
  longleftarrow: "\u27F5",
  longleftrightarrow: "\u27F7",
  longmapsto: "\u27FC",
  longrightarrow: "\u27F6",
  looparrowleft: "\u21AB",
  looparrowright: "\u21AC",
  lopar: "\u2985",
  lopf: "\u{1D55D}",
  loplus: "\u2A2D",
  lotimes: "\u2A34",
  lowast: "\u2217",
  lowbar: "_",
  loz: "\u25CA",
  lozenge: "\u25CA",
  lozf: "\u29EB",
  lpar: "(",
  lparlt: "\u2993",
  lrarr: "\u21C6",
  lrcorner: "\u231F",
  lrhar: "\u21CB",
  lrhard: "\u296D",
  lrm: "\u200E",
  lrtri: "\u22BF",
  lsaquo: "\u2039",
  lscr: "\u{1D4C1}",
  lsh: "\u21B0",
  lsim: "\u2272",
  lsime: "\u2A8D",
  lsimg: "\u2A8F",
  lsqb: "[",
  lsquo: "\u2018",
  lsquor: "\u201A",
  lstrok: "\u0142",
  lt: "<",
  ltcc: "\u2AA6",
  ltcir: "\u2A79",
  ltdot: "\u22D6",
  lthree: "\u22CB",
  ltimes: "\u22C9",
  ltlarr: "\u2976",
  ltquest: "\u2A7B",
  ltrPar: "\u2996",
  ltri: "\u25C3",
  ltrie: "\u22B4",
  ltrif: "\u25C2",
  lurdshar: "\u294A",
  luruhar: "\u2966",
  lvertneqq: "\u2268\uFE00",
  lvnE: "\u2268\uFE00",
  mDDot: "\u223A",
  macr: "\xAF",
  male: "\u2642",
  malt: "\u2720",
  maltese: "\u2720",
  map: "\u21A6",
  mapsto: "\u21A6",
  mapstodown: "\u21A7",
  mapstoleft: "\u21A4",
  mapstoup: "\u21A5",
  marker: "\u25AE",
  mcomma: "\u2A29",
  mcy: "\u043C",
  mdash: "\u2014",
  measuredangle: "\u2221",
  mfr: "\u{1D52A}",
  mho: "\u2127",
  micro: "\xB5",
  mid: "\u2223",
  midast: "*",
  midcir: "\u2AF0",
  middot: "\xB7",
  minus: "\u2212",
  minusb: "\u229F",
  minusd: "\u2238",
  minusdu: "\u2A2A",
  mlcp: "\u2ADB",
  mldr: "\u2026",
  mnplus: "\u2213",
  models: "\u22A7",
  mopf: "\u{1D55E}",
  mp: "\u2213",
  mscr: "\u{1D4C2}",
  mstpos: "\u223E",
  mu: "\u03BC",
  multimap: "\u22B8",
  mumap: "\u22B8",
  nGg: "\u22D9\u0338",
  nGt: "\u226B\u20D2",
  nGtv: "\u226B\u0338",
  nLeftarrow: "\u21CD",
  nLeftrightarrow: "\u21CE",
  nLl: "\u22D8\u0338",
  nLt: "\u226A\u20D2",
  nLtv: "\u226A\u0338",
  nRightarrow: "\u21CF",
  nVDash: "\u22AF",
  nVdash: "\u22AE",
  nabla: "\u2207",
  nacute: "\u0144",
  nang: "\u2220\u20D2",
  nap: "\u2249",
  napE: "\u2A70\u0338",
  napid: "\u224B\u0338",
  napos: "\u0149",
  napprox: "\u2249",
  natur: "\u266E",
  natural: "\u266E",
  naturals: "\u2115",
  nbsp: "\xA0",
  nbump: "\u224E\u0338",
  nbumpe: "\u224F\u0338",
  ncap: "\u2A43",
  ncaron: "\u0148",
  ncedil: "\u0146",
  ncong: "\u2247",
  ncongdot: "\u2A6D\u0338",
  ncup: "\u2A42",
  ncy: "\u043D",
  ndash: "\u2013",
  ne: "\u2260",
  neArr: "\u21D7",
  nearhk: "\u2924",
  nearr: "\u2197",
  nearrow: "\u2197",
  nedot: "\u2250\u0338",
  nequiv: "\u2262",
  nesear: "\u2928",
  nesim: "\u2242\u0338",
  nexist: "\u2204",
  nexists: "\u2204",
  nfr: "\u{1D52B}",
  ngE: "\u2267\u0338",
  nge: "\u2271",
  ngeq: "\u2271",
  ngeqq: "\u2267\u0338",
  ngeqslant: "\u2A7E\u0338",
  nges: "\u2A7E\u0338",
  ngsim: "\u2275",
  ngt: "\u226F",
  ngtr: "\u226F",
  nhArr: "\u21CE",
  nharr: "\u21AE",
  nhpar: "\u2AF2",
  ni: "\u220B",
  nis: "\u22FC",
  nisd: "\u22FA",
  niv: "\u220B",
  njcy: "\u045A",
  nlArr: "\u21CD",
  nlE: "\u2266\u0338",
  nlarr: "\u219A",
  nldr: "\u2025",
  nle: "\u2270",
  nleftarrow: "\u219A",
  nleftrightarrow: "\u21AE",
  nleq: "\u2270",
  nleqq: "\u2266\u0338",
  nleqslant: "\u2A7D\u0338",
  nles: "\u2A7D\u0338",
  nless: "\u226E",
  nlsim: "\u2274",
  nlt: "\u226E",
  nltri: "\u22EA",
  nltrie: "\u22EC",
  nmid: "\u2224",
  nopf: "\u{1D55F}",
  not: "\xAC",
  notin: "\u2209",
  notinE: "\u22F9\u0338",
  notindot: "\u22F5\u0338",
  notinva: "\u2209",
  notinvb: "\u22F7",
  notinvc: "\u22F6",
  notni: "\u220C",
  notniva: "\u220C",
  notnivb: "\u22FE",
  notnivc: "\u22FD",
  npar: "\u2226",
  nparallel: "\u2226",
  nparsl: "\u2AFD\u20E5",
  npart: "\u2202\u0338",
  npolint: "\u2A14",
  npr: "\u2280",
  nprcue: "\u22E0",
  npre: "\u2AAF\u0338",
  nprec: "\u2280",
  npreceq: "\u2AAF\u0338",
  nrArr: "\u21CF",
  nrarr: "\u219B",
  nrarrc: "\u2933\u0338",
  nrarrw: "\u219D\u0338",
  nrightarrow: "\u219B",
  nrtri: "\u22EB",
  nrtrie: "\u22ED",
  nsc: "\u2281",
  nsccue: "\u22E1",
  nsce: "\u2AB0\u0338",
  nscr: "\u{1D4C3}",
  nshortmid: "\u2224",
  nshortparallel: "\u2226",
  nsim: "\u2241",
  nsime: "\u2244",
  nsimeq: "\u2244",
  nsmid: "\u2224",
  nspar: "\u2226",
  nsqsube: "\u22E2",
  nsqsupe: "\u22E3",
  nsub: "\u2284",
  nsubE: "\u2AC5\u0338",
  nsube: "\u2288",
  nsubset: "\u2282\u20D2",
  nsubseteq: "\u2288",
  nsubseteqq: "\u2AC5\u0338",
  nsucc: "\u2281",
  nsucceq: "\u2AB0\u0338",
  nsup: "\u2285",
  nsupE: "\u2AC6\u0338",
  nsupe: "\u2289",
  nsupset: "\u2283\u20D2",
  nsupseteq: "\u2289",
  nsupseteqq: "\u2AC6\u0338",
  ntgl: "\u2279",
  ntilde: "\xF1",
  ntlg: "\u2278",
  ntriangleleft: "\u22EA",
  ntrianglelefteq: "\u22EC",
  ntriangleright: "\u22EB",
  ntrianglerighteq: "\u22ED",
  nu: "\u03BD",
  num: "#",
  numero: "\u2116",
  numsp: "\u2007",
  nvDash: "\u22AD",
  nvHarr: "\u2904",
  nvap: "\u224D\u20D2",
  nvdash: "\u22AC",
  nvge: "\u2265\u20D2",
  nvgt: ">\u20D2",
  nvinfin: "\u29DE",
  nvlArr: "\u2902",
  nvle: "\u2264\u20D2",
  nvlt: "<\u20D2",
  nvltrie: "\u22B4\u20D2",
  nvrArr: "\u2903",
  nvrtrie: "\u22B5\u20D2",
  nvsim: "\u223C\u20D2",
  nwArr: "\u21D6",
  nwarhk: "\u2923",
  nwarr: "\u2196",
  nwarrow: "\u2196",
  nwnear: "\u2927",
  oS: "\u24C8",
  oacute: "\xF3",
  oast: "\u229B",
  ocir: "\u229A",
  ocirc: "\xF4",
  ocy: "\u043E",
  odash: "\u229D",
  odblac: "\u0151",
  odiv: "\u2A38",
  odot: "\u2299",
  odsold: "\u29BC",
  oelig: "\u0153",
  ofcir: "\u29BF",
  ofr: "\u{1D52C}",
  ogon: "\u02DB",
  ograve: "\xF2",
  ogt: "\u29C1",
  ohbar: "\u29B5",
  ohm: "\u03A9",
  oint: "\u222E",
  olarr: "\u21BA",
  olcir: "\u29BE",
  olcross: "\u29BB",
  oline: "\u203E",
  olt: "\u29C0",
  omacr: "\u014D",
  omega: "\u03C9",
  omicron: "\u03BF",
  omid: "\u29B6",
  ominus: "\u2296",
  oopf: "\u{1D560}",
  opar: "\u29B7",
  operp: "\u29B9",
  oplus: "\u2295",
  or: "\u2228",
  orarr: "\u21BB",
  ord: "\u2A5D",
  order: "\u2134",
  orderof: "\u2134",
  ordf: "\xAA",
  ordm: "\xBA",
  origof: "\u22B6",
  oror: "\u2A56",
  orslope: "\u2A57",
  orv: "\u2A5B",
  oscr: "\u2134",
  oslash: "\xF8",
  osol: "\u2298",
  otilde: "\xF5",
  otimes: "\u2297",
  otimesas: "\u2A36",
  ouml: "\xF6",
  ovbar: "\u233D",
  par: "\u2225",
  para: "\xB6",
  parallel: "\u2225",
  parsim: "\u2AF3",
  parsl: "\u2AFD",
  part: "\u2202",
  pcy: "\u043F",
  percnt: "%",
  period: ".",
  permil: "\u2030",
  perp: "\u22A5",
  pertenk: "\u2031",
  pfr: "\u{1D52D}",
  phi: "\u03C6",
  phiv: "\u03D5",
  phmmat: "\u2133",
  phone: "\u260E",
  pi: "\u03C0",
  pitchfork: "\u22D4",
  piv: "\u03D6",
  planck: "\u210F",
  planckh: "\u210E",
  plankv: "\u210F",
  plus: "+",
  plusacir: "\u2A23",
  plusb: "\u229E",
  pluscir: "\u2A22",
  plusdo: "\u2214",
  plusdu: "\u2A25",
  pluse: "\u2A72",
  plusmn: "\xB1",
  plussim: "\u2A26",
  plustwo: "\u2A27",
  pm: "\xB1",
  pointint: "\u2A15",
  popf: "\u{1D561}",
  pound: "\xA3",
  pr: "\u227A",
  prE: "\u2AB3",
  prap: "\u2AB7",
  prcue: "\u227C",
  pre: "\u2AAF",
  prec: "\u227A",
  precapprox: "\u2AB7",
  preccurlyeq: "\u227C",
  preceq: "\u2AAF",
  precnapprox: "\u2AB9",
  precneqq: "\u2AB5",
  precnsim: "\u22E8",
  precsim: "\u227E",
  prime: "\u2032",
  primes: "\u2119",
  prnE: "\u2AB5",
  prnap: "\u2AB9",
  prnsim: "\u22E8",
  prod: "\u220F",
  profalar: "\u232E",
  profline: "\u2312",
  profsurf: "\u2313",
  prop: "\u221D",
  propto: "\u221D",
  prsim: "\u227E",
  prurel: "\u22B0",
  pscr: "\u{1D4C5}",
  psi: "\u03C8",
  puncsp: "\u2008",
  qfr: "\u{1D52E}",
  qint: "\u2A0C",
  qopf: "\u{1D562}",
  qprime: "\u2057",
  qscr: "\u{1D4C6}",
  quaternions: "\u210D",
  quatint: "\u2A16",
  quest: "?",
  questeq: "\u225F",
  quot: '"',
  rAarr: "\u21DB",
  rArr: "\u21D2",
  rAtail: "\u291C",
  rBarr: "\u290F",
  rHar: "\u2964",
  race: "\u223D\u0331",
  racute: "\u0155",
  radic: "\u221A",
  raemptyv: "\u29B3",
  rang: "\u27E9",
  rangd: "\u2992",
  range: "\u29A5",
  rangle: "\u27E9",
  raquo: "\xBB",
  rarr: "\u2192",
  rarrap: "\u2975",
  rarrb: "\u21E5",
  rarrbfs: "\u2920",
  rarrc: "\u2933",
  rarrfs: "\u291E",
  rarrhk: "\u21AA",
  rarrlp: "\u21AC",
  rarrpl: "\u2945",
  rarrsim: "\u2974",
  rarrtl: "\u21A3",
  rarrw: "\u219D",
  ratail: "\u291A",
  ratio: "\u2236",
  rationals: "\u211A",
  rbarr: "\u290D",
  rbbrk: "\u2773",
  rbrace: "}",
  rbrack: "]",
  rbrke: "\u298C",
  rbrksld: "\u298E",
  rbrkslu: "\u2990",
  rcaron: "\u0159",
  rcedil: "\u0157",
  rceil: "\u2309",
  rcub: "}",
  rcy: "\u0440",
  rdca: "\u2937",
  rdldhar: "\u2969",
  rdquo: "\u201D",
  rdquor: "\u201D",
  rdsh: "\u21B3",
  real: "\u211C",
  realine: "\u211B",
  realpart: "\u211C",
  reals: "\u211D",
  rect: "\u25AD",
  reg: "\xAE",
  rfisht: "\u297D",
  rfloor: "\u230B",
  rfr: "\u{1D52F}",
  rhard: "\u21C1",
  rharu: "\u21C0",
  rharul: "\u296C",
  rho: "\u03C1",
  rhov: "\u03F1",
  rightarrow: "\u2192",
  rightarrowtail: "\u21A3",
  rightharpoondown: "\u21C1",
  rightharpoonup: "\u21C0",
  rightleftarrows: "\u21C4",
  rightleftharpoons: "\u21CC",
  rightrightarrows: "\u21C9",
  rightsquigarrow: "\u219D",
  rightthreetimes: "\u22CC",
  ring: "\u02DA",
  risingdotseq: "\u2253",
  rlarr: "\u21C4",
  rlhar: "\u21CC",
  rlm: "\u200F",
  rmoust: "\u23B1",
  rmoustache: "\u23B1",
  rnmid: "\u2AEE",
  roang: "\u27ED",
  roarr: "\u21FE",
  robrk: "\u27E7",
  ropar: "\u2986",
  ropf: "\u{1D563}",
  roplus: "\u2A2E",
  rotimes: "\u2A35",
  rpar: ")",
  rpargt: "\u2994",
  rppolint: "\u2A12",
  rrarr: "\u21C9",
  rsaquo: "\u203A",
  rscr: "\u{1D4C7}",
  rsh: "\u21B1",
  rsqb: "]",
  rsquo: "\u2019",
  rsquor: "\u2019",
  rthree: "\u22CC",
  rtimes: "\u22CA",
  rtri: "\u25B9",
  rtrie: "\u22B5",
  rtrif: "\u25B8",
  rtriltri: "\u29CE",
  ruluhar: "\u2968",
  rx: "\u211E",
  sacute: "\u015B",
  sbquo: "\u201A",
  sc: "\u227B",
  scE: "\u2AB4",
  scap: "\u2AB8",
  scaron: "\u0161",
  sccue: "\u227D",
  sce: "\u2AB0",
  scedil: "\u015F",
  scirc: "\u015D",
  scnE: "\u2AB6",
  scnap: "\u2ABA",
  scnsim: "\u22E9",
  scpolint: "\u2A13",
  scsim: "\u227F",
  scy: "\u0441",
  sdot: "\u22C5",
  sdotb: "\u22A1",
  sdote: "\u2A66",
  seArr: "\u21D8",
  searhk: "\u2925",
  searr: "\u2198",
  searrow: "\u2198",
  sect: "\xA7",
  semi: ";",
  seswar: "\u2929",
  setminus: "\u2216",
  setmn: "\u2216",
  sext: "\u2736",
  sfr: "\u{1D530}",
  sfrown: "\u2322",
  sharp: "\u266F",
  shchcy: "\u0449",
  shcy: "\u0448",
  shortmid: "\u2223",
  shortparallel: "\u2225",
  shy: "\xAD",
  sigma: "\u03C3",
  sigmaf: "\u03C2",
  sigmav: "\u03C2",
  sim: "\u223C",
  simdot: "\u2A6A",
  sime: "\u2243",
  simeq: "\u2243",
  simg: "\u2A9E",
  simgE: "\u2AA0",
  siml: "\u2A9D",
  simlE: "\u2A9F",
  simne: "\u2246",
  simplus: "\u2A24",
  simrarr: "\u2972",
  slarr: "\u2190",
  smallsetminus: "\u2216",
  smashp: "\u2A33",
  smeparsl: "\u29E4",
  smid: "\u2223",
  smile: "\u2323",
  smt: "\u2AAA",
  smte: "\u2AAC",
  smtes: "\u2AAC\uFE00",
  softcy: "\u044C",
  sol: "/",
  solb: "\u29C4",
  solbar: "\u233F",
  sopf: "\u{1D564}",
  spades: "\u2660",
  spadesuit: "\u2660",
  spar: "\u2225",
  sqcap: "\u2293",
  sqcaps: "\u2293\uFE00",
  sqcup: "\u2294",
  sqcups: "\u2294\uFE00",
  sqsub: "\u228F",
  sqsube: "\u2291",
  sqsubset: "\u228F",
  sqsubseteq: "\u2291",
  sqsup: "\u2290",
  sqsupe: "\u2292",
  sqsupset: "\u2290",
  sqsupseteq: "\u2292",
  squ: "\u25A1",
  square: "\u25A1",
  squarf: "\u25AA",
  squf: "\u25AA",
  srarr: "\u2192",
  sscr: "\u{1D4C8}",
  ssetmn: "\u2216",
  ssmile: "\u2323",
  sstarf: "\u22C6",
  star: "\u2606",
  starf: "\u2605",
  straightepsilon: "\u03F5",
  straightphi: "\u03D5",
  strns: "\xAF",
  sub: "\u2282",
  subE: "\u2AC5",
  subdot: "\u2ABD",
  sube: "\u2286",
  subedot: "\u2AC3",
  submult: "\u2AC1",
  subnE: "\u2ACB",
  subne: "\u228A",
  subplus: "\u2ABF",
  subrarr: "\u2979",
  subset: "\u2282",
  subseteq: "\u2286",
  subseteqq: "\u2AC5",
  subsetneq: "\u228A",
  subsetneqq: "\u2ACB",
  subsim: "\u2AC7",
  subsub: "\u2AD5",
  subsup: "\u2AD3",
  succ: "\u227B",
  succapprox: "\u2AB8",
  succcurlyeq: "\u227D",
  succeq: "\u2AB0",
  succnapprox: "\u2ABA",
  succneqq: "\u2AB6",
  succnsim: "\u22E9",
  succsim: "\u227F",
  sum: "\u2211",
  sung: "\u266A",
  sup1: "\xB9",
  sup2: "\xB2",
  sup3: "\xB3",
  sup: "\u2283",
  supE: "\u2AC6",
  supdot: "\u2ABE",
  supdsub: "\u2AD8",
  supe: "\u2287",
  supedot: "\u2AC4",
  suphsol: "\u27C9",
  suphsub: "\u2AD7",
  suplarr: "\u297B",
  supmult: "\u2AC2",
  supnE: "\u2ACC",
  supne: "\u228B",
  supplus: "\u2AC0",
  supset: "\u2283",
  supseteq: "\u2287",
  supseteqq: "\u2AC6",
  supsetneq: "\u228B",
  supsetneqq: "\u2ACC",
  supsim: "\u2AC8",
  supsub: "\u2AD4",
  supsup: "\u2AD6",
  swArr: "\u21D9",
  swarhk: "\u2926",
  swarr: "\u2199",
  swarrow: "\u2199",
  swnwar: "\u292A",
  szlig: "\xDF",
  target: "\u2316",
  tau: "\u03C4",
  tbrk: "\u23B4",
  tcaron: "\u0165",
  tcedil: "\u0163",
  tcy: "\u0442",
  tdot: "\u20DB",
  telrec: "\u2315",
  tfr: "\u{1D531}",
  there4: "\u2234",
  therefore: "\u2234",
  theta: "\u03B8",
  thetasym: "\u03D1",
  thetav: "\u03D1",
  thickapprox: "\u2248",
  thicksim: "\u223C",
  thinsp: "\u2009",
  thkap: "\u2248",
  thksim: "\u223C",
  thorn: "\xFE",
  tilde: "\u02DC",
  times: "\xD7",
  timesb: "\u22A0",
  timesbar: "\u2A31",
  timesd: "\u2A30",
  tint: "\u222D",
  toea: "\u2928",
  top: "\u22A4",
  topbot: "\u2336",
  topcir: "\u2AF1",
  topf: "\u{1D565}",
  topfork: "\u2ADA",
  tosa: "\u2929",
  tprime: "\u2034",
  trade: "\u2122",
  triangle: "\u25B5",
  triangledown: "\u25BF",
  triangleleft: "\u25C3",
  trianglelefteq: "\u22B4",
  triangleq: "\u225C",
  triangleright: "\u25B9",
  trianglerighteq: "\u22B5",
  tridot: "\u25EC",
  trie: "\u225C",
  triminus: "\u2A3A",
  triplus: "\u2A39",
  trisb: "\u29CD",
  tritime: "\u2A3B",
  trpezium: "\u23E2",
  tscr: "\u{1D4C9}",
  tscy: "\u0446",
  tshcy: "\u045B",
  tstrok: "\u0167",
  twixt: "\u226C",
  twoheadleftarrow: "\u219E",
  twoheadrightarrow: "\u21A0",
  uArr: "\u21D1",
  uHar: "\u2963",
  uacute: "\xFA",
  uarr: "\u2191",
  ubrcy: "\u045E",
  ubreve: "\u016D",
  ucirc: "\xFB",
  ucy: "\u0443",
  udarr: "\u21C5",
  udblac: "\u0171",
  udhar: "\u296E",
  ufisht: "\u297E",
  ufr: "\u{1D532}",
  ugrave: "\xF9",
  uharl: "\u21BF",
  uharr: "\u21BE",
  uhblk: "\u2580",
  ulcorn: "\u231C",
  ulcorner: "\u231C",
  ulcrop: "\u230F",
  ultri: "\u25F8",
  umacr: "\u016B",
  uml: "\xA8",
  uogon: "\u0173",
  uopf: "\u{1D566}",
  uparrow: "\u2191",
  updownarrow: "\u2195",
  upharpoonleft: "\u21BF",
  upharpoonright: "\u21BE",
  uplus: "\u228E",
  upsi: "\u03C5",
  upsih: "\u03D2",
  upsilon: "\u03C5",
  upuparrows: "\u21C8",
  urcorn: "\u231D",
  urcorner: "\u231D",
  urcrop: "\u230E",
  uring: "\u016F",
  urtri: "\u25F9",
  uscr: "\u{1D4CA}",
  utdot: "\u22F0",
  utilde: "\u0169",
  utri: "\u25B5",
  utrif: "\u25B4",
  uuarr: "\u21C8",
  uuml: "\xFC",
  uwangle: "\u29A7",
  vArr: "\u21D5",
  vBar: "\u2AE8",
  vBarv: "\u2AE9",
  vDash: "\u22A8",
  vangrt: "\u299C",
  varepsilon: "\u03F5",
  varkappa: "\u03F0",
  varnothing: "\u2205",
  varphi: "\u03D5",
  varpi: "\u03D6",
  varpropto: "\u221D",
  varr: "\u2195",
  varrho: "\u03F1",
  varsigma: "\u03C2",
  varsubsetneq: "\u228A\uFE00",
  varsubsetneqq: "\u2ACB\uFE00",
  varsupsetneq: "\u228B\uFE00",
  varsupsetneqq: "\u2ACC\uFE00",
  vartheta: "\u03D1",
  vartriangleleft: "\u22B2",
  vartriangleright: "\u22B3",
  vcy: "\u0432",
  vdash: "\u22A2",
  vee: "\u2228",
  veebar: "\u22BB",
  veeeq: "\u225A",
  vellip: "\u22EE",
  verbar: "|",
  vert: "|",
  vfr: "\u{1D533}",
  vltri: "\u22B2",
  vnsub: "\u2282\u20D2",
  vnsup: "\u2283\u20D2",
  vopf: "\u{1D567}",
  vprop: "\u221D",
  vrtri: "\u22B3",
  vscr: "\u{1D4CB}",
  vsubnE: "\u2ACB\uFE00",
  vsubne: "\u228A\uFE00",
  vsupnE: "\u2ACC\uFE00",
  vsupne: "\u228B\uFE00",
  vzigzag: "\u299A",
  wcirc: "\u0175",
  wedbar: "\u2A5F",
  wedge: "\u2227",
  wedgeq: "\u2259",
  weierp: "\u2118",
  wfr: "\u{1D534}",
  wopf: "\u{1D568}",
  wp: "\u2118",
  wr: "\u2240",
  wreath: "\u2240",
  wscr: "\u{1D4CC}",
  xcap: "\u22C2",
  xcirc: "\u25EF",
  xcup: "\u22C3",
  xdtri: "\u25BD",
  xfr: "\u{1D535}",
  xhArr: "\u27FA",
  xharr: "\u27F7",
  xi: "\u03BE",
  xlArr: "\u27F8",
  xlarr: "\u27F5",
  xmap: "\u27FC",
  xnis: "\u22FB",
  xodot: "\u2A00",
  xopf: "\u{1D569}",
  xoplus: "\u2A01",
  xotime: "\u2A02",
  xrArr: "\u27F9",
  xrarr: "\u27F6",
  xscr: "\u{1D4CD}",
  xsqcup: "\u2A06",
  xuplus: "\u2A04",
  xutri: "\u25B3",
  xvee: "\u22C1",
  xwedge: "\u22C0",
  yacute: "\xFD",
  yacy: "\u044F",
  ycirc: "\u0177",
  ycy: "\u044B",
  yen: "\xA5",
  yfr: "\u{1D536}",
  yicy: "\u0457",
  yopf: "\u{1D56A}",
  yscr: "\u{1D4CE}",
  yucy: "\u044E",
  yuml: "\xFF",
  zacute: "\u017A",
  zcaron: "\u017E",
  zcy: "\u0437",
  zdot: "\u017C",
  zeetrf: "\u2128",
  zeta: "\u03B6",
  zfr: "\u{1D537}",
  zhcy: "\u0436",
  zigrarr: "\u21DD",
  zopf: "\u{1D56B}",
  zscr: "\u{1D4CF}",
  zwj: "\u200D",
  zwnj: "\u200C"
};

// node_modules/decode-named-character-reference/index.js
var own5 = {}.hasOwnProperty;
function decodeNamedCharacterReference(value) {
  return own5.call(characterEntities, value) ? characterEntities[value] : false;
}

// node_modules/mdast-util-gfm-table/lib/index.js
function gfmTableFromMarkdown() {
  return {
    enter: {
      table: enterTable,
      tableData: enterCell,
      tableHeader: enterCell,
      tableRow: enterRow
    },
    exit: {
      codeText: exitCodeText,
      table: exitTable,
      tableData: exit,
      tableHeader: exit,
      tableRow: exit
    }
  };
}
function enterTable(token) {
  const align = token._align;
  ok(align, "expected `_align` on table");
  this.enter(
    {
      type: "table",
      align: align.map(function(d2) {
        return d2 === "none" ? null : d2;
      }),
      children: []
    },
    token
  );
  this.data.inTable = true;
}
function exitTable(token) {
  this.exit(token);
  this.data.inTable = void 0;
}
function enterRow(token) {
  this.enter({ type: "tableRow", children: [] }, token);
}
function exit(token) {
  this.exit(token);
}
function enterCell(token) {
  this.enter({ type: "tableCell", children: [] }, token);
}
function exitCodeText(token) {
  let value = this.resume();
  if (this.data.inTable) {
    value = value.replace(/\\([\\|])/g, replace);
  }
  const node3 = this.stack[this.stack.length - 1];
  ok(node3.type === "inlineCode");
  node3.value = value;
  this.exit(token);
}
function replace($0, $1) {
  return $1 === "|" ? $1 : $0;
}
function gfmTableToMarkdown(options) {
  const settings = options || {};
  const padding = settings.tableCellPadding;
  const alignDelimiters = settings.tablePipeAlign;
  const stringLength = settings.stringLength;
  const around = padding ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: "\n", inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: true, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: true, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: true, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: inlineCodeWithTable,
      table: handleTable,
      tableCell: handleTableCell,
      tableRow: handleTableRow
    }
  };
  function handleTable(node3, _, state, info2) {
    return serializeData(handleTableAsData(node3, state, info2), node3.align);
  }
  function handleTableRow(node3, _, state, info2) {
    const row = handleTableRowAsData(node3, state, info2);
    const value = serializeData([row]);
    return value.slice(0, value.indexOf("\n"));
  }
  function handleTableCell(node3, _, state, info2) {
    const exit3 = state.enter("tableCell");
    const subexit = state.enter("phrasing");
    const value = state.containerPhrasing(node3, {
      ...info2,
      before: around,
      after: around
    });
    subexit();
    exit3();
    return value;
  }
  function serializeData(matrix, align) {
    return markdownTable(matrix, {
      align,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength
    });
  }
  function handleTableAsData(node3, state, info2) {
    const children = node3.children;
    let index3 = -1;
    const result = [];
    const subexit = state.enter("table");
    while (++index3 < children.length) {
      result[index3] = handleTableRowAsData(children[index3], state, info2);
    }
    subexit();
    return result;
  }
  function handleTableRowAsData(node3, state, info2) {
    const children = node3.children;
    let index3 = -1;
    const result = [];
    const subexit = state.enter("tableRow");
    while (++index3 < children.length) {
      result[index3] = handleTableCell(children[index3], node3, state, info2);
    }
    subexit();
    return result;
  }
  function inlineCodeWithTable(node3, parent, state) {
    let value = handle2.inlineCode(node3, parent, state);
    if (state.stack.includes("tableCell")) {
      value = value.replace(/\|/g, "\\$&");
    }
    return value;
  }
}

// node_modules/mdast-util-gfm-task-list-item/index.js
init_process();
init_buffer();

// node_modules/mdast-util-gfm-task-list-item/lib/index.js
init_process();
init_buffer();
function gfmTaskListItemFromMarkdown() {
  return {
    exit: {
      taskListCheckValueChecked: exitCheck,
      taskListCheckValueUnchecked: exitCheck,
      paragraph: exitParagraphWithTaskListItem
    }
  };
}
function gfmTaskListItemToMarkdown() {
  return {
    unsafe: [{ atBreak: true, character: "-", after: "[:|-]" }],
    handlers: { listItem: listItemWithTaskListItem }
  };
}
function exitCheck(token) {
  const node3 = this.stack[this.stack.length - 2];
  ok(node3.type === "listItem");
  node3.checked = token.type === "taskListCheckValueChecked";
}
function exitParagraphWithTaskListItem(token) {
  const parent = this.stack[this.stack.length - 2];
  if (parent && parent.type === "listItem" && typeof parent.checked === "boolean") {
    const node3 = this.stack[this.stack.length - 1];
    ok(node3.type === "paragraph");
    const head2 = node3.children[0];
    if (head2 && head2.type === "text") {
      const siblings2 = parent.children;
      let index3 = -1;
      let firstParaghraph;
      while (++index3 < siblings2.length) {
        const sibling = siblings2[index3];
        if (sibling.type === "paragraph") {
          firstParaghraph = sibling;
          break;
        }
      }
      if (firstParaghraph === node3) {
        head2.value = head2.value.slice(1);
        if (head2.value.length === 0) {
          node3.children.shift();
        } else if (node3.position && head2.position && typeof head2.position.start.offset === "number") {
          head2.position.start.column++;
          head2.position.start.offset++;
          node3.position.start = Object.assign({}, head2.position.start);
        }
      }
    }
  }
  this.exit(token);
}
function listItemWithTaskListItem(node3, parent, state, info2) {
  const head2 = node3.children[0];
  const checkable = typeof node3.checked === "boolean" && head2 && head2.type === "paragraph";
  const checkbox = "[" + (node3.checked ? "x" : " ") + "] ";
  const tracker = state.createTracker(info2);
  if (checkable) {
    tracker.move(checkbox);
  }
  let value = handle2.listItem(node3, parent, state, {
    ...info2,
    ...tracker.current()
  });
  if (checkable) {
    value = value.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, check);
  }
  return value;
  function check($0) {
    return $0 + checkbox;
  }
}

// node_modules/mdast-util-gfm/lib/index.js
function gfmFromMarkdown() {
  return [
    gfmAutolinkLiteralFromMarkdown(),
    gfmFootnoteFromMarkdown(),
    gfmStrikethroughFromMarkdown(),
    gfmTableFromMarkdown(),
    gfmTaskListItemFromMarkdown()
  ];
}
function gfmToMarkdown(options) {
  return {
    extensions: [
      gfmAutolinkLiteralToMarkdown(),
      gfmFootnoteToMarkdown(),
      gfmStrikethroughToMarkdown(),
      gfmTableToMarkdown(options),
      gfmTaskListItemToMarkdown()
    ]
  };
}

// node_modules/micromark-extension-gfm/index.js
init_process();
init_buffer();

// node_modules/micromark-util-combine-extensions/index.js
init_process();
init_buffer();

// node_modules/micromark-util-combine-extensions/node_modules/micromark-util-chunked/index.js
init_process();
init_buffer();
function splice(list4, start, remove, items) {
  const end = list4.length;
  let chunkStart = 0;
  let parameters;
  if (start < 0) {
    start = -start > end ? 0 : end + start;
  } else {
    start = start > end ? end : start;
  }
  remove = remove > 0 ? remove : 0;
  if (items.length < 1e4) {
    parameters = Array.from(items);
    parameters.unshift(start, remove);
    list4.splice(...parameters);
  } else {
    if (remove)
      list4.splice(start, remove);
    while (chunkStart < items.length) {
      parameters = items.slice(chunkStart, chunkStart + 1e4);
      parameters.unshift(start, 0);
      list4.splice(...parameters);
      chunkStart += 1e4;
      start += 1e4;
    }
  }
}

// node_modules/micromark-util-combine-extensions/index.js
var hasOwnProperty2 = {}.hasOwnProperty;
function combineExtensions(extensions) {
  const all4 = {};
  let index3 = -1;
  while (++index3 < extensions.length) {
    syntaxExtension(all4, extensions[index3]);
  }
  return all4;
}
function syntaxExtension(all4, extension2) {
  let hook;
  for (hook in extension2) {
    const maybe = hasOwnProperty2.call(all4, hook) ? all4[hook] : void 0;
    const left = maybe || (all4[hook] = {});
    const right = extension2[hook];
    let code4;
    if (right) {
      for (code4 in right) {
        if (!hasOwnProperty2.call(left, code4))
          left[code4] = [];
        const value = right[code4];
        constructs(
          // @ts-expect-error Looks like a list.
          left[code4],
          Array.isArray(value) ? value : value ? [value] : []
        );
      }
    }
  }
}
function constructs(existing, list4) {
  let index3 = -1;
  const before = [];
  while (++index3 < list4.length) {
    ;
    (list4[index3].add === "after" ? existing : before).push(list4[index3]);
  }
  splice(existing, 0, 0, before);
}

// node_modules/micromark-extension-gfm-autolink-literal/index.js
init_process();
init_buffer();

// node_modules/micromark-extension-gfm-autolink-literal/lib/syntax.js
init_process();
init_buffer();
var wwwPrefix = {
  tokenize: tokenizeWwwPrefix,
  partial: true
};
var domain2 = {
  tokenize: tokenizeDomain,
  partial: true
};
var path = {
  tokenize: tokenizePath,
  partial: true
};
var trail = {
  tokenize: tokenizeTrail,
  partial: true
};
var emailDomainDotTrail = {
  tokenize: tokenizeEmailDomainDotTrail,
  partial: true
};
var wwwAutolink = {
  name: "wwwAutolink",
  tokenize: tokenizeWwwAutolink,
  previous: previousWww
};
var protocolAutolink = {
  name: "protocolAutolink",
  tokenize: tokenizeProtocolAutolink,
  previous: previousProtocol
};
var emailAutolink = {
  name: "emailAutolink",
  tokenize: tokenizeEmailAutolink,
  previous: previousEmail
};
var text4 = {};
function gfmAutolinkLiteral() {
  return {
    text: text4
  };
}
var code2 = 48;
while (code2 < 123) {
  text4[code2] = emailAutolink;
  code2++;
  if (code2 === 58)
    code2 = 65;
  else if (code2 === 91)
    code2 = 97;
}
text4[43] = emailAutolink;
text4[45] = emailAutolink;
text4[46] = emailAutolink;
text4[95] = emailAutolink;
text4[72] = [emailAutolink, protocolAutolink];
text4[104] = [emailAutolink, protocolAutolink];
text4[87] = [emailAutolink, wwwAutolink];
text4[119] = [emailAutolink, wwwAutolink];
function tokenizeEmailAutolink(effects, ok3, nok) {
  const self2 = this;
  let dot;
  let data;
  return start;
  function start(code4) {
    if (!gfmAtext(code4) || !previousEmail.call(self2, self2.previous) || previousUnbalanced(self2.events)) {
      return nok(code4);
    }
    effects.enter("literalAutolink");
    effects.enter("literalAutolinkEmail");
    return atext(code4);
  }
  function atext(code4) {
    if (gfmAtext(code4)) {
      effects.consume(code4);
      return atext;
    }
    if (code4 === 64) {
      effects.consume(code4);
      return emailDomain;
    }
    return nok(code4);
  }
  function emailDomain(code4) {
    if (code4 === 46) {
      return effects.check(emailDomainDotTrail, emailDomainAfter, emailDomainDot)(code4);
    }
    if (code4 === 45 || code4 === 95 || asciiAlphanumeric(code4)) {
      data = true;
      effects.consume(code4);
      return emailDomain;
    }
    return emailDomainAfter(code4);
  }
  function emailDomainDot(code4) {
    effects.consume(code4);
    dot = true;
    return emailDomain;
  }
  function emailDomainAfter(code4) {
    if (data && dot && asciiAlpha(self2.previous)) {
      effects.exit("literalAutolinkEmail");
      effects.exit("literalAutolink");
      return ok3(code4);
    }
    return nok(code4);
  }
}
function tokenizeWwwAutolink(effects, ok3, nok) {
  const self2 = this;
  return wwwStart;
  function wwwStart(code4) {
    if (code4 !== 87 && code4 !== 119 || !previousWww.call(self2, self2.previous) || previousUnbalanced(self2.events)) {
      return nok(code4);
    }
    effects.enter("literalAutolink");
    effects.enter("literalAutolinkWww");
    return effects.check(wwwPrefix, effects.attempt(domain2, effects.attempt(path, wwwAfter), nok), nok)(code4);
  }
  function wwwAfter(code4) {
    effects.exit("literalAutolinkWww");
    effects.exit("literalAutolink");
    return ok3(code4);
  }
}
function tokenizeProtocolAutolink(effects, ok3, nok) {
  const self2 = this;
  let buffer = "";
  let seen = false;
  return protocolStart;
  function protocolStart(code4) {
    if ((code4 === 72 || code4 === 104) && previousProtocol.call(self2, self2.previous) && !previousUnbalanced(self2.events)) {
      effects.enter("literalAutolink");
      effects.enter("literalAutolinkHttp");
      buffer += String.fromCodePoint(code4);
      effects.consume(code4);
      return protocolPrefixInside;
    }
    return nok(code4);
  }
  function protocolPrefixInside(code4) {
    if (asciiAlpha(code4) && buffer.length < 5) {
      buffer += String.fromCodePoint(code4);
      effects.consume(code4);
      return protocolPrefixInside;
    }
    if (code4 === 58) {
      const protocol = buffer.toLowerCase();
      if (protocol === "http" || protocol === "https") {
        effects.consume(code4);
        return protocolSlashesInside;
      }
    }
    return nok(code4);
  }
  function protocolSlashesInside(code4) {
    if (code4 === 47) {
      effects.consume(code4);
      if (seen) {
        return afterProtocol;
      }
      seen = true;
      return protocolSlashesInside;
    }
    return nok(code4);
  }
  function afterProtocol(code4) {
    return code4 === null || asciiControl(code4) || markdownLineEndingOrSpace(code4) || unicodeWhitespace(code4) || unicodePunctuation(code4) ? nok(code4) : effects.attempt(domain2, effects.attempt(path, protocolAfter), nok)(code4);
  }
  function protocolAfter(code4) {
    effects.exit("literalAutolinkHttp");
    effects.exit("literalAutolink");
    return ok3(code4);
  }
}
function tokenizeWwwPrefix(effects, ok3, nok) {
  let size = 0;
  return wwwPrefixInside;
  function wwwPrefixInside(code4) {
    if ((code4 === 87 || code4 === 119) && size < 3) {
      size++;
      effects.consume(code4);
      return wwwPrefixInside;
    }
    if (code4 === 46 && size === 3) {
      effects.consume(code4);
      return wwwPrefixAfter;
    }
    return nok(code4);
  }
  function wwwPrefixAfter(code4) {
    return code4 === null ? nok(code4) : ok3(code4);
  }
}
function tokenizeDomain(effects, ok3, nok) {
  let underscoreInLastSegment;
  let underscoreInLastLastSegment;
  let seen;
  return domainInside;
  function domainInside(code4) {
    if (code4 === 46 || code4 === 95) {
      return effects.check(trail, domainAfter, domainAtPunctuation)(code4);
    }
    if (code4 === null || markdownLineEndingOrSpace(code4) || unicodeWhitespace(code4) || code4 !== 45 && unicodePunctuation(code4)) {
      return domainAfter(code4);
    }
    seen = true;
    effects.consume(code4);
    return domainInside;
  }
  function domainAtPunctuation(code4) {
    if (code4 === 95) {
      underscoreInLastSegment = true;
    } else {
      underscoreInLastLastSegment = underscoreInLastSegment;
      underscoreInLastSegment = void 0;
    }
    effects.consume(code4);
    return domainInside;
  }
  function domainAfter(code4) {
    if (underscoreInLastLastSegment || underscoreInLastSegment || !seen) {
      return nok(code4);
    }
    return ok3(code4);
  }
}
function tokenizePath(effects, ok3) {
  let sizeOpen = 0;
  let sizeClose = 0;
  return pathInside;
  function pathInside(code4) {
    if (code4 === 40) {
      sizeOpen++;
      effects.consume(code4);
      return pathInside;
    }
    if (code4 === 41 && sizeClose < sizeOpen) {
      return pathAtPunctuation(code4);
    }
    if (code4 === 33 || code4 === 34 || code4 === 38 || code4 === 39 || code4 === 41 || code4 === 42 || code4 === 44 || code4 === 46 || code4 === 58 || code4 === 59 || code4 === 60 || code4 === 63 || code4 === 93 || code4 === 95 || code4 === 126) {
      return effects.check(trail, ok3, pathAtPunctuation)(code4);
    }
    if (code4 === null || markdownLineEndingOrSpace(code4) || unicodeWhitespace(code4)) {
      return ok3(code4);
    }
    effects.consume(code4);
    return pathInside;
  }
  function pathAtPunctuation(code4) {
    if (code4 === 41) {
      sizeClose++;
    }
    effects.consume(code4);
    return pathInside;
  }
}
function tokenizeTrail(effects, ok3, nok) {
  return trail2;
  function trail2(code4) {
    if (code4 === 33 || code4 === 34 || code4 === 39 || code4 === 41 || code4 === 42 || code4 === 44 || code4 === 46 || code4 === 58 || code4 === 59 || code4 === 63 || code4 === 95 || code4 === 126) {
      effects.consume(code4);
      return trail2;
    }
    if (code4 === 38) {
      effects.consume(code4);
      return trailCharacterReferenceStart;
    }
    if (code4 === 93) {
      effects.consume(code4);
      return trailBracketAfter;
    }
    if (
      // `<` is an end.
      code4 === 60 || // So is whitespace.
      code4 === null || markdownLineEndingOrSpace(code4) || unicodeWhitespace(code4)
    ) {
      return ok3(code4);
    }
    return nok(code4);
  }
  function trailBracketAfter(code4) {
    if (code4 === null || code4 === 40 || code4 === 91 || markdownLineEndingOrSpace(code4) || unicodeWhitespace(code4)) {
      return ok3(code4);
    }
    return trail2(code4);
  }
  function trailCharacterReferenceStart(code4) {
    return asciiAlpha(code4) ? trailCharacterReferenceInside(code4) : nok(code4);
  }
  function trailCharacterReferenceInside(code4) {
    if (code4 === 59) {
      effects.consume(code4);
      return trail2;
    }
    if (asciiAlpha(code4)) {
      effects.consume(code4);
      return trailCharacterReferenceInside;
    }
    return nok(code4);
  }
}
function tokenizeEmailDomainDotTrail(effects, ok3, nok) {
  return start;
  function start(code4) {
    effects.consume(code4);
    return after;
  }
  function after(code4) {
    return asciiAlphanumeric(code4) ? nok(code4) : ok3(code4);
  }
}
function previousWww(code4) {
  return code4 === null || code4 === 40 || code4 === 42 || code4 === 95 || code4 === 91 || code4 === 93 || code4 === 126 || markdownLineEndingOrSpace(code4);
}
function previousProtocol(code4) {
  return !asciiAlpha(code4);
}
function previousEmail(code4) {
  return !(code4 === 47 || gfmAtext(code4));
}
function gfmAtext(code4) {
  return code4 === 43 || code4 === 45 || code4 === 46 || code4 === 95 || asciiAlphanumeric(code4);
}
function previousUnbalanced(events) {
  let index3 = events.length;
  let result = false;
  while (index3--) {
    const token = events[index3][1];
    if ((token.type === "labelLink" || token.type === "labelImage") && !token._balanced) {
      result = true;
      break;
    }
    if (token._gfmAutolinkLiteralWalkedInto) {
      result = false;
      break;
    }
  }
  if (events.length > 0 && !result) {
    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;
  }
  return result;
}

// node_modules/micromark-util-sanitize-uri/index.js
init_process();
init_buffer();
function normalizeUri(value) {
  const result = [];
  let index3 = -1;
  let start = 0;
  let skip = 0;
  while (++index3 < value.length) {
    const code4 = value.charCodeAt(index3);
    let replace2 = "";
    if (code4 === 37 && asciiAlphanumeric(value.charCodeAt(index3 + 1)) && asciiAlphanumeric(value.charCodeAt(index3 + 2))) {
      skip = 2;
    } else if (code4 < 128) {
      if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code4))) {
        replace2 = String.fromCharCode(code4);
      }
    } else if (code4 > 55295 && code4 < 57344) {
      const next = value.charCodeAt(index3 + 1);
      if (code4 < 56320 && next > 56319 && next < 57344) {
        replace2 = String.fromCharCode(code4, next);
        skip = 1;
      } else {
        replace2 = "\uFFFD";
      }
    } else {
      replace2 = String.fromCharCode(code4);
    }
    if (replace2) {
      result.push(value.slice(start, index3), encodeURIComponent(replace2));
      start = index3 + skip + 1;
      replace2 = "";
    }
    if (skip) {
      index3 += skip;
      skip = 0;
    }
  }
  return result.join("") + value.slice(start);
}

// node_modules/micromark-extension-gfm-footnote/index.js
init_process();
init_buffer();

// node_modules/micromark-extension-gfm-footnote/lib/syntax.js
init_process();
init_buffer();

// node_modules/micromark-extension-gfm-footnote/node_modules/micromark-core-commonmark/index.js
init_process();
init_buffer();

// node_modules/micromark-util-classify-character/index.js
init_process();
init_buffer();
function classifyCharacter(code4) {
  if (code4 === null || markdownLineEndingOrSpace(code4) || unicodeWhitespace(code4)) {
    return 1;
  }
  if (unicodePunctuation(code4)) {
    return 2;
  }
}

// node_modules/micromark-extension-gfm-footnote/node_modules/micromark-core-commonmark/lib/blank-line.js
init_process();
init_buffer();

// node_modules/micromark-factory-space/index.js
init_process();
init_buffer();
function factorySpace(effects, ok3, type, max) {
  const limit = max ? max - 1 : Number.POSITIVE_INFINITY;
  let size = 0;
  return start;
  function start(code4) {
    if (markdownSpace(code4)) {
      effects.enter(type);
      return prefix(code4);
    }
    return ok3(code4);
  }
  function prefix(code4) {
    if (markdownSpace(code4) && size++ < limit) {
      effects.consume(code4);
      return prefix;
    }
    effects.exit(type);
    return ok3(code4);
  }
}

// node_modules/micromark-extension-gfm-footnote/node_modules/micromark-core-commonmark/lib/blank-line.js
var blankLine = {
  tokenize: tokenizeBlankLine,
  partial: true
};
function tokenizeBlankLine(effects, ok3, nok) {
  return start;
  function start(code4) {
    return markdownSpace(code4) ? factorySpace(effects, after, "linePrefix")(code4) : after(code4);
  }
  function after(code4) {
    return code4 === null || markdownLineEnding(code4) ? ok3(code4) : nok(code4);
  }
}

// node_modules/micromark-extension-gfm-footnote/node_modules/micromark-util-normalize-identifier/index.js
init_process();
init_buffer();
function normalizeIdentifier2(value) {
  return value.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}

// node_modules/micromark-extension-gfm-footnote/lib/syntax.js
var indent = {
  tokenize: tokenizeIndent,
  partial: true
};
function gfmFootnote() {
  return {
    document: {
      [91]: {
        name: "gfmFootnoteDefinition",
        tokenize: tokenizeDefinitionStart,
        continuation: {
          tokenize: tokenizeDefinitionContinuation
        },
        exit: gfmFootnoteDefinitionEnd
      }
    },
    text: {
      [91]: {
        name: "gfmFootnoteCall",
        tokenize: tokenizeGfmFootnoteCall
      },
      [93]: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: tokenizePotentialGfmFootnoteCall,
        resolveTo: resolveToPotentialGfmFootnoteCall
      }
    }
  };
}
function tokenizePotentialGfmFootnoteCall(effects, ok3, nok) {
  const self2 = this;
  let index3 = self2.events.length;
  const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
  let labelStart;
  while (index3--) {
    const token = self2.events[index3][1];
    if (token.type === "labelImage") {
      labelStart = token;
      break;
    }
    if (token.type === "gfmFootnoteCall" || token.type === "labelLink" || token.type === "label" || token.type === "image" || token.type === "link") {
      break;
    }
  }
  return start;
  function start(code4) {
    if (!labelStart || !labelStart._balanced) {
      return nok(code4);
    }
    const id = normalizeIdentifier2(self2.sliceSerialize({
      start: labelStart.end,
      end: self2.now()
    }));
    if (id.codePointAt(0) !== 94 || !defined.includes(id.slice(1))) {
      return nok(code4);
    }
    effects.enter("gfmFootnoteCallLabelMarker");
    effects.consume(code4);
    effects.exit("gfmFootnoteCallLabelMarker");
    return ok3(code4);
  }
}
function resolveToPotentialGfmFootnoteCall(events, context) {
  let index3 = events.length;
  let labelStart;
  while (index3--) {
    if (events[index3][1].type === "labelImage" && events[index3][0] === "enter") {
      labelStart = events[index3][1];
      break;
    }
  }
  events[index3 + 1][1].type = "data";
  events[index3 + 3][1].type = "gfmFootnoteCallLabelMarker";
  const call = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, events[index3 + 3][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  const marker = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, events[index3 + 3][1].end),
    end: Object.assign({}, events[index3 + 3][1].end)
  };
  marker.end.column++;
  marker.end.offset++;
  marker.end._bufferIndex++;
  const string3 = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, marker.end),
    end: Object.assign({}, events[events.length - 1][1].start)
  };
  const chunk = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, string3.start),
    end: Object.assign({}, string3.end)
  };
  const replacement = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    events[index3 + 1],
    events[index3 + 2],
    ["enter", call, context],
    // The `[`
    events[index3 + 3],
    events[index3 + 4],
    // The `^`.
    ["enter", marker, context],
    ["exit", marker, context],
    // Everything in between.
    ["enter", string3, context],
    ["enter", chunk, context],
    ["exit", chunk, context],
    ["exit", string3, context],
    // The ending (`]`, properly parsed and labelled).
    events[events.length - 2],
    events[events.length - 1],
    ["exit", call, context]
  ];
  events.splice(index3, events.length - index3 + 1, ...replacement);
  return events;
}
function tokenizeGfmFootnoteCall(effects, ok3, nok) {
  const self2 = this;
  const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
  let size = 0;
  let data;
  return start;
  function start(code4) {
    effects.enter("gfmFootnoteCall");
    effects.enter("gfmFootnoteCallLabelMarker");
    effects.consume(code4);
    effects.exit("gfmFootnoteCallLabelMarker");
    return callStart;
  }
  function callStart(code4) {
    if (code4 !== 94)
      return nok(code4);
    effects.enter("gfmFootnoteCallMarker");
    effects.consume(code4);
    effects.exit("gfmFootnoteCallMarker");
    effects.enter("gfmFootnoteCallString");
    effects.enter("chunkString").contentType = "string";
    return callData;
  }
  function callData(code4) {
    if (
      // Too long.
      size > 999 || // Closing brace with nothing.
      code4 === 93 && !data || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      code4 === null || code4 === 91 || markdownLineEndingOrSpace(code4)
    ) {
      return nok(code4);
    }
    if (code4 === 93) {
      effects.exit("chunkString");
      const token = effects.exit("gfmFootnoteCallString");
      if (!defined.includes(normalizeIdentifier2(self2.sliceSerialize(token)))) {
        return nok(code4);
      }
      effects.enter("gfmFootnoteCallLabelMarker");
      effects.consume(code4);
      effects.exit("gfmFootnoteCallLabelMarker");
      effects.exit("gfmFootnoteCall");
      return ok3;
    }
    if (!markdownLineEndingOrSpace(code4)) {
      data = true;
    }
    size++;
    effects.consume(code4);
    return code4 === 92 ? callEscape : callData;
  }
  function callEscape(code4) {
    if (code4 === 91 || code4 === 92 || code4 === 93) {
      effects.consume(code4);
      size++;
      return callData;
    }
    return callData(code4);
  }
}
function tokenizeDefinitionStart(effects, ok3, nok) {
  const self2 = this;
  const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
  let identifier;
  let size = 0;
  let data;
  return start;
  function start(code4) {
    effects.enter("gfmFootnoteDefinition")._container = true;
    effects.enter("gfmFootnoteDefinitionLabel");
    effects.enter("gfmFootnoteDefinitionLabelMarker");
    effects.consume(code4);
    effects.exit("gfmFootnoteDefinitionLabelMarker");
    return labelAtMarker;
  }
  function labelAtMarker(code4) {
    if (code4 === 94) {
      effects.enter("gfmFootnoteDefinitionMarker");
      effects.consume(code4);
      effects.exit("gfmFootnoteDefinitionMarker");
      effects.enter("gfmFootnoteDefinitionLabelString");
      effects.enter("chunkString").contentType = "string";
      return labelInside;
    }
    return nok(code4);
  }
  function labelInside(code4) {
    if (
      // Too long.
      size > 999 || // Closing brace with nothing.
      code4 === 93 && !data || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      code4 === null || code4 === 91 || markdownLineEndingOrSpace(code4)
    ) {
      return nok(code4);
    }
    if (code4 === 93) {
      effects.exit("chunkString");
      const token = effects.exit("gfmFootnoteDefinitionLabelString");
      identifier = normalizeIdentifier2(self2.sliceSerialize(token));
      effects.enter("gfmFootnoteDefinitionLabelMarker");
      effects.consume(code4);
      effects.exit("gfmFootnoteDefinitionLabelMarker");
      effects.exit("gfmFootnoteDefinitionLabel");
      return labelAfter;
    }
    if (!markdownLineEndingOrSpace(code4)) {
      data = true;
    }
    size++;
    effects.consume(code4);
    return code4 === 92 ? labelEscape : labelInside;
  }
  function labelEscape(code4) {
    if (code4 === 91 || code4 === 92 || code4 === 93) {
      effects.consume(code4);
      size++;
      return labelInside;
    }
    return labelInside(code4);
  }
  function labelAfter(code4) {
    if (code4 === 58) {
      effects.enter("definitionMarker");
      effects.consume(code4);
      effects.exit("definitionMarker");
      if (!defined.includes(identifier)) {
        defined.push(identifier);
      }
      return factorySpace(effects, whitespaceAfter, "gfmFootnoteDefinitionWhitespace");
    }
    return nok(code4);
  }
  function whitespaceAfter(code4) {
    return ok3(code4);
  }
}
function tokenizeDefinitionContinuation(effects, ok3, nok) {
  return effects.check(blankLine, ok3, effects.attempt(indent, ok3, nok));
}
function gfmFootnoteDefinitionEnd(effects) {
  effects.exit("gfmFootnoteDefinition");
}
function tokenizeIndent(effects, ok3, nok) {
  const self2 = this;
  return factorySpace(effects, afterPrefix, "gfmFootnoteDefinitionIndent", 4 + 1);
  function afterPrefix(code4) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "gfmFootnoteDefinitionIndent" && tail[2].sliceSerialize(tail[1], true).length === 4 ? ok3(code4) : nok(code4);
  }
}

// node_modules/micromark-extension-gfm-strikethrough/index.js
init_process();
init_buffer();

// node_modules/micromark-extension-gfm-strikethrough/lib/syntax.js
init_process();
init_buffer();

// node_modules/micromark-extension-gfm-strikethrough/node_modules/micromark-util-chunked/index.js
init_process();
init_buffer();
function splice2(list4, start, remove, items) {
  const end = list4.length;
  let chunkStart = 0;
  let parameters;
  if (start < 0) {
    start = -start > end ? 0 : end + start;
  } else {
    start = start > end ? end : start;
  }
  remove = remove > 0 ? remove : 0;
  if (items.length < 1e4) {
    parameters = Array.from(items);
    parameters.unshift(start, remove);
    list4.splice(...parameters);
  } else {
    if (remove)
      list4.splice(start, remove);
    while (chunkStart < items.length) {
      parameters = items.slice(chunkStart, chunkStart + 1e4);
      parameters.unshift(start, 0);
      list4.splice(...parameters);
      chunkStart += 1e4;
      start += 1e4;
    }
  }
}

// node_modules/micromark-extension-gfm-strikethrough/node_modules/micromark-util-resolve-all/index.js
init_process();
init_buffer();
function resolveAll(constructs2, events, context) {
  const called = [];
  let index3 = -1;
  while (++index3 < constructs2.length) {
    const resolve2 = constructs2[index3].resolveAll;
    if (resolve2 && !called.includes(resolve2)) {
      events = resolve2(events, context);
      called.push(resolve2);
    }
  }
  return events;
}

// node_modules/micromark-extension-gfm-strikethrough/lib/syntax.js
function gfmStrikethrough(options) {
  const options_ = options || {};
  let single = options_.singleTilde;
  const tokenizer = {
    name: "strikethrough",
    tokenize: tokenizeStrikethrough,
    resolveAll: resolveAllStrikethrough
  };
  if (single === null || single === void 0) {
    single = true;
  }
  return {
    text: {
      [126]: tokenizer
    },
    insideSpan: {
      null: [tokenizer]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function resolveAllStrikethrough(events, context) {
    let index3 = -1;
    while (++index3 < events.length) {
      if (events[index3][0] === "enter" && events[index3][1].type === "strikethroughSequenceTemporary" && events[index3][1]._close) {
        let open = index3;
        while (open--) {
          if (events[open][0] === "exit" && events[open][1].type === "strikethroughSequenceTemporary" && events[open][1]._open && // If the sizes are the same:
          events[index3][1].end.offset - events[index3][1].start.offset === events[open][1].end.offset - events[open][1].start.offset) {
            events[index3][1].type = "strikethroughSequence";
            events[open][1].type = "strikethroughSequence";
            const strikethrough2 = {
              type: "strikethrough",
              start: Object.assign({}, events[open][1].start),
              end: Object.assign({}, events[index3][1].end)
            };
            const text8 = {
              type: "strikethroughText",
              start: Object.assign({}, events[open][1].end),
              end: Object.assign({}, events[index3][1].start)
            };
            const nextEvents = [["enter", strikethrough2, context], ["enter", events[open][1], context], ["exit", events[open][1], context], ["enter", text8, context]];
            const insideSpan2 = context.parser.constructs.insideSpan.null;
            if (insideSpan2) {
              splice2(nextEvents, nextEvents.length, 0, resolveAll(insideSpan2, events.slice(open + 1, index3), context));
            }
            splice2(nextEvents, nextEvents.length, 0, [["exit", text8, context], ["enter", events[index3][1], context], ["exit", events[index3][1], context], ["exit", strikethrough2, context]]);
            splice2(events, open - 1, index3 - open + 3, nextEvents);
            index3 = open + nextEvents.length - 2;
            break;
          }
        }
      }
    }
    index3 = -1;
    while (++index3 < events.length) {
      if (events[index3][1].type === "strikethroughSequenceTemporary") {
        events[index3][1].type = "data";
      }
    }
    return events;
  }
  function tokenizeStrikethrough(effects, ok3, nok) {
    const previous3 = this.previous;
    const events = this.events;
    let size = 0;
    return start;
    function start(code4) {
      if (previous3 === 126 && events[events.length - 1][1].type !== "characterEscape") {
        return nok(code4);
      }
      effects.enter("strikethroughSequenceTemporary");
      return more(code4);
    }
    function more(code4) {
      const before = classifyCharacter(previous3);
      if (code4 === 126) {
        if (size > 1)
          return nok(code4);
        effects.consume(code4);
        size++;
        return more;
      }
      if (size < 2 && !single)
        return nok(code4);
      const token = effects.exit("strikethroughSequenceTemporary");
      const after = classifyCharacter(code4);
      token._open = !after || after === 2 && Boolean(before);
      token._close = !before || before === 2 && Boolean(after);
      return ok3(code4);
    }
  }
}

// node_modules/micromark-extension-gfm-table/index.js
init_process();
init_buffer();

// node_modules/micromark-extension-gfm-table/lib/syntax.js
init_process();
init_buffer();

// node_modules/micromark-extension-gfm-table/lib/edit-map.js
init_process();
init_buffer();
var EditMap = class {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(index3, remove, add) {
    addImplementation(this, index3, remove, add);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(events) {
    this.map.sort(function(a2, b2) {
      return a2[0] - b2[0];
    });
    if (this.map.length === 0) {
      return;
    }
    let index3 = this.map.length;
    const vecs = [];
    while (index3 > 0) {
      index3 -= 1;
      vecs.push(events.slice(this.map[index3][0] + this.map[index3][1]), this.map[index3][2]);
      events.length = this.map[index3][0];
    }
    vecs.push([...events]);
    events.length = 0;
    let slice3 = vecs.pop();
    while (slice3) {
      events.push(...slice3);
      slice3 = vecs.pop();
    }
    this.map.length = 0;
  }
};
function addImplementation(editMap, at2, remove, add) {
  let index3 = 0;
  if (remove === 0 && add.length === 0) {
    return;
  }
  while (index3 < editMap.map.length) {
    if (editMap.map[index3][0] === at2) {
      editMap.map[index3][1] += remove;
      editMap.map[index3][2].push(...add);
      return;
    }
    index3 += 1;
  }
  editMap.map.push([at2, remove, add]);
}

// node_modules/micromark-extension-gfm-table/lib/infer.js
init_process();
init_buffer();
function gfmTableAlign(events, index3) {
  let inDelimiterRow = false;
  const align = [];
  while (index3 < events.length) {
    const event = events[index3];
    if (inDelimiterRow) {
      if (event[0] === "enter") {
        if (event[1].type === "tableContent") {
          align.push(events[index3 + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
        }
      } else if (event[1].type === "tableContent") {
        if (events[index3 - 1][1].type === "tableDelimiterMarker") {
          const alignIndex = align.length - 1;
          align[alignIndex] = align[alignIndex] === "left" ? "center" : "right";
        }
      } else if (event[1].type === "tableDelimiterRow") {
        break;
      }
    } else if (event[0] === "enter" && event[1].type === "tableDelimiterRow") {
      inDelimiterRow = true;
    }
    index3 += 1;
  }
  return align;
}

// node_modules/micromark-extension-gfm-table/lib/syntax.js
function gfmTable() {
  return {
    flow: {
      null: {
        name: "table",
        tokenize: tokenizeTable,
        resolveAll: resolveTable
      }
    }
  };
}
function tokenizeTable(effects, ok3, nok) {
  const self2 = this;
  let size = 0;
  let sizeB = 0;
  let seen;
  return start;
  function start(code4) {
    let index3 = self2.events.length - 1;
    while (index3 > -1) {
      const type = self2.events[index3][1].type;
      if (type === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      type === "linePrefix")
        index3--;
      else
        break;
    }
    const tail = index3 > -1 ? self2.events[index3][1].type : null;
    const next = tail === "tableHead" || tail === "tableRow" ? bodyRowStart : headRowBefore;
    if (next === bodyRowStart && self2.parser.lazy[self2.now().line]) {
      return nok(code4);
    }
    return next(code4);
  }
  function headRowBefore(code4) {
    effects.enter("tableHead");
    effects.enter("tableRow");
    return headRowStart(code4);
  }
  function headRowStart(code4) {
    if (code4 === 124) {
      return headRowBreak(code4);
    }
    seen = true;
    sizeB += 1;
    return headRowBreak(code4);
  }
  function headRowBreak(code4) {
    if (code4 === null) {
      return nok(code4);
    }
    if (markdownLineEnding(code4)) {
      if (sizeB > 1) {
        sizeB = 0;
        self2.interrupt = true;
        effects.exit("tableRow");
        effects.enter("lineEnding");
        effects.consume(code4);
        effects.exit("lineEnding");
        return headDelimiterStart;
      }
      return nok(code4);
    }
    if (markdownSpace(code4)) {
      return factorySpace(effects, headRowBreak, "whitespace")(code4);
    }
    sizeB += 1;
    if (seen) {
      seen = false;
      size += 1;
    }
    if (code4 === 124) {
      effects.enter("tableCellDivider");
      effects.consume(code4);
      effects.exit("tableCellDivider");
      seen = true;
      return headRowBreak;
    }
    effects.enter("data");
    return headRowData(code4);
  }
  function headRowData(code4) {
    if (code4 === null || code4 === 124 || markdownLineEndingOrSpace(code4)) {
      effects.exit("data");
      return headRowBreak(code4);
    }
    effects.consume(code4);
    return code4 === 92 ? headRowEscape : headRowData;
  }
  function headRowEscape(code4) {
    if (code4 === 92 || code4 === 124) {
      effects.consume(code4);
      return headRowData;
    }
    return headRowData(code4);
  }
  function headDelimiterStart(code4) {
    self2.interrupt = false;
    if (self2.parser.lazy[self2.now().line]) {
      return nok(code4);
    }
    effects.enter("tableDelimiterRow");
    seen = false;
    if (markdownSpace(code4)) {
      return factorySpace(effects, headDelimiterBefore, "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code4);
    }
    return headDelimiterBefore(code4);
  }
  function headDelimiterBefore(code4) {
    if (code4 === 45 || code4 === 58) {
      return headDelimiterValueBefore(code4);
    }
    if (code4 === 124) {
      seen = true;
      effects.enter("tableCellDivider");
      effects.consume(code4);
      effects.exit("tableCellDivider");
      return headDelimiterCellBefore;
    }
    return headDelimiterNok(code4);
  }
  function headDelimiterCellBefore(code4) {
    if (markdownSpace(code4)) {
      return factorySpace(effects, headDelimiterValueBefore, "whitespace")(code4);
    }
    return headDelimiterValueBefore(code4);
  }
  function headDelimiterValueBefore(code4) {
    if (code4 === 58) {
      sizeB += 1;
      seen = true;
      effects.enter("tableDelimiterMarker");
      effects.consume(code4);
      effects.exit("tableDelimiterMarker");
      return headDelimiterLeftAlignmentAfter;
    }
    if (code4 === 45) {
      sizeB += 1;
      return headDelimiterLeftAlignmentAfter(code4);
    }
    if (code4 === null || markdownLineEnding(code4)) {
      return headDelimiterCellAfter(code4);
    }
    return headDelimiterNok(code4);
  }
  function headDelimiterLeftAlignmentAfter(code4) {
    if (code4 === 45) {
      effects.enter("tableDelimiterFiller");
      return headDelimiterFiller(code4);
    }
    return headDelimiterNok(code4);
  }
  function headDelimiterFiller(code4) {
    if (code4 === 45) {
      effects.consume(code4);
      return headDelimiterFiller;
    }
    if (code4 === 58) {
      seen = true;
      effects.exit("tableDelimiterFiller");
      effects.enter("tableDelimiterMarker");
      effects.consume(code4);
      effects.exit("tableDelimiterMarker");
      return headDelimiterRightAlignmentAfter;
    }
    effects.exit("tableDelimiterFiller");
    return headDelimiterRightAlignmentAfter(code4);
  }
  function headDelimiterRightAlignmentAfter(code4) {
    if (markdownSpace(code4)) {
      return factorySpace(effects, headDelimiterCellAfter, "whitespace")(code4);
    }
    return headDelimiterCellAfter(code4);
  }
  function headDelimiterCellAfter(code4) {
    if (code4 === 124) {
      return headDelimiterBefore(code4);
    }
    if (code4 === null || markdownLineEnding(code4)) {
      if (!seen || size !== sizeB) {
        return headDelimiterNok(code4);
      }
      effects.exit("tableDelimiterRow");
      effects.exit("tableHead");
      return ok3(code4);
    }
    return headDelimiterNok(code4);
  }
  function headDelimiterNok(code4) {
    return nok(code4);
  }
  function bodyRowStart(code4) {
    effects.enter("tableRow");
    return bodyRowBreak(code4);
  }
  function bodyRowBreak(code4) {
    if (code4 === 124) {
      effects.enter("tableCellDivider");
      effects.consume(code4);
      effects.exit("tableCellDivider");
      return bodyRowBreak;
    }
    if (code4 === null || markdownLineEnding(code4)) {
      effects.exit("tableRow");
      return ok3(code4);
    }
    if (markdownSpace(code4)) {
      return factorySpace(effects, bodyRowBreak, "whitespace")(code4);
    }
    effects.enter("data");
    return bodyRowData(code4);
  }
  function bodyRowData(code4) {
    if (code4 === null || code4 === 124 || markdownLineEndingOrSpace(code4)) {
      effects.exit("data");
      return bodyRowBreak(code4);
    }
    effects.consume(code4);
    return code4 === 92 ? bodyRowEscape : bodyRowData;
  }
  function bodyRowEscape(code4) {
    if (code4 === 92 || code4 === 124) {
      effects.consume(code4);
      return bodyRowData;
    }
    return bodyRowData(code4);
  }
}
function resolveTable(events, context) {
  let index3 = -1;
  let inFirstCellAwaitingPipe = true;
  let rowKind = 0;
  let lastCell = [0, 0, 0, 0];
  let cell = [0, 0, 0, 0];
  let afterHeadAwaitingFirstBodyRow = false;
  let lastTableEnd = 0;
  let currentTable;
  let currentBody;
  let currentCell;
  const map9 = new EditMap();
  while (++index3 < events.length) {
    const event = events[index3];
    const token = event[1];
    if (event[0] === "enter") {
      if (token.type === "tableHead") {
        afterHeadAwaitingFirstBodyRow = false;
        if (lastTableEnd !== 0) {
          flushTableEnd(map9, context, lastTableEnd, currentTable, currentBody);
          currentBody = void 0;
          lastTableEnd = 0;
        }
        currentTable = {
          type: "table",
          start: Object.assign({}, token.start),
          // Note: correct end is set later.
          end: Object.assign({}, token.end)
        };
        map9.add(index3, 0, [["enter", currentTable, context]]);
      } else if (token.type === "tableRow" || token.type === "tableDelimiterRow") {
        inFirstCellAwaitingPipe = true;
        currentCell = void 0;
        lastCell = [0, 0, 0, 0];
        cell = [0, index3 + 1, 0, 0];
        if (afterHeadAwaitingFirstBodyRow) {
          afterHeadAwaitingFirstBodyRow = false;
          currentBody = {
            type: "tableBody",
            start: Object.assign({}, token.start),
            // Note: correct end is set later.
            end: Object.assign({}, token.end)
          };
          map9.add(index3, 0, [["enter", currentBody, context]]);
        }
        rowKind = token.type === "tableDelimiterRow" ? 2 : currentBody ? 3 : 1;
      } else if (rowKind && (token.type === "data" || token.type === "tableDelimiterMarker" || token.type === "tableDelimiterFiller")) {
        inFirstCellAwaitingPipe = false;
        if (cell[2] === 0) {
          if (lastCell[1] !== 0) {
            cell[0] = cell[1];
            currentCell = flushCell(map9, context, lastCell, rowKind, void 0, currentCell);
            lastCell = [0, 0, 0, 0];
          }
          cell[2] = index3;
        }
      } else if (token.type === "tableCellDivider") {
        if (inFirstCellAwaitingPipe) {
          inFirstCellAwaitingPipe = false;
        } else {
          if (lastCell[1] !== 0) {
            cell[0] = cell[1];
            currentCell = flushCell(map9, context, lastCell, rowKind, void 0, currentCell);
          }
          lastCell = cell;
          cell = [lastCell[1], index3, 0, 0];
        }
      }
    } else if (token.type === "tableHead") {
      afterHeadAwaitingFirstBodyRow = true;
      lastTableEnd = index3;
    } else if (token.type === "tableRow" || token.type === "tableDelimiterRow") {
      lastTableEnd = index3;
      if (lastCell[1] !== 0) {
        cell[0] = cell[1];
        currentCell = flushCell(map9, context, lastCell, rowKind, index3, currentCell);
      } else if (cell[1] !== 0) {
        currentCell = flushCell(map9, context, cell, rowKind, index3, currentCell);
      }
      rowKind = 0;
    } else if (rowKind && (token.type === "data" || token.type === "tableDelimiterMarker" || token.type === "tableDelimiterFiller")) {
      cell[3] = index3;
    }
  }
  if (lastTableEnd !== 0) {
    flushTableEnd(map9, context, lastTableEnd, currentTable, currentBody);
  }
  map9.consume(context.events);
  index3 = -1;
  while (++index3 < context.events.length) {
    const event = context.events[index3];
    if (event[0] === "enter" && event[1].type === "table") {
      event[1]._align = gfmTableAlign(context.events, index3);
    }
  }
  return events;
}
function flushCell(map9, context, range, rowKind, rowEnd, previousCell) {
  const groupName = rowKind === 1 ? "tableHeader" : rowKind === 2 ? "tableDelimiter" : "tableData";
  const valueName = "tableContent";
  if (range[0] !== 0) {
    previousCell.end = Object.assign({}, getPoint(context.events, range[0]));
    map9.add(range[0], 0, [["exit", previousCell, context]]);
  }
  const now = getPoint(context.events, range[1]);
  previousCell = {
    type: groupName,
    start: Object.assign({}, now),
    // Note: correct end is set later.
    end: Object.assign({}, now)
  };
  map9.add(range[1], 0, [["enter", previousCell, context]]);
  if (range[2] !== 0) {
    const relatedStart = getPoint(context.events, range[2]);
    const relatedEnd = getPoint(context.events, range[3]);
    const valueToken = {
      type: valueName,
      start: Object.assign({}, relatedStart),
      end: Object.assign({}, relatedEnd)
    };
    map9.add(range[2], 0, [["enter", valueToken, context]]);
    if (rowKind !== 2) {
      const start = context.events[range[2]];
      const end = context.events[range[3]];
      start[1].end = Object.assign({}, end[1].end);
      start[1].type = "chunkText";
      start[1].contentType = "text";
      if (range[3] > range[2] + 1) {
        const a2 = range[2] + 1;
        const b2 = range[3] - range[2] - 1;
        map9.add(a2, b2, []);
      }
    }
    map9.add(range[3] + 1, 0, [["exit", valueToken, context]]);
  }
  if (rowEnd !== void 0) {
    previousCell.end = Object.assign({}, getPoint(context.events, rowEnd));
    map9.add(rowEnd, 0, [["exit", previousCell, context]]);
    previousCell = void 0;
  }
  return previousCell;
}
function flushTableEnd(map9, context, index3, table2, tableBody) {
  const exits = [];
  const related = getPoint(context.events, index3);
  if (tableBody) {
    tableBody.end = Object.assign({}, related);
    exits.push(["exit", tableBody, context]);
  }
  table2.end = Object.assign({}, related);
  exits.push(["exit", table2, context]);
  map9.add(index3 + 1, 0, exits);
}
function getPoint(events, index3) {
  const event = events[index3];
  const side = event[0] === "enter" ? "start" : "end";
  return event[1][side];
}

// node_modules/micromark-extension-gfm-task-list-item/index.js
init_process();
init_buffer();

// node_modules/micromark-extension-gfm-task-list-item/lib/syntax.js
init_process();
init_buffer();
var tasklistCheck = {
  name: "tasklistCheck",
  tokenize: tokenizeTasklistCheck
};
function gfmTaskListItem() {
  return {
    text: {
      [91]: tasklistCheck
    }
  };
}
function tokenizeTasklistCheck(effects, ok3, nok) {
  const self2 = this;
  return open;
  function open(code4) {
    if (
      // Exit if there’s stuff before.
      self2.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !self2._gfmTasklistFirstContentOfListItem
    ) {
      return nok(code4);
    }
    effects.enter("taskListCheck");
    effects.enter("taskListCheckMarker");
    effects.consume(code4);
    effects.exit("taskListCheckMarker");
    return inside;
  }
  function inside(code4) {
    if (markdownLineEndingOrSpace(code4)) {
      effects.enter("taskListCheckValueUnchecked");
      effects.consume(code4);
      effects.exit("taskListCheckValueUnchecked");
      return close;
    }
    if (code4 === 88 || code4 === 120) {
      effects.enter("taskListCheckValueChecked");
      effects.consume(code4);
      effects.exit("taskListCheckValueChecked");
      return close;
    }
    return nok(code4);
  }
  function close(code4) {
    if (code4 === 93) {
      effects.enter("taskListCheckMarker");
      effects.consume(code4);
      effects.exit("taskListCheckMarker");
      effects.exit("taskListCheck");
      return after;
    }
    return nok(code4);
  }
  function after(code4) {
    if (markdownLineEnding(code4)) {
      return ok3(code4);
    }
    if (markdownSpace(code4)) {
      return effects.check({
        tokenize: spaceThenNonSpace
      }, ok3, nok)(code4);
    }
    return nok(code4);
  }
}
function spaceThenNonSpace(effects, ok3, nok) {
  return factorySpace(effects, after, "whitespace");
  function after(code4) {
    return code4 === null ? nok(code4) : ok3(code4);
  }
}

// node_modules/micromark-extension-gfm/index.js
function gfm(options) {
  return combineExtensions([
    gfmAutolinkLiteral(),
    gfmFootnote(),
    gfmStrikethrough(options),
    gfmTable(),
    gfmTaskListItem()
  ]);
}

// node_modules/remark-gfm/lib/index.js
var emptyOptions3 = {};
function remarkGfm(options) {
  const self2 = (
    /** @type {Processor} */
    this
  );
  const settings = options || emptyOptions3;
  const data = self2.data();
  const micromarkExtensions = data.micromarkExtensions || (data.micromarkExtensions = []);
  const fromMarkdownExtensions = data.fromMarkdownExtensions || (data.fromMarkdownExtensions = []);
  const toMarkdownExtensions = data.toMarkdownExtensions || (data.toMarkdownExtensions = []);
  micromarkExtensions.push(gfm(settings));
  fromMarkdownExtensions.push(gfmFromMarkdown());
  toMarkdownExtensions.push(gfmToMarkdown(settings));
}

// node_modules/remark-parse/index.js
init_process();
init_buffer();

// node_modules/remark-parse/lib/index.js
init_process();
init_buffer();

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/index.js
init_process();
init_buffer();

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/lib/index.js
init_process();
init_buffer();

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/mdast-util-to-string/index.js
init_process();
init_buffer();

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/mdast-util-to-string/lib/index.js
init_process();
init_buffer();
var emptyOptions4 = {};
function toString5(value, options) {
  const settings = options || emptyOptions4;
  const includeImageAlt = typeof settings.includeImageAlt === "boolean" ? settings.includeImageAlt : true;
  const includeHtml = typeof settings.includeHtml === "boolean" ? settings.includeHtml : true;
  return one3(value, includeImageAlt, includeHtml);
}
function one3(value, includeImageAlt, includeHtml) {
  if (node2(value)) {
    if ("value" in value) {
      return value.type === "html" && !includeHtml ? "" : value.value;
    }
    if (includeImageAlt && "alt" in value && value.alt) {
      return value.alt;
    }
    if ("children" in value) {
      return all3(value.children, includeImageAlt, includeHtml);
    }
  }
  if (Array.isArray(value)) {
    return all3(value, includeImageAlt, includeHtml);
  }
  return "";
}
function all3(values, includeImageAlt, includeHtml) {
  const result = [];
  let index3 = -1;
  while (++index3 < values.length) {
    result[index3] = one3(values[index3], includeImageAlt, includeHtml);
  }
  return result.join("");
}
function node2(value) {
  return Boolean(value && typeof value === "object");
}

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/index.js
init_process();
init_buffer();

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/node_modules/micromark-util-chunked/index.js
init_process();
init_buffer();
function splice3(list4, start, remove, items) {
  const end = list4.length;
  let chunkStart = 0;
  let parameters;
  if (start < 0) {
    start = -start > end ? 0 : end + start;
  } else {
    start = start > end ? end : start;
  }
  remove = remove > 0 ? remove : 0;
  if (items.length < 1e4) {
    parameters = Array.from(items);
    parameters.unshift(start, remove);
    list4.splice(...parameters);
  } else {
    if (remove)
      list4.splice(start, remove);
    while (chunkStart < items.length) {
      parameters = items.slice(chunkStart, chunkStart + 1e4);
      parameters.unshift(start, 0);
      list4.splice(...parameters);
      chunkStart += 1e4;
      start += 1e4;
    }
  }
}
function push(list4, items) {
  if (list4.length > 0) {
    splice3(list4, list4.length, 0, items);
    return list4;
  }
  return items;
}

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark-util-decode-numeric-character-reference/index.js
init_process();
init_buffer();
function decodeNumericCharacterReference(value, base2) {
  const code4 = Number.parseInt(value, base2);
  if (
    // C0 except for HT, LF, FF, CR, space.
    code4 < 9 || code4 === 11 || code4 > 13 && code4 < 32 || // Control character (DEL) of C0, and C1 controls.
    code4 > 126 && code4 < 160 || // Lone high surrogates and low surrogates.
    code4 > 55295 && code4 < 57344 || // Noncharacters.
    code4 > 64975 && code4 < 65008 || /* eslint-disable no-bitwise */
    (code4 & 65535) === 65535 || (code4 & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    code4 > 1114111
  ) {
    return "\uFFFD";
  }
  return String.fromCodePoint(code4);
}

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark-util-normalize-identifier/index.js
init_process();
init_buffer();
function normalizeIdentifier3(value) {
  return value.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/lib/parse.js
init_process();
init_buffer();

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/lib/initialize/content.js
init_process();
init_buffer();
var content = {
  tokenize: initializeContent
};
function initializeContent(effects) {
  const contentStart = effects.attempt(
    this.parser.constructs.contentInitial,
    afterContentStartConstruct,
    paragraphInitial
  );
  let previous3;
  return contentStart;
  function afterContentStartConstruct(code4) {
    if (code4 === null) {
      effects.consume(code4);
      return;
    }
    effects.enter("lineEnding");
    effects.consume(code4);
    effects.exit("lineEnding");
    return factorySpace(effects, contentStart, "linePrefix");
  }
  function paragraphInitial(code4) {
    effects.enter("paragraph");
    return lineStart(code4);
  }
  function lineStart(code4) {
    const token = effects.enter("chunkText", {
      contentType: "text",
      previous: previous3
    });
    if (previous3) {
      previous3.next = token;
    }
    previous3 = token;
    return data(code4);
  }
  function data(code4) {
    if (code4 === null) {
      effects.exit("chunkText");
      effects.exit("paragraph");
      effects.consume(code4);
      return;
    }
    if (markdownLineEnding(code4)) {
      effects.consume(code4);
      effects.exit("chunkText");
      return lineStart;
    }
    effects.consume(code4);
    return data;
  }
}

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/lib/initialize/document.js
init_process();
init_buffer();
var document = {
  tokenize: initializeDocument
};
var containerConstruct = {
  tokenize: tokenizeContainer
};
function initializeDocument(effects) {
  const self2 = this;
  const stack = [];
  let continued = 0;
  let childFlow;
  let childToken;
  let lineStartOffset;
  return start;
  function start(code4) {
    if (continued < stack.length) {
      const item = stack[continued];
      self2.containerState = item[1];
      return effects.attempt(
        item[0].continuation,
        documentContinue,
        checkNewContainers
      )(code4);
    }
    return checkNewContainers(code4);
  }
  function documentContinue(code4) {
    continued++;
    if (self2.containerState._closeFlow) {
      self2.containerState._closeFlow = void 0;
      if (childFlow) {
        closeFlow();
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let point5;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
          point5 = self2.events[indexBeforeFlow][1].end;
          break;
        }
      }
      exitContainers(continued);
      let index3 = indexBeforeExits;
      while (index3 < self2.events.length) {
        self2.events[index3][1].end = Object.assign({}, point5);
        index3++;
      }
      splice3(
        self2.events,
        indexBeforeFlow + 1,
        0,
        self2.events.slice(indexBeforeExits)
      );
      self2.events.length = index3;
      return checkNewContainers(code4);
    }
    return start(code4);
  }
  function checkNewContainers(code4) {
    if (continued === stack.length) {
      if (!childFlow) {
        return documentContinued(code4);
      }
      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
        return flowStart(code4);
      }
      self2.interrupt = Boolean(
        childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack
      );
    }
    self2.containerState = {};
    return effects.check(
      containerConstruct,
      thereIsANewContainer,
      thereIsNoNewContainer
    )(code4);
  }
  function thereIsANewContainer(code4) {
    if (childFlow)
      closeFlow();
    exitContainers(continued);
    return documentContinued(code4);
  }
  function thereIsNoNewContainer(code4) {
    self2.parser.lazy[self2.now().line] = continued !== stack.length;
    lineStartOffset = self2.now().offset;
    return flowStart(code4);
  }
  function documentContinued(code4) {
    self2.containerState = {};
    return effects.attempt(
      containerConstruct,
      containerContinue,
      flowStart
    )(code4);
  }
  function containerContinue(code4) {
    continued++;
    stack.push([self2.currentConstruct, self2.containerState]);
    return documentContinued(code4);
  }
  function flowStart(code4) {
    if (code4 === null) {
      if (childFlow)
        closeFlow();
      exitContainers(0);
      effects.consume(code4);
      return;
    }
    childFlow = childFlow || self2.parser.flow(self2.now());
    effects.enter("chunkFlow", {
      contentType: "flow",
      previous: childToken,
      _tokenizer: childFlow
    });
    return flowContinue(code4);
  }
  function flowContinue(code4) {
    if (code4 === null) {
      writeToChild(effects.exit("chunkFlow"), true);
      exitContainers(0);
      effects.consume(code4);
      return;
    }
    if (markdownLineEnding(code4)) {
      effects.consume(code4);
      writeToChild(effects.exit("chunkFlow"));
      continued = 0;
      self2.interrupt = void 0;
      return start;
    }
    effects.consume(code4);
    return flowContinue;
  }
  function writeToChild(token, eof) {
    const stream = self2.sliceStream(token);
    if (eof)
      stream.push(null);
    token.previous = childToken;
    if (childToken)
      childToken.next = token;
    childToken = token;
    childFlow.defineSkip(token.start);
    childFlow.write(stream);
    if (self2.parser.lazy[token.start.line]) {
      let index3 = childFlow.events.length;
      while (index3--) {
        if (
          // The token starts before the line ending…
          childFlow.events[index3][1].start.offset < lineStartOffset && // …and either is not ended yet…
          (!childFlow.events[index3][1].end || // …or ends after it.
          childFlow.events[index3][1].end.offset > lineStartOffset)
        ) {
          return;
        }
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let seen;
      let point5;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
          if (seen) {
            point5 = self2.events[indexBeforeFlow][1].end;
            break;
          }
          seen = true;
        }
      }
      exitContainers(continued);
      index3 = indexBeforeExits;
      while (index3 < self2.events.length) {
        self2.events[index3][1].end = Object.assign({}, point5);
        index3++;
      }
      splice3(
        self2.events,
        indexBeforeFlow + 1,
        0,
        self2.events.slice(indexBeforeExits)
      );
      self2.events.length = index3;
    }
  }
  function exitContainers(size) {
    let index3 = stack.length;
    while (index3-- > size) {
      const entry = stack[index3];
      self2.containerState = entry[1];
      entry[0].exit.call(self2, effects);
    }
    stack.length = size;
  }
  function closeFlow() {
    childFlow.write([null]);
    childToken = void 0;
    childFlow = void 0;
    self2.containerState._closeFlow = void 0;
  }
}
function tokenizeContainer(effects, ok3, nok) {
  return factorySpace(
    effects,
    effects.attempt(this.parser.constructs.document, ok3, nok),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/lib/initialize/flow.js
init_process();
init_buffer();

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/node_modules/micromark-core-commonmark/index.js
init_process();
init_buffer();

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/node_modules/micromark-core-commonmark/lib/attention.js
init_process();
init_buffer();

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/node_modules/micromark-util-resolve-all/index.js
init_process();
init_buffer();
function resolveAll2(constructs2, events, context) {
  const called = [];
  let index3 = -1;
  while (++index3 < constructs2.length) {
    const resolve2 = constructs2[index3].resolveAll;
    if (resolve2 && !called.includes(resolve2)) {
      events = resolve2(events, context);
      called.push(resolve2);
    }
  }
  return events;
}

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/node_modules/micromark-core-commonmark/lib/attention.js
var attention = {
  name: "attention",
  tokenize: tokenizeAttention,
  resolveAll: resolveAllAttention
};
function resolveAllAttention(events, context) {
  let index3 = -1;
  let open;
  let group;
  let text8;
  let openingSequence;
  let closingSequence;
  let use;
  let nextEvents;
  let offset;
  while (++index3 < events.length) {
    if (events[index3][0] === "enter" && events[index3][1].type === "attentionSequence" && events[index3][1]._close) {
      open = index3;
      while (open--) {
        if (events[open][0] === "exit" && events[open][1].type === "attentionSequence" && events[open][1]._open && // If the markers are the same:
        context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index3][1]).charCodeAt(0)) {
          if ((events[open][1]._close || events[index3][1]._open) && (events[index3][1].end.offset - events[index3][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index3][1].end.offset - events[index3][1].start.offset) % 3)) {
            continue;
          }
          use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index3][1].end.offset - events[index3][1].start.offset > 1 ? 2 : 1;
          const start = Object.assign({}, events[open][1].end);
          const end = Object.assign({}, events[index3][1].start);
          movePoint(start, -use);
          movePoint(end, use);
          openingSequence = {
            type: use > 1 ? "strongSequence" : "emphasisSequence",
            start,
            end: Object.assign({}, events[open][1].end)
          };
          closingSequence = {
            type: use > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, events[index3][1].start),
            end
          };
          text8 = {
            type: use > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, events[open][1].end),
            end: Object.assign({}, events[index3][1].start)
          };
          group = {
            type: use > 1 ? "strong" : "emphasis",
            start: Object.assign({}, openingSequence.start),
            end: Object.assign({}, closingSequence.end)
          };
          events[open][1].end = Object.assign({}, openingSequence.start);
          events[index3][1].start = Object.assign({}, closingSequence.end);
          nextEvents = [];
          if (events[open][1].end.offset - events[open][1].start.offset) {
            nextEvents = push(nextEvents, [["enter", events[open][1], context], ["exit", events[open][1], context]]);
          }
          nextEvents = push(nextEvents, [["enter", group, context], ["enter", openingSequence, context], ["exit", openingSequence, context], ["enter", text8, context]]);
          nextEvents = push(nextEvents, resolveAll2(context.parser.constructs.insideSpan.null, events.slice(open + 1, index3), context));
          nextEvents = push(nextEvents, [["exit", text8, context], ["enter", closingSequence, context], ["exit", closingSequence, context], ["exit", group, context]]);
          if (events[index3][1].end.offset - events[index3][1].start.offset) {
            offset = 2;
            nextEvents = push(nextEvents, [["enter", events[index3][1], context], ["exit", events[index3][1], context]]);
          } else {
            offset = 0;
          }
          splice3(events, open - 1, index3 - open + 3, nextEvents);
          index3 = open + nextEvents.length - offset - 2;
          break;
        }
      }
    }
  }
  index3 = -1;
  while (++index3 < events.length) {
    if (events[index3][1].type === "attentionSequence") {
      events[index3][1].type = "data";
    }
  }
  return events;
}
function tokenizeAttention(effects, ok3) {
  const attentionMarkers2 = this.parser.constructs.attentionMarkers.null;
  const previous3 = this.previous;
  const before = classifyCharacter(previous3);
  let marker;
  return start;
  function start(code4) {
    marker = code4;
    effects.enter("attentionSequence");
    return inside(code4);
  }
  function inside(code4) {
    if (code4 === marker) {
      effects.consume(code4);
      return inside;
    }
    const token = effects.exit("attentionSequence");
    const after = classifyCharacter(code4);
    const open = !after || after === 2 && before || attentionMarkers2.includes(code4);
    const close = !before || before === 2 && after || attentionMarkers2.includes(previous3);
    token._open = Boolean(marker === 42 ? open : open && (before || !close));
    token._close = Boolean(marker === 42 ? close : close && (after || !open));
    return ok3(code4);
  }
}
function movePoint(point5, offset) {
  point5.column += offset;
  point5.offset += offset;
  point5._bufferIndex += offset;
}

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/node_modules/micromark-core-commonmark/lib/autolink.js
init_process();
init_buffer();
var autolink = {
  name: "autolink",
  tokenize: tokenizeAutolink
};
function tokenizeAutolink(effects, ok3, nok) {
  let size = 0;
  return start;
  function start(code4) {
    effects.enter("autolink");
    effects.enter("autolinkMarker");
    effects.consume(code4);
    effects.exit("autolinkMarker");
    effects.enter("autolinkProtocol");
    return open;
  }
  function open(code4) {
    if (asciiAlpha(code4)) {
      effects.consume(code4);
      return schemeOrEmailAtext;
    }
    if (code4 === 64) {
      return nok(code4);
    }
    return emailAtext(code4);
  }
  function schemeOrEmailAtext(code4) {
    if (code4 === 43 || code4 === 45 || code4 === 46 || asciiAlphanumeric(code4)) {
      size = 1;
      return schemeInsideOrEmailAtext(code4);
    }
    return emailAtext(code4);
  }
  function schemeInsideOrEmailAtext(code4) {
    if (code4 === 58) {
      effects.consume(code4);
      size = 0;
      return urlInside;
    }
    if ((code4 === 43 || code4 === 45 || code4 === 46 || asciiAlphanumeric(code4)) && size++ < 32) {
      effects.consume(code4);
      return schemeInsideOrEmailAtext;
    }
    size = 0;
    return emailAtext(code4);
  }
  function urlInside(code4) {
    if (code4 === 62) {
      effects.exit("autolinkProtocol");
      effects.enter("autolinkMarker");
      effects.consume(code4);
      effects.exit("autolinkMarker");
      effects.exit("autolink");
      return ok3;
    }
    if (code4 === null || code4 === 32 || code4 === 60 || asciiControl(code4)) {
      return nok(code4);
    }
    effects.consume(code4);
    return urlInside;
  }
  function emailAtext(code4) {
    if (code4 === 64) {
      effects.consume(code4);
      return emailAtSignOrDot;
    }
    if (asciiAtext(code4)) {
      effects.consume(code4);
      return emailAtext;
    }
    return nok(code4);
  }
  function emailAtSignOrDot(code4) {
    return asciiAlphanumeric(code4) ? emailLabel(code4) : nok(code4);
  }
  function emailLabel(code4) {
    if (code4 === 46) {
      effects.consume(code4);
      size = 0;
      return emailAtSignOrDot;
    }
    if (code4 === 62) {
      effects.exit("autolinkProtocol").type = "autolinkEmail";
      effects.enter("autolinkMarker");
      effects.consume(code4);
      effects.exit("autolinkMarker");
      effects.exit("autolink");
      return ok3;
    }
    return emailValue(code4);
  }
  function emailValue(code4) {
    if ((code4 === 45 || asciiAlphanumeric(code4)) && size++ < 63) {
      const next = code4 === 45 ? emailValue : emailLabel;
      effects.consume(code4);
      return next;
    }
    return nok(code4);
  }
}

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/node_modules/micromark-core-commonmark/lib/blank-line.js
init_process();
init_buffer();
var blankLine2 = {
  tokenize: tokenizeBlankLine2,
  partial: true
};
function tokenizeBlankLine2(effects, ok3, nok) {
  return start;
  function start(code4) {
    return markdownSpace(code4) ? factorySpace(effects, after, "linePrefix")(code4) : after(code4);
  }
  function after(code4) {
    return code4 === null || markdownLineEnding(code4) ? ok3(code4) : nok(code4);
  }
}

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/node_modules/micromark-core-commonmark/lib/block-quote.js
init_process();
init_buffer();
var blockQuote = {
  name: "blockQuote",
  tokenize: tokenizeBlockQuoteStart,
  continuation: {
    tokenize: tokenizeBlockQuoteContinuation
  },
  exit: exit2
};
function tokenizeBlockQuoteStart(effects, ok3, nok) {
  const self2 = this;
  return start;
  function start(code4) {
    if (code4 === 62) {
      const state = self2.containerState;
      if (!state.open) {
        effects.enter("blockQuote", {
          _container: true
        });
        state.open = true;
      }
      effects.enter("blockQuotePrefix");
      effects.enter("blockQuoteMarker");
      effects.consume(code4);
      effects.exit("blockQuoteMarker");
      return after;
    }
    return nok(code4);
  }
  function after(code4) {
    if (markdownSpace(code4)) {
      effects.enter("blockQuotePrefixWhitespace");
      effects.consume(code4);
      effects.exit("blockQuotePrefixWhitespace");
      effects.exit("blockQuotePrefix");
      return ok3;
    }
    effects.exit("blockQuotePrefix");
    return ok3(code4);
  }
}
function tokenizeBlockQuoteContinuation(effects, ok3, nok) {
  const self2 = this;
  return contStart;
  function contStart(code4) {
    if (markdownSpace(code4)) {
      return factorySpace(effects, contBefore, "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code4);
    }
    return contBefore(code4);
  }
  function contBefore(code4) {
    return effects.attempt(blockQuote, ok3, nok)(code4);
  }
}
function exit2(effects) {
  effects.exit("blockQuote");
}

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/node_modules/micromark-core-commonmark/lib/character-escape.js
init_process();
init_buffer();
var characterEscape = {
  name: "characterEscape",
  tokenize: tokenizeCharacterEscape
};
function tokenizeCharacterEscape(effects, ok3, nok) {
  return start;
  function start(code4) {
    effects.enter("characterEscape");
    effects.enter("escapeMarker");
    effects.consume(code4);
    effects.exit("escapeMarker");
    return inside;
  }
  function inside(code4) {
    if (asciiPunctuation(code4)) {
      effects.enter("characterEscapeValue");
      effects.consume(code4);
      effects.exit("characterEscapeValue");
      effects.exit("characterEscape");
      return ok3;
    }
    return nok(code4);
  }
}

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/node_modules/micromark-core-commonmark/lib/character-reference.js
init_process();
init_buffer();
var characterReference = {
  name: "characterReference",
  tokenize: tokenizeCharacterReference
};
function tokenizeCharacterReference(effects, ok3, nok) {
  const self2 = this;
  let size = 0;
  let max;
  let test;
  return start;
  function start(code4) {
    effects.enter("characterReference");
    effects.enter("characterReferenceMarker");
    effects.consume(code4);
    effects.exit("characterReferenceMarker");
    return open;
  }
  function open(code4) {
    if (code4 === 35) {
      effects.enter("characterReferenceMarkerNumeric");
      effects.consume(code4);
      effects.exit("characterReferenceMarkerNumeric");
      return numeric;
    }
    effects.enter("characterReferenceValue");
    max = 31;
    test = asciiAlphanumeric;
    return value(code4);
  }
  function numeric(code4) {
    if (code4 === 88 || code4 === 120) {
      effects.enter("characterReferenceMarkerHexadecimal");
      effects.consume(code4);
      effects.exit("characterReferenceMarkerHexadecimal");
      effects.enter("characterReferenceValue");
      max = 6;
      test = asciiHexDigit;
      return value;
    }
    effects.enter("characterReferenceValue");
    max = 7;
    test = asciiDigit;
    return value(code4);
  }
  function value(code4) {
    if (code4 === 59 && size) {
      const token = effects.exit("characterReferenceValue");
      if (test === asciiAlphanumeric && !decodeNamedCharacterReference(self2.sliceSerialize(token))) {
        return nok(code4);
      }
      effects.enter("characterReferenceMarker");
      effects.consume(code4);
      effects.exit("characterReferenceMarker");
      effects.exit("characterReference");
      return ok3;
    }
    if (test(code4) && size++ < max) {
      effects.consume(code4);
      return value;
    }
    return nok(code4);
  }
}

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/node_modules/micromark-core-commonmark/lib/code-fenced.js
init_process();
init_buffer();
var nonLazyContinuation = {
  tokenize: tokenizeNonLazyContinuation,
  partial: true
};
var codeFenced = {
  name: "codeFenced",
  tokenize: tokenizeCodeFenced,
  concrete: true
};
function tokenizeCodeFenced(effects, ok3, nok) {
  const self2 = this;
  const closeStart = {
    tokenize: tokenizeCloseStart,
    partial: true
  };
  let initialPrefix = 0;
  let sizeOpen = 0;
  let marker;
  return start;
  function start(code4) {
    return beforeSequenceOpen(code4);
  }
  function beforeSequenceOpen(code4) {
    const tail = self2.events[self2.events.length - 1];
    initialPrefix = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
    marker = code4;
    effects.enter("codeFenced");
    effects.enter("codeFencedFence");
    effects.enter("codeFencedFenceSequence");
    return sequenceOpen(code4);
  }
  function sequenceOpen(code4) {
    if (code4 === marker) {
      sizeOpen++;
      effects.consume(code4);
      return sequenceOpen;
    }
    if (sizeOpen < 3) {
      return nok(code4);
    }
    effects.exit("codeFencedFenceSequence");
    return markdownSpace(code4) ? factorySpace(effects, infoBefore, "whitespace")(code4) : infoBefore(code4);
  }
  function infoBefore(code4) {
    if (code4 === null || markdownLineEnding(code4)) {
      effects.exit("codeFencedFence");
      return self2.interrupt ? ok3(code4) : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code4);
    }
    effects.enter("codeFencedFenceInfo");
    effects.enter("chunkString", {
      contentType: "string"
    });
    return info2(code4);
  }
  function info2(code4) {
    if (code4 === null || markdownLineEnding(code4)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceInfo");
      return infoBefore(code4);
    }
    if (markdownSpace(code4)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceInfo");
      return factorySpace(effects, metaBefore, "whitespace")(code4);
    }
    if (code4 === 96 && code4 === marker) {
      return nok(code4);
    }
    effects.consume(code4);
    return info2;
  }
  function metaBefore(code4) {
    if (code4 === null || markdownLineEnding(code4)) {
      return infoBefore(code4);
    }
    effects.enter("codeFencedFenceMeta");
    effects.enter("chunkString", {
      contentType: "string"
    });
    return meta(code4);
  }
  function meta(code4) {
    if (code4 === null || markdownLineEnding(code4)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceMeta");
      return infoBefore(code4);
    }
    if (code4 === 96 && code4 === marker) {
      return nok(code4);
    }
    effects.consume(code4);
    return meta;
  }
  function atNonLazyBreak(code4) {
    return effects.attempt(closeStart, after, contentBefore)(code4);
  }
  function contentBefore(code4) {
    effects.enter("lineEnding");
    effects.consume(code4);
    effects.exit("lineEnding");
    return contentStart;
  }
  function contentStart(code4) {
    return initialPrefix > 0 && markdownSpace(code4) ? factorySpace(effects, beforeContentChunk, "linePrefix", initialPrefix + 1)(code4) : beforeContentChunk(code4);
  }
  function beforeContentChunk(code4) {
    if (code4 === null || markdownLineEnding(code4)) {
      return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code4);
    }
    effects.enter("codeFlowValue");
    return contentChunk(code4);
  }
  function contentChunk(code4) {
    if (code4 === null || markdownLineEnding(code4)) {
      effects.exit("codeFlowValue");
      return beforeContentChunk(code4);
    }
    effects.consume(code4);
    return contentChunk;
  }
  function after(code4) {
    effects.exit("codeFenced");
    return ok3(code4);
  }
  function tokenizeCloseStart(effects2, ok4, nok2) {
    let size = 0;
    return startBefore;
    function startBefore(code4) {
      effects2.enter("lineEnding");
      effects2.consume(code4);
      effects2.exit("lineEnding");
      return start2;
    }
    function start2(code4) {
      effects2.enter("codeFencedFence");
      return markdownSpace(code4) ? factorySpace(effects2, beforeSequenceClose, "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code4) : beforeSequenceClose(code4);
    }
    function beforeSequenceClose(code4) {
      if (code4 === marker) {
        effects2.enter("codeFencedFenceSequence");
        return sequenceClose(code4);
      }
      return nok2(code4);
    }
    function sequenceClose(code4) {
      if (code4 === marker) {
        size++;
        effects2.consume(code4);
        return sequenceClose;
      }
      if (size >= sizeOpen) {
        effects2.exit("codeFencedFenceSequence");
        return markdownSpace(code4) ? factorySpace(effects2, sequenceCloseAfter, "whitespace")(code4) : sequenceCloseAfter(code4);
      }
      return nok2(code4);
    }
    function sequenceCloseAfter(code4) {
      if (code4 === null || markdownLineEnding(code4)) {
        effects2.exit("codeFencedFence");
        return ok4(code4);
      }
      return nok2(code4);
    }
  }
}
function tokenizeNonLazyContinuation(effects, ok3, nok) {
  const self2 = this;
  return start;
  function start(code4) {
    if (code4 === null) {
      return nok(code4);
    }
    effects.enter("lineEnding");
    effects.consume(code4);
    effects.exit("lineEnding");
    return lineStart;
  }
  function lineStart(code4) {
    return self2.parser.lazy[self2.now().line] ? nok(code4) : ok3(code4);
  }
}

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/node_modules/micromark-core-commonmark/lib/code-indented.js
init_process();
init_buffer();
var codeIndented = {
  name: "codeIndented",
  tokenize: tokenizeCodeIndented
};
var furtherStart = {
  tokenize: tokenizeFurtherStart,
  partial: true
};
function tokenizeCodeIndented(effects, ok3, nok) {
  const self2 = this;
  return start;
  function start(code4) {
    effects.enter("codeIndented");
    return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code4);
  }
  function afterPrefix(code4) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? atBreak(code4) : nok(code4);
  }
  function atBreak(code4) {
    if (code4 === null) {
      return after(code4);
    }
    if (markdownLineEnding(code4)) {
      return effects.attempt(furtherStart, atBreak, after)(code4);
    }
    effects.enter("codeFlowValue");
    return inside(code4);
  }
  function inside(code4) {
    if (code4 === null || markdownLineEnding(code4)) {
      effects.exit("codeFlowValue");
      return atBreak(code4);
    }
    effects.consume(code4);
    return inside;
  }
  function after(code4) {
    effects.exit("codeIndented");
    return ok3(code4);
  }
}
function tokenizeFurtherStart(effects, ok3, nok) {
  const self2 = this;
  return furtherStart2;
  function furtherStart2(code4) {
    if (self2.parser.lazy[self2.now().line]) {
      return nok(code4);
    }
    if (markdownLineEnding(code4)) {
      effects.enter("lineEnding");
      effects.consume(code4);
      effects.exit("lineEnding");
      return furtherStart2;
    }
    return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code4);
  }
  function afterPrefix(code4) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? ok3(code4) : markdownLineEnding(code4) ? furtherStart2(code4) : nok(code4);
  }
}

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/node_modules/micromark-core-commonmark/lib/code-text.js
init_process();
init_buffer();
var codeText = {
  name: "codeText",
  tokenize: tokenizeCodeText,
  resolve: resolveCodeText,
  previous: previous2
};
function resolveCodeText(events) {
  let tailExitIndex = events.length - 4;
  let headEnterIndex = 3;
  let index3;
  let enter;
  if ((events[headEnterIndex][1].type === "lineEnding" || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === "lineEnding" || events[tailExitIndex][1].type === "space")) {
    index3 = headEnterIndex;
    while (++index3 < tailExitIndex) {
      if (events[index3][1].type === "codeTextData") {
        events[headEnterIndex][1].type = "codeTextPadding";
        events[tailExitIndex][1].type = "codeTextPadding";
        headEnterIndex += 2;
        tailExitIndex -= 2;
        break;
      }
    }
  }
  index3 = headEnterIndex - 1;
  tailExitIndex++;
  while (++index3 <= tailExitIndex) {
    if (enter === void 0) {
      if (index3 !== tailExitIndex && events[index3][1].type !== "lineEnding") {
        enter = index3;
      }
    } else if (index3 === tailExitIndex || events[index3][1].type === "lineEnding") {
      events[enter][1].type = "codeTextData";
      if (index3 !== enter + 2) {
        events[enter][1].end = events[index3 - 1][1].end;
        events.splice(enter + 2, index3 - enter - 2);
        tailExitIndex -= index3 - enter - 2;
        index3 = enter + 2;
      }
      enter = void 0;
    }
  }
  return events;
}
function previous2(code4) {
  return code4 !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function tokenizeCodeText(effects, ok3, nok) {
  const self2 = this;
  let sizeOpen = 0;
  let size;
  let token;
  return start;
  function start(code4) {
    effects.enter("codeText");
    effects.enter("codeTextSequence");
    return sequenceOpen(code4);
  }
  function sequenceOpen(code4) {
    if (code4 === 96) {
      effects.consume(code4);
      sizeOpen++;
      return sequenceOpen;
    }
    effects.exit("codeTextSequence");
    return between2(code4);
  }
  function between2(code4) {
    if (code4 === null) {
      return nok(code4);
    }
    if (code4 === 32) {
      effects.enter("space");
      effects.consume(code4);
      effects.exit("space");
      return between2;
    }
    if (code4 === 96) {
      token = effects.enter("codeTextSequence");
      size = 0;
      return sequenceClose(code4);
    }
    if (markdownLineEnding(code4)) {
      effects.enter("lineEnding");
      effects.consume(code4);
      effects.exit("lineEnding");
      return between2;
    }
    effects.enter("codeTextData");
    return data(code4);
  }
  function data(code4) {
    if (code4 === null || code4 === 32 || code4 === 96 || markdownLineEnding(code4)) {
      effects.exit("codeTextData");
      return between2(code4);
    }
    effects.consume(code4);
    return data;
  }
  function sequenceClose(code4) {
    if (code4 === 96) {
      effects.consume(code4);
      size++;
      return sequenceClose;
    }
    if (size === sizeOpen) {
      effects.exit("codeTextSequence");
      effects.exit("codeText");
      return ok3(code4);
    }
    token.type = "codeTextData";
    return data(code4);
  }
}

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/node_modules/micromark-core-commonmark/lib/content.js
init_process();
init_buffer();

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/node_modules/micromark-util-subtokenize/index.js
init_process();
init_buffer();

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/node_modules/micromark-util-subtokenize/lib/splice-buffer.js
init_process();
init_buffer();
var SpliceBuffer = class {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(initial) {
    this.left = initial ? [...initial] : [];
    this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(index3) {
    if (index3 < 0 || index3 >= this.left.length + this.right.length) {
      throw new RangeError("Cannot access index `" + index3 + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    }
    if (index3 < this.left.length)
      return this.left[index3];
    return this.right[this.right.length - index3 + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    this.setCursor(0);
    return this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(start, end) {
    const stop = end === null || end === void 0 ? Number.POSITIVE_INFINITY : end;
    if (stop < this.left.length) {
      return this.left.slice(start, stop);
    }
    if (start > this.left.length) {
      return this.right.slice(this.right.length - stop + this.left.length, this.right.length - start + this.left.length).reverse();
    }
    return this.left.slice(start).concat(this.right.slice(this.right.length - stop + this.left.length).reverse());
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(start, deleteCount, items) {
    const count2 = deleteCount || 0;
    this.setCursor(Math.trunc(start));
    const removed = this.right.splice(this.right.length - count2, Number.POSITIVE_INFINITY);
    if (items)
      chunkedPush(this.left, items);
    return removed.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    this.setCursor(Number.POSITIVE_INFINITY);
    return this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(item) {
    this.setCursor(Number.POSITIVE_INFINITY);
    this.left.push(item);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(items) {
    this.setCursor(Number.POSITIVE_INFINITY);
    chunkedPush(this.left, items);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(item) {
    this.setCursor(0);
    this.right.push(item);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(items) {
    this.setCursor(0);
    chunkedPush(this.right, items.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(n2) {
    if (n2 === this.left.length || n2 > this.left.length && this.right.length === 0 || n2 < 0 && this.left.length === 0)
      return;
    if (n2 < this.left.length) {
      const removed = this.left.splice(n2, Number.POSITIVE_INFINITY);
      chunkedPush(this.right, removed.reverse());
    } else {
      const removed = this.right.splice(this.left.length + this.right.length - n2, Number.POSITIVE_INFINITY);
      chunkedPush(this.left, removed.reverse());
    }
  }
};
function chunkedPush(list4, right) {
  let chunkStart = 0;
  if (right.length < 1e4) {
    list4.push(...right);
  } else {
    while (chunkStart < right.length) {
      list4.push(...right.slice(chunkStart, chunkStart + 1e4));
      chunkStart += 1e4;
    }
  }
}

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/node_modules/micromark-util-subtokenize/index.js
function subtokenize(eventsArray) {
  const jumps = {};
  let index3 = -1;
  let event;
  let lineIndex;
  let otherIndex;
  let otherEvent;
  let parameters;
  let subevents;
  let more;
  const events = new SpliceBuffer(eventsArray);
  while (++index3 < events.length) {
    while (index3 in jumps) {
      index3 = jumps[index3];
    }
    event = events.get(index3);
    if (index3 && event[1].type === "chunkFlow" && events.get(index3 - 1)[1].type === "listItemPrefix") {
      subevents = event[1]._tokenizer.events;
      otherIndex = 0;
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === "lineEndingBlank") {
        otherIndex += 2;
      }
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === "content") {
        while (++otherIndex < subevents.length) {
          if (subevents[otherIndex][1].type === "content") {
            break;
          }
          if (subevents[otherIndex][1].type === "chunkText") {
            subevents[otherIndex][1]._isInFirstContentOfListItem = true;
            otherIndex++;
          }
        }
      }
    }
    if (event[0] === "enter") {
      if (event[1].contentType) {
        Object.assign(jumps, subcontent(events, index3));
        index3 = jumps[index3];
        more = true;
      }
    } else if (event[1]._container) {
      otherIndex = index3;
      lineIndex = void 0;
      while (otherIndex--) {
        otherEvent = events.get(otherIndex);
        if (otherEvent[1].type === "lineEnding" || otherEvent[1].type === "lineEndingBlank") {
          if (otherEvent[0] === "enter") {
            if (lineIndex) {
              events.get(lineIndex)[1].type = "lineEndingBlank";
            }
            otherEvent[1].type = "lineEnding";
            lineIndex = otherIndex;
          }
        } else {
          break;
        }
      }
      if (lineIndex) {
        event[1].end = Object.assign({}, events.get(lineIndex)[1].start);
        parameters = events.slice(lineIndex, index3);
        parameters.unshift(event);
        events.splice(lineIndex, index3 - lineIndex + 1, parameters);
      }
    }
  }
  splice3(eventsArray, 0, Number.POSITIVE_INFINITY, events.slice(0));
  return !more;
}
function subcontent(events, eventIndex) {
  const token = events.get(eventIndex)[1];
  const context = events.get(eventIndex)[2];
  let startPosition = eventIndex - 1;
  const startPositions = [];
  const tokenizer = token._tokenizer || context.parser[token.contentType](token.start);
  const childEvents = tokenizer.events;
  const jumps = [];
  const gaps = {};
  let stream;
  let previous3;
  let index3 = -1;
  let current = token;
  let adjust = 0;
  let start = 0;
  const breaks = [start];
  while (current) {
    while (events.get(++startPosition)[1] !== current) {
    }
    startPositions.push(startPosition);
    if (!current._tokenizer) {
      stream = context.sliceStream(current);
      if (!current.next) {
        stream.push(null);
      }
      if (previous3) {
        tokenizer.defineSkip(current.start);
      }
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = true;
      }
      tokenizer.write(stream);
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = void 0;
      }
    }
    previous3 = current;
    current = current.next;
  }
  current = token;
  while (++index3 < childEvents.length) {
    if (
      // Find a void token that includes a break.
      childEvents[index3][0] === "exit" && childEvents[index3 - 1][0] === "enter" && childEvents[index3][1].type === childEvents[index3 - 1][1].type && childEvents[index3][1].start.line !== childEvents[index3][1].end.line
    ) {
      start = index3 + 1;
      breaks.push(start);
      current._tokenizer = void 0;
      current.previous = void 0;
      current = current.next;
    }
  }
  tokenizer.events = [];
  if (current) {
    current._tokenizer = void 0;
    current.previous = void 0;
  } else {
    breaks.pop();
  }
  index3 = breaks.length;
  while (index3--) {
    const slice3 = childEvents.slice(breaks[index3], breaks[index3 + 1]);
    const start2 = startPositions.pop();
    jumps.push([start2, start2 + slice3.length - 1]);
    events.splice(start2, 2, slice3);
  }
  jumps.reverse();
  index3 = -1;
  while (++index3 < jumps.length) {
    gaps[adjust + jumps[index3][0]] = adjust + jumps[index3][1];
    adjust += jumps[index3][1] - jumps[index3][0] - 1;
  }
  return gaps;
}

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/node_modules/micromark-core-commonmark/lib/content.js
var content2 = {
  tokenize: tokenizeContent,
  resolve: resolveContent
};
var continuationConstruct = {
  tokenize: tokenizeContinuation,
  partial: true
};
function resolveContent(events) {
  subtokenize(events);
  return events;
}
function tokenizeContent(effects, ok3) {
  let previous3;
  return chunkStart;
  function chunkStart(code4) {
    effects.enter("content");
    previous3 = effects.enter("chunkContent", {
      contentType: "content"
    });
    return chunkInside(code4);
  }
  function chunkInside(code4) {
    if (code4 === null) {
      return contentEnd(code4);
    }
    if (markdownLineEnding(code4)) {
      return effects.check(continuationConstruct, contentContinue, contentEnd)(code4);
    }
    effects.consume(code4);
    return chunkInside;
  }
  function contentEnd(code4) {
    effects.exit("chunkContent");
    effects.exit("content");
    return ok3(code4);
  }
  function contentContinue(code4) {
    effects.consume(code4);
    effects.exit("chunkContent");
    previous3.next = effects.enter("chunkContent", {
      contentType: "content",
      previous: previous3
    });
    previous3 = previous3.next;
    return chunkInside;
  }
}
function tokenizeContinuation(effects, ok3, nok) {
  const self2 = this;
  return startLookahead;
  function startLookahead(code4) {
    effects.exit("chunkContent");
    effects.enter("lineEnding");
    effects.consume(code4);
    effects.exit("lineEnding");
    return factorySpace(effects, prefixed, "linePrefix");
  }
  function prefixed(code4) {
    if (code4 === null || markdownLineEnding(code4)) {
      return nok(code4);
    }
    const tail = self2.events[self2.events.length - 1];
    if (!self2.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4) {
      return ok3(code4);
    }
    return effects.interrupt(self2.parser.constructs.flow, nok, ok3)(code4);
  }
}

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/node_modules/micromark-core-commonmark/lib/definition.js
init_process();
init_buffer();

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/node_modules/micromark-core-commonmark/node_modules/micromark-factory-destination/index.js
init_process();
init_buffer();
function factoryDestination(effects, ok3, nok, type, literalType, literalMarkerType, rawType, stringType, max) {
  const limit = max || Number.POSITIVE_INFINITY;
  let balance = 0;
  return start;
  function start(code4) {
    if (code4 === 60) {
      effects.enter(type);
      effects.enter(literalType);
      effects.enter(literalMarkerType);
      effects.consume(code4);
      effects.exit(literalMarkerType);
      return enclosedBefore;
    }
    if (code4 === null || code4 === 32 || code4 === 41 || asciiControl(code4)) {
      return nok(code4);
    }
    effects.enter(type);
    effects.enter(rawType);
    effects.enter(stringType);
    effects.enter("chunkString", {
      contentType: "string"
    });
    return raw2(code4);
  }
  function enclosedBefore(code4) {
    if (code4 === 62) {
      effects.enter(literalMarkerType);
      effects.consume(code4);
      effects.exit(literalMarkerType);
      effects.exit(literalType);
      effects.exit(type);
      return ok3;
    }
    effects.enter(stringType);
    effects.enter("chunkString", {
      contentType: "string"
    });
    return enclosed(code4);
  }
  function enclosed(code4) {
    if (code4 === 62) {
      effects.exit("chunkString");
      effects.exit(stringType);
      return enclosedBefore(code4);
    }
    if (code4 === null || code4 === 60 || markdownLineEnding(code4)) {
      return nok(code4);
    }
    effects.consume(code4);
    return code4 === 92 ? enclosedEscape : enclosed;
  }
  function enclosedEscape(code4) {
    if (code4 === 60 || code4 === 62 || code4 === 92) {
      effects.consume(code4);
      return enclosed;
    }
    return enclosed(code4);
  }
  function raw2(code4) {
    if (!balance && (code4 === null || code4 === 41 || markdownLineEndingOrSpace(code4))) {
      effects.exit("chunkString");
      effects.exit(stringType);
      effects.exit(rawType);
      effects.exit(type);
      return ok3(code4);
    }
    if (balance < limit && code4 === 40) {
      effects.consume(code4);
      balance++;
      return raw2;
    }
    if (code4 === 41) {
      effects.consume(code4);
      balance--;
      return raw2;
    }
    if (code4 === null || code4 === 32 || code4 === 40 || asciiControl(code4)) {
      return nok(code4);
    }
    effects.consume(code4);
    return code4 === 92 ? rawEscape : raw2;
  }
  function rawEscape(code4) {
    if (code4 === 40 || code4 === 41 || code4 === 92) {
      effects.consume(code4);
      return raw2;
    }
    return raw2(code4);
  }
}

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/node_modules/micromark-core-commonmark/node_modules/micromark-factory-label/index.js
init_process();
init_buffer();
function factoryLabel(effects, ok3, nok, type, markerType, stringType) {
  const self2 = this;
  let size = 0;
  let seen;
  return start;
  function start(code4) {
    effects.enter(type);
    effects.enter(markerType);
    effects.consume(code4);
    effects.exit(markerType);
    effects.enter(stringType);
    return atBreak;
  }
  function atBreak(code4) {
    if (size > 999 || code4 === null || code4 === 91 || code4 === 93 && !seen || // To do: remove in the future once we’ve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesn’t need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    code4 === 94 && !size && "_hiddenFootnoteSupport" in self2.parser.constructs) {
      return nok(code4);
    }
    if (code4 === 93) {
      effects.exit(stringType);
      effects.enter(markerType);
      effects.consume(code4);
      effects.exit(markerType);
      effects.exit(type);
      return ok3;
    }
    if (markdownLineEnding(code4)) {
      effects.enter("lineEnding");
      effects.consume(code4);
      effects.exit("lineEnding");
      return atBreak;
    }
    effects.enter("chunkString", {
      contentType: "string"
    });
    return labelInside(code4);
  }
  function labelInside(code4) {
    if (code4 === null || code4 === 91 || code4 === 93 || markdownLineEnding(code4) || size++ > 999) {
      effects.exit("chunkString");
      return atBreak(code4);
    }
    effects.consume(code4);
    if (!seen)
      seen = !markdownSpace(code4);
    return code4 === 92 ? labelEscape : labelInside;
  }
  function labelEscape(code4) {
    if (code4 === 91 || code4 === 92 || code4 === 93) {
      effects.consume(code4);
      size++;
      return labelInside;
    }
    return labelInside(code4);
  }
}

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/node_modules/micromark-core-commonmark/node_modules/micromark-factory-title/index.js
init_process();
init_buffer();
function factoryTitle(effects, ok3, nok, type, markerType, stringType) {
  let marker;
  return start;
  function start(code4) {
    if (code4 === 34 || code4 === 39 || code4 === 40) {
      effects.enter(type);
      effects.enter(markerType);
      effects.consume(code4);
      effects.exit(markerType);
      marker = code4 === 40 ? 41 : code4;
      return begin;
    }
    return nok(code4);
  }
  function begin(code4) {
    if (code4 === marker) {
      effects.enter(markerType);
      effects.consume(code4);
      effects.exit(markerType);
      effects.exit(type);
      return ok3;
    }
    effects.enter(stringType);
    return atBreak(code4);
  }
  function atBreak(code4) {
    if (code4 === marker) {
      effects.exit(stringType);
      return begin(marker);
    }
    if (code4 === null) {
      return nok(code4);
    }
    if (markdownLineEnding(code4)) {
      effects.enter("lineEnding");
      effects.consume(code4);
      effects.exit("lineEnding");
      return factorySpace(effects, atBreak, "linePrefix");
    }
    effects.enter("chunkString", {
      contentType: "string"
    });
    return inside(code4);
  }
  function inside(code4) {
    if (code4 === marker || code4 === null || markdownLineEnding(code4)) {
      effects.exit("chunkString");
      return atBreak(code4);
    }
    effects.consume(code4);
    return code4 === 92 ? escape2 : inside;
  }
  function escape2(code4) {
    if (code4 === marker || code4 === 92) {
      effects.consume(code4);
      return inside;
    }
    return inside(code4);
  }
}

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/node_modules/micromark-core-commonmark/node_modules/micromark-factory-whitespace/index.js
init_process();
init_buffer();
function factoryWhitespace(effects, ok3) {
  let seen;
  return start;
  function start(code4) {
    if (markdownLineEnding(code4)) {
      effects.enter("lineEnding");
      effects.consume(code4);
      effects.exit("lineEnding");
      seen = true;
      return start;
    }
    if (markdownSpace(code4)) {
      return factorySpace(
        effects,
        start,
        seen ? "linePrefix" : "lineSuffix"
      )(code4);
    }
    return ok3(code4);
  }
}

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/node_modules/micromark-core-commonmark/lib/definition.js
var definition2 = {
  name: "definition",
  tokenize: tokenizeDefinition
};
var titleBefore = {
  tokenize: tokenizeTitleBefore,
  partial: true
};
function tokenizeDefinition(effects, ok3, nok) {
  const self2 = this;
  let identifier;
  return start;
  function start(code4) {
    effects.enter("definition");
    return before(code4);
  }
  function before(code4) {
    return factoryLabel.call(
      self2,
      effects,
      labelAfter,
      // Note: we don’t need to reset the way `markdown-rs` does.
      nok,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(code4);
  }
  function labelAfter(code4) {
    identifier = normalizeIdentifier3(self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1));
    if (code4 === 58) {
      effects.enter("definitionMarker");
      effects.consume(code4);
      effects.exit("definitionMarker");
      return markerAfter;
    }
    return nok(code4);
  }
  function markerAfter(code4) {
    return markdownLineEndingOrSpace(code4) ? factoryWhitespace(effects, destinationBefore)(code4) : destinationBefore(code4);
  }
  function destinationBefore(code4) {
    return factoryDestination(
      effects,
      destinationAfter,
      // Note: we don’t need to reset the way `markdown-rs` does.
      nok,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(code4);
  }
  function destinationAfter(code4) {
    return effects.attempt(titleBefore, after, after)(code4);
  }
  function after(code4) {
    return markdownSpace(code4) ? factorySpace(effects, afterWhitespace, "whitespace")(code4) : afterWhitespace(code4);
  }
  function afterWhitespace(code4) {
    if (code4 === null || markdownLineEnding(code4)) {
      effects.exit("definition");
      self2.parser.defined.push(identifier);
      return ok3(code4);
    }
    return nok(code4);
  }
}
function tokenizeTitleBefore(effects, ok3, nok) {
  return titleBefore2;
  function titleBefore2(code4) {
    return markdownLineEndingOrSpace(code4) ? factoryWhitespace(effects, beforeMarker)(code4) : nok(code4);
  }
  function beforeMarker(code4) {
    return factoryTitle(effects, titleAfter, nok, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(code4);
  }
  function titleAfter(code4) {
    return markdownSpace(code4) ? factorySpace(effects, titleAfterOptionalWhitespace, "whitespace")(code4) : titleAfterOptionalWhitespace(code4);
  }
  function titleAfterOptionalWhitespace(code4) {
    return code4 === null || markdownLineEnding(code4) ? ok3(code4) : nok(code4);
  }
}

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/node_modules/micromark-core-commonmark/lib/hard-break-escape.js
init_process();
init_buffer();
var hardBreakEscape = {
  name: "hardBreakEscape",
  tokenize: tokenizeHardBreakEscape
};
function tokenizeHardBreakEscape(effects, ok3, nok) {
  return start;
  function start(code4) {
    effects.enter("hardBreakEscape");
    effects.consume(code4);
    return after;
  }
  function after(code4) {
    if (markdownLineEnding(code4)) {
      effects.exit("hardBreakEscape");
      return ok3(code4);
    }
    return nok(code4);
  }
}

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/node_modules/micromark-core-commonmark/lib/heading-atx.js
init_process();
init_buffer();
var headingAtx = {
  name: "headingAtx",
  tokenize: tokenizeHeadingAtx,
  resolve: resolveHeadingAtx
};
function resolveHeadingAtx(events, context) {
  let contentEnd = events.length - 2;
  let contentStart = 3;
  let content3;
  let text8;
  if (events[contentStart][1].type === "whitespace") {
    contentStart += 2;
  }
  if (contentEnd - 2 > contentStart && events[contentEnd][1].type === "whitespace") {
    contentEnd -= 2;
  }
  if (events[contentEnd][1].type === "atxHeadingSequence" && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === "whitespace")) {
    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
  }
  if (contentEnd > contentStart) {
    content3 = {
      type: "atxHeadingText",
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end
    };
    text8 = {
      type: "chunkText",
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end,
      contentType: "text"
    };
    splice3(events, contentStart, contentEnd - contentStart + 1, [["enter", content3, context], ["enter", text8, context], ["exit", text8, context], ["exit", content3, context]]);
  }
  return events;
}
function tokenizeHeadingAtx(effects, ok3, nok) {
  let size = 0;
  return start;
  function start(code4) {
    effects.enter("atxHeading");
    return before(code4);
  }
  function before(code4) {
    effects.enter("atxHeadingSequence");
    return sequenceOpen(code4);
  }
  function sequenceOpen(code4) {
    if (code4 === 35 && size++ < 6) {
      effects.consume(code4);
      return sequenceOpen;
    }
    if (code4 === null || markdownLineEndingOrSpace(code4)) {
      effects.exit("atxHeadingSequence");
      return atBreak(code4);
    }
    return nok(code4);
  }
  function atBreak(code4) {
    if (code4 === 35) {
      effects.enter("atxHeadingSequence");
      return sequenceFurther(code4);
    }
    if (code4 === null || markdownLineEnding(code4)) {
      effects.exit("atxHeading");
      return ok3(code4);
    }
    if (markdownSpace(code4)) {
      return factorySpace(effects, atBreak, "whitespace")(code4);
    }
    effects.enter("atxHeadingText");
    return data(code4);
  }
  function sequenceFurther(code4) {
    if (code4 === 35) {
      effects.consume(code4);
      return sequenceFurther;
    }
    effects.exit("atxHeadingSequence");
    return atBreak(code4);
  }
  function data(code4) {
    if (code4 === null || code4 === 35 || markdownLineEndingOrSpace(code4)) {
      effects.exit("atxHeadingText");
      return atBreak(code4);
    }
    effects.consume(code4);
    return data;
  }
}

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/node_modules/micromark-core-commonmark/lib/html-flow.js
init_process();
init_buffer();

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/node_modules/micromark-core-commonmark/node_modules/micromark-util-html-tag-name/index.js
init_process();
init_buffer();
var htmlBlockNames = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
var htmlRawNames = ["pre", "script", "style", "textarea"];

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/node_modules/micromark-core-commonmark/lib/html-flow.js
var htmlFlow = {
  name: "htmlFlow",
  tokenize: tokenizeHtmlFlow,
  resolveTo: resolveToHtmlFlow,
  concrete: true
};
var blankLineBefore = {
  tokenize: tokenizeBlankLineBefore,
  partial: true
};
var nonLazyContinuationStart = {
  tokenize: tokenizeNonLazyContinuationStart,
  partial: true
};
function resolveToHtmlFlow(events) {
  let index3 = events.length;
  while (index3--) {
    if (events[index3][0] === "enter" && events[index3][1].type === "htmlFlow") {
      break;
    }
  }
  if (index3 > 1 && events[index3 - 2][1].type === "linePrefix") {
    events[index3][1].start = events[index3 - 2][1].start;
    events[index3 + 1][1].start = events[index3 - 2][1].start;
    events.splice(index3 - 2, 2);
  }
  return events;
}
function tokenizeHtmlFlow(effects, ok3, nok) {
  const self2 = this;
  let marker;
  let closingTag;
  let buffer;
  let index3;
  let markerB;
  return start;
  function start(code4) {
    return before(code4);
  }
  function before(code4) {
    effects.enter("htmlFlow");
    effects.enter("htmlFlowData");
    effects.consume(code4);
    return open;
  }
  function open(code4) {
    if (code4 === 33) {
      effects.consume(code4);
      return declarationOpen;
    }
    if (code4 === 47) {
      effects.consume(code4);
      closingTag = true;
      return tagCloseStart;
    }
    if (code4 === 63) {
      effects.consume(code4);
      marker = 3;
      return self2.interrupt ? ok3 : continuationDeclarationInside;
    }
    if (asciiAlpha(code4)) {
      effects.consume(code4);
      buffer = String.fromCharCode(code4);
      return tagName;
    }
    return nok(code4);
  }
  function declarationOpen(code4) {
    if (code4 === 45) {
      effects.consume(code4);
      marker = 2;
      return commentOpenInside;
    }
    if (code4 === 91) {
      effects.consume(code4);
      marker = 5;
      index3 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code4)) {
      effects.consume(code4);
      marker = 4;
      return self2.interrupt ? ok3 : continuationDeclarationInside;
    }
    return nok(code4);
  }
  function commentOpenInside(code4) {
    if (code4 === 45) {
      effects.consume(code4);
      return self2.interrupt ? ok3 : continuationDeclarationInside;
    }
    return nok(code4);
  }
  function cdataOpenInside(code4) {
    const value = "CDATA[";
    if (code4 === value.charCodeAt(index3++)) {
      effects.consume(code4);
      if (index3 === value.length) {
        return self2.interrupt ? ok3 : continuation;
      }
      return cdataOpenInside;
    }
    return nok(code4);
  }
  function tagCloseStart(code4) {
    if (asciiAlpha(code4)) {
      effects.consume(code4);
      buffer = String.fromCharCode(code4);
      return tagName;
    }
    return nok(code4);
  }
  function tagName(code4) {
    if (code4 === null || code4 === 47 || code4 === 62 || markdownLineEndingOrSpace(code4)) {
      const slash = code4 === 47;
      const name = buffer.toLowerCase();
      if (!slash && !closingTag && htmlRawNames.includes(name)) {
        marker = 1;
        return self2.interrupt ? ok3(code4) : continuation(code4);
      }
      if (htmlBlockNames.includes(buffer.toLowerCase())) {
        marker = 6;
        if (slash) {
          effects.consume(code4);
          return basicSelfClosing;
        }
        return self2.interrupt ? ok3(code4) : continuation(code4);
      }
      marker = 7;
      return self2.interrupt && !self2.parser.lazy[self2.now().line] ? nok(code4) : closingTag ? completeClosingTagAfter(code4) : completeAttributeNameBefore(code4);
    }
    if (code4 === 45 || asciiAlphanumeric(code4)) {
      effects.consume(code4);
      buffer += String.fromCharCode(code4);
      return tagName;
    }
    return nok(code4);
  }
  function basicSelfClosing(code4) {
    if (code4 === 62) {
      effects.consume(code4);
      return self2.interrupt ? ok3 : continuation;
    }
    return nok(code4);
  }
  function completeClosingTagAfter(code4) {
    if (markdownSpace(code4)) {
      effects.consume(code4);
      return completeClosingTagAfter;
    }
    return completeEnd(code4);
  }
  function completeAttributeNameBefore(code4) {
    if (code4 === 47) {
      effects.consume(code4);
      return completeEnd;
    }
    if (code4 === 58 || code4 === 95 || asciiAlpha(code4)) {
      effects.consume(code4);
      return completeAttributeName;
    }
    if (markdownSpace(code4)) {
      effects.consume(code4);
      return completeAttributeNameBefore;
    }
    return completeEnd(code4);
  }
  function completeAttributeName(code4) {
    if (code4 === 45 || code4 === 46 || code4 === 58 || code4 === 95 || asciiAlphanumeric(code4)) {
      effects.consume(code4);
      return completeAttributeName;
    }
    return completeAttributeNameAfter(code4);
  }
  function completeAttributeNameAfter(code4) {
    if (code4 === 61) {
      effects.consume(code4);
      return completeAttributeValueBefore;
    }
    if (markdownSpace(code4)) {
      effects.consume(code4);
      return completeAttributeNameAfter;
    }
    return completeAttributeNameBefore(code4);
  }
  function completeAttributeValueBefore(code4) {
    if (code4 === null || code4 === 60 || code4 === 61 || code4 === 62 || code4 === 96) {
      return nok(code4);
    }
    if (code4 === 34 || code4 === 39) {
      effects.consume(code4);
      markerB = code4;
      return completeAttributeValueQuoted;
    }
    if (markdownSpace(code4)) {
      effects.consume(code4);
      return completeAttributeValueBefore;
    }
    return completeAttributeValueUnquoted(code4);
  }
  function completeAttributeValueQuoted(code4) {
    if (code4 === markerB) {
      effects.consume(code4);
      markerB = null;
      return completeAttributeValueQuotedAfter;
    }
    if (code4 === null || markdownLineEnding(code4)) {
      return nok(code4);
    }
    effects.consume(code4);
    return completeAttributeValueQuoted;
  }
  function completeAttributeValueUnquoted(code4) {
    if (code4 === null || code4 === 34 || code4 === 39 || code4 === 47 || code4 === 60 || code4 === 61 || code4 === 62 || code4 === 96 || markdownLineEndingOrSpace(code4)) {
      return completeAttributeNameAfter(code4);
    }
    effects.consume(code4);
    return completeAttributeValueUnquoted;
  }
  function completeAttributeValueQuotedAfter(code4) {
    if (code4 === 47 || code4 === 62 || markdownSpace(code4)) {
      return completeAttributeNameBefore(code4);
    }
    return nok(code4);
  }
  function completeEnd(code4) {
    if (code4 === 62) {
      effects.consume(code4);
      return completeAfter;
    }
    return nok(code4);
  }
  function completeAfter(code4) {
    if (code4 === null || markdownLineEnding(code4)) {
      return continuation(code4);
    }
    if (markdownSpace(code4)) {
      effects.consume(code4);
      return completeAfter;
    }
    return nok(code4);
  }
  function continuation(code4) {
    if (code4 === 45 && marker === 2) {
      effects.consume(code4);
      return continuationCommentInside;
    }
    if (code4 === 60 && marker === 1) {
      effects.consume(code4);
      return continuationRawTagOpen;
    }
    if (code4 === 62 && marker === 4) {
      effects.consume(code4);
      return continuationClose;
    }
    if (code4 === 63 && marker === 3) {
      effects.consume(code4);
      return continuationDeclarationInside;
    }
    if (code4 === 93 && marker === 5) {
      effects.consume(code4);
      return continuationCdataInside;
    }
    if (markdownLineEnding(code4) && (marker === 6 || marker === 7)) {
      effects.exit("htmlFlowData");
      return effects.check(blankLineBefore, continuationAfter, continuationStart)(code4);
    }
    if (code4 === null || markdownLineEnding(code4)) {
      effects.exit("htmlFlowData");
      return continuationStart(code4);
    }
    effects.consume(code4);
    return continuation;
  }
  function continuationStart(code4) {
    return effects.check(nonLazyContinuationStart, continuationStartNonLazy, continuationAfter)(code4);
  }
  function continuationStartNonLazy(code4) {
    effects.enter("lineEnding");
    effects.consume(code4);
    effects.exit("lineEnding");
    return continuationBefore;
  }
  function continuationBefore(code4) {
    if (code4 === null || markdownLineEnding(code4)) {
      return continuationStart(code4);
    }
    effects.enter("htmlFlowData");
    return continuation(code4);
  }
  function continuationCommentInside(code4) {
    if (code4 === 45) {
      effects.consume(code4);
      return continuationDeclarationInside;
    }
    return continuation(code4);
  }
  function continuationRawTagOpen(code4) {
    if (code4 === 47) {
      effects.consume(code4);
      buffer = "";
      return continuationRawEndTag;
    }
    return continuation(code4);
  }
  function continuationRawEndTag(code4) {
    if (code4 === 62) {
      const name = buffer.toLowerCase();
      if (htmlRawNames.includes(name)) {
        effects.consume(code4);
        return continuationClose;
      }
      return continuation(code4);
    }
    if (asciiAlpha(code4) && buffer.length < 8) {
      effects.consume(code4);
      buffer += String.fromCharCode(code4);
      return continuationRawEndTag;
    }
    return continuation(code4);
  }
  function continuationCdataInside(code4) {
    if (code4 === 93) {
      effects.consume(code4);
      return continuationDeclarationInside;
    }
    return continuation(code4);
  }
  function continuationDeclarationInside(code4) {
    if (code4 === 62) {
      effects.consume(code4);
      return continuationClose;
    }
    if (code4 === 45 && marker === 2) {
      effects.consume(code4);
      return continuationDeclarationInside;
    }
    return continuation(code4);
  }
  function continuationClose(code4) {
    if (code4 === null || markdownLineEnding(code4)) {
      effects.exit("htmlFlowData");
      return continuationAfter(code4);
    }
    effects.consume(code4);
    return continuationClose;
  }
  function continuationAfter(code4) {
    effects.exit("htmlFlow");
    return ok3(code4);
  }
}
function tokenizeNonLazyContinuationStart(effects, ok3, nok) {
  const self2 = this;
  return start;
  function start(code4) {
    if (markdownLineEnding(code4)) {
      effects.enter("lineEnding");
      effects.consume(code4);
      effects.exit("lineEnding");
      return after;
    }
    return nok(code4);
  }
  function after(code4) {
    return self2.parser.lazy[self2.now().line] ? nok(code4) : ok3(code4);
  }
}
function tokenizeBlankLineBefore(effects, ok3, nok) {
  return start;
  function start(code4) {
    effects.enter("lineEnding");
    effects.consume(code4);
    effects.exit("lineEnding");
    return effects.attempt(blankLine2, ok3, nok);
  }
}

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/node_modules/micromark-core-commonmark/lib/html-text.js
init_process();
init_buffer();
var htmlText = {
  name: "htmlText",
  tokenize: tokenizeHtmlText
};
function tokenizeHtmlText(effects, ok3, nok) {
  const self2 = this;
  let marker;
  let index3;
  let returnState;
  return start;
  function start(code4) {
    effects.enter("htmlText");
    effects.enter("htmlTextData");
    effects.consume(code4);
    return open;
  }
  function open(code4) {
    if (code4 === 33) {
      effects.consume(code4);
      return declarationOpen;
    }
    if (code4 === 47) {
      effects.consume(code4);
      return tagCloseStart;
    }
    if (code4 === 63) {
      effects.consume(code4);
      return instruction;
    }
    if (asciiAlpha(code4)) {
      effects.consume(code4);
      return tagOpen;
    }
    return nok(code4);
  }
  function declarationOpen(code4) {
    if (code4 === 45) {
      effects.consume(code4);
      return commentOpenInside;
    }
    if (code4 === 91) {
      effects.consume(code4);
      index3 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code4)) {
      effects.consume(code4);
      return declaration;
    }
    return nok(code4);
  }
  function commentOpenInside(code4) {
    if (code4 === 45) {
      effects.consume(code4);
      return commentEnd;
    }
    return nok(code4);
  }
  function comment2(code4) {
    if (code4 === null) {
      return nok(code4);
    }
    if (code4 === 45) {
      effects.consume(code4);
      return commentClose;
    }
    if (markdownLineEnding(code4)) {
      returnState = comment2;
      return lineEndingBefore(code4);
    }
    effects.consume(code4);
    return comment2;
  }
  function commentClose(code4) {
    if (code4 === 45) {
      effects.consume(code4);
      return commentEnd;
    }
    return comment2(code4);
  }
  function commentEnd(code4) {
    return code4 === 62 ? end(code4) : code4 === 45 ? commentClose(code4) : comment2(code4);
  }
  function cdataOpenInside(code4) {
    const value = "CDATA[";
    if (code4 === value.charCodeAt(index3++)) {
      effects.consume(code4);
      return index3 === value.length ? cdata : cdataOpenInside;
    }
    return nok(code4);
  }
  function cdata(code4) {
    if (code4 === null) {
      return nok(code4);
    }
    if (code4 === 93) {
      effects.consume(code4);
      return cdataClose;
    }
    if (markdownLineEnding(code4)) {
      returnState = cdata;
      return lineEndingBefore(code4);
    }
    effects.consume(code4);
    return cdata;
  }
  function cdataClose(code4) {
    if (code4 === 93) {
      effects.consume(code4);
      return cdataEnd;
    }
    return cdata(code4);
  }
  function cdataEnd(code4) {
    if (code4 === 62) {
      return end(code4);
    }
    if (code4 === 93) {
      effects.consume(code4);
      return cdataEnd;
    }
    return cdata(code4);
  }
  function declaration(code4) {
    if (code4 === null || code4 === 62) {
      return end(code4);
    }
    if (markdownLineEnding(code4)) {
      returnState = declaration;
      return lineEndingBefore(code4);
    }
    effects.consume(code4);
    return declaration;
  }
  function instruction(code4) {
    if (code4 === null) {
      return nok(code4);
    }
    if (code4 === 63) {
      effects.consume(code4);
      return instructionClose;
    }
    if (markdownLineEnding(code4)) {
      returnState = instruction;
      return lineEndingBefore(code4);
    }
    effects.consume(code4);
    return instruction;
  }
  function instructionClose(code4) {
    return code4 === 62 ? end(code4) : instruction(code4);
  }
  function tagCloseStart(code4) {
    if (asciiAlpha(code4)) {
      effects.consume(code4);
      return tagClose;
    }
    return nok(code4);
  }
  function tagClose(code4) {
    if (code4 === 45 || asciiAlphanumeric(code4)) {
      effects.consume(code4);
      return tagClose;
    }
    return tagCloseBetween(code4);
  }
  function tagCloseBetween(code4) {
    if (markdownLineEnding(code4)) {
      returnState = tagCloseBetween;
      return lineEndingBefore(code4);
    }
    if (markdownSpace(code4)) {
      effects.consume(code4);
      return tagCloseBetween;
    }
    return end(code4);
  }
  function tagOpen(code4) {
    if (code4 === 45 || asciiAlphanumeric(code4)) {
      effects.consume(code4);
      return tagOpen;
    }
    if (code4 === 47 || code4 === 62 || markdownLineEndingOrSpace(code4)) {
      return tagOpenBetween(code4);
    }
    return nok(code4);
  }
  function tagOpenBetween(code4) {
    if (code4 === 47) {
      effects.consume(code4);
      return end;
    }
    if (code4 === 58 || code4 === 95 || asciiAlpha(code4)) {
      effects.consume(code4);
      return tagOpenAttributeName;
    }
    if (markdownLineEnding(code4)) {
      returnState = tagOpenBetween;
      return lineEndingBefore(code4);
    }
    if (markdownSpace(code4)) {
      effects.consume(code4);
      return tagOpenBetween;
    }
    return end(code4);
  }
  function tagOpenAttributeName(code4) {
    if (code4 === 45 || code4 === 46 || code4 === 58 || code4 === 95 || asciiAlphanumeric(code4)) {
      effects.consume(code4);
      return tagOpenAttributeName;
    }
    return tagOpenAttributeNameAfter(code4);
  }
  function tagOpenAttributeNameAfter(code4) {
    if (code4 === 61) {
      effects.consume(code4);
      return tagOpenAttributeValueBefore;
    }
    if (markdownLineEnding(code4)) {
      returnState = tagOpenAttributeNameAfter;
      return lineEndingBefore(code4);
    }
    if (markdownSpace(code4)) {
      effects.consume(code4);
      return tagOpenAttributeNameAfter;
    }
    return tagOpenBetween(code4);
  }
  function tagOpenAttributeValueBefore(code4) {
    if (code4 === null || code4 === 60 || code4 === 61 || code4 === 62 || code4 === 96) {
      return nok(code4);
    }
    if (code4 === 34 || code4 === 39) {
      effects.consume(code4);
      marker = code4;
      return tagOpenAttributeValueQuoted;
    }
    if (markdownLineEnding(code4)) {
      returnState = tagOpenAttributeValueBefore;
      return lineEndingBefore(code4);
    }
    if (markdownSpace(code4)) {
      effects.consume(code4);
      return tagOpenAttributeValueBefore;
    }
    effects.consume(code4);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuoted(code4) {
    if (code4 === marker) {
      effects.consume(code4);
      marker = void 0;
      return tagOpenAttributeValueQuotedAfter;
    }
    if (code4 === null) {
      return nok(code4);
    }
    if (markdownLineEnding(code4)) {
      returnState = tagOpenAttributeValueQuoted;
      return lineEndingBefore(code4);
    }
    effects.consume(code4);
    return tagOpenAttributeValueQuoted;
  }
  function tagOpenAttributeValueUnquoted(code4) {
    if (code4 === null || code4 === 34 || code4 === 39 || code4 === 60 || code4 === 61 || code4 === 96) {
      return nok(code4);
    }
    if (code4 === 47 || code4 === 62 || markdownLineEndingOrSpace(code4)) {
      return tagOpenBetween(code4);
    }
    effects.consume(code4);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuotedAfter(code4) {
    if (code4 === 47 || code4 === 62 || markdownLineEndingOrSpace(code4)) {
      return tagOpenBetween(code4);
    }
    return nok(code4);
  }
  function end(code4) {
    if (code4 === 62) {
      effects.consume(code4);
      effects.exit("htmlTextData");
      effects.exit("htmlText");
      return ok3;
    }
    return nok(code4);
  }
  function lineEndingBefore(code4) {
    effects.exit("htmlTextData");
    effects.enter("lineEnding");
    effects.consume(code4);
    effects.exit("lineEnding");
    return lineEndingAfter;
  }
  function lineEndingAfter(code4) {
    return markdownSpace(code4) ? factorySpace(effects, lineEndingAfterPrefix, "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code4) : lineEndingAfterPrefix(code4);
  }
  function lineEndingAfterPrefix(code4) {
    effects.enter("htmlTextData");
    return returnState(code4);
  }
}

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/node_modules/micromark-core-commonmark/lib/label-end.js
init_process();
init_buffer();
var labelEnd = {
  name: "labelEnd",
  tokenize: tokenizeLabelEnd,
  resolveTo: resolveToLabelEnd,
  resolveAll: resolveAllLabelEnd
};
var resourceConstruct = {
  tokenize: tokenizeResource
};
var referenceFullConstruct = {
  tokenize: tokenizeReferenceFull
};
var referenceCollapsedConstruct = {
  tokenize: tokenizeReferenceCollapsed
};
function resolveAllLabelEnd(events) {
  let index3 = -1;
  while (++index3 < events.length) {
    const token = events[index3][1];
    if (token.type === "labelImage" || token.type === "labelLink" || token.type === "labelEnd") {
      events.splice(index3 + 1, token.type === "labelImage" ? 4 : 2);
      token.type = "data";
      index3++;
    }
  }
  return events;
}
function resolveToLabelEnd(events, context) {
  let index3 = events.length;
  let offset = 0;
  let token;
  let open;
  let close;
  let media;
  while (index3--) {
    token = events[index3][1];
    if (open) {
      if (token.type === "link" || token.type === "labelLink" && token._inactive) {
        break;
      }
      if (events[index3][0] === "enter" && token.type === "labelLink") {
        token._inactive = true;
      }
    } else if (close) {
      if (events[index3][0] === "enter" && (token.type === "labelImage" || token.type === "labelLink") && !token._balanced) {
        open = index3;
        if (token.type !== "labelLink") {
          offset = 2;
          break;
        }
      }
    } else if (token.type === "labelEnd") {
      close = index3;
    }
  }
  const group = {
    type: events[open][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  const label = {
    type: "label",
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[close][1].end)
  };
  const text8 = {
    type: "labelText",
    start: Object.assign({}, events[open + offset + 2][1].end),
    end: Object.assign({}, events[close - 2][1].start)
  };
  media = [["enter", group, context], ["enter", label, context]];
  media = push(media, events.slice(open + 1, open + offset + 3));
  media = push(media, [["enter", text8, context]]);
  media = push(media, resolveAll2(context.parser.constructs.insideSpan.null, events.slice(open + offset + 4, close - 3), context));
  media = push(media, [["exit", text8, context], events[close - 2], events[close - 1], ["exit", label, context]]);
  media = push(media, events.slice(close + 1));
  media = push(media, [["exit", group, context]]);
  splice3(events, open, events.length, media);
  return events;
}
function tokenizeLabelEnd(effects, ok3, nok) {
  const self2 = this;
  let index3 = self2.events.length;
  let labelStart;
  let defined;
  while (index3--) {
    if ((self2.events[index3][1].type === "labelImage" || self2.events[index3][1].type === "labelLink") && !self2.events[index3][1]._balanced) {
      labelStart = self2.events[index3][1];
      break;
    }
  }
  return start;
  function start(code4) {
    if (!labelStart) {
      return nok(code4);
    }
    if (labelStart._inactive) {
      return labelEndNok(code4);
    }
    defined = self2.parser.defined.includes(normalizeIdentifier3(self2.sliceSerialize({
      start: labelStart.end,
      end: self2.now()
    })));
    effects.enter("labelEnd");
    effects.enter("labelMarker");
    effects.consume(code4);
    effects.exit("labelMarker");
    effects.exit("labelEnd");
    return after;
  }
  function after(code4) {
    if (code4 === 40) {
      return effects.attempt(resourceConstruct, labelEndOk, defined ? labelEndOk : labelEndNok)(code4);
    }
    if (code4 === 91) {
      return effects.attempt(referenceFullConstruct, labelEndOk, defined ? referenceNotFull : labelEndNok)(code4);
    }
    return defined ? labelEndOk(code4) : labelEndNok(code4);
  }
  function referenceNotFull(code4) {
    return effects.attempt(referenceCollapsedConstruct, labelEndOk, labelEndNok)(code4);
  }
  function labelEndOk(code4) {
    return ok3(code4);
  }
  function labelEndNok(code4) {
    labelStart._balanced = true;
    return nok(code4);
  }
}
function tokenizeResource(effects, ok3, nok) {
  return resourceStart;
  function resourceStart(code4) {
    effects.enter("resource");
    effects.enter("resourceMarker");
    effects.consume(code4);
    effects.exit("resourceMarker");
    return resourceBefore;
  }
  function resourceBefore(code4) {
    return markdownLineEndingOrSpace(code4) ? factoryWhitespace(effects, resourceOpen)(code4) : resourceOpen(code4);
  }
  function resourceOpen(code4) {
    if (code4 === 41) {
      return resourceEnd(code4);
    }
    return factoryDestination(effects, resourceDestinationAfter, resourceDestinationMissing, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(code4);
  }
  function resourceDestinationAfter(code4) {
    return markdownLineEndingOrSpace(code4) ? factoryWhitespace(effects, resourceBetween)(code4) : resourceEnd(code4);
  }
  function resourceDestinationMissing(code4) {
    return nok(code4);
  }
  function resourceBetween(code4) {
    if (code4 === 34 || code4 === 39 || code4 === 40) {
      return factoryTitle(effects, resourceTitleAfter, nok, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(code4);
    }
    return resourceEnd(code4);
  }
  function resourceTitleAfter(code4) {
    return markdownLineEndingOrSpace(code4) ? factoryWhitespace(effects, resourceEnd)(code4) : resourceEnd(code4);
  }
  function resourceEnd(code4) {
    if (code4 === 41) {
      effects.enter("resourceMarker");
      effects.consume(code4);
      effects.exit("resourceMarker");
      effects.exit("resource");
      return ok3;
    }
    return nok(code4);
  }
}
function tokenizeReferenceFull(effects, ok3, nok) {
  const self2 = this;
  return referenceFull;
  function referenceFull(code4) {
    return factoryLabel.call(self2, effects, referenceFullAfter, referenceFullMissing, "reference", "referenceMarker", "referenceString")(code4);
  }
  function referenceFullAfter(code4) {
    return self2.parser.defined.includes(normalizeIdentifier3(self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1))) ? ok3(code4) : nok(code4);
  }
  function referenceFullMissing(code4) {
    return nok(code4);
  }
}
function tokenizeReferenceCollapsed(effects, ok3, nok) {
  return referenceCollapsedStart;
  function referenceCollapsedStart(code4) {
    effects.enter("reference");
    effects.enter("referenceMarker");
    effects.consume(code4);
    effects.exit("referenceMarker");
    return referenceCollapsedOpen;
  }
  function referenceCollapsedOpen(code4) {
    if (code4 === 93) {
      effects.enter("referenceMarker");
      effects.consume(code4);
      effects.exit("referenceMarker");
      effects.exit("reference");
      return ok3;
    }
    return nok(code4);
  }
}

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/node_modules/micromark-core-commonmark/lib/label-start-image.js
init_process();
init_buffer();
var labelStartImage = {
  name: "labelStartImage",
  tokenize: tokenizeLabelStartImage,
  resolveAll: labelEnd.resolveAll
};
function tokenizeLabelStartImage(effects, ok3, nok) {
  const self2 = this;
  return start;
  function start(code4) {
    effects.enter("labelImage");
    effects.enter("labelImageMarker");
    effects.consume(code4);
    effects.exit("labelImageMarker");
    return open;
  }
  function open(code4) {
    if (code4 === 91) {
      effects.enter("labelMarker");
      effects.consume(code4);
      effects.exit("labelMarker");
      effects.exit("labelImage");
      return after;
    }
    return nok(code4);
  }
  function after(code4) {
    return code4 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code4) : ok3(code4);
  }
}

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/node_modules/micromark-core-commonmark/lib/label-start-link.js
init_process();
init_buffer();
var labelStartLink = {
  name: "labelStartLink",
  tokenize: tokenizeLabelStartLink,
  resolveAll: labelEnd.resolveAll
};
function tokenizeLabelStartLink(effects, ok3, nok) {
  const self2 = this;
  return start;
  function start(code4) {
    effects.enter("labelLink");
    effects.enter("labelMarker");
    effects.consume(code4);
    effects.exit("labelMarker");
    effects.exit("labelLink");
    return after;
  }
  function after(code4) {
    return code4 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code4) : ok3(code4);
  }
}

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/node_modules/micromark-core-commonmark/lib/line-ending.js
init_process();
init_buffer();
var lineEnding = {
  name: "lineEnding",
  tokenize: tokenizeLineEnding
};
function tokenizeLineEnding(effects, ok3) {
  return start;
  function start(code4) {
    effects.enter("lineEnding");
    effects.consume(code4);
    effects.exit("lineEnding");
    return factorySpace(effects, ok3, "linePrefix");
  }
}

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/node_modules/micromark-core-commonmark/lib/list.js
init_process();
init_buffer();

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/node_modules/micromark-core-commonmark/lib/thematic-break.js
init_process();
init_buffer();
var thematicBreak2 = {
  name: "thematicBreak",
  tokenize: tokenizeThematicBreak
};
function tokenizeThematicBreak(effects, ok3, nok) {
  let size = 0;
  let marker;
  return start;
  function start(code4) {
    effects.enter("thematicBreak");
    return before(code4);
  }
  function before(code4) {
    marker = code4;
    return atBreak(code4);
  }
  function atBreak(code4) {
    if (code4 === marker) {
      effects.enter("thematicBreakSequence");
      return sequence(code4);
    }
    if (size >= 3 && (code4 === null || markdownLineEnding(code4))) {
      effects.exit("thematicBreak");
      return ok3(code4);
    }
    return nok(code4);
  }
  function sequence(code4) {
    if (code4 === marker) {
      effects.consume(code4);
      size++;
      return sequence;
    }
    effects.exit("thematicBreakSequence");
    return markdownSpace(code4) ? factorySpace(effects, atBreak, "whitespace")(code4) : atBreak(code4);
  }
}

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/node_modules/micromark-core-commonmark/lib/list.js
var list2 = {
  name: "list",
  tokenize: tokenizeListStart,
  continuation: {
    tokenize: tokenizeListContinuation
  },
  exit: tokenizeListEnd
};
var listItemPrefixWhitespaceConstruct = {
  tokenize: tokenizeListItemPrefixWhitespace,
  partial: true
};
var indentConstruct = {
  tokenize: tokenizeIndent2,
  partial: true
};
function tokenizeListStart(effects, ok3, nok) {
  const self2 = this;
  const tail = self2.events[self2.events.length - 1];
  let initialSize = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
  let size = 0;
  return start;
  function start(code4) {
    const kind = self2.containerState.type || (code4 === 42 || code4 === 43 || code4 === 45 ? "listUnordered" : "listOrdered");
    if (kind === "listUnordered" ? !self2.containerState.marker || code4 === self2.containerState.marker : asciiDigit(code4)) {
      if (!self2.containerState.type) {
        self2.containerState.type = kind;
        effects.enter(kind, {
          _container: true
        });
      }
      if (kind === "listUnordered") {
        effects.enter("listItemPrefix");
        return code4 === 42 || code4 === 45 ? effects.check(thematicBreak2, nok, atMarker)(code4) : atMarker(code4);
      }
      if (!self2.interrupt || code4 === 49) {
        effects.enter("listItemPrefix");
        effects.enter("listItemValue");
        return inside(code4);
      }
    }
    return nok(code4);
  }
  function inside(code4) {
    if (asciiDigit(code4) && ++size < 10) {
      effects.consume(code4);
      return inside;
    }
    if ((!self2.interrupt || size < 2) && (self2.containerState.marker ? code4 === self2.containerState.marker : code4 === 41 || code4 === 46)) {
      effects.exit("listItemValue");
      return atMarker(code4);
    }
    return nok(code4);
  }
  function atMarker(code4) {
    effects.enter("listItemMarker");
    effects.consume(code4);
    effects.exit("listItemMarker");
    self2.containerState.marker = self2.containerState.marker || code4;
    return effects.check(
      blankLine2,
      // Can’t be empty when interrupting.
      self2.interrupt ? nok : onBlank,
      effects.attempt(listItemPrefixWhitespaceConstruct, endOfPrefix, otherPrefix)
    );
  }
  function onBlank(code4) {
    self2.containerState.initialBlankLine = true;
    initialSize++;
    return endOfPrefix(code4);
  }
  function otherPrefix(code4) {
    if (markdownSpace(code4)) {
      effects.enter("listItemPrefixWhitespace");
      effects.consume(code4);
      effects.exit("listItemPrefixWhitespace");
      return endOfPrefix;
    }
    return nok(code4);
  }
  function endOfPrefix(code4) {
    self2.containerState.size = initialSize + self2.sliceSerialize(effects.exit("listItemPrefix"), true).length;
    return ok3(code4);
  }
}
function tokenizeListContinuation(effects, ok3, nok) {
  const self2 = this;
  self2.containerState._closeFlow = void 0;
  return effects.check(blankLine2, onBlank, notBlank);
  function onBlank(code4) {
    self2.containerState.furtherBlankLines = self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine;
    return factorySpace(effects, ok3, "listItemIndent", self2.containerState.size + 1)(code4);
  }
  function notBlank(code4) {
    if (self2.containerState.furtherBlankLines || !markdownSpace(code4)) {
      self2.containerState.furtherBlankLines = void 0;
      self2.containerState.initialBlankLine = void 0;
      return notInCurrentItem(code4);
    }
    self2.containerState.furtherBlankLines = void 0;
    self2.containerState.initialBlankLine = void 0;
    return effects.attempt(indentConstruct, ok3, notInCurrentItem)(code4);
  }
  function notInCurrentItem(code4) {
    self2.containerState._closeFlow = true;
    self2.interrupt = void 0;
    return factorySpace(effects, effects.attempt(list2, ok3, nok), "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code4);
  }
}
function tokenizeIndent2(effects, ok3, nok) {
  const self2 = this;
  return factorySpace(effects, afterPrefix, "listItemIndent", self2.containerState.size + 1);
  function afterPrefix(code4) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "listItemIndent" && tail[2].sliceSerialize(tail[1], true).length === self2.containerState.size ? ok3(code4) : nok(code4);
  }
}
function tokenizeListEnd(effects) {
  effects.exit(this.containerState.type);
}
function tokenizeListItemPrefixWhitespace(effects, ok3, nok) {
  const self2 = this;
  return factorySpace(effects, afterPrefix, "listItemPrefixWhitespace", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4 + 1);
  function afterPrefix(code4) {
    const tail = self2.events[self2.events.length - 1];
    return !markdownSpace(code4) && tail && tail[1].type === "listItemPrefixWhitespace" ? ok3(code4) : nok(code4);
  }
}

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/node_modules/micromark-core-commonmark/lib/setext-underline.js
init_process();
init_buffer();
var setextUnderline = {
  name: "setextUnderline",
  tokenize: tokenizeSetextUnderline,
  resolveTo: resolveToSetextUnderline
};
function resolveToSetextUnderline(events, context) {
  let index3 = events.length;
  let content3;
  let text8;
  let definition3;
  while (index3--) {
    if (events[index3][0] === "enter") {
      if (events[index3][1].type === "content") {
        content3 = index3;
        break;
      }
      if (events[index3][1].type === "paragraph") {
        text8 = index3;
      }
    } else {
      if (events[index3][1].type === "content") {
        events.splice(index3, 1);
      }
      if (!definition3 && events[index3][1].type === "definition") {
        definition3 = index3;
      }
    }
  }
  const heading3 = {
    type: "setextHeading",
    start: Object.assign({}, events[text8][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  events[text8][1].type = "setextHeadingText";
  if (definition3) {
    events.splice(text8, 0, ["enter", heading3, context]);
    events.splice(definition3 + 1, 0, ["exit", events[content3][1], context]);
    events[content3][1].end = Object.assign({}, events[definition3][1].end);
  } else {
    events[content3][1] = heading3;
  }
  events.push(["exit", heading3, context]);
  return events;
}
function tokenizeSetextUnderline(effects, ok3, nok) {
  const self2 = this;
  let marker;
  return start;
  function start(code4) {
    let index3 = self2.events.length;
    let paragraph3;
    while (index3--) {
      if (self2.events[index3][1].type !== "lineEnding" && self2.events[index3][1].type !== "linePrefix" && self2.events[index3][1].type !== "content") {
        paragraph3 = self2.events[index3][1].type === "paragraph";
        break;
      }
    }
    if (!self2.parser.lazy[self2.now().line] && (self2.interrupt || paragraph3)) {
      effects.enter("setextHeadingLine");
      marker = code4;
      return before(code4);
    }
    return nok(code4);
  }
  function before(code4) {
    effects.enter("setextHeadingLineSequence");
    return inside(code4);
  }
  function inside(code4) {
    if (code4 === marker) {
      effects.consume(code4);
      return inside;
    }
    effects.exit("setextHeadingLineSequence");
    return markdownSpace(code4) ? factorySpace(effects, after, "lineSuffix")(code4) : after(code4);
  }
  function after(code4) {
    if (code4 === null || markdownLineEnding(code4)) {
      effects.exit("setextHeadingLine");
      return ok3(code4);
    }
    return nok(code4);
  }
}

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/lib/initialize/flow.js
var flow2 = {
  tokenize: initializeFlow
};
function initializeFlow(effects) {
  const self2 = this;
  const initial = effects.attempt(
    // Try to parse a blank line.
    blankLine2,
    atBlankEnding,
    // Try to parse initial flow (essentially, only code).
    effects.attempt(
      this.parser.constructs.flowInitial,
      afterConstruct,
      factorySpace(
        effects,
        effects.attempt(
          this.parser.constructs.flow,
          afterConstruct,
          effects.attempt(content2, afterConstruct)
        ),
        "linePrefix"
      )
    )
  );
  return initial;
  function atBlankEnding(code4) {
    if (code4 === null) {
      effects.consume(code4);
      return;
    }
    effects.enter("lineEndingBlank");
    effects.consume(code4);
    effects.exit("lineEndingBlank");
    self2.currentConstruct = void 0;
    return initial;
  }
  function afterConstruct(code4) {
    if (code4 === null) {
      effects.consume(code4);
      return;
    }
    effects.enter("lineEnding");
    effects.consume(code4);
    effects.exit("lineEnding");
    self2.currentConstruct = void 0;
    return initial;
  }
}

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/lib/initialize/text.js
init_process();
init_buffer();
var resolver = {
  resolveAll: createResolver()
};
var string = initializeFactory("string");
var text5 = initializeFactory("text");
function initializeFactory(field) {
  return {
    tokenize: initializeText,
    resolveAll: createResolver(
      field === "text" ? resolveAllLineSuffixes : void 0
    )
  };
  function initializeText(effects) {
    const self2 = this;
    const constructs2 = this.parser.constructs[field];
    const text8 = effects.attempt(constructs2, start, notText);
    return start;
    function start(code4) {
      return atBreak(code4) ? text8(code4) : notText(code4);
    }
    function notText(code4) {
      if (code4 === null) {
        effects.consume(code4);
        return;
      }
      effects.enter("data");
      effects.consume(code4);
      return data;
    }
    function data(code4) {
      if (atBreak(code4)) {
        effects.exit("data");
        return text8(code4);
      }
      effects.consume(code4);
      return data;
    }
    function atBreak(code4) {
      if (code4 === null) {
        return true;
      }
      const list4 = constructs2[code4];
      let index3 = -1;
      if (list4) {
        while (++index3 < list4.length) {
          const item = list4[index3];
          if (!item.previous || item.previous.call(self2, self2.previous)) {
            return true;
          }
        }
      }
      return false;
    }
  }
}
function createResolver(extraResolver) {
  return resolveAllText;
  function resolveAllText(events, context) {
    let index3 = -1;
    let enter;
    while (++index3 <= events.length) {
      if (enter === void 0) {
        if (events[index3] && events[index3][1].type === "data") {
          enter = index3;
          index3++;
        }
      } else if (!events[index3] || events[index3][1].type !== "data") {
        if (index3 !== enter + 2) {
          events[enter][1].end = events[index3 - 1][1].end;
          events.splice(enter + 2, index3 - enter - 2);
          index3 = enter + 2;
        }
        enter = void 0;
      }
    }
    return extraResolver ? extraResolver(events, context) : events;
  }
}
function resolveAllLineSuffixes(events, context) {
  let eventIndex = 0;
  while (++eventIndex <= events.length) {
    if ((eventIndex === events.length || events[eventIndex][1].type === "lineEnding") && events[eventIndex - 1][1].type === "data") {
      const data = events[eventIndex - 1][1];
      const chunks = context.sliceStream(data);
      let index3 = chunks.length;
      let bufferIndex = -1;
      let size = 0;
      let tabs;
      while (index3--) {
        const chunk = chunks[index3];
        if (typeof chunk === "string") {
          bufferIndex = chunk.length;
          while (chunk.charCodeAt(bufferIndex - 1) === 32) {
            size++;
            bufferIndex--;
          }
          if (bufferIndex)
            break;
          bufferIndex = -1;
        } else if (chunk === -2) {
          tabs = true;
          size++;
        } else if (chunk === -1) {
        } else {
          index3++;
          break;
        }
      }
      if (size) {
        const token = {
          type: eventIndex === events.length || tabs || size < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: data.end.line,
            column: data.end.column - size,
            offset: data.end.offset - size,
            _index: data.start._index + index3,
            _bufferIndex: index3 ? bufferIndex : data.start._bufferIndex + bufferIndex
          },
          end: Object.assign({}, data.end)
        };
        data.end = Object.assign({}, token.start);
        if (data.start.offset === data.end.offset) {
          Object.assign(data, token);
        } else {
          events.splice(
            eventIndex,
            0,
            ["enter", token, context],
            ["exit", token, context]
          );
          eventIndex += 2;
        }
      }
      eventIndex++;
    }
  }
  return events;
}

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/lib/create-tokenizer.js
init_process();
init_buffer();
function createTokenizer(parser, initialize, from3) {
  let point5 = Object.assign(
    from3 ? Object.assign({}, from3) : {
      line: 1,
      column: 1,
      offset: 0
    },
    {
      _index: 0,
      _bufferIndex: -1
    }
  );
  const columnStart = {};
  const resolveAllConstructs = [];
  let chunks = [];
  let stack = [];
  let consumed = true;
  const effects = {
    consume,
    enter,
    exit: exit3,
    attempt: constructFactory(onsuccessfulconstruct),
    check: constructFactory(onsuccessfulcheck),
    interrupt: constructFactory(onsuccessfulcheck, {
      interrupt: true
    })
  };
  const context = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser,
    sliceStream,
    sliceSerialize,
    now,
    defineSkip,
    write: write4
  };
  let state = initialize.tokenize.call(context, effects);
  let expectedCode;
  if (initialize.resolveAll) {
    resolveAllConstructs.push(initialize);
  }
  return context;
  function write4(slice3) {
    chunks = push(chunks, slice3);
    main();
    if (chunks[chunks.length - 1] !== null) {
      return [];
    }
    addResult(initialize, 0);
    context.events = resolveAll2(resolveAllConstructs, context.events, context);
    return context.events;
  }
  function sliceSerialize(token, expandTabs) {
    return serializeChunks(sliceStream(token), expandTabs);
  }
  function sliceStream(token) {
    return sliceChunks(chunks, token);
  }
  function now() {
    const { line, column, offset, _index, _bufferIndex } = point5;
    return {
      line,
      column,
      offset,
      _index,
      _bufferIndex
    };
  }
  function defineSkip(value) {
    columnStart[value.line] = value.column;
    accountForPotentialSkip();
  }
  function main() {
    let chunkIndex;
    while (point5._index < chunks.length) {
      const chunk = chunks[point5._index];
      if (typeof chunk === "string") {
        chunkIndex = point5._index;
        if (point5._bufferIndex < 0) {
          point5._bufferIndex = 0;
        }
        while (point5._index === chunkIndex && point5._bufferIndex < chunk.length) {
          go(chunk.charCodeAt(point5._bufferIndex));
        }
      } else {
        go(chunk);
      }
    }
  }
  function go(code4) {
    consumed = void 0;
    expectedCode = code4;
    state = state(code4);
  }
  function consume(code4) {
    if (markdownLineEnding(code4)) {
      point5.line++;
      point5.column = 1;
      point5.offset += code4 === -3 ? 2 : 1;
      accountForPotentialSkip();
    } else if (code4 !== -1) {
      point5.column++;
      point5.offset++;
    }
    if (point5._bufferIndex < 0) {
      point5._index++;
    } else {
      point5._bufferIndex++;
      if (point5._bufferIndex === chunks[point5._index].length) {
        point5._bufferIndex = -1;
        point5._index++;
      }
    }
    context.previous = code4;
    consumed = true;
  }
  function enter(type, fields) {
    const token = fields || {};
    token.type = type;
    token.start = now();
    context.events.push(["enter", token, context]);
    stack.push(token);
    return token;
  }
  function exit3(type) {
    const token = stack.pop();
    token.end = now();
    context.events.push(["exit", token, context]);
    return token;
  }
  function onsuccessfulconstruct(construct, info2) {
    addResult(construct, info2.from);
  }
  function onsuccessfulcheck(_, info2) {
    info2.restore();
  }
  function constructFactory(onreturn, fields) {
    return hook;
    function hook(constructs2, returnState, bogusState) {
      let listOfConstructs;
      let constructIndex;
      let currentConstruct;
      let info2;
      return Array.isArray(constructs2) ? handleListOfConstructs(constructs2) : "tokenize" in constructs2 ? (
        // @ts-expect-error Looks like a construct.
        handleListOfConstructs([constructs2])
      ) : handleMapOfConstructs(constructs2);
      function handleMapOfConstructs(map9) {
        return start;
        function start(code4) {
          const def = code4 !== null && map9[code4];
          const all4 = code4 !== null && map9.null;
          const list4 = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(def) ? def : def ? [def] : [],
            ...Array.isArray(all4) ? all4 : all4 ? [all4] : []
          ];
          return handleListOfConstructs(list4)(code4);
        }
      }
      function handleListOfConstructs(list4) {
        listOfConstructs = list4;
        constructIndex = 0;
        if (list4.length === 0) {
          return bogusState;
        }
        return handleConstruct(list4[constructIndex]);
      }
      function handleConstruct(construct) {
        return start;
        function start(code4) {
          info2 = store();
          currentConstruct = construct;
          if (!construct.partial) {
            context.currentConstruct = construct;
          }
          if (construct.name && context.parser.constructs.disable.null.includes(construct.name)) {
            return nok(code4);
          }
          return construct.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a “live binding”, which is needed for `interrupt`.
            fields ? Object.assign(Object.create(context), fields) : context,
            effects,
            ok3,
            nok
          )(code4);
        }
      }
      function ok3(code4) {
        consumed = true;
        onreturn(currentConstruct, info2);
        return returnState;
      }
      function nok(code4) {
        consumed = true;
        info2.restore();
        if (++constructIndex < listOfConstructs.length) {
          return handleConstruct(listOfConstructs[constructIndex]);
        }
        return bogusState;
      }
    }
  }
  function addResult(construct, from4) {
    if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
      resolveAllConstructs.push(construct);
    }
    if (construct.resolve) {
      splice3(
        context.events,
        from4,
        context.events.length - from4,
        construct.resolve(context.events.slice(from4), context)
      );
    }
    if (construct.resolveTo) {
      context.events = construct.resolveTo(context.events, context);
    }
  }
  function store() {
    const startPoint = now();
    const startPrevious = context.previous;
    const startCurrentConstruct = context.currentConstruct;
    const startEventsIndex = context.events.length;
    const startStack = Array.from(stack);
    return {
      restore,
      from: startEventsIndex
    };
    function restore() {
      point5 = startPoint;
      context.previous = startPrevious;
      context.currentConstruct = startCurrentConstruct;
      context.events.length = startEventsIndex;
      stack = startStack;
      accountForPotentialSkip();
    }
  }
  function accountForPotentialSkip() {
    if (point5.line in columnStart && point5.column < 2) {
      point5.column = columnStart[point5.line];
      point5.offset += columnStart[point5.line] - 1;
    }
  }
}
function sliceChunks(chunks, token) {
  const startIndex = token.start._index;
  const startBufferIndex = token.start._bufferIndex;
  const endIndex = token.end._index;
  const endBufferIndex = token.end._bufferIndex;
  let view;
  if (startIndex === endIndex) {
    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
  } else {
    view = chunks.slice(startIndex, endIndex);
    if (startBufferIndex > -1) {
      const head2 = view[0];
      if (typeof head2 === "string") {
        view[0] = head2.slice(startBufferIndex);
      } else {
        view.shift();
      }
    }
    if (endBufferIndex > 0) {
      view.push(chunks[endIndex].slice(0, endBufferIndex));
    }
  }
  return view;
}
function serializeChunks(chunks, expandTabs) {
  let index3 = -1;
  const result = [];
  let atTab;
  while (++index3 < chunks.length) {
    const chunk = chunks[index3];
    let value;
    if (typeof chunk === "string") {
      value = chunk;
    } else
      switch (chunk) {
        case -5: {
          value = "\r";
          break;
        }
        case -4: {
          value = "\n";
          break;
        }
        case -3: {
          value = "\r\n";
          break;
        }
        case -2: {
          value = expandTabs ? " " : "	";
          break;
        }
        case -1: {
          if (!expandTabs && atTab)
            continue;
          value = " ";
          break;
        }
        default: {
          value = String.fromCharCode(chunk);
        }
      }
    atTab = chunk === -2;
    result.push(value);
  }
  return result.join("");
}

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/lib/constructs.js
var constructs_exports = {};
__export(constructs_exports, {
  attentionMarkers: () => attentionMarkers,
  contentInitial: () => contentInitial,
  disable: () => disable,
  document: () => document2,
  flow: () => flow3,
  flowInitial: () => flowInitial,
  insideSpan: () => insideSpan,
  string: () => string2,
  text: () => text6
});
init_process();
init_buffer();
var document2 = {
  [42]: list2,
  [43]: list2,
  [45]: list2,
  [48]: list2,
  [49]: list2,
  [50]: list2,
  [51]: list2,
  [52]: list2,
  [53]: list2,
  [54]: list2,
  [55]: list2,
  [56]: list2,
  [57]: list2,
  [62]: blockQuote
};
var contentInitial = {
  [91]: definition2
};
var flowInitial = {
  [-2]: codeIndented,
  [-1]: codeIndented,
  [32]: codeIndented
};
var flow3 = {
  [35]: headingAtx,
  [42]: thematicBreak2,
  [45]: [setextUnderline, thematicBreak2],
  [60]: htmlFlow,
  [61]: setextUnderline,
  [95]: thematicBreak2,
  [96]: codeFenced,
  [126]: codeFenced
};
var string2 = {
  [38]: characterReference,
  [92]: characterEscape
};
var text6 = {
  [-5]: lineEnding,
  [-4]: lineEnding,
  [-3]: lineEnding,
  [33]: labelStartImage,
  [38]: characterReference,
  [42]: attention,
  [60]: [autolink, htmlText],
  [91]: labelStartLink,
  [92]: [hardBreakEscape, characterEscape],
  [93]: labelEnd,
  [95]: attention,
  [96]: codeText
};
var insideSpan = {
  null: [attention, resolver]
};
var attentionMarkers = {
  null: [42, 95]
};
var disable = {
  null: []
};

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/lib/parse.js
function parse3(options) {
  const settings = options || {};
  const constructs2 = (
    /** @type {FullNormalizedExtension} */
    combineExtensions([constructs_exports, ...settings.extensions || []])
  );
  const parser = {
    defined: [],
    lazy: {},
    constructs: constructs2,
    content: create2(content),
    document: create2(document),
    flow: create2(flow2),
    string: create2(string),
    text: create2(text5)
  };
  return parser;
  function create2(initial) {
    return creator;
    function creator(from3) {
      return createTokenizer(parser, initial, from3);
    }
  }
}

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/lib/postprocess.js
init_process();
init_buffer();
function postprocess(events) {
  while (!subtokenize(events)) {
  }
  return events;
}

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/lib/preprocess.js
init_process();
init_buffer();
var search = /[\0\t\n\r]/g;
function preprocess() {
  let column = 1;
  let buffer = "";
  let start = true;
  let atCarriageReturn;
  return preprocessor;
  function preprocessor(value, encoding, end) {
    const chunks = [];
    let match;
    let next;
    let startPosition;
    let endPosition;
    let code4;
    value = buffer + (typeof value === "string" ? value.toString() : new TextDecoder(encoding || void 0).decode(value));
    startPosition = 0;
    buffer = "";
    if (start) {
      if (value.charCodeAt(0) === 65279) {
        startPosition++;
      }
      start = void 0;
    }
    while (startPosition < value.length) {
      search.lastIndex = startPosition;
      match = search.exec(value);
      endPosition = match && match.index !== void 0 ? match.index : value.length;
      code4 = value.charCodeAt(endPosition);
      if (!match) {
        buffer = value.slice(startPosition);
        break;
      }
      if (code4 === 10 && startPosition === endPosition && atCarriageReturn) {
        chunks.push(-3);
        atCarriageReturn = void 0;
      } else {
        if (atCarriageReturn) {
          chunks.push(-5);
          atCarriageReturn = void 0;
        }
        if (startPosition < endPosition) {
          chunks.push(value.slice(startPosition, endPosition));
          column += endPosition - startPosition;
        }
        switch (code4) {
          case 0: {
            chunks.push(65533);
            column++;
            break;
          }
          case 9: {
            next = Math.ceil(column / 4) * 4;
            chunks.push(-2);
            while (column++ < next)
              chunks.push(-1);
            break;
          }
          case 10: {
            chunks.push(-4);
            column = 1;
            break;
          }
          default: {
            atCarriageReturn = true;
            column = 1;
          }
        }
      }
      startPosition = endPosition + 1;
    }
    if (end) {
      if (atCarriageReturn)
        chunks.push(-5);
      if (buffer)
        chunks.push(buffer);
      chunks.push(null);
    }
    return chunks;
  }
}

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark-util-decode-string/index.js
init_process();
init_buffer();
var characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function decodeString(value) {
  return value.replace(characterEscapeOrReference, decode2);
}
function decode2($0, $1, $2) {
  if ($1) {
    return $1;
  }
  const head2 = $2.charCodeAt(0);
  if (head2 === 35) {
    const head3 = $2.charCodeAt(1);
    const hex = head3 === 120 || head3 === 88;
    return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10);
  }
  return decodeNamedCharacterReference($2) || $0;
}

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/unist-util-stringify-position/index.js
init_process();
init_buffer();

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/unist-util-stringify-position/lib/index.js
init_process();
init_buffer();
function stringifyPosition(value) {
  if (!value || typeof value !== "object") {
    return "";
  }
  if ("position" in value || "type" in value) {
    return position(value.position);
  }
  if ("start" in value || "end" in value) {
    return position(value);
  }
  if ("line" in value || "column" in value) {
    return point(value);
  }
  return "";
}
function point(point5) {
  return index(point5 && point5.line) + ":" + index(point5 && point5.column);
}
function position(pos) {
  return point(pos && pos.start) + "-" + point(pos && pos.end);
}
function index(value) {
  return value && typeof value === "number" ? value : 1;
}

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/lib/index.js
var own6 = {}.hasOwnProperty;
function fromMarkdown(value, encoding, options) {
  if (typeof encoding !== "string") {
    options = encoding;
    encoding = void 0;
  }
  return compiler(options)(postprocess(parse3(options).document().write(preprocess()(value, encoding, true))));
}
function compiler(options) {
  const config3 = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: opener(link3),
      autolinkProtocol: onenterdata,
      autolinkEmail: onenterdata,
      atxHeading: opener(heading3),
      blockQuote: opener(blockQuote2),
      characterEscape: onenterdata,
      characterReference: onenterdata,
      codeFenced: opener(codeFlow),
      codeFencedFenceInfo: buffer,
      codeFencedFenceMeta: buffer,
      codeIndented: opener(codeFlow, buffer),
      codeText: opener(codeText2, buffer),
      codeTextData: onenterdata,
      data: onenterdata,
      codeFlowValue: onenterdata,
      definition: opener(definition3),
      definitionDestinationString: buffer,
      definitionLabelString: buffer,
      definitionTitleString: buffer,
      emphasis: opener(emphasis3),
      hardBreakEscape: opener(hardBreak3),
      hardBreakTrailing: opener(hardBreak3),
      htmlFlow: opener(html7, buffer),
      htmlFlowData: onenterdata,
      htmlText: opener(html7, buffer),
      htmlTextData: onenterdata,
      image: opener(image3),
      label: buffer,
      link: opener(link3),
      listItem: opener(listItem3),
      listItemValue: onenterlistitemvalue,
      listOrdered: opener(list4, onenterlistordered),
      listUnordered: opener(list4),
      paragraph: opener(paragraph3),
      reference: onenterreference,
      referenceString: buffer,
      resourceDestinationString: buffer,
      resourceTitleString: buffer,
      setextHeading: opener(heading3),
      strong: opener(strong3),
      thematicBreak: opener(thematicBreak4)
    },
    exit: {
      atxHeading: closer(),
      atxHeadingSequence: onexitatxheadingsequence,
      autolink: closer(),
      autolinkEmail: onexitautolinkemail,
      autolinkProtocol: onexitautolinkprotocol,
      blockQuote: closer(),
      characterEscapeValue: onexitdata,
      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
      characterReferenceValue: onexitcharacterreferencevalue,
      characterReference: onexitcharacterreference,
      codeFenced: closer(onexitcodefenced),
      codeFencedFence: onexitcodefencedfence,
      codeFencedFenceInfo: onexitcodefencedfenceinfo,
      codeFencedFenceMeta: onexitcodefencedfencemeta,
      codeFlowValue: onexitdata,
      codeIndented: closer(onexitcodeindented),
      codeText: closer(onexitcodetext),
      codeTextData: onexitdata,
      data: onexitdata,
      definition: closer(),
      definitionDestinationString: onexitdefinitiondestinationstring,
      definitionLabelString: onexitdefinitionlabelstring,
      definitionTitleString: onexitdefinitiontitlestring,
      emphasis: closer(),
      hardBreakEscape: closer(onexithardbreak),
      hardBreakTrailing: closer(onexithardbreak),
      htmlFlow: closer(onexithtmlflow),
      htmlFlowData: onexitdata,
      htmlText: closer(onexithtmltext),
      htmlTextData: onexitdata,
      image: closer(onexitimage),
      label: onexitlabel,
      labelText: onexitlabeltext,
      lineEnding: onexitlineending,
      link: closer(onexitlink),
      listItem: closer(),
      listOrdered: closer(),
      listUnordered: closer(),
      paragraph: closer(),
      referenceString: onexitreferencestring,
      resourceDestinationString: onexitresourcedestinationstring,
      resourceTitleString: onexitresourcetitlestring,
      resource: onexitresource,
      setextHeading: closer(onexitsetextheading),
      setextHeadingLineSequence: onexitsetextheadinglinesequence,
      setextHeadingText: onexitsetextheadingtext,
      strong: closer(),
      thematicBreak: closer()
    }
  };
  configure(config3, (options || {}).mdastExtensions || []);
  const data = {};
  return compile;
  function compile(events) {
    let tree = {
      type: "root",
      children: []
    };
    const context = {
      stack: [tree],
      tokenStack: [],
      config: config3,
      enter,
      exit: exit3,
      buffer,
      resume: resume2,
      data
    };
    const listStack = [];
    let index3 = -1;
    while (++index3 < events.length) {
      if (events[index3][1].type === "listOrdered" || events[index3][1].type === "listUnordered") {
        if (events[index3][0] === "enter") {
          listStack.push(index3);
        } else {
          const tail = listStack.pop();
          index3 = prepareList(events, tail, index3);
        }
      }
    }
    index3 = -1;
    while (++index3 < events.length) {
      const handler = config3[events[index3][0]];
      if (own6.call(handler, events[index3][1].type)) {
        handler[events[index3][1].type].call(Object.assign({
          sliceSerialize: events[index3][2].sliceSerialize
        }, context), events[index3][1]);
      }
    }
    if (context.tokenStack.length > 0) {
      const tail = context.tokenStack[context.tokenStack.length - 1];
      const handler = tail[1] || defaultOnError;
      handler.call(context, void 0, tail[0]);
    }
    tree.position = {
      start: point2(events.length > 0 ? events[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: point2(events.length > 0 ? events[events.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    };
    index3 = -1;
    while (++index3 < config3.transforms.length) {
      tree = config3.transforms[index3](tree) || tree;
    }
    return tree;
  }
  function prepareList(events, start, length) {
    let index3 = start - 1;
    let containerBalance = -1;
    let listSpread = false;
    let listItem4;
    let lineIndex;
    let firstBlankLineIndex;
    let atMarker;
    while (++index3 <= length) {
      const event = events[index3];
      switch (event[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          if (event[0] === "enter") {
            containerBalance++;
          } else {
            containerBalance--;
          }
          atMarker = void 0;
          break;
        }
        case "lineEndingBlank": {
          if (event[0] === "enter") {
            if (listItem4 && !atMarker && !containerBalance && !firstBlankLineIndex) {
              firstBlankLineIndex = index3;
            }
            atMarker = void 0;
          }
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace": {
          break;
        }
        default: {
          atMarker = void 0;
        }
      }
      if (!containerBalance && event[0] === "enter" && event[1].type === "listItemPrefix" || containerBalance === -1 && event[0] === "exit" && (event[1].type === "listUnordered" || event[1].type === "listOrdered")) {
        if (listItem4) {
          let tailIndex = index3;
          lineIndex = void 0;
          while (tailIndex--) {
            const tailEvent = events[tailIndex];
            if (tailEvent[1].type === "lineEnding" || tailEvent[1].type === "lineEndingBlank") {
              if (tailEvent[0] === "exit")
                continue;
              if (lineIndex) {
                events[lineIndex][1].type = "lineEndingBlank";
                listSpread = true;
              }
              tailEvent[1].type = "lineEnding";
              lineIndex = tailIndex;
            } else if (tailEvent[1].type === "linePrefix" || tailEvent[1].type === "blockQuotePrefix" || tailEvent[1].type === "blockQuotePrefixWhitespace" || tailEvent[1].type === "blockQuoteMarker" || tailEvent[1].type === "listItemIndent") {
            } else {
              break;
            }
          }
          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
            listItem4._spread = true;
          }
          listItem4.end = Object.assign({}, lineIndex ? events[lineIndex][1].start : event[1].end);
          events.splice(lineIndex || index3, 0, ["exit", listItem4, event[2]]);
          index3++;
          length++;
        }
        if (event[1].type === "listItemPrefix") {
          const item = {
            type: "listItem",
            _spread: false,
            start: Object.assign({}, event[1].start),
            // @ts-expect-error: we’ll add `end` in a second.
            end: void 0
          };
          listItem4 = item;
          events.splice(index3, 0, ["enter", item, event[2]]);
          index3++;
          length++;
          firstBlankLineIndex = void 0;
          atMarker = true;
        }
      }
    }
    events[start][1]._spread = listSpread;
    return length;
  }
  function opener(create2, and2) {
    return open;
    function open(token) {
      enter.call(this, create2(token), token);
      if (and2)
        and2.call(this, token);
    }
  }
  function buffer() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function enter(node3, token, errorHandler) {
    const parent = this.stack[this.stack.length - 1];
    const siblings2 = parent.children;
    siblings2.push(node3);
    this.stack.push(node3);
    this.tokenStack.push([token, errorHandler]);
    node3.position = {
      start: point2(token.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function closer(and2) {
    return close;
    function close(token) {
      if (and2)
        and2.call(this, token);
      exit3.call(this, token);
    }
  }
  function exit3(token, onExitError) {
    const node3 = this.stack.pop();
    const open = this.tokenStack.pop();
    if (!open) {
      throw new Error("Cannot close `" + token.type + "` (" + stringifyPosition({
        start: token.start,
        end: token.end
      }) + "): it\u2019s not open");
    } else if (open[0].type !== token.type) {
      if (onExitError) {
        onExitError.call(this, token, open[0]);
      } else {
        const handler = open[1] || defaultOnError;
        handler.call(this, token, open[0]);
      }
    }
    node3.position.end = point2(token.end);
  }
  function resume2() {
    return toString5(this.stack.pop());
  }
  function onenterlistordered() {
    this.data.expectingFirstListItemValue = true;
  }
  function onenterlistitemvalue(token) {
    if (this.data.expectingFirstListItemValue) {
      const ancestor = this.stack[this.stack.length - 2];
      ancestor.start = Number.parseInt(this.sliceSerialize(token), 10);
      this.data.expectingFirstListItemValue = void 0;
    }
  }
  function onexitcodefencedfenceinfo() {
    const data2 = this.resume();
    const node3 = this.stack[this.stack.length - 1];
    node3.lang = data2;
  }
  function onexitcodefencedfencemeta() {
    const data2 = this.resume();
    const node3 = this.stack[this.stack.length - 1];
    node3.meta = data2;
  }
  function onexitcodefencedfence() {
    if (this.data.flowCodeInside)
      return;
    this.buffer();
    this.data.flowCodeInside = true;
  }
  function onexitcodefenced() {
    const data2 = this.resume();
    const node3 = this.stack[this.stack.length - 1];
    node3.value = data2.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
    this.data.flowCodeInside = void 0;
  }
  function onexitcodeindented() {
    const data2 = this.resume();
    const node3 = this.stack[this.stack.length - 1];
    node3.value = data2.replace(/(\r?\n|\r)$/g, "");
  }
  function onexitdefinitionlabelstring(token) {
    const label = this.resume();
    const node3 = this.stack[this.stack.length - 1];
    node3.label = label;
    node3.identifier = normalizeIdentifier3(this.sliceSerialize(token)).toLowerCase();
  }
  function onexitdefinitiontitlestring() {
    const data2 = this.resume();
    const node3 = this.stack[this.stack.length - 1];
    node3.title = data2;
  }
  function onexitdefinitiondestinationstring() {
    const data2 = this.resume();
    const node3 = this.stack[this.stack.length - 1];
    node3.url = data2;
  }
  function onexitatxheadingsequence(token) {
    const node3 = this.stack[this.stack.length - 1];
    if (!node3.depth) {
      const depth = this.sliceSerialize(token).length;
      node3.depth = depth;
    }
  }
  function onexitsetextheadingtext() {
    this.data.setextHeadingSlurpLineEnding = true;
  }
  function onexitsetextheadinglinesequence(token) {
    const node3 = this.stack[this.stack.length - 1];
    node3.depth = this.sliceSerialize(token).codePointAt(0) === 61 ? 1 : 2;
  }
  function onexitsetextheading() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function onenterdata(token) {
    const node3 = this.stack[this.stack.length - 1];
    const siblings2 = node3.children;
    let tail = siblings2[siblings2.length - 1];
    if (!tail || tail.type !== "text") {
      tail = text8();
      tail.position = {
        start: point2(token.start),
        // @ts-expect-error: we’ll add `end` later.
        end: void 0
      };
      siblings2.push(tail);
    }
    this.stack.push(tail);
  }
  function onexitdata(token) {
    const tail = this.stack.pop();
    tail.value += this.sliceSerialize(token);
    tail.position.end = point2(token.end);
  }
  function onexitlineending(token) {
    const context = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const tail = context.children[context.children.length - 1];
      tail.position.end = point2(token.end);
      this.data.atHardBreak = void 0;
      return;
    }
    if (!this.data.setextHeadingSlurpLineEnding && config3.canContainEols.includes(context.type)) {
      onenterdata.call(this, token);
      onexitdata.call(this, token);
    }
  }
  function onexithardbreak() {
    this.data.atHardBreak = true;
  }
  function onexithtmlflow() {
    const data2 = this.resume();
    const node3 = this.stack[this.stack.length - 1];
    node3.value = data2;
  }
  function onexithtmltext() {
    const data2 = this.resume();
    const node3 = this.stack[this.stack.length - 1];
    node3.value = data2;
  }
  function onexitcodetext() {
    const data2 = this.resume();
    const node3 = this.stack[this.stack.length - 1];
    node3.value = data2;
  }
  function onexitlink() {
    const node3 = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const referenceType = this.data.referenceType || "shortcut";
      node3.type += "Reference";
      node3.referenceType = referenceType;
      delete node3.url;
      delete node3.title;
    } else {
      delete node3.identifier;
      delete node3.label;
    }
    this.data.referenceType = void 0;
  }
  function onexitimage() {
    const node3 = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const referenceType = this.data.referenceType || "shortcut";
      node3.type += "Reference";
      node3.referenceType = referenceType;
      delete node3.url;
      delete node3.title;
    } else {
      delete node3.identifier;
      delete node3.label;
    }
    this.data.referenceType = void 0;
  }
  function onexitlabeltext(token) {
    const string3 = this.sliceSerialize(token);
    const ancestor = this.stack[this.stack.length - 2];
    ancestor.label = decodeString(string3);
    ancestor.identifier = normalizeIdentifier3(string3).toLowerCase();
  }
  function onexitlabel() {
    const fragment = this.stack[this.stack.length - 1];
    const value = this.resume();
    const node3 = this.stack[this.stack.length - 1];
    this.data.inReference = true;
    if (node3.type === "link") {
      const children = fragment.children;
      node3.children = children;
    } else {
      node3.alt = value;
    }
  }
  function onexitresourcedestinationstring() {
    const data2 = this.resume();
    const node3 = this.stack[this.stack.length - 1];
    node3.url = data2;
  }
  function onexitresourcetitlestring() {
    const data2 = this.resume();
    const node3 = this.stack[this.stack.length - 1];
    node3.title = data2;
  }
  function onexitresource() {
    this.data.inReference = void 0;
  }
  function onenterreference() {
    this.data.referenceType = "collapsed";
  }
  function onexitreferencestring(token) {
    const label = this.resume();
    const node3 = this.stack[this.stack.length - 1];
    node3.label = label;
    node3.identifier = normalizeIdentifier3(this.sliceSerialize(token)).toLowerCase();
    this.data.referenceType = "full";
  }
  function onexitcharacterreferencemarker(token) {
    this.data.characterReferenceType = token.type;
  }
  function onexitcharacterreferencevalue(token) {
    const data2 = this.sliceSerialize(token);
    const type = this.data.characterReferenceType;
    let value;
    if (type) {
      value = decodeNumericCharacterReference(data2, type === "characterReferenceMarkerNumeric" ? 10 : 16);
      this.data.characterReferenceType = void 0;
    } else {
      const result = decodeNamedCharacterReference(data2);
      value = result;
    }
    const tail = this.stack[this.stack.length - 1];
    tail.value += value;
  }
  function onexitcharacterreference(token) {
    const tail = this.stack.pop();
    tail.position.end = point2(token.end);
  }
  function onexitautolinkprotocol(token) {
    onexitdata.call(this, token);
    const node3 = this.stack[this.stack.length - 1];
    node3.url = this.sliceSerialize(token);
  }
  function onexitautolinkemail(token) {
    onexitdata.call(this, token);
    const node3 = this.stack[this.stack.length - 1];
    node3.url = "mailto:" + this.sliceSerialize(token);
  }
  function blockQuote2() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function codeFlow() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function codeText2() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function definition3() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function emphasis3() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function heading3() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function hardBreak3() {
    return {
      type: "break"
    };
  }
  function html7() {
    return {
      type: "html",
      value: ""
    };
  }
  function image3() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function link3() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function list4(token) {
    return {
      type: "list",
      ordered: token.type === "listOrdered",
      start: null,
      spread: token._spread,
      children: []
    };
  }
  function listItem3(token) {
    return {
      type: "listItem",
      spread: token._spread,
      checked: null,
      children: []
    };
  }
  function paragraph3() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function strong3() {
    return {
      type: "strong",
      children: []
    };
  }
  function text8() {
    return {
      type: "text",
      value: ""
    };
  }
  function thematicBreak4() {
    return {
      type: "thematicBreak"
    };
  }
}
function point2(d2) {
  return {
    line: d2.line,
    column: d2.column,
    offset: d2.offset
  };
}
function configure(combined, extensions) {
  let index3 = -1;
  while (++index3 < extensions.length) {
    const value = extensions[index3];
    if (Array.isArray(value)) {
      configure(combined, value);
    } else {
      extension(combined, value);
    }
  }
}
function extension(combined, extension2) {
  let key2;
  for (key2 in extension2) {
    if (own6.call(extension2, key2)) {
      switch (key2) {
        case "canContainEols": {
          const right = extension2[key2];
          if (right) {
            combined[key2].push(...right);
          }
          break;
        }
        case "transforms": {
          const right = extension2[key2];
          if (right) {
            combined[key2].push(...right);
          }
          break;
        }
        case "enter":
        case "exit": {
          const right = extension2[key2];
          if (right) {
            Object.assign(combined[key2], right);
          }
          break;
        }
      }
    }
  }
}
function defaultOnError(left, right) {
  if (left) {
    throw new Error("Cannot close `" + left.type + "` (" + stringifyPosition({
      start: left.start,
      end: left.end
    }) + "): a different token (`" + right.type + "`, " + stringifyPosition({
      start: right.start,
      end: right.end
    }) + ") is open");
  } else {
    throw new Error("Cannot close document, a token (`" + right.type + "`, " + stringifyPosition({
      start: right.start,
      end: right.end
    }) + ") is still open");
  }
}

// node_modules/remark-parse/lib/index.js
function remarkParse(options) {
  const self2 = this;
  self2.parser = parser;
  function parser(doc) {
    return fromMarkdown(doc, {
      ...self2.data("settings"),
      ...options,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: self2.data("micromarkExtensions") || [],
      mdastExtensions: self2.data("fromMarkdownExtensions") || []
    });
  }
}

// node_modules/remark-rehype/index.js
init_process();
init_buffer();

// node_modules/mdast-util-to-hast/index.js
init_process();
init_buffer();

// node_modules/mdast-util-to-hast/lib/handlers/index.js
init_process();
init_buffer();

// node_modules/mdast-util-to-hast/lib/handlers/blockquote.js
init_process();
init_buffer();
function blockquote2(state, node3) {
  const result = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: state.wrap(state.all(node3), true)
  };
  state.patch(node3, result);
  return state.applyData(node3, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/break.js
init_process();
init_buffer();
function hardBreak2(state, node3) {
  const result = { type: "element", tagName: "br", properties: {}, children: [] };
  state.patch(node3, result);
  return [state.applyData(node3, result), { type: "text", value: "\n" }];
}

// node_modules/mdast-util-to-hast/lib/handlers/code.js
init_process();
init_buffer();
function code3(state, node3) {
  const value = node3.value ? node3.value + "\n" : "";
  const properties = {};
  if (node3.lang) {
    properties.className = ["language-" + node3.lang];
  }
  let result = {
    type: "element",
    tagName: "code",
    properties,
    children: [{ type: "text", value }]
  };
  if (node3.meta) {
    result.data = { meta: node3.meta };
  }
  state.patch(node3, result);
  result = state.applyData(node3, result);
  result = { type: "element", tagName: "pre", properties: {}, children: [result] };
  state.patch(node3, result);
  return result;
}

// node_modules/mdast-util-to-hast/lib/handlers/delete.js
init_process();
init_buffer();
function strikethrough(state, node3) {
  const result = {
    type: "element",
    tagName: "del",
    properties: {},
    children: state.all(node3)
  };
  state.patch(node3, result);
  return state.applyData(node3, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/emphasis.js
init_process();
init_buffer();
function emphasis2(state, node3) {
  const result = {
    type: "element",
    tagName: "em",
    properties: {},
    children: state.all(node3)
  };
  state.patch(node3, result);
  return state.applyData(node3, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/footnote-reference.js
init_process();
init_buffer();
function footnoteReference2(state, node3) {
  const clobberPrefix = typeof state.options.clobberPrefix === "string" ? state.options.clobberPrefix : "user-content-";
  const id = String(node3.identifier).toUpperCase();
  const safeId = normalizeUri(id.toLowerCase());
  const index3 = state.footnoteOrder.indexOf(id);
  let counter;
  let reuseCounter = state.footnoteCounts.get(id);
  if (reuseCounter === void 0) {
    reuseCounter = 0;
    state.footnoteOrder.push(id);
    counter = state.footnoteOrder.length;
  } else {
    counter = index3 + 1;
  }
  reuseCounter += 1;
  state.footnoteCounts.set(id, reuseCounter);
  const link3 = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + clobberPrefix + "fn-" + safeId,
      id: clobberPrefix + "fnref-" + safeId + (reuseCounter > 1 ? "-" + reuseCounter : ""),
      dataFootnoteRef: true,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(counter) }]
  };
  state.patch(node3, link3);
  const sup = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [link3]
  };
  state.patch(node3, sup);
  return state.applyData(node3, sup);
}

// node_modules/mdast-util-to-hast/lib/handlers/heading.js
init_process();
init_buffer();
function heading2(state, node3) {
  const result = {
    type: "element",
    tagName: "h" + node3.depth,
    properties: {},
    children: state.all(node3)
  };
  state.patch(node3, result);
  return state.applyData(node3, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/html.js
init_process();
init_buffer();
function html6(state, node3) {
  if (state.options.allowDangerousHtml) {
    const result = { type: "raw", value: node3.value };
    state.patch(node3, result);
    return state.applyData(node3, result);
  }
  return void 0;
}

// node_modules/mdast-util-to-hast/lib/handlers/image-reference.js
init_process();
init_buffer();

// node_modules/mdast-util-to-hast/lib/revert.js
init_process();
init_buffer();
function revert(state, node3) {
  const subtype = node3.referenceType;
  let suffix = "]";
  if (subtype === "collapsed") {
    suffix += "[]";
  } else if (subtype === "full") {
    suffix += "[" + (node3.label || node3.identifier) + "]";
  }
  if (node3.type === "imageReference") {
    return [{ type: "text", value: "![" + node3.alt + suffix }];
  }
  const contents = state.all(node3);
  const head2 = contents[0];
  if (head2 && head2.type === "text") {
    head2.value = "[" + head2.value;
  } else {
    contents.unshift({ type: "text", value: "[" });
  }
  const tail = contents[contents.length - 1];
  if (tail && tail.type === "text") {
    tail.value += suffix;
  } else {
    contents.push({ type: "text", value: suffix });
  }
  return contents;
}

// node_modules/mdast-util-to-hast/lib/handlers/image-reference.js
function imageReference2(state, node3) {
  const id = String(node3.identifier).toUpperCase();
  const definition3 = state.definitionById.get(id);
  if (!definition3) {
    return revert(state, node3);
  }
  const properties = { src: normalizeUri(definition3.url || ""), alt: node3.alt };
  if (definition3.title !== null && definition3.title !== void 0) {
    properties.title = definition3.title;
  }
  const result = { type: "element", tagName: "img", properties, children: [] };
  state.patch(node3, result);
  return state.applyData(node3, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/image.js
init_process();
init_buffer();
function image2(state, node3) {
  const properties = { src: normalizeUri(node3.url) };
  if (node3.alt !== null && node3.alt !== void 0) {
    properties.alt = node3.alt;
  }
  if (node3.title !== null && node3.title !== void 0) {
    properties.title = node3.title;
  }
  const result = { type: "element", tagName: "img", properties, children: [] };
  state.patch(node3, result);
  return state.applyData(node3, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/inline-code.js
init_process();
init_buffer();
function inlineCode2(state, node3) {
  const text8 = { type: "text", value: node3.value.replace(/\r?\n|\r/g, " ") };
  state.patch(node3, text8);
  const result = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [text8]
  };
  state.patch(node3, result);
  return state.applyData(node3, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/link-reference.js
init_process();
init_buffer();
function linkReference2(state, node3) {
  const id = String(node3.identifier).toUpperCase();
  const definition3 = state.definitionById.get(id);
  if (!definition3) {
    return revert(state, node3);
  }
  const properties = { href: normalizeUri(definition3.url || "") };
  if (definition3.title !== null && definition3.title !== void 0) {
    properties.title = definition3.title;
  }
  const result = {
    type: "element",
    tagName: "a",
    properties,
    children: state.all(node3)
  };
  state.patch(node3, result);
  return state.applyData(node3, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/link.js
init_process();
init_buffer();
function link2(state, node3) {
  const properties = { href: normalizeUri(node3.url) };
  if (node3.title !== null && node3.title !== void 0) {
    properties.title = node3.title;
  }
  const result = {
    type: "element",
    tagName: "a",
    properties,
    children: state.all(node3)
  };
  state.patch(node3, result);
  return state.applyData(node3, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/list-item.js
init_process();
init_buffer();
function listItem2(state, node3, parent) {
  const results = state.all(node3);
  const loose = parent ? listLoose(parent) : listItemLoose(node3);
  const properties = {};
  const children = [];
  if (typeof node3.checked === "boolean") {
    const head2 = results[0];
    let paragraph3;
    if (head2 && head2.type === "element" && head2.tagName === "p") {
      paragraph3 = head2;
    } else {
      paragraph3 = { type: "element", tagName: "p", properties: {}, children: [] };
      results.unshift(paragraph3);
    }
    if (paragraph3.children.length > 0) {
      paragraph3.children.unshift({ type: "text", value: " " });
    }
    paragraph3.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: node3.checked, disabled: true },
      children: []
    });
    properties.className = ["task-list-item"];
  }
  let index3 = -1;
  while (++index3 < results.length) {
    const child = results[index3];
    if (loose || index3 !== 0 || child.type !== "element" || child.tagName !== "p") {
      children.push({ type: "text", value: "\n" });
    }
    if (child.type === "element" && child.tagName === "p" && !loose) {
      children.push(...child.children);
    } else {
      children.push(child);
    }
  }
  const tail = results[results.length - 1];
  if (tail && (loose || tail.type !== "element" || tail.tagName !== "p")) {
    children.push({ type: "text", value: "\n" });
  }
  const result = { type: "element", tagName: "li", properties, children };
  state.patch(node3, result);
  return state.applyData(node3, result);
}
function listLoose(node3) {
  let loose = false;
  if (node3.type === "list") {
    loose = node3.spread || false;
    const children = node3.children;
    let index3 = -1;
    while (!loose && ++index3 < children.length) {
      loose = listItemLoose(children[index3]);
    }
  }
  return loose;
}
function listItemLoose(node3) {
  const spread = node3.spread;
  return spread === null || spread === void 0 ? node3.children.length > 1 : spread;
}

// node_modules/mdast-util-to-hast/lib/handlers/list.js
init_process();
init_buffer();
function list3(state, node3) {
  const properties = {};
  const results = state.all(node3);
  let index3 = -1;
  if (typeof node3.start === "number" && node3.start !== 1) {
    properties.start = node3.start;
  }
  while (++index3 < results.length) {
    const child = results[index3];
    if (child.type === "element" && child.tagName === "li" && child.properties && Array.isArray(child.properties.className) && child.properties.className.includes("task-list-item")) {
      properties.className = ["contains-task-list"];
      break;
    }
  }
  const result = {
    type: "element",
    tagName: node3.ordered ? "ol" : "ul",
    properties,
    children: state.wrap(results, true)
  };
  state.patch(node3, result);
  return state.applyData(node3, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/paragraph.js
init_process();
init_buffer();
function paragraph2(state, node3) {
  const result = {
    type: "element",
    tagName: "p",
    properties: {},
    children: state.all(node3)
  };
  state.patch(node3, result);
  return state.applyData(node3, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/root.js
init_process();
init_buffer();
function root3(state, node3) {
  const result = { type: "root", children: state.wrap(state.all(node3)) };
  state.patch(node3, result);
  return state.applyData(node3, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/strong.js
init_process();
init_buffer();
function strong2(state, node3) {
  const result = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: state.all(node3)
  };
  state.patch(node3, result);
  return state.applyData(node3, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/table.js
init_process();
init_buffer();

// node_modules/unist-util-position/index.js
init_process();
init_buffer();

// node_modules/unist-util-position/lib/index.js
init_process();
init_buffer();
var pointEnd = point3("end");
var pointStart = point3("start");
function point3(type) {
  return point5;
  function point5(node3) {
    const point6 = node3 && node3.position && node3.position[type] || {};
    if (typeof point6.line === "number" && point6.line > 0 && typeof point6.column === "number" && point6.column > 0) {
      return {
        line: point6.line,
        column: point6.column,
        offset: typeof point6.offset === "number" && point6.offset > -1 ? point6.offset : void 0
      };
    }
  }
}
function position2(node3) {
  const start = pointStart(node3);
  const end = pointEnd(node3);
  if (start && end) {
    return { start, end };
  }
}

// node_modules/mdast-util-to-hast/lib/handlers/table.js
function table(state, node3) {
  const rows = state.all(node3);
  const firstRow = rows.shift();
  const tableContent = [];
  if (firstRow) {
    const head2 = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: state.wrap([firstRow], true)
    };
    state.patch(node3.children[0], head2);
    tableContent.push(head2);
  }
  if (rows.length > 0) {
    const body3 = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: state.wrap(rows, true)
    };
    const start = pointStart(node3.children[1]);
    const end = pointEnd(node3.children[node3.children.length - 1]);
    if (start && end)
      body3.position = { start, end };
    tableContent.push(body3);
  }
  const result = {
    type: "element",
    tagName: "table",
    properties: {},
    children: state.wrap(tableContent, true)
  };
  state.patch(node3, result);
  return state.applyData(node3, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/table-row.js
init_process();
init_buffer();
function tableRow(state, node3, parent) {
  const siblings2 = parent ? parent.children : void 0;
  const rowIndex = siblings2 ? siblings2.indexOf(node3) : 1;
  const tagName = rowIndex === 0 ? "th" : "td";
  const align = parent && parent.type === "table" ? parent.align : void 0;
  const length = align ? align.length : node3.children.length;
  let cellIndex = -1;
  const cells2 = [];
  while (++cellIndex < length) {
    const cell = node3.children[cellIndex];
    const properties = {};
    const alignValue = align ? align[cellIndex] : void 0;
    if (alignValue) {
      properties.align = alignValue;
    }
    let result2 = { type: "element", tagName, properties, children: [] };
    if (cell) {
      result2.children = state.all(cell);
      state.patch(cell, result2);
      result2 = state.applyData(cell, result2);
    }
    cells2.push(result2);
  }
  const result = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: state.wrap(cells2, true)
  };
  state.patch(node3, result);
  return state.applyData(node3, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/table-cell.js
init_process();
init_buffer();
function tableCell(state, node3) {
  const result = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: state.all(node3)
  };
  state.patch(node3, result);
  return state.applyData(node3, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/text.js
init_process();
init_buffer();

// node_modules/trim-lines/index.js
init_process();
init_buffer();
var tab = 9;
var space = 32;
function trimLines(value) {
  const source = String(value);
  const search2 = /\r?\n|\r/g;
  let match = search2.exec(source);
  let last = 0;
  const lines = [];
  while (match) {
    lines.push(
      trimLine(source.slice(last, match.index), last > 0, true),
      match[0]
    );
    last = match.index + match[0].length;
    match = search2.exec(source);
  }
  lines.push(trimLine(source.slice(last), last > 0, false));
  return lines.join("");
}
function trimLine(value, start, end) {
  let startIndex = 0;
  let endIndex = value.length;
  if (start) {
    let code4 = value.codePointAt(startIndex);
    while (code4 === tab || code4 === space) {
      startIndex++;
      code4 = value.codePointAt(startIndex);
    }
  }
  if (end) {
    let code4 = value.codePointAt(endIndex - 1);
    while (code4 === tab || code4 === space) {
      endIndex--;
      code4 = value.codePointAt(endIndex - 1);
    }
  }
  return endIndex > startIndex ? value.slice(startIndex, endIndex) : "";
}

// node_modules/mdast-util-to-hast/lib/handlers/text.js
function text7(state, node3) {
  const result = { type: "text", value: trimLines(String(node3.value)) };
  state.patch(node3, result);
  return state.applyData(node3, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/thematic-break.js
init_process();
init_buffer();
function thematicBreak3(state, node3) {
  const result = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  state.patch(node3, result);
  return state.applyData(node3, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/index.js
var handlers = {
  blockquote: blockquote2,
  break: hardBreak2,
  code: code3,
  delete: strikethrough,
  emphasis: emphasis2,
  footnoteReference: footnoteReference2,
  heading: heading2,
  html: html6,
  imageReference: imageReference2,
  image: image2,
  inlineCode: inlineCode2,
  linkReference: linkReference2,
  link: link2,
  listItem: listItem2,
  list: list3,
  paragraph: paragraph2,
  // @ts-expect-error: root is different, but hard to type.
  root: root3,
  strong: strong2,
  table,
  tableCell,
  tableRow,
  text: text7,
  thematicBreak: thematicBreak3,
  toml: ignore,
  yaml: ignore,
  definition: ignore,
  footnoteDefinition: ignore
};
function ignore() {
  return void 0;
}

// node_modules/mdast-util-to-hast/lib/index.js
init_process();
init_buffer();

// node_modules/mdast-util-to-hast/lib/footer.js
init_process();
init_buffer();

// node_modules/@ungap/structured-clone/esm/index.js
init_process();
init_buffer();

// node_modules/@ungap/structured-clone/esm/deserialize.js
init_process();
init_buffer();

// node_modules/@ungap/structured-clone/esm/types.js
init_process();
init_buffer();
var VOID = -1;
var PRIMITIVE = 0;
var ARRAY = 1;
var OBJECT = 2;
var DATE2 = 3;
var REGEXP = 4;
var MAP = 5;
var SET = 6;
var ERROR = 7;
var BIGINT = 8;

// node_modules/@ungap/structured-clone/esm/deserialize.js
var env4 = typeof self === "object" ? self : globalThis;
var deserializer = ($, _) => {
  const as2 = (out, index3) => {
    $.set(index3, out);
    return out;
  };
  const unpair = (index3) => {
    if ($.has(index3))
      return $.get(index3);
    const [type, value] = _[index3];
    switch (type) {
      case PRIMITIVE:
      case VOID:
        return as2(value, index3);
      case ARRAY: {
        const arr = as2([], index3);
        for (const index4 of value)
          arr.push(unpair(index4));
        return arr;
      }
      case OBJECT: {
        const object = as2({}, index3);
        for (const [key2, index4] of value)
          object[unpair(key2)] = unpair(index4);
        return object;
      }
      case DATE2:
        return as2(new Date(value), index3);
      case REGEXP: {
        const { source, flags } = value;
        return as2(new RegExp(source, flags), index3);
      }
      case MAP: {
        const map9 = as2(/* @__PURE__ */ new Map(), index3);
        for (const [key2, index4] of value)
          map9.set(unpair(key2), unpair(index4));
        return map9;
      }
      case SET: {
        const set = as2(/* @__PURE__ */ new Set(), index3);
        for (const index4 of value)
          set.add(unpair(index4));
        return set;
      }
      case ERROR: {
        const { name, message: message2 } = value;
        return as2(new env4[name](message2), index3);
      }
      case BIGINT:
        return as2(BigInt(value), index3);
      case "BigInt":
        return as2(Object(BigInt(value)), index3);
    }
    return as2(new env4[type](value), index3);
  };
  return unpair;
};
var deserialize = (serialized) => deserializer(/* @__PURE__ */ new Map(), serialized)(0);

// node_modules/@ungap/structured-clone/esm/serialize.js
init_process();
init_buffer();
var EMPTY = "";
var { toString: toString6 } = {};
var { keys: keys2 } = Object;
var typeOf = (value) => {
  const type = typeof value;
  if (type !== "object" || !value)
    return [PRIMITIVE, type];
  const asString = toString6.call(value).slice(8, -1);
  switch (asString) {
    case "Array":
      return [ARRAY, EMPTY];
    case "Object":
      return [OBJECT, EMPTY];
    case "Date":
      return [DATE2, EMPTY];
    case "RegExp":
      return [REGEXP, EMPTY];
    case "Map":
      return [MAP, EMPTY];
    case "Set":
      return [SET, EMPTY];
  }
  if (asString.includes("Array"))
    return [ARRAY, asString];
  if (asString.includes("Error"))
    return [ERROR, asString];
  return [OBJECT, asString];
};
var shouldSkip = ([TYPE, type]) => TYPE === PRIMITIVE && (type === "function" || type === "symbol");
var serializer = (strict, json, $, _) => {
  const as2 = (out, value) => {
    const index3 = _.push(out) - 1;
    $.set(value, index3);
    return index3;
  };
  const pair = (value) => {
    if ($.has(value))
      return $.get(value);
    let [TYPE, type] = typeOf(value);
    switch (TYPE) {
      case PRIMITIVE: {
        let entry = value;
        switch (type) {
          case "bigint":
            TYPE = BIGINT;
            entry = value.toString();
            break;
          case "function":
          case "symbol":
            if (strict)
              throw new TypeError("unable to serialize " + type);
            entry = null;
            break;
          case "undefined":
            return as2([VOID], value);
        }
        return as2([TYPE, entry], value);
      }
      case ARRAY: {
        if (type)
          return as2([type, [...value]], value);
        const arr = [];
        const index3 = as2([TYPE, arr], value);
        for (const entry of value)
          arr.push(pair(entry));
        return index3;
      }
      case OBJECT: {
        if (type) {
          switch (type) {
            case "BigInt":
              return as2([type, value.toString()], value);
            case "Boolean":
            case "Number":
            case "String":
              return as2([type, value.valueOf()], value);
          }
        }
        if (json && "toJSON" in value)
          return pair(value.toJSON());
        const entries = [];
        const index3 = as2([TYPE, entries], value);
        for (const key2 of keys2(value)) {
          if (strict || !shouldSkip(typeOf(value[key2])))
            entries.push([pair(key2), pair(value[key2])]);
        }
        return index3;
      }
      case DATE2:
        return as2([TYPE, value.toISOString()], value);
      case REGEXP: {
        const { source, flags } = value;
        return as2([TYPE, { source, flags }], value);
      }
      case MAP: {
        const entries = [];
        const index3 = as2([TYPE, entries], value);
        for (const [key2, entry] of value) {
          if (strict || !(shouldSkip(typeOf(key2)) || shouldSkip(typeOf(entry))))
            entries.push([pair(key2), pair(entry)]);
        }
        return index3;
      }
      case SET: {
        const entries = [];
        const index3 = as2([TYPE, entries], value);
        for (const entry of value) {
          if (strict || !shouldSkip(typeOf(entry)))
            entries.push(pair(entry));
        }
        return index3;
      }
    }
    const { message: message2 } = value;
    return as2([TYPE, { name: type, message: message2 }], value);
  };
  return pair;
};
var serialize3 = (value, { json, lossy } = {}) => {
  const _ = [];
  return serializer(!(json || lossy), !!json, /* @__PURE__ */ new Map(), _)(value), _;
};

// node_modules/@ungap/structured-clone/esm/index.js
var esm_default = typeof structuredClone === "function" ? (
  /* c8 ignore start */
  (any, options) => options && ("json" in options || "lossy" in options) ? deserialize(serialize3(any, options)) : structuredClone(any)
) : (any, options) => deserialize(serialize3(any, options));

// node_modules/mdast-util-to-hast/lib/footer.js
function defaultFootnoteBackContent(_, rereferenceIndex) {
  const result = [{ type: "text", value: "\u21A9" }];
  if (rereferenceIndex > 1) {
    result.push({
      type: "element",
      tagName: "sup",
      properties: {},
      children: [{ type: "text", value: String(rereferenceIndex) }]
    });
  }
  return result;
}
function defaultFootnoteBackLabel(referenceIndex, rereferenceIndex) {
  return "Back to reference " + (referenceIndex + 1) + (rereferenceIndex > 1 ? "-" + rereferenceIndex : "");
}
function footer(state) {
  const clobberPrefix = typeof state.options.clobberPrefix === "string" ? state.options.clobberPrefix : "user-content-";
  const footnoteBackContent = state.options.footnoteBackContent || defaultFootnoteBackContent;
  const footnoteBackLabel = state.options.footnoteBackLabel || defaultFootnoteBackLabel;
  const footnoteLabel = state.options.footnoteLabel || "Footnotes";
  const footnoteLabelTagName = state.options.footnoteLabelTagName || "h2";
  const footnoteLabelProperties = state.options.footnoteLabelProperties || {
    className: ["sr-only"]
  };
  const listItems = [];
  let referenceIndex = -1;
  while (++referenceIndex < state.footnoteOrder.length) {
    const definition3 = state.footnoteById.get(
      state.footnoteOrder[referenceIndex]
    );
    if (!definition3) {
      continue;
    }
    const content3 = state.all(definition3);
    const id = String(definition3.identifier).toUpperCase();
    const safeId = normalizeUri(id.toLowerCase());
    let rereferenceIndex = 0;
    const backReferences = [];
    const counts = state.footnoteCounts.get(id);
    while (counts !== void 0 && ++rereferenceIndex <= counts) {
      if (backReferences.length > 0) {
        backReferences.push({ type: "text", value: " " });
      }
      let children = typeof footnoteBackContent === "string" ? footnoteBackContent : footnoteBackContent(referenceIndex, rereferenceIndex);
      if (typeof children === "string") {
        children = { type: "text", value: children };
      }
      backReferences.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + clobberPrefix + "fnref-" + safeId + (rereferenceIndex > 1 ? "-" + rereferenceIndex : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof footnoteBackLabel === "string" ? footnoteBackLabel : footnoteBackLabel(referenceIndex, rereferenceIndex),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(children) ? children : [children]
      });
    }
    const tail = content3[content3.length - 1];
    if (tail && tail.type === "element" && tail.tagName === "p") {
      const tailTail = tail.children[tail.children.length - 1];
      if (tailTail && tailTail.type === "text") {
        tailTail.value += " ";
      } else {
        tail.children.push({ type: "text", value: " " });
      }
      tail.children.push(...backReferences);
    } else {
      content3.push(...backReferences);
    }
    const listItem3 = {
      type: "element",
      tagName: "li",
      properties: { id: clobberPrefix + "fn-" + safeId },
      children: state.wrap(content3, true)
    };
    state.patch(definition3, listItem3);
    listItems.push(listItem3);
  }
  if (listItems.length === 0) {
    return;
  }
  return {
    type: "element",
    tagName: "section",
    properties: { dataFootnotes: true, className: ["footnotes"] },
    children: [
      {
        type: "element",
        tagName: footnoteLabelTagName,
        properties: {
          ...esm_default(footnoteLabelProperties),
          id: "footnote-label"
        },
        children: [{ type: "text", value: footnoteLabel }]
      },
      { type: "text", value: "\n" },
      {
        type: "element",
        tagName: "ol",
        properties: {},
        children: state.wrap(listItems, true)
      },
      { type: "text", value: "\n" }
    ]
  };
}

// node_modules/mdast-util-to-hast/lib/state.js
init_process();
init_buffer();
var own7 = {}.hasOwnProperty;
var emptyOptions5 = {};
function createState(tree, options) {
  const settings = options || emptyOptions5;
  const definitionById = /* @__PURE__ */ new Map();
  const footnoteById = /* @__PURE__ */ new Map();
  const footnoteCounts = /* @__PURE__ */ new Map();
  const handlers2 = { ...handlers, ...settings.handlers };
  const state = {
    all: all4,
    applyData,
    definitionById,
    footnoteById,
    footnoteCounts,
    footnoteOrder: [],
    handlers: handlers2,
    one: one4,
    options: settings,
    patch,
    wrap
  };
  visit(tree, function(node3) {
    if (node3.type === "definition" || node3.type === "footnoteDefinition") {
      const map9 = node3.type === "definition" ? definitionById : footnoteById;
      const id = String(node3.identifier).toUpperCase();
      if (!map9.has(id)) {
        map9.set(id, node3);
      }
    }
  });
  return state;
  function one4(node3, parent) {
    const type = node3.type;
    const handle3 = state.handlers[type];
    if (own7.call(state.handlers, type) && handle3) {
      return handle3(state, node3, parent);
    }
    if (state.options.passThrough && state.options.passThrough.includes(type)) {
      if ("children" in node3) {
        const { children, ...shallow } = node3;
        const result = esm_default(shallow);
        result.children = state.all(node3);
        return result;
      }
      return esm_default(node3);
    }
    const unknown2 = state.options.unknownHandler || defaultUnknownHandler;
    return unknown2(state, node3, parent);
  }
  function all4(parent) {
    const values = [];
    if ("children" in parent) {
      const nodes = parent.children;
      let index3 = -1;
      while (++index3 < nodes.length) {
        const result = state.one(nodes[index3], parent);
        if (result) {
          if (index3 && nodes[index3 - 1].type === "break") {
            if (!Array.isArray(result) && result.type === "text") {
              result.value = trimMarkdownSpaceStart(result.value);
            }
            if (!Array.isArray(result) && result.type === "element") {
              const head2 = result.children[0];
              if (head2 && head2.type === "text") {
                head2.value = trimMarkdownSpaceStart(head2.value);
              }
            }
          }
          if (Array.isArray(result)) {
            values.push(...result);
          } else {
            values.push(result);
          }
        }
      }
    }
    return values;
  }
}
function patch(from3, to) {
  if (from3.position)
    to.position = position2(from3);
}
function applyData(from3, to) {
  let result = to;
  if (from3 && from3.data) {
    const hName = from3.data.hName;
    const hChildren = from3.data.hChildren;
    const hProperties = from3.data.hProperties;
    if (typeof hName === "string") {
      if (result.type === "element") {
        result.tagName = hName;
      } else {
        const children = "children" in result ? result.children : [result];
        result = { type: "element", tagName: hName, properties: {}, children };
      }
    }
    if (result.type === "element" && hProperties) {
      Object.assign(result.properties, esm_default(hProperties));
    }
    if ("children" in result && result.children && hChildren !== null && hChildren !== void 0) {
      result.children = hChildren;
    }
  }
  return result;
}
function defaultUnknownHandler(state, node3) {
  const data = node3.data || {};
  const result = "value" in node3 && !(own7.call(data, "hProperties") || own7.call(data, "hChildren")) ? { type: "text", value: node3.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: state.all(node3)
  };
  state.patch(node3, result);
  return state.applyData(node3, result);
}
function wrap(nodes, loose) {
  const result = [];
  let index3 = -1;
  if (loose) {
    result.push({ type: "text", value: "\n" });
  }
  while (++index3 < nodes.length) {
    if (index3)
      result.push({ type: "text", value: "\n" });
    result.push(nodes[index3]);
  }
  if (loose && nodes.length > 0) {
    result.push({ type: "text", value: "\n" });
  }
  return result;
}
function trimMarkdownSpaceStart(value) {
  let index3 = 0;
  let code4 = value.charCodeAt(index3);
  while (code4 === 9 || code4 === 32) {
    index3++;
    code4 = value.charCodeAt(index3);
  }
  return value.slice(index3);
}

// node_modules/mdast-util-to-hast/lib/index.js
function toHast(tree, options) {
  const state = createState(tree, options);
  const node3 = state.one(tree, void 0);
  const foot = footer(state);
  const result = Array.isArray(node3) ? { type: "root", children: node3 } : node3 || { type: "root", children: [] };
  if (foot) {
    ok("children" in result);
    result.children.push({ type: "text", value: "\n" }, foot);
  }
  return result;
}

// node_modules/remark-rehype/lib/index.js
init_process();
init_buffer();
function remarkRehype(destination, options) {
  if (destination && "run" in destination) {
    return async function(tree, file) {
      const hastTree = (
        /** @type {HastRoot} */
        toHast(tree, { file, ...options })
      );
      await destination.run(hastTree, file);
    };
  }
  return function(tree, file) {
    return (
      /** @type {HastRoot} */
      toHast(tree, { file, ...options || destination })
    );
  };
}

// node_modules/unified/index.js
init_process();
init_buffer();

// node_modules/unified/lib/index.js
init_process();
init_buffer();

// node_modules/bail/index.js
init_process();
init_buffer();
function bail(error3) {
  if (error3) {
    throw error3;
  }
}

// node_modules/unified/lib/index.js
var import_extend = __toESM(require_extend(), 1);

// node_modules/is-plain-obj/index.js
init_process();
init_buffer();
function isPlainObject(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}

// node_modules/trough/index.js
init_process();
init_buffer();

// node_modules/trough/lib/index.js
init_process();
init_buffer();
function trough() {
  const fns = [];
  const pipeline = { run, use };
  return pipeline;
  function run(...values) {
    let middlewareIndex = -1;
    const callback = values.pop();
    if (typeof callback !== "function") {
      throw new TypeError("Expected function as last argument, not " + callback);
    }
    next(null, ...values);
    function next(error3, ...output) {
      const fn = fns[++middlewareIndex];
      let index3 = -1;
      if (error3) {
        callback(error3);
        return;
      }
      while (++index3 < values.length) {
        if (output[index3] === null || output[index3] === void 0) {
          output[index3] = values[index3];
        }
      }
      values = output;
      if (fn) {
        wrap2(fn, next)(...output);
      } else {
        callback(null, ...output);
      }
    }
  }
  function use(middelware) {
    if (typeof middelware !== "function") {
      throw new TypeError(
        "Expected `middelware` to be a function, not " + middelware
      );
    }
    fns.push(middelware);
    return pipeline;
  }
}
function wrap2(middleware, callback) {
  let called;
  return wrapped;
  function wrapped(...parameters) {
    const fnExpectsCallback = middleware.length > parameters.length;
    let result;
    if (fnExpectsCallback) {
      parameters.push(done2);
    }
    try {
      result = middleware.apply(this, parameters);
    } catch (error3) {
      const exception = (
        /** @type {Error} */
        error3
      );
      if (fnExpectsCallback && called) {
        throw exception;
      }
      return done2(exception);
    }
    if (!fnExpectsCallback) {
      if (result && result.then && typeof result.then === "function") {
        result.then(then, done2);
      } else if (result instanceof Error) {
        done2(result);
      } else {
        then(result);
      }
    }
  }
  function done2(error3, ...output) {
    if (!called) {
      called = true;
      callback(error3, ...output);
    }
  }
  function then(value) {
    done2(null, value);
  }
}

// node_modules/vfile/index.js
init_process();
init_buffer();

// node_modules/vfile/lib/index.js
init_process();
init_buffer();

// node_modules/vfile-message/index.js
init_process();
init_buffer();

// node_modules/vfile-message/lib/index.js
init_process();
init_buffer();

// node_modules/vfile-message/node_modules/unist-util-stringify-position/index.js
init_process();
init_buffer();

// node_modules/vfile-message/node_modules/unist-util-stringify-position/lib/index.js
init_process();
init_buffer();
function stringifyPosition2(value) {
  if (!value || typeof value !== "object") {
    return "";
  }
  if ("position" in value || "type" in value) {
    return position3(value.position);
  }
  if ("start" in value || "end" in value) {
    return position3(value);
  }
  if ("line" in value || "column" in value) {
    return point4(value);
  }
  return "";
}
function point4(point5) {
  return index2(point5 && point5.line) + ":" + index2(point5 && point5.column);
}
function position3(pos) {
  return point4(pos && pos.start) + "-" + point4(pos && pos.end);
}
function index2(value) {
  return value && typeof value === "number" ? value : 1;
}

// node_modules/vfile-message/lib/index.js
var VFileMessage = class extends Error {
  /**
   * Create a message for `reason`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(causeOrReason, optionsOrParentOrPlace, origin) {
    super();
    if (typeof optionsOrParentOrPlace === "string") {
      origin = optionsOrParentOrPlace;
      optionsOrParentOrPlace = void 0;
    }
    let reason = "";
    let options = {};
    let legacyCause = false;
    if (optionsOrParentOrPlace) {
      if ("line" in optionsOrParentOrPlace && "column" in optionsOrParentOrPlace) {
        options = { place: optionsOrParentOrPlace };
      } else if ("start" in optionsOrParentOrPlace && "end" in optionsOrParentOrPlace) {
        options = { place: optionsOrParentOrPlace };
      } else if ("type" in optionsOrParentOrPlace) {
        options = {
          ancestors: [optionsOrParentOrPlace],
          place: optionsOrParentOrPlace.position
        };
      } else {
        options = { ...optionsOrParentOrPlace };
      }
    }
    if (typeof causeOrReason === "string") {
      reason = causeOrReason;
    } else if (!options.cause && causeOrReason) {
      legacyCause = true;
      reason = causeOrReason.message;
      options.cause = causeOrReason;
    }
    if (!options.ruleId && !options.source && typeof origin === "string") {
      const index3 = origin.indexOf(":");
      if (index3 === -1) {
        options.ruleId = origin;
      } else {
        options.source = origin.slice(0, index3);
        options.ruleId = origin.slice(index3 + 1);
      }
    }
    if (!options.place && options.ancestors && options.ancestors) {
      const parent = options.ancestors[options.ancestors.length - 1];
      if (parent) {
        options.place = parent.position;
      }
    }
    const start = options.place && "start" in options.place ? options.place.start : options.place;
    this.ancestors = options.ancestors || void 0;
    this.cause = options.cause || void 0;
    this.column = start ? start.column : void 0;
    this.fatal = void 0;
    this.file;
    this.message = reason;
    this.line = start ? start.line : void 0;
    this.name = stringifyPosition2(options.place) || "1:1";
    this.place = options.place || void 0;
    this.reason = this.message;
    this.ruleId = options.ruleId || void 0;
    this.source = options.source || void 0;
    this.stack = legacyCause && options.cause && typeof options.cause.stack === "string" ? options.cause.stack : "";
    this.actual;
    this.expected;
    this.note;
    this.url;
  }
};
VFileMessage.prototype.file = "";
VFileMessage.prototype.name = "";
VFileMessage.prototype.reason = "";
VFileMessage.prototype.message = "";
VFileMessage.prototype.stack = "";
VFileMessage.prototype.column = void 0;
VFileMessage.prototype.line = void 0;
VFileMessage.prototype.ancestors = void 0;
VFileMessage.prototype.cause = void 0;
VFileMessage.prototype.fatal = void 0;
VFileMessage.prototype.place = void 0;
VFileMessage.prototype.ruleId = void 0;
VFileMessage.prototype.source = void 0;

// node_modules/vfile/lib/minpath.browser.js
init_process();
init_buffer();
var minpath = { basename: basename2, dirname: dirname2, extname: extname2, join: join2, sep: "/" };
function basename2(path2, extname3) {
  if (extname3 !== void 0 && typeof extname3 !== "string") {
    throw new TypeError('"ext" argument must be a string');
  }
  assertPath(path2);
  let start = 0;
  let end = -1;
  let index3 = path2.length;
  let seenNonSlash;
  if (extname3 === void 0 || extname3.length === 0 || extname3.length > path2.length) {
    while (index3--) {
      if (path2.codePointAt(index3) === 47) {
        if (seenNonSlash) {
          start = index3 + 1;
          break;
        }
      } else if (end < 0) {
        seenNonSlash = true;
        end = index3 + 1;
      }
    }
    return end < 0 ? "" : path2.slice(start, end);
  }
  if (extname3 === path2) {
    return "";
  }
  let firstNonSlashEnd = -1;
  let extnameIndex = extname3.length - 1;
  while (index3--) {
    if (path2.codePointAt(index3) === 47) {
      if (seenNonSlash) {
        start = index3 + 1;
        break;
      }
    } else {
      if (firstNonSlashEnd < 0) {
        seenNonSlash = true;
        firstNonSlashEnd = index3 + 1;
      }
      if (extnameIndex > -1) {
        if (path2.codePointAt(index3) === extname3.codePointAt(extnameIndex--)) {
          if (extnameIndex < 0) {
            end = index3;
          }
        } else {
          extnameIndex = -1;
          end = firstNonSlashEnd;
        }
      }
    }
  }
  if (start === end) {
    end = firstNonSlashEnd;
  } else if (end < 0) {
    end = path2.length;
  }
  return path2.slice(start, end);
}
function dirname2(path2) {
  assertPath(path2);
  if (path2.length === 0) {
    return ".";
  }
  let end = -1;
  let index3 = path2.length;
  let unmatchedSlash;
  while (--index3) {
    if (path2.codePointAt(index3) === 47) {
      if (unmatchedSlash) {
        end = index3;
        break;
      }
    } else if (!unmatchedSlash) {
      unmatchedSlash = true;
    }
  }
  return end < 0 ? path2.codePointAt(0) === 47 ? "/" : "." : end === 1 && path2.codePointAt(0) === 47 ? "//" : path2.slice(0, end);
}
function extname2(path2) {
  assertPath(path2);
  let index3 = path2.length;
  let end = -1;
  let startPart = 0;
  let startDot = -1;
  let preDotState = 0;
  let unmatchedSlash;
  while (index3--) {
    const code4 = path2.codePointAt(index3);
    if (code4 === 47) {
      if (unmatchedSlash) {
        startPart = index3 + 1;
        break;
      }
      continue;
    }
    if (end < 0) {
      unmatchedSlash = true;
      end = index3 + 1;
    }
    if (code4 === 46) {
      if (startDot < 0) {
        startDot = index3;
      } else if (preDotState !== 1) {
        preDotState = 1;
      }
    } else if (startDot > -1) {
      preDotState = -1;
    }
  }
  if (startDot < 0 || end < 0 || // We saw a non-dot character immediately before the dot.
  preDotState === 0 || // The (right-most) trimmed path component is exactly `..`.
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path2.slice(startDot, end);
}
function join2(...segments) {
  let index3 = -1;
  let joined;
  while (++index3 < segments.length) {
    assertPath(segments[index3]);
    if (segments[index3]) {
      joined = joined === void 0 ? segments[index3] : joined + "/" + segments[index3];
    }
  }
  return joined === void 0 ? "." : normalize3(joined);
}
function normalize3(path2) {
  assertPath(path2);
  const absolute = path2.codePointAt(0) === 47;
  let value = normalizeString(path2, !absolute);
  if (value.length === 0 && !absolute) {
    value = ".";
  }
  if (value.length > 0 && path2.codePointAt(path2.length - 1) === 47) {
    value += "/";
  }
  return absolute ? "/" + value : value;
}
function normalizeString(path2, allowAboveRoot) {
  let result = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let index3 = -1;
  let code4;
  let lastSlashIndex;
  while (++index3 <= path2.length) {
    if (index3 < path2.length) {
      code4 = path2.codePointAt(index3);
    } else if (code4 === 47) {
      break;
    } else {
      code4 = 47;
    }
    if (code4 === 47) {
      if (lastSlash === index3 - 1 || dots === 1) {
      } else if (lastSlash !== index3 - 1 && dots === 2) {
        if (result.length < 2 || lastSegmentLength !== 2 || result.codePointAt(result.length - 1) !== 46 || result.codePointAt(result.length - 2) !== 46) {
          if (result.length > 2) {
            lastSlashIndex = result.lastIndexOf("/");
            if (lastSlashIndex !== result.length - 1) {
              if (lastSlashIndex < 0) {
                result = "";
                lastSegmentLength = 0;
              } else {
                result = result.slice(0, lastSlashIndex);
                lastSegmentLength = result.length - 1 - result.lastIndexOf("/");
              }
              lastSlash = index3;
              dots = 0;
              continue;
            }
          } else if (result.length > 0) {
            result = "";
            lastSegmentLength = 0;
            lastSlash = index3;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          result = result.length > 0 ? result + "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (result.length > 0) {
          result += "/" + path2.slice(lastSlash + 1, index3);
        } else {
          result = path2.slice(lastSlash + 1, index3);
        }
        lastSegmentLength = index3 - lastSlash - 1;
      }
      lastSlash = index3;
      dots = 0;
    } else if (code4 === 46 && dots > -1) {
      dots++;
    } else {
      dots = -1;
    }
  }
  return result;
}
function assertPath(path2) {
  if (typeof path2 !== "string") {
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(path2)
    );
  }
}

// node_modules/vfile/lib/minproc.browser.js
init_process();
init_buffer();
var minproc = { cwd: cwd3 };
function cwd3() {
  return "/";
}

// node_modules/vfile/lib/minurl.browser.js
init_process();
init_buffer();

// node_modules/vfile/lib/minurl.shared.js
init_process();
init_buffer();
function isUrl(fileUrlOrPath) {
  return Boolean(
    fileUrlOrPath !== null && typeof fileUrlOrPath === "object" && "href" in fileUrlOrPath && fileUrlOrPath.href && "protocol" in fileUrlOrPath && fileUrlOrPath.protocol && // @ts-expect-error: indexing is fine.
    fileUrlOrPath.auth === void 0
  );
}

// node_modules/vfile/lib/minurl.browser.js
function urlToPath(path2) {
  if (typeof path2 === "string") {
    path2 = new URL(path2);
  } else if (!isUrl(path2)) {
    const error3 = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + path2 + "`"
    );
    error3.code = "ERR_INVALID_ARG_TYPE";
    throw error3;
  }
  if (path2.protocol !== "file:") {
    const error3 = new TypeError("The URL must be of scheme file");
    error3.code = "ERR_INVALID_URL_SCHEME";
    throw error3;
  }
  return getPathFromURLPosix(path2);
}
function getPathFromURLPosix(url) {
  if (url.hostname !== "") {
    const error3 = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    error3.code = "ERR_INVALID_FILE_URL_HOST";
    throw error3;
  }
  const pathname = url.pathname;
  let index3 = -1;
  while (++index3 < pathname.length) {
    if (pathname.codePointAt(index3) === 37 && pathname.codePointAt(index3 + 1) === 50) {
      const third = pathname.codePointAt(index3 + 2);
      if (third === 70 || third === 102) {
        const error3 = new TypeError(
          "File URL path must not include encoded / characters"
        );
        error3.code = "ERR_INVALID_FILE_URL_PATH";
        throw error3;
      }
    }
  }
  return decodeURIComponent(pathname);
}

// node_modules/vfile/lib/index.js
var order = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
var VFile = class {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array` — `{value: options}`
   * *   `URL` — `{path: options}`
   * *   `VFile` — shallow copies its data over to the new file
   * *   `object` — all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(value) {
    let options;
    if (!value) {
      options = {};
    } else if (isUrl(value)) {
      options = { path: value };
    } else if (typeof value === "string" || isUint8Array(value)) {
      options = { value };
    } else {
      options = value;
    }
    this.cwd = "cwd" in options ? "" : minproc.cwd();
    this.data = {};
    this.history = [];
    this.messages = [];
    this.value;
    this.map;
    this.result;
    this.stored;
    let index3 = -1;
    while (++index3 < order.length) {
      const field2 = order[index3];
      if (field2 in options && options[field2] !== void 0 && options[field2] !== null) {
        this[field2] = field2 === "history" ? [...options[field2]] : options[field2];
      }
    }
    let field;
    for (field in options) {
      if (!order.includes(field)) {
        this[field] = options[field];
      }
    }
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path === "string" ? minpath.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(basename3) {
    assertNonEmpty(basename3, "basename");
    assertPart(basename3, "basename");
    this.path = minpath.join(this.dirname || "", basename3);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path === "string" ? minpath.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if there’s no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(dirname3) {
    assertPath2(this.basename, "dirname");
    this.path = minpath.join(dirname3 || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path === "string" ? minpath.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if there’s no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(extname3) {
    assertPart(extname3, "extname");
    assertPath2(this.dirname, "extname");
    if (extname3) {
      if (extname3.codePointAt(0) !== 46) {
        throw new Error("`extname` must start with `.`");
      }
      if (extname3.includes(".", 1)) {
        throw new Error("`extname` cannot contain multiple dots");
      }
    }
    this.path = minpath.join(this.dirname, this.stem + (extname3 || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(path2) {
    if (isUrl(path2)) {
      path2 = urlToPath(path2);
    }
    assertNonEmpty(path2, "path");
    if (this.path !== path2) {
      this.history.push(path2);
    }
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path === "string" ? minpath.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(stem) {
    assertNonEmpty(stem, "stem");
    assertPart(stem, "stem");
    this.path = minpath.join(this.dirname || "", stem + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(causeOrReason, optionsOrParentOrPlace, origin) {
    const message2 = this.message(causeOrReason, optionsOrParentOrPlace, origin);
    message2.fatal = true;
    throw message2;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(causeOrReason, optionsOrParentOrPlace, origin) {
    const message2 = this.message(causeOrReason, optionsOrParentOrPlace, origin);
    message2.fatal = void 0;
    return message2;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(causeOrReason, optionsOrParentOrPlace, origin) {
    const message2 = new VFileMessage(
      // @ts-expect-error: the overloads are fine.
      causeOrReason,
      optionsOrParentOrPlace,
      origin
    );
    if (this.path) {
      message2.name = this.path + ":" + message2.name;
      message2.file = this.path;
    }
    message2.fatal = false;
    this.messages.push(message2);
    return message2;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when it’s a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(encoding) {
    if (this.value === void 0) {
      return "";
    }
    if (typeof this.value === "string") {
      return this.value;
    }
    const decoder2 = new TextDecoder(encoding || void 0);
    return decoder2.decode(this.value);
  }
};
function assertPart(part, name) {
  if (part && part.includes(minpath.sep)) {
    throw new Error(
      "`" + name + "` cannot be a path: did not expect `" + minpath.sep + "`"
    );
  }
}
function assertNonEmpty(part, name) {
  if (!part) {
    throw new Error("`" + name + "` cannot be empty");
  }
}
function assertPath2(path2, name) {
  if (!path2) {
    throw new Error("Setting `" + name + "` requires `path` to be set too");
  }
}
function isUint8Array(value) {
  return Boolean(
    value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
  );
}

// node_modules/unified/lib/callable-instance.js
init_process();
init_buffer();
var CallableInstance = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(property) {
    const self2 = this;
    const constr = self2.constructor;
    const proto = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      constr.prototype
    );
    const value = proto[property];
    const apply = function() {
      return value.apply(apply, arguments);
    };
    Object.setPrototypeOf(apply, proto);
    return apply;
  }
);

// node_modules/unified/lib/index.js
var own8 = {}.hasOwnProperty;
var Processor = class extends CallableInstance {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy");
    this.Compiler = void 0;
    this.Parser = void 0;
    this.attachers = [];
    this.compiler = void 0;
    this.freezeIndex = -1;
    this.frozen = void 0;
    this.namespace = {};
    this.parser = void 0;
    this.transformers = trough();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const destination = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new Processor()
    );
    let index3 = -1;
    while (++index3 < this.attachers.length) {
      const attacher = this.attachers[index3];
      destination.use(...attacher);
    }
    destination.data((0, import_extend.default)(true, {}, this.namespace));
    return destination;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(key2, value) {
    if (typeof key2 === "string") {
      if (arguments.length === 2) {
        assertUnfrozen("data", this.frozen);
        this.namespace[key2] = value;
        return this;
      }
      return own8.call(this.namespace, key2) && this.namespace[key2] || void 0;
    }
    if (key2) {
      assertUnfrozen("data", this.frozen);
      this.namespace = key2;
      return this;
    }
    return this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * It’s possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen) {
      return this;
    }
    const self2 = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    while (++this.freezeIndex < this.attachers.length) {
      const [attacher, ...options] = this.attachers[this.freezeIndex];
      if (options[0] === false) {
        continue;
      }
      if (options[0] === true) {
        options[0] = void 0;
      }
      const transformer = attacher.call(self2, ...options);
      if (typeof transformer === "function") {
        this.transformers.use(transformer);
      }
    }
    this.frozen = true;
    this.freezeIndex = Number.POSITIVE_INFINITY;
    return this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(file) {
    this.freeze();
    const realFile = vfile(file);
    const parser = this.parser || this.Parser;
    assertParser("parse", parser);
    return parser(String(realFile), realFile);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(file, done2) {
    const self2 = this;
    this.freeze();
    assertParser("process", this.parser || this.Parser);
    assertCompiler("process", this.compiler || this.Compiler);
    return done2 ? executor(void 0, done2) : new Promise(executor);
    function executor(resolve2, reject) {
      const realFile = vfile(file);
      const parseTree = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        self2.parse(realFile)
      );
      self2.run(parseTree, realFile, function(error3, tree, file2) {
        if (error3 || !tree || !file2) {
          return realDone(error3);
        }
        const compileTree = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          tree
        );
        const compileResult = self2.stringify(compileTree, file2);
        if (looksLikeAValue(compileResult)) {
          file2.value = compileResult;
        } else {
          file2.result = compileResult;
        }
        realDone(
          error3,
          /** @type {VFileWithOutput<CompileResult>} */
          file2
        );
      });
      function realDone(error3, file2) {
        if (error3 || !file2) {
          reject(error3);
        } else if (resolve2) {
          resolve2(file2);
        } else {
          ok(done2, "`done` is defined if `resolve` is not");
          done2(void 0, file2);
        }
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(file) {
    let complete = false;
    let result;
    this.freeze();
    assertParser("processSync", this.parser || this.Parser);
    assertCompiler("processSync", this.compiler || this.Compiler);
    this.process(file, realDone);
    assertDone("processSync", "process", complete);
    ok(result, "we either bailed on an error or have a tree");
    return result;
    function realDone(error3, file2) {
      complete = true;
      bail(error3);
      result = file2;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(tree, file, done2) {
    assertNode(tree);
    this.freeze();
    const transformers = this.transformers;
    if (!done2 && typeof file === "function") {
      done2 = file;
      file = void 0;
    }
    return done2 ? executor(void 0, done2) : new Promise(executor);
    function executor(resolve2, reject) {
      ok(
        typeof file !== "function",
        "`file` can\u2019t be a `done` anymore, we checked"
      );
      const realFile = vfile(file);
      transformers.run(tree, realFile, realDone);
      function realDone(error3, outputTree, file2) {
        const resultingTree = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          outputTree || tree
        );
        if (error3) {
          reject(error3);
        } else if (resolve2) {
          resolve2(resultingTree);
        } else {
          ok(done2, "`done` is defined if `resolve` is not");
          done2(void 0, resultingTree, file2);
        }
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(tree, file) {
    let complete = false;
    let result;
    this.run(tree, file, realDone);
    assertDone("runSync", "run", complete);
    ok(result, "we either bailed on an error or have a tree");
    return result;
    function realDone(error3, tree2) {
      bail(error3);
      result = tree2;
      complete = true;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(tree, file) {
    this.freeze();
    const realFile = vfile(file);
    const compiler2 = this.compiler || this.Compiler;
    assertCompiler("stringify", compiler2);
    assertNode(tree);
    return compiler2(tree, realFile);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(value, ...parameters) {
    const attachers = this.attachers;
    const namespace = this.namespace;
    assertUnfrozen("use", this.frozen);
    if (value === null || value === void 0) {
    } else if (typeof value === "function") {
      addPlugin(value, parameters);
    } else if (typeof value === "object") {
      if (Array.isArray(value)) {
        addList(value);
      } else {
        addPreset(value);
      }
    } else {
      throw new TypeError("Expected usable value, not `" + value + "`");
    }
    return this;
    function add(value2) {
      if (typeof value2 === "function") {
        addPlugin(value2, []);
      } else if (typeof value2 === "object") {
        if (Array.isArray(value2)) {
          const [plugin, ...parameters2] = (
            /** @type {PluginTuple<Array<unknown>>} */
            value2
          );
          addPlugin(plugin, parameters2);
        } else {
          addPreset(value2);
        }
      } else {
        throw new TypeError("Expected usable value, not `" + value2 + "`");
      }
    }
    function addPreset(result) {
      if (!("plugins" in result) && !("settings" in result)) {
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      }
      addList(result.plugins);
      if (result.settings) {
        namespace.settings = (0, import_extend.default)(true, namespace.settings, result.settings);
      }
    }
    function addList(plugins) {
      let index3 = -1;
      if (plugins === null || plugins === void 0) {
      } else if (Array.isArray(plugins)) {
        while (++index3 < plugins.length) {
          const thing = plugins[index3];
          add(thing);
        }
      } else {
        throw new TypeError("Expected a list of plugins, not `" + plugins + "`");
      }
    }
    function addPlugin(plugin, parameters2) {
      let index3 = -1;
      let entryIndex = -1;
      while (++index3 < attachers.length) {
        if (attachers[index3][0] === plugin) {
          entryIndex = index3;
          break;
        }
      }
      if (entryIndex === -1) {
        attachers.push([plugin, ...parameters2]);
      } else if (parameters2.length > 0) {
        let [primary, ...rest] = parameters2;
        const currentPrimary = attachers[entryIndex][1];
        if (isPlainObject(currentPrimary) && isPlainObject(primary)) {
          primary = (0, import_extend.default)(true, currentPrimary, primary);
        }
        attachers[entryIndex] = [plugin, primary, ...rest];
      }
    }
  }
};
var unified = new Processor().freeze();
function assertParser(name, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name + "` without `parser`");
  }
}
function assertCompiler(name, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name + "` without `compiler`");
  }
}
function assertUnfrozen(name, frozen) {
  if (frozen) {
    throw new Error(
      "Cannot call `" + name + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
  }
}
function assertNode(node3) {
  if (!isPlainObject(node3) || typeof node3.type !== "string") {
    throw new TypeError("Expected node, got `" + node3 + "`");
  }
}
function assertDone(name, asyncName, complete) {
  if (!complete) {
    throw new Error(
      "`" + name + "` finished async. Use `" + asyncName + "` instead"
    );
  }
}
function vfile(value) {
  return looksLikeAVFile(value) ? value : new VFile(value);
}
function looksLikeAVFile(value) {
  return Boolean(
    value && typeof value === "object" && "message" in value && "messages" in value
  );
}
function looksLikeAValue(value) {
  return typeof value === "string" || isUint8Array2(value);
}
function isUint8Array2(value) {
  return Boolean(
    value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
  );
}

// server/src/services/rss.ts
function RSSService() {
  const env5 = getEnv();
  const endpoint = env5.S3_ENDPOINT;
  const accessHost = env5.S3_ACCESS_HOST || endpoint;
  const folder = env5.S3_CACHE_FOLDER || "cache/";
  return new Elysia({ aot: false }).get("/sub/:name", async ({ set, params: { name } }) => {
    const host = `${accessHost.startsWith("http://") || accessHost.startsWith("https://") ? "" : "https://"}${accessHost}`;
    if (!host) {
      set.status = 500;
      return "S3_ACCESS_HOST is not defined";
    }
    if (name === "feed.xml") {
      name = "rss.xml";
    }
    if (["rss.xml", "atom.xml", "rss.json"].includes(name)) {
      const key2 = path_default.join(folder, name);
      try {
        const url = `${host}/${key2}`;
        console.log(`Fetching ${url}`);
        const response = await fetch(new Request(url));
        const contentType = name === "rss.xml" ? "application/rss+xml; charset=UTF-8" : name === "atom.xml" ? "application/atom+xml; charset=UTF-8" : "application/feed+json; charset=UTF-8";
        return new Response(response.body, {
          status: response.status,
          statusText: response.statusText,
          headers: {
            "Content-Type": contentType,
            "Cache-Control": response.headers.get("Cache-Control") || "public, max-age=3600"
          }
        });
      } catch (e2) {
        console.error(e2);
        set.status = 500;
        return e2.message;
      }
    }
    set.status = 404;
    return "Not Found";
  });
}
async function rssCrontab(env5) {
  const frontendUrl = `${env5.FRONTEND_URL.startsWith("http://") || env5.FRONTEND_URL.startsWith("https://") ? "" : "https://"}${env5.FRONTEND_URL}`;
  const db = drizzle(env5.DB, { schema: schema_exports });
  let title3 = env5.RSS_TITLE;
  const description = env5.RSS_DESCRIPTION || "Feed from Rin";
  if (!title3) {
    const user = await db.query.users.findFirst({ where: eq(users.id, 1) });
    if (!user) {
      return;
    }
    title3 = user.username;
  }
  const feed = new import_feed.Feed({
    title: title3,
    description,
    id: frontendUrl,
    link: frontendUrl,
    favicon: `${frontendUrl}/favicon.png`,
    copyright: "All rights reserved 2024",
    updated: /* @__PURE__ */ new Date(),
    // optional, default = today
    generator: "Feed from Rin",
    // optional, default = 'Feed for Node.js'
    feedLinks: {
      rss: `${frontendUrl}/sub/rss.xml`,
      json: `${frontendUrl}/sub/rss.json`,
      atom: `${frontendUrl}/sub/atom.xml`
    }
  });
  const feed_list = await db.query.feeds.findMany({
    where: and(eq(feeds.draft, 0), eq(feeds.listed, 1)),
    orderBy: [desc(feeds.createdAt), desc(feeds.updatedAt)],
    limit: 20,
    with: {
      user: {
        columns: { id: true, username: true, avatar: true }
      }
    }
  });
  for (const f2 of feed_list) {
    const { summary, content: content3, user, ...other } = f2;
    const file = await unified().use(remarkParse).use(remarkGfm).use(remarkRehype).use(rehypeStringify).process(content3);
    let contentHtml = file.toString();
    feed.addItem({
      title: other.title || "No title",
      id: other.id?.toString() || "0",
      link: `${frontendUrl}/feed/${other.id}`,
      date: other.createdAt,
      description: summary.length > 0 ? summary : content3.length > 100 ? content3.slice(0, 100) : content3,
      content: contentHtml,
      author: [{ name: user.username }],
      image: extractImage(content3) || user.avatar
    });
  }
  console.log("save rss.xml to s3");
  const bucket = env5.S3_BUCKET;
  const folder = env5.S3_CACHE_FOLDER || "cache/";
  const s3 = createS3Client();
  async function save(name, data) {
    const hashkey = path_default.join(folder, name);
    try {
      await s3.send(new PutObjectCommand({ Bucket: bucket, Key: hashkey, Body: data }));
    } catch (e2) {
      console.error(e2.message);
    }
  }
  await save("rss.xml", feed.rss2());
  console.log("Saved atom.xml to s3");
  await save("atom.xml", feed.atom1());
  console.log("Saved rss.json to s3");
  await save("rss.json", feed.json1());
  console.log("Saved rss.xml to s3");
}

// server/src/services/seo.ts
init_process();
init_buffer();
function SEOService() {
  const env5 = getEnv();
  const endpoint = env5.S3_ENDPOINT;
  const accessHost = env5.S3_ACCESS_HOST || endpoint;
  const folder = env5.S3_CACHE_FOLDER || "cache/";
  return new Elysia({ aot: false }).get("/seo/*", async ({ set, params, query }) => {
    if (!accessHost) {
      set.status = 500;
      return "S3_ACCESS_HOST is not defined";
    }
    let url = params["*"];
    for (const key3 in query) {
      url += `&${key3}=${query[key3]}`;
    }
    if (url.endsWith("/") || url === "") {
      url += "index.html";
    }
    const key2 = path_default.join(folder, url);
    try {
      const url2 = `${accessHost}/${key2}`;
      console.log(`Fetching ${url2}`);
      const response = await fetch(new Request(url2));
      return new Response(response.body, {
        status: response.status,
        statusText: response.statusText
      });
    } catch (e2) {
      console.error(e2);
      set.status = 500;
      return e2.message;
    }
  });
}

// server/src/services/storage.ts
init_process();
init_buffer();
function buf2hex(buffer) {
  return [...new Uint8Array(buffer)].map((x2) => x2.toString(16).padStart(2, "0")).join("");
}
function StorageService() {
  const env5 = getEnv();
  const endpoint = env5.S3_ENDPOINT;
  const bucket = env5.S3_BUCKET;
  const folder = env5.S3_FOLDER || "";
  const accessHost = env5.S3_ACCESS_HOST || endpoint;
  const accessKeyId = env5.S3_ACCESS_KEY_ID;
  const secretAccessKey = env5.S3_SECRET_ACCESS_KEY;
  const s3 = createS3Client();
  return new Elysia({ aot: false }).use(setup()).group(
    "/storage",
    (group) => group.post("/", async ({ uid, set, body: { key: key2, file } }) => {
      if (!endpoint) {
        set.status = 500;
        return "S3_ENDPOINT is not defined";
      }
      if (!accessKeyId) {
        set.status = 500;
        return "S3_ACCESS_KEY_ID is not defined";
      }
      if (!secretAccessKey) {
        set.status = 500;
        return "S3_SECRET_ACCESS_KEY is not defined";
      }
      if (!bucket) {
        set.status = 500;
        return "S3_BUCKET is not defined";
      }
      if (!uid) {
        set.status = 401;
        return "Unauthorized";
      }
      const suffix = key2.includes(".") ? key2.split(".").pop() : "";
      const hashArray = await crypto.subtle.digest(
        { name: "SHA-1" },
        await file.arrayBuffer()
      );
      const hash = buf2hex(hashArray);
      const hashkey = path_default.join(folder, hash + "." + suffix);
      try {
        const response = await s3.send(new PutObjectCommand({ Bucket: bucket, Key: hashkey, Body: file, ContentType: file.type }));
        console.info(response);
        return `${accessHost}/${hashkey}`;
      } catch (e2) {
        set.status = 400;
        console.error(e2.message);
        return e2.message;
      }
    }, {
      body: t.Object({
        key: t.String(),
        file: t.File()
      })
    })
  );
}

// server/src/services/user.ts
init_process();
init_buffer();

// wrangler-url:wrangler-url-polyfill
init_process();
init_buffer();

// node-modules-polyfills:url
init_process();
init_buffer();

// node-modules-polyfills:punycode
init_process();
init_buffer();
var maxInt = 2147483647;
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128;
var delimiter2 = "-";
var regexNonASCII = /[^\x20-\x7E]/;
var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
var errors = {
  "overflow": "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
};
var baseMinusTMin = base - tMin;
var floor = Math.floor;
var stringFromCharCode = String.fromCharCode;
function error2(type) {
  throw new RangeError(errors[type]);
}
function map7(array, fn) {
  var length = array.length;
  var result = [];
  while (length--) {
    result[length] = fn(array[length]);
  }
  return result;
}
function mapDomain(string3, fn) {
  var parts = string3.split("@");
  var result = "";
  if (parts.length > 1) {
    result = parts[0] + "@";
    string3 = parts[1];
  }
  string3 = string3.replace(regexSeparators, ".");
  var labels = string3.split(".");
  var encoded = map7(labels, fn).join(".");
  return result + encoded;
}
function ucs2decode(string3) {
  var output = [], counter = 0, length = string3.length, value, extra;
  while (counter < length) {
    value = string3.charCodeAt(counter++);
    if (value >= 55296 && value <= 56319 && counter < length) {
      extra = string3.charCodeAt(counter++);
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}
function digitToBasic(digit, flag) {
  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
}
function adapt(delta, numPoints, firstTime) {
  var k2 = 0;
  delta = firstTime ? floor(delta / damp) : delta >> 1;
  delta += floor(delta / numPoints);
  for (; delta > baseMinusTMin * tMax >> 1; k2 += base) {
    delta = floor(delta / baseMinusTMin);
  }
  return floor(k2 + (baseMinusTMin + 1) * delta / (delta + skew));
}
function encode2(input) {
  var n2, delta, handledCPCount, basicLength, bias, j2, m2, q2, k2, t3, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
  input = ucs2decode(input);
  inputLength = input.length;
  n2 = initialN;
  delta = 0;
  bias = initialBias;
  for (j2 = 0; j2 < inputLength; ++j2) {
    currentValue = input[j2];
    if (currentValue < 128) {
      output.push(stringFromCharCode(currentValue));
    }
  }
  handledCPCount = basicLength = output.length;
  if (basicLength) {
    output.push(delimiter2);
  }
  while (handledCPCount < inputLength) {
    for (m2 = maxInt, j2 = 0; j2 < inputLength; ++j2) {
      currentValue = input[j2];
      if (currentValue >= n2 && currentValue < m2) {
        m2 = currentValue;
      }
    }
    handledCPCountPlusOne = handledCPCount + 1;
    if (m2 - n2 > floor((maxInt - delta) / handledCPCountPlusOne)) {
      error2("overflow");
    }
    delta += (m2 - n2) * handledCPCountPlusOne;
    n2 = m2;
    for (j2 = 0; j2 < inputLength; ++j2) {
      currentValue = input[j2];
      if (currentValue < n2 && ++delta > maxInt) {
        error2("overflow");
      }
      if (currentValue == n2) {
        for (q2 = delta, k2 = base; ; k2 += base) {
          t3 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
          if (q2 < t3) {
            break;
          }
          qMinusT = q2 - t3;
          baseMinusT = base - t3;
          output.push(
            stringFromCharCode(digitToBasic(t3 + qMinusT % baseMinusT, 0))
          );
          q2 = floor(qMinusT / baseMinusT);
        }
        output.push(stringFromCharCode(digitToBasic(q2, 0)));
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
        delta = 0;
        ++handledCPCount;
      }
    }
    ++delta;
    ++n2;
  }
  return output.join("");
}
function toASCII(input) {
  return mapDomain(input, function(string3) {
    return regexNonASCII.test(string3) ? "xn--" + encode2(string3) : string3;
  });
}

// node-modules-polyfills:url
init_util();

// node-modules-polyfills:querystring
init_process();
init_buffer();
function hasOwnProperty3(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var isArray3 = Array.isArray || function(xs) {
  return Object.prototype.toString.call(xs) === "[object Array]";
};
function stringifyPrimitive(v2) {
  switch (typeof v2) {
    case "string":
      return v2;
    case "boolean":
      return v2 ? "true" : "false";
    case "number":
      return isFinite(v2) ? v2 : "";
    default:
      return "";
  }
}
function stringify3(obj, sep2, eq2, name) {
  sep2 = sep2 || "&";
  eq2 = eq2 || "=";
  if (obj === null) {
    obj = void 0;
  }
  if (typeof obj === "object") {
    return map8(objectKeys(obj), function(k2) {
      var ks = encodeURIComponent(stringifyPrimitive(k2)) + eq2;
      if (isArray3(obj[k2])) {
        return map8(obj[k2], function(v2) {
          return ks + encodeURIComponent(stringifyPrimitive(v2));
        }).join(sep2);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k2]));
      }
    }).join(sep2);
  }
  if (!name)
    return "";
  return encodeURIComponent(stringifyPrimitive(name)) + eq2 + encodeURIComponent(stringifyPrimitive(obj));
}
function map8(xs, f2) {
  if (xs.map)
    return xs.map(f2);
  var res = [];
  for (var i2 = 0; i2 < xs.length; i2++) {
    res.push(f2(xs[i2], i2));
  }
  return res;
}
var objectKeys = Object.keys || function(obj) {
  var res = [];
  for (var key2 in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key2))
      res.push(key2);
  }
  return res;
};
function parse4(qs, sep2, eq2, options) {
  sep2 = sep2 || "&";
  eq2 = eq2 || "=";
  var obj = {};
  if (typeof qs !== "string" || qs.length === 0) {
    return obj;
  }
  var regexp = /\+/g;
  qs = qs.split(sep2);
  var maxKeys = 1e3;
  if (options && typeof options.maxKeys === "number") {
    maxKeys = options.maxKeys;
  }
  var len = qs.length;
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }
  for (var i2 = 0; i2 < len; ++i2) {
    var x2 = qs[i2].replace(regexp, "%20"), idx = x2.indexOf(eq2), kstr, vstr, k2, v2;
    if (idx >= 0) {
      kstr = x2.substr(0, idx);
      vstr = x2.substr(idx + 1);
    } else {
      kstr = x2;
      vstr = "";
    }
    k2 = decodeURIComponent(kstr);
    v2 = decodeURIComponent(vstr);
    if (!hasOwnProperty3(obj, k2)) {
      obj[k2] = v2;
    } else if (isArray3(obj[k2])) {
      obj[k2].push(v2);
    } else {
      obj[k2] = [obj[k2], v2];
    }
  }
  return obj;
}

// node-modules-polyfills:url
function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}
var protocolPattern = /^([a-z0-9.+-]+:)/i;
var portPattern = /:[0-9]*$/;
var simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
var delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
var unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
var autoEscape = ["'"].concat(unwise);
var nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
var hostEndingChars = ["/", "?", "#"];
var hostnameMaxLen = 255;
var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
var unsafeProtocol = {
  "javascript": true,
  "javascript:": true
};
var hostlessProtocol = {
  "javascript": true,
  "javascript:": true
};
var slashedProtocol = {
  "http": true,
  "https": true,
  "ftp": true,
  "gopher": true,
  "file": true,
  "http:": true,
  "https:": true,
  "ftp:": true,
  "gopher:": true,
  "file:": true
};
function urlParse(url, parseQueryString2, slashesDenoteHost) {
  if (url && isObject3(url) && url instanceof Url)
    return url;
  var u2 = new Url();
  u2.parse(url, parseQueryString2, slashesDenoteHost);
  return u2;
}
Url.prototype.parse = function(url, parseQueryString2, slashesDenoteHost) {
  return parse5(this, url, parseQueryString2, slashesDenoteHost);
};
function parse5(self2, url, parseQueryString2, slashesDenoteHost) {
  if (!isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }
  var queryIndex = url.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url.indexOf("#") ? "?" : "#", uSplit = url.split(splitter), slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, "/");
  url = uSplit.join(splitter);
  var rest = url;
  rest = rest.trim();
  if (!slashesDenoteHost && url.split("#").length === 1) {
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      self2.path = rest;
      self2.href = rest;
      self2.pathname = simplePath[1];
      if (simplePath[2]) {
        self2.search = simplePath[2];
        if (parseQueryString2) {
          self2.query = parse4(self2.search.substr(1));
        } else {
          self2.query = self2.search.substr(1);
        }
      } else if (parseQueryString2) {
        self2.search = "";
        self2.query = {};
      }
      return self2;
    }
  }
  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    self2.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === "//";
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      self2.slashes = true;
    }
  }
  var i2, hec, l2, p3;
  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
    var hostEnd = -1;
    for (i2 = 0; i2 < hostEndingChars.length; i2++) {
      hec = rest.indexOf(hostEndingChars[i2]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    var auth, atSign;
    if (hostEnd === -1) {
      atSign = rest.lastIndexOf("@");
    } else {
      atSign = rest.lastIndexOf("@", hostEnd);
    }
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      self2.auth = decodeURIComponent(auth);
    }
    hostEnd = -1;
    for (i2 = 0; i2 < nonHostChars.length; i2++) {
      hec = rest.indexOf(nonHostChars[i2]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    if (hostEnd === -1)
      hostEnd = rest.length;
    self2.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);
    parseHost(self2);
    self2.hostname = self2.hostname || "";
    var ipv6Hostname = self2.hostname[0] === "[" && self2.hostname[self2.hostname.length - 1] === "]";
    if (!ipv6Hostname) {
      var hostparts = self2.hostname.split(/\./);
      for (i2 = 0, l2 = hostparts.length; i2 < l2; i2++) {
        var part = hostparts[i2];
        if (!part)
          continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = "";
          for (var j2 = 0, k2 = part.length; j2 < k2; j2++) {
            if (part.charCodeAt(j2) > 127) {
              newpart += "x";
            } else {
              newpart += part[j2];
            }
          }
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i2);
            var notHost = hostparts.slice(i2 + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = "/" + notHost.join(".") + rest;
            }
            self2.hostname = validParts.join(".");
            break;
          }
        }
      }
    }
    if (self2.hostname.length > hostnameMaxLen) {
      self2.hostname = "";
    } else {
      self2.hostname = self2.hostname.toLowerCase();
    }
    if (!ipv6Hostname) {
      self2.hostname = toASCII(self2.hostname);
    }
    p3 = self2.port ? ":" + self2.port : "";
    var h2 = self2.hostname || "";
    self2.host = h2 + p3;
    self2.href += self2.host;
    if (ipv6Hostname) {
      self2.hostname = self2.hostname.substr(1, self2.hostname.length - 2);
      if (rest[0] !== "/") {
        rest = "/" + rest;
      }
    }
  }
  if (!unsafeProtocol[lowerProto]) {
    for (i2 = 0, l2 = autoEscape.length; i2 < l2; i2++) {
      var ae2 = autoEscape[i2];
      if (rest.indexOf(ae2) === -1)
        continue;
      var esc = encodeURIComponent(ae2);
      if (esc === ae2) {
        esc = escape(ae2);
      }
      rest = rest.split(ae2).join(esc);
    }
  }
  var hash = rest.indexOf("#");
  if (hash !== -1) {
    self2.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf("?");
  if (qm !== -1) {
    self2.search = rest.substr(qm);
    self2.query = rest.substr(qm + 1);
    if (parseQueryString2) {
      self2.query = parse4(self2.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString2) {
    self2.search = "";
    self2.query = {};
  }
  if (rest)
    self2.pathname = rest;
  if (slashedProtocol[lowerProto] && self2.hostname && !self2.pathname) {
    self2.pathname = "/";
  }
  if (self2.pathname || self2.search) {
    p3 = self2.pathname || "";
    var s2 = self2.search || "";
    self2.path = p3 + s2;
  }
  self2.href = format2(self2);
  return self2;
}
function format2(self2) {
  var auth = self2.auth || "";
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ":");
    auth += "@";
  }
  var protocol = self2.protocol || "", pathname = self2.pathname || "", hash = self2.hash || "", host = false, query = "";
  if (self2.host) {
    host = auth + self2.host;
  } else if (self2.hostname) {
    host = auth + (self2.hostname.indexOf(":") === -1 ? self2.hostname : "[" + this.hostname + "]");
    if (self2.port) {
      host += ":" + self2.port;
    }
  }
  if (self2.query && isObject3(self2.query) && Object.keys(self2.query).length) {
    query = stringify3(self2.query);
  }
  var search2 = self2.search || query && "?" + query || "";
  if (protocol && protocol.substr(-1) !== ":")
    protocol += ":";
  if (self2.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = "//" + (host || "");
    if (pathname && pathname.charAt(0) !== "/")
      pathname = "/" + pathname;
  } else if (!host) {
    host = "";
  }
  if (hash && hash.charAt(0) !== "#")
    hash = "#" + hash;
  if (search2 && search2.charAt(0) !== "?")
    search2 = "?" + search2;
  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search2 = search2.replace("#", "%23");
  return protocol + host + pathname + search2 + hash;
}
Url.prototype.format = function() {
  return format2(this);
};
Url.prototype.resolve = function(relative2) {
  return this.resolveObject(urlParse(relative2, false, true)).format();
};
Url.prototype.resolveObject = function(relative2) {
  if (isString(relative2)) {
    var rel = new Url();
    rel.parse(relative2, false, true);
    relative2 = rel;
  }
  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }
  result.hash = relative2.hash;
  if (relative2.href === "") {
    result.href = result.format();
    return result;
  }
  if (relative2.slashes && !relative2.protocol) {
    var rkeys = Object.keys(relative2);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== "protocol")
        result[rkey] = relative2[rkey];
    }
    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
      result.path = result.pathname = "/";
    }
    result.href = result.format();
    return result;
  }
  var relPath;
  if (relative2.protocol && relative2.protocol !== result.protocol) {
    if (!slashedProtocol[relative2.protocol]) {
      var keys3 = Object.keys(relative2);
      for (var v2 = 0; v2 < keys3.length; v2++) {
        var k2 = keys3[v2];
        result[k2] = relative2[k2];
      }
      result.href = result.format();
      return result;
    }
    result.protocol = relative2.protocol;
    if (!relative2.host && !hostlessProtocol[relative2.protocol]) {
      relPath = (relative2.pathname || "").split("/");
      while (relPath.length && !(relative2.host = relPath.shift()))
        ;
      if (!relative2.host)
        relative2.host = "";
      if (!relative2.hostname)
        relative2.hostname = "";
      if (relPath[0] !== "")
        relPath.unshift("");
      if (relPath.length < 2)
        relPath.unshift("");
      result.pathname = relPath.join("/");
    } else {
      result.pathname = relative2.pathname;
    }
    result.search = relative2.search;
    result.query = relative2.query;
    result.host = relative2.host || "";
    result.auth = relative2.auth;
    result.hostname = relative2.hostname || relative2.host;
    result.port = relative2.port;
    if (result.pathname || result.search) {
      var p3 = result.pathname || "";
      var s2 = result.search || "";
      result.path = p3 + s2;
    }
    result.slashes = result.slashes || relative2.slashes;
    result.href = result.format();
    return result;
  }
  var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative2.host || relative2.pathname && relative2.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative2.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
  relPath = relative2.pathname && relative2.pathname.split("/") || [];
  if (psychotic) {
    result.hostname = "";
    result.port = null;
    if (result.host) {
      if (srcPath[0] === "")
        srcPath[0] = result.host;
      else
        srcPath.unshift(result.host);
    }
    result.host = "";
    if (relative2.protocol) {
      relative2.hostname = null;
      relative2.port = null;
      if (relative2.host) {
        if (relPath[0] === "")
          relPath[0] = relative2.host;
        else
          relPath.unshift(relative2.host);
      }
      relative2.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
  }
  var authInHost;
  if (isRelAbs) {
    result.host = relative2.host || relative2.host === "" ? relative2.host : result.host;
    result.hostname = relative2.hostname || relative2.hostname === "" ? relative2.hostname : result.hostname;
    result.search = relative2.search;
    result.query = relative2.query;
    srcPath = relPath;
  } else if (relPath.length) {
    if (!srcPath)
      srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative2.search;
    result.query = relative2.query;
  } else if (!isNullOrUndefined(relative2.search)) {
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative2.search;
    result.query = relative2.query;
    if (!isNull2(result.pathname) || !isNull2(result.search)) {
      result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
    }
    result.href = result.format();
    return result;
  }
  if (!srcPath.length) {
    result.pathname = null;
    if (result.search) {
      result.path = "/" + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (result.host || relative2.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
  var up = 0;
  for (var i2 = srcPath.length; i2 >= 0; i2--) {
    last = srcPath[i2];
    if (last === ".") {
      srcPath.splice(i2, 1);
    } else if (last === "..") {
      srcPath.splice(i2, 1);
      up++;
    } else if (up) {
      srcPath.splice(i2, 1);
      up--;
    }
  }
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift("..");
    }
  }
  if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
    srcPath.unshift("");
  }
  if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
    srcPath.push("");
  }
  var isAbsolute2 = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
  if (psychotic) {
    result.hostname = result.host = isAbsolute2 ? "" : srcPath.length ? srcPath.shift() : "";
    authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }
  mustEndAbs = mustEndAbs || result.host && srcPath.length;
  if (mustEndAbs && !isAbsolute2) {
    srcPath.unshift("");
  }
  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join("/");
  }
  if (!isNull2(result.pathname) || !isNull2(result.search)) {
    result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
  }
  result.auth = relative2.auth || result.auth;
  result.slashes = result.slashes || relative2.slashes;
  result.href = result.format();
  return result;
};
Url.prototype.parseHost = function() {
  return parseHost(this);
};
function parseHost(self2) {
  var host = self2.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ":") {
      self2.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host)
    self2.hostname = host;
}

// wrangler-url:wrangler-url-polyfill
var URL2 = globalThis.URL;

// server/src/services/user.ts
function UserService() {
  const db = getDB();
  return new Elysia({ aot: false }).use(setup()).group(
    "/user",
    (group) => group.get("/github", ({ oauth2: oauth22, headers: { referer }, cookie: { redirect_to } }) => {
      if (!referer) {
        return "Referer not found";
      }
      const referer_url = new URL2(referer);
      redirect_to.value = `${referer_url.protocol}//${referer_url.host}`;
      return oauth22.redirect("GitHub", { scopes: ["read:user"] });
    }).get("/github/callback", async ({ jwt: jwt2, oauth2: oauth22, set, store, query, cookie: { token, redirect_to, state } }) => {
      console.log("state", state.value);
      console.log("p_state", query.state);
      const gh_token = await oauth22.authorize("GitHub");
      const response = await fetch("https://api.github.com/user", {
        headers: {
          Authorization: `Bearer ${gh_token.accessToken}`,
          Accept: "application/json",
          "User-Agent": "elysia"
        }
      });
      const user = await response.json();
      const profile = {
        openid: user.id,
        username: user.name || user.login,
        avatar: user.avatar_url,
        permission: 0
      };
      await db.query.users.findFirst({ where: eq(users.openid, profile.openid) }).then(async (user2) => {
        if (user2) {
          profile.permission = user2.permission;
          await db.update(users).set(profile).where(eq(users.id, user2.id));
          token.set({
            value: await jwt2.sign({ id: user2.id }),
            expires: new Date(Date.now() + 1e3 * 60 * 60 * 24 * 7),
            path: "/"
          });
        } else {
          if (!await store.anyUser(db)) {
            const realTimeCheck = (await db.query.users.findMany())?.length > 0;
            if (!realTimeCheck) {
              profile.permission = 1;
              store.anyUser = async (_) => true;
            }
          }
          const result = await db.insert(users).values(profile).returning({ insertedId: users.id });
          if (!result || result.length === 0) {
            throw new Error("Failed to register");
          } else {
            token.set({
              value: await jwt2.sign({ id: result[0].insertedId }),
              expires: new Date(Date.now() + 1e3 * 60 * 60 * 24 * 7),
              path: "/"
            });
          }
        }
      });
      const redirect_host = redirect_to.value || "";
      const redirect_url = `${redirect_host}/callback?token=${token.value}`;
      set.headers = {
        "Content-Type": "text/html"
      };
      set.redirect = redirect_url;
    }, {
      query: t.Object({
        state: t.String(),
        code: t.String()
      })
    }).get("/profile", async ({ set, uid }) => {
      if (!uid) {
        set.status = 403;
        return "Permission denied";
      }
      const uid_num = parseInt(uid);
      const user = await db.query.users.findFirst({ where: eq(users.id, uid_num) });
      if (!user) {
        set.status = 404;
        return "User not found";
      }
      return {
        id: user.id,
        username: user.username,
        avatar: user.avatar,
        permission: user.permission === 1,
        createdAt: user.createdAt,
        updatedAt: user.updatedAt
      };
    })
  );
}

// server/src/services/config.ts
init_process();
init_buffer();
function ConfigService() {
  return new Elysia({ aot: false }).use(setup()).group(
    "/config",
    (group) => group.get("/:type", async ({ set, admin, params: { type } }) => {
      if (type !== "server" && type !== "client") {
        set.status = 400;
        return "Invalid type";
      }
      if (type === "server" && !admin) {
        set.status = 401;
        return "Unauthorized";
      }
      const config3 = type === "server" ? ServerConfig() : ClientConfig();
      const all4 = await config3.all();
      return Object.fromEntries(all4);
    }).post("/:type", async ({ set, admin, body: body3, params: { type } }) => {
      if (type !== "server" && type !== "client") {
        set.status = 400;
        return "Invalid type";
      }
      if (!admin) {
        set.status = 401;
        return "Unauthorized";
      }
      const config3 = type === "server" ? ServerConfig() : ClientConfig();
      for (const key2 in body3) {
        await config3.set(key2, body3[key2], false);
      }
      await config3.save();
      return "OK";
    }, {
      body: t.Record(t.String(), t.Any())
    }).delete("/cache", async ({ set, admin }) => {
      if (!admin) {
        set.status = 401;
        return "Unauthorized";
      }
      await PublicCache().clear();
      return "OK";
    })
  );
}

// server/src/server.ts
var app = () => new Elysia({ aot: false }).use(dist_default({
  aot: false,
  origin: "*",
  methods: "*",
  allowedHeaders: [
    "authorization",
    "content-type"
  ],
  maxAge: 600,
  credentials: true,
  preflight: true
})).use(serverTiming({
  enabled: true
})).use(UserService()).use(FeedService()).use(CommentService()).use(TagService()).use(StorageService()).use(FriendService()).use(SEOService()).use(RSSService()).use(ConfigService()).get("/", () => `Hi`).onError(({ path: path2, params, code: code4 }) => {
  if (code4 === "NOT_FOUND")
    return `${path2} ${JSON.stringify(params)} not found`;
});

// server/src/_worker.ts
var worker_default = {
  async fetch(request, env5) {
    const db = drizzle(env5.DB, { schema: schema_exports });
    esm5_default.set(envToken, env5);
    esm5_default.set(dbToken, db);
    const exist = esm5_default.has("cache");
    if (!exist) {
      esm5_default.set("cache", new CacheImpl());
      esm5_default.set("server.config", new CacheImpl("server.config"));
      esm5_default.set("client.config", new CacheImpl("client.config"));
    }
    return await new Elysia({ aot: false }).use(app()).handle(request);
  },
  async scheduled(_controller, env5, ctx) {
    const db = drizzle(env5.DB, { schema: schema_exports });
    esm5_default.set(envToken, env5);
    esm5_default.set(dbToken, db);
    const exist = esm5_default.has("cache");
    if (!exist) {
      esm5_default.set("cache", new CacheImpl());
      esm5_default.set("server.config", new CacheImpl("server.config"));
      esm5_default.set("client.config", new CacheImpl("client.config"));
    }
    await friendCrontab(env5, ctx);
    await rssCrontab(env5);
  }
};
export {
  worker_default as default
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/*! https://mths.be/punycode v1.4.1 by @mathias */
/*! Bundled license information:

@esbuild-plugins/node-globals-polyfill/Buffer.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)

cookie/index.js:
  (*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

reflect-metadata/Reflect.js:
  (*! *****************************************************************************
  Copyright (C) Microsoft. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)

elysia/dist/cjs/index.js:
  (**
   * @license
   * 
   * MIT License
   * 
   * Copyright (c) 2020 Evgeny Poberezkin
   * 
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   * 
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   * 
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   *)

sax/lib/sax.js:
  (*! http://mths.be/fromcodepoint v0.1.0 by @mathias *)

elysia/dist/index.mjs:
  (**
   * @license
   * 
   * MIT License
   * 
   * Copyright (c) 2020 Evgeny Poberezkin
   * 
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   * 
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   * 
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   *)
*/
//# sourceMappingURL=_worker.js.map
